
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_start>:
	forced_pm_state = state;
#endif
}

enum power_states _sys_suspend(int32_t ticks)
{
   0:	20001d48 	.word	0x20001d48
   4:	00004f2d 	.word	0x00004f2d
	bool deep_sleep;
#if CONFIG_DEVICE_POWER_MANAGEMENT
	bool low_power = false;
#endif

	pm_state = (forced_pm_state == SYS_POWER_STATE_AUTO) ?
   8:	00012e4d 	.word	0x00012e4d
   c:	00004f5d 	.word	0x00004f5d
		   sys_pm_policy_next_state(ticks) : forced_pm_state;
  10:	00004f5d 	.word	0x00004f5d
  14:	00004f5d 	.word	0x00004f5d
  18:	00004f5d 	.word	0x00004f5d
  1c:	00004f5d 	.word	0x00004f5d
	...

	if (pm_state == SYS_POWER_STATE_ACTIVE) {
  2c:	000049e1 	.word	0x000049e1
  30:	00004f5d 	.word	0x00004f5d
  34:	00000000 	.word	0x00000000
		LOG_DBG("No PM operations done.");
  38:	00004985 	.word	0x00004985
  3c:	00004155 	.word	0x00004155

00000040 <_irq_vector_table>:
  40:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
  50:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
  60:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
  70:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
  80:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
  90:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		return pm_state;
	}

	deep_sleep = IS_ENABLED(CONFIG_SYS_POWER_DEEP_SLEEP_STATES) ?
  a0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		     sys_pm_is_deep_sleep_state(pm_state) : 0;

	post_ops_done = 0;
	sys_pm_notify_power_state_entry(pm_state);
  b0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		}
#endif
	}

	/* Enter power state */
	sys_pm_debug_start_timer();
  c0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
	sys_set_power_state(pm_state);
	sys_pm_debug_stop_timer();
  d0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		sys_pm_resume_devices();
	}
#endif
	sys_pm_log_debug_info(pm_state);

	if (!post_ops_done) {
  e0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		post_ops_done = 1;
		/* clear forced_pm_state */
		forced_pm_state = SYS_POWER_STATE_AUTO;
  f0:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
		sys_pm_notify_power_state_exit(pm_state);
		_sys_pm_power_state_exit_post_ops(pm_state);
 100:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
	}

	return pm_state;
 110:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
}
 120:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
 130:	00004eed 00004eed 00004eed 00004eed     .N...N...N...N..
 140:	00004eed                                .N..

Disassembly of section text:

00000144 <__aeabi_uldivmod>:
     144:	b953      	cbnz	r3, 15c <__aeabi_uldivmod+0x18>
     146:	b94a      	cbnz	r2, 15c <__aeabi_uldivmod+0x18>
     148:	2900      	cmp	r1, #0
     14a:	bf08      	it	eq
     14c:	2800      	cmpeq	r0, #0
     14e:	bf1c      	itt	ne
     150:	f04f 31ff 	movne.w	r1, #4294967295
     154:	f04f 30ff 	movne.w	r0, #4294967295
     158:	f000 b970 	b.w	43c <__aeabi_idiv0>
     15c:	f1ad 0c08 	sub.w	ip, sp, #8
     160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     164:	f000 f806 	bl	174 <__udivmoddi4>
     168:	f8dd e004 	ldr.w	lr, [sp, #4]
     16c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     170:	b004      	add	sp, #16
     172:	4770      	bx	lr

00000174 <__udivmoddi4>:
     174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     178:	9e08      	ldr	r6, [sp, #32]
     17a:	460d      	mov	r5, r1
     17c:	4604      	mov	r4, r0
     17e:	468a      	mov	sl, r1
     180:	2b00      	cmp	r3, #0
     182:	d17f      	bne.n	284 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x4>
     184:	428a      	cmp	r2, r1
     186:	4617      	mov	r7, r2
     188:	d941      	bls.n	20e <CONFIG_KOBJECT_TEXT_AREA+0xe>
     18a:	fab2 f282 	clz	r2, r2
     18e:	b14a      	cbz	r2, 1a4 <__udivmoddi4+0x30>
     190:	f1c2 0120 	rsb	r1, r2, #32
     194:	fa05 f302 	lsl.w	r3, r5, r2
     198:	4097      	lsls	r7, r2
     19a:	4094      	lsls	r4, r2
     19c:	fa20 f101 	lsr.w	r1, r0, r1
     1a0:	ea41 0a03 	orr.w	sl, r1, r3
     1a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
     1a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
     1ac:	fa1f f987 	uxth.w	r9, r7
     1b0:	fbba fef8 	udiv	lr, sl, r8
     1b4:	fb08 a31e 	mls	r3, r8, lr, sl
     1b8:	fb0e f109 	mul.w	r1, lr, r9
     1bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
     1c0:	4299      	cmp	r1, r3
     1c2:	d906      	bls.n	1d2 <__udivmoddi4+0x5e>
     1c4:	18fb      	adds	r3, r7, r3
     1c6:	d202      	bcs.n	1ce <__udivmoddi4+0x5a>
     1c8:	4299      	cmp	r1, r3
     1ca:	f200 8124 	bhi.w	416 <CONFIG_FLASH_SIZE+0x16>
     1ce:	f10e 3eff 	add.w	lr, lr, #4294967295
     1d2:	1a59      	subs	r1, r3, r1
     1d4:	b2a3      	uxth	r3, r4
     1d6:	fbb1 f0f8 	udiv	r0, r1, r8
     1da:	fb08 1110 	mls	r1, r8, r0, r1
     1de:	fb00 f909 	mul.w	r9, r0, r9
     1e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
     1e6:	45a1      	cmp	r9, r4
     1e8:	d905      	bls.n	1f6 <__udivmoddi4+0x82>
     1ea:	193c      	adds	r4, r7, r4
     1ec:	d202      	bcs.n	1f4 <__udivmoddi4+0x80>
     1ee:	45a1      	cmp	r9, r4
     1f0:	f200 810e 	bhi.w	410 <CONFIG_FLASH_SIZE+0x10>
     1f4:	3801      	subs	r0, #1
     1f6:	eba4 0409 	sub.w	r4, r4, r9
     1fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     1fe:	2100      	movs	r1, #0
     200:	b11e      	cbz	r6, 20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     202:	40d4      	lsrs	r4, r2
     204:	2300      	movs	r3, #0
     206:	e9c6 4300 	strd	r4, r3, [r6]
     20a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     20e:	b902      	cbnz	r2, 212 <CONFIG_KOBJECT_TEXT_AREA+0x12>
     210:	deff      	udf	#255	; 0xff
     212:	fab2 f282 	clz	r2, r2
     216:	2a00      	cmp	r2, #0
     218:	d14f      	bne.n	2ba <CONFIG_PM_PARTITION_SIZE_PROVISION+0x3a>
     21a:	1bcb      	subs	r3, r1, r7
     21c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     220:	fa1f f887 	uxth.w	r8, r7
     224:	2101      	movs	r1, #1
     226:	0c25      	lsrs	r5, r4, #16
     228:	fbb3 fcfe 	udiv	ip, r3, lr
     22c:	fb0e 301c 	mls	r0, lr, ip, r3
     230:	462b      	mov	r3, r5
     232:	fb08 f90c 	mul.w	r9, r8, ip
     236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
     23a:	45a9      	cmp	r9, r5
     23c:	d90a      	bls.n	254 <CONFIG_KOBJECT_TEXT_AREA+0x54>
     23e:	197d      	adds	r5, r7, r5
     240:	bf2c      	ite	cs
     242:	2301      	movcs	r3, #1
     244:	2300      	movcc	r3, #0
     246:	45a9      	cmp	r9, r5
     248:	d902      	bls.n	250 <CONFIG_KOBJECT_TEXT_AREA+0x50>
     24a:	2b00      	cmp	r3, #0
     24c:	f000 80d9 	beq.w	402 <CONFIG_FLASH_SIZE+0x2>
     250:	f10c 3cff 	add.w	ip, ip, #4294967295
     254:	eba5 0509 	sub.w	r5, r5, r9
     258:	b2a3      	uxth	r3, r4
     25a:	fbb5 f0fe 	udiv	r0, r5, lr
     25e:	fb0e 5510 	mls	r5, lr, r0, r5
     262:	fb08 f800 	mul.w	r8, r8, r0
     266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
     26a:	45a0      	cmp	r8, r4
     26c:	d905      	bls.n	27a <CONFIG_KOBJECT_TEXT_AREA+0x7a>
     26e:	193c      	adds	r4, r7, r4
     270:	d202      	bcs.n	278 <CONFIG_KOBJECT_TEXT_AREA+0x78>
     272:	45a0      	cmp	r8, r4
     274:	f200 80c9 	bhi.w	40a <CONFIG_FLASH_SIZE+0xa>
     278:	3801      	subs	r0, #1
     27a:	eba4 0408 	sub.w	r4, r4, r8
     27e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     282:	e7bd      	b.n	200 <CONFIG_KOBJECT_TEXT_AREA>
     284:	428b      	cmp	r3, r1
     286:	d908      	bls.n	29a <CONFIG_PM_PARTITION_SIZE_PROVISION+0x1a>
     288:	2e00      	cmp	r6, #0
     28a:	f000 80b1 	beq.w	3f0 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x8>
     28e:	2100      	movs	r1, #0
     290:	e9c6 0500 	strd	r0, r5, [r6]
     294:	4608      	mov	r0, r1
     296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     29a:	fab3 f183 	clz	r1, r3
     29e:	2900      	cmp	r1, #0
     2a0:	d146      	bne.n	330 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xb0>
     2a2:	42ab      	cmp	r3, r5
     2a4:	f0c0 80a7 	bcc.w	3f6 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0xe>
     2a8:	4282      	cmp	r2, r0
     2aa:	f240 80a4 	bls.w	3f6 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0xe>
     2ae:	4608      	mov	r0, r1
     2b0:	2e00      	cmp	r6, #0
     2b2:	d0aa      	beq.n	20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     2b4:	e9c6 4a00 	strd	r4, sl, [r6]
     2b8:	e7a7      	b.n	20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     2ba:	f1c2 0020 	rsb	r0, r2, #32
     2be:	4097      	lsls	r7, r2
     2c0:	fa01 f302 	lsl.w	r3, r1, r2
     2c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     2c8:	40c1      	lsrs	r1, r0
     2ca:	fa24 f500 	lsr.w	r5, r4, r0
     2ce:	fa1f f887 	uxth.w	r8, r7
     2d2:	4094      	lsls	r4, r2
     2d4:	431d      	orrs	r5, r3
     2d6:	fbb1 f0fe 	udiv	r0, r1, lr
     2da:	0c2b      	lsrs	r3, r5, #16
     2dc:	fb0e 1110 	mls	r1, lr, r0, r1
     2e0:	fb00 fc08 	mul.w	ip, r0, r8
     2e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
     2e8:	459c      	cmp	ip, r3
     2ea:	d909      	bls.n	300 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x80>
     2ec:	18fb      	adds	r3, r7, r3
     2ee:	bf2c      	ite	cs
     2f0:	2101      	movcs	r1, #1
     2f2:	2100      	movcc	r1, #0
     2f4:	459c      	cmp	ip, r3
     2f6:	d902      	bls.n	2fe <CONFIG_PM_PARTITION_SIZE_PROVISION+0x7e>
     2f8:	2900      	cmp	r1, #0
     2fa:	f000 8095 	beq.w	428 <CONFIG_FLASH_SIZE+0x28>
     2fe:	3801      	subs	r0, #1
     300:	eba3 030c 	sub.w	r3, r3, ip
     304:	b2ad      	uxth	r5, r5
     306:	fbb3 f1fe 	udiv	r1, r3, lr
     30a:	fb0e 3311 	mls	r3, lr, r1, r3
     30e:	fb01 fc08 	mul.w	ip, r1, r8
     312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     316:	45ac      	cmp	ip, r5
     318:	d905      	bls.n	326 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xa6>
     31a:	197d      	adds	r5, r7, r5
     31c:	d202      	bcs.n	324 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xa4>
     31e:	45ac      	cmp	ip, r5
     320:	f200 8089 	bhi.w	436 <CONFIG_FLASH_SIZE+0x36>
     324:	3901      	subs	r1, #1
     326:	eba5 030c 	sub.w	r3, r5, ip
     32a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
     32e:	e77a      	b.n	226 <CONFIG_KOBJECT_TEXT_AREA+0x26>
     330:	f1c1 0420 	rsb	r4, r1, #32
     334:	408b      	lsls	r3, r1
     336:	fa02 f701 	lsl.w	r7, r2, r1
     33a:	fa05 fc01 	lsl.w	ip, r5, r1
     33e:	40e2      	lsrs	r2, r4
     340:	fa20 f804 	lsr.w	r8, r0, r4
     344:	40e5      	lsrs	r5, r4
     346:	fa00 fe01 	lsl.w	lr, r0, r1
     34a:	4313      	orrs	r3, r2
     34c:	ea48 020c 	orr.w	r2, r8, ip
     350:	ea4f 4813 	mov.w	r8, r3, lsr #16
     354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
     358:	fa1f f983 	uxth.w	r9, r3
     35c:	fbb5 faf8 	udiv	sl, r5, r8
     360:	fb08 551a 	mls	r5, r8, sl, r5
     364:	fb0a f009 	mul.w	r0, sl, r9
     368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
     36c:	4560      	cmp	r0, ip
     36e:	d90a      	bls.n	386 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x106>
     370:	eb13 0c0c 	adds.w	ip, r3, ip
     374:	bf2c      	ite	cs
     376:	2501      	movcs	r5, #1
     378:	2500      	movcc	r5, #0
     37a:	4560      	cmp	r0, ip
     37c:	d901      	bls.n	382 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x102>
     37e:	2d00      	cmp	r5, #0
     380:	d055      	beq.n	42e <CONFIG_FLASH_SIZE+0x2e>
     382:	f10a 3aff 	add.w	sl, sl, #4294967295
     386:	ebac 0c00 	sub.w	ip, ip, r0
     38a:	b292      	uxth	r2, r2
     38c:	fbbc f0f8 	udiv	r0, ip, r8
     390:	fb08 cc10 	mls	ip, r8, r0, ip
     394:	fb00 f909 	mul.w	r9, r0, r9
     398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
     39c:	45e1      	cmp	r9, ip
     39e:	d905      	bls.n	3ac <CONFIG_PM_PARTITION_SIZE_PROVISION+0x12c>
     3a0:	eb13 0c0c 	adds.w	ip, r3, ip
     3a4:	d201      	bcs.n	3aa <CONFIG_PM_PARTITION_SIZE_PROVISION+0x12a>
     3a6:	45e1      	cmp	r9, ip
     3a8:	d83b      	bhi.n	422 <CONFIG_FLASH_SIZE+0x22>
     3aa:	3801      	subs	r0, #1
     3ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
     3b0:	ebac 0c09 	sub.w	ip, ip, r9
     3b4:	fba0 8907 	umull	r8, r9, r0, r7
     3b8:	45cc      	cmp	ip, r9
     3ba:	4645      	mov	r5, r8
     3bc:	464a      	mov	r2, r9
     3be:	d302      	bcc.n	3c6 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x146>
     3c0:	d106      	bne.n	3d0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x150>
     3c2:	45c6      	cmp	lr, r8
     3c4:	d204      	bcs.n	3d0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x150>
     3c6:	3801      	subs	r0, #1
     3c8:	ebb8 0507 	subs.w	r5, r8, r7
     3cc:	eb69 0203 	sbc.w	r2, r9, r3
     3d0:	b32e      	cbz	r6, 41e <CONFIG_FLASH_SIZE+0x1e>
     3d2:	ebbe 0305 	subs.w	r3, lr, r5
     3d6:	eb6c 0c02 	sbc.w	ip, ip, r2
     3da:	fa23 f201 	lsr.w	r2, r3, r1
     3de:	fa0c f404 	lsl.w	r4, ip, r4
     3e2:	fa2c f301 	lsr.w	r3, ip, r1
     3e6:	2100      	movs	r1, #0
     3e8:	4314      	orrs	r4, r2
     3ea:	e9c6 4300 	strd	r4, r3, [r6]
     3ee:	e70c      	b.n	20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     3f0:	4631      	mov	r1, r6
     3f2:	4630      	mov	r0, r6
     3f4:	e709      	b.n	20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     3f6:	1a84      	subs	r4, r0, r2
     3f8:	eb65 0303 	sbc.w	r3, r5, r3
     3fc:	2001      	movs	r0, #1
     3fe:	469a      	mov	sl, r3
     400:	e756      	b.n	2b0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x30>
     402:	f1ac 0c02 	sub.w	ip, ip, #2
     406:	443d      	add	r5, r7
     408:	e724      	b.n	254 <CONFIG_KOBJECT_TEXT_AREA+0x54>
     40a:	3802      	subs	r0, #2
     40c:	443c      	add	r4, r7
     40e:	e734      	b.n	27a <CONFIG_KOBJECT_TEXT_AREA+0x7a>
     410:	3802      	subs	r0, #2
     412:	443c      	add	r4, r7
     414:	e6ef      	b.n	1f6 <__udivmoddi4+0x82>
     416:	f1ae 0e02 	sub.w	lr, lr, #2
     41a:	443b      	add	r3, r7
     41c:	e6d9      	b.n	1d2 <__udivmoddi4+0x5e>
     41e:	4631      	mov	r1, r6
     420:	e6f3      	b.n	20a <CONFIG_KOBJECT_TEXT_AREA+0xa>
     422:	3802      	subs	r0, #2
     424:	449c      	add	ip, r3
     426:	e7c1      	b.n	3ac <CONFIG_PM_PARTITION_SIZE_PROVISION+0x12c>
     428:	3802      	subs	r0, #2
     42a:	443b      	add	r3, r7
     42c:	e768      	b.n	300 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x80>
     42e:	f1aa 0a02 	sub.w	sl, sl, #2
     432:	449c      	add	ip, r3
     434:	e7a7      	b.n	386 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x106>
     436:	3902      	subs	r1, #2
     438:	443d      	add	r5, r7
     43a:	e774      	b.n	326 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xa6>

0000043c <__aeabi_idiv0>:
     43c:	4770      	bx	lr
     43e:	bf00      	nop

00000440 <uart_irq_handler>:

#define BUF_SIZE 64
static K_MEM_SLAB_DEFINE(uart_slab, BUF_SIZE, 3, 4);

static void uart_irq_handler(const struct device *dev, void *context)
{
     440:	b580      	push	{r7, lr}
     442:	b088      	sub	sp, #32
     444:	af00      	add	r7, sp, #0
     446:	6078      	str	r0, [r7, #4]
     448:	6039      	str	r1, [r7, #0]
	uint8_t buf[] = {"hi"};
     44a:	4a20      	ldr	r2, [pc, #128]	; (4cc <uart_irq_handler+0x8c>)
     44c:	f107 0318 	add.w	r3, r7, #24
     450:	6812      	ldr	r2, [r2, #0]
     452:	4611      	mov	r1, r2
     454:	8019      	strh	r1, [r3, #0]
     456:	3302      	adds	r3, #2
     458:	0c12      	lsrs	r2, r2, #16
     45a:	701a      	strb	r2, [r3, #0]

	if (uart_irq_tx_ready(dev)) {
     45c:	6878      	ldr	r0, [r7, #4]
     45e:	f00f fd34 	bl	feca <uart_irq_tx_ready>
     462:	4603      	mov	r3, r0
     464:	2b00      	cmp	r3, #0
     466:	d00c      	beq.n	482 <uart_irq_handler+0x42>
		(void)uart_fifo_fill(dev, buf, sizeof(buf));
     468:	f107 0318 	add.w	r3, r7, #24
     46c:	2203      	movs	r2, #3
     46e:	4619      	mov	r1, r3
     470:	6878      	ldr	r0, [r7, #4]
     472:	f00f fcd0 	bl	fe16 <uart_fifo_fill>
		uart_irq_tx_disable(dev);
     476:	6878      	ldr	r0, [r7, #4]
     478:	f00f fd99 	bl	ffae <uart_irq_tx_disable>
		printk("sent\n");
     47c:	4814      	ldr	r0, [pc, #80]	; (4d0 <uart_irq_handler+0x90>)
     47e:	f00f fdf3 	bl	10068 <printk>
	}

	if (uart_irq_rx_ready(dev)) {
     482:	6878      	ldr	r0, [r7, #4]
     484:	f00f fd4a 	bl	ff1c <uart_irq_rx_ready>
     488:	4603      	mov	r3, r0
     48a:	2b00      	cmp	r3, #0
     48c:	d01a      	beq.n	4c4 <uart_irq_handler+0x84>
		uint8_t buf[10];
		int len = uart_fifo_read(dev, buf, sizeof(buf));
     48e:	f107 030c 	add.w	r3, r7, #12
     492:	220a      	movs	r2, #10
     494:	4619      	mov	r1, r3
     496:	6878      	ldr	r0, [r7, #4]
     498:	f00f fcd7 	bl	fe4a <uart_fifo_read>
     49c:	61f8      	str	r0, [r7, #28]
		buf[len] = 0;
     49e:	f107 020c 	add.w	r2, r7, #12
     4a2:	69fb      	ldr	r3, [r7, #28]
     4a4:	4413      	add	r3, r2
     4a6:	2200      	movs	r2, #0
     4a8:	701a      	strb	r2, [r3, #0]
		printk("%s\n", buf);
     4aa:	f107 030c 	add.w	r3, r7, #12
     4ae:	4619      	mov	r1, r3
     4b0:	4808      	ldr	r0, [pc, #32]	; (4d4 <uart_irq_handler+0x94>)
     4b2:	f00f fdd9 	bl	10068 <printk>
		

		if (len) {
     4b6:	69fb      	ldr	r3, [r7, #28]
     4b8:	2b00      	cmp	r3, #0
     4ba:	d003      	beq.n	4c4 <uart_irq_handler+0x84>
			printk("read %d bytes\n", len);
     4bc:	69f9      	ldr	r1, [r7, #28]
     4be:	4806      	ldr	r0, [pc, #24]	; (4d8 <uart_irq_handler+0x98>)
     4c0:	f00f fdd2 	bl	10068 <printk>
		}
	}
}
     4c4:	bf00      	nop
     4c6:	3720      	adds	r7, #32
     4c8:	46bd      	mov	sp, r7
     4ca:	bd80      	pop	{r7, pc}
     4cc:	00018810 	.word	0x00018810
     4d0:	000187f4 	.word	0x000187f4
     4d4:	000187fc 	.word	0x000187fc
     4d8:	00018800 	.word	0x00018800

000004dc <interrupt_driven>:

static void interrupt_driven(const struct device *dev)
{
     4dc:	b580      	push	{r7, lr}
     4de:	b084      	sub	sp, #16
     4e0:	af00      	add	r7, sp, #0
     4e2:	6078      	str	r0, [r7, #4]
	uint8_t c = 0xff;
     4e4:	23ff      	movs	r3, #255	; 0xff
     4e6:	73fb      	strb	r3, [r7, #15]

	uart_irq_callback_set(dev, uart_irq_handler);
     4e8:	490b      	ldr	r1, [pc, #44]	; (518 <interrupt_driven+0x3c>)
     4ea:	6878      	ldr	r0, [r7, #4]
     4ec:	f00f fd46 	bl	ff7c <uart_irq_callback_set>
	uart_irq_rx_enable(dev);
     4f0:	6878      	ldr	r0, [r7, #4]
     4f2:	f00f fd67 	bl	ffc4 <uart_irq_rx_enable>
	while (1) {
		uart_irq_tx_enable(dev);
     4f6:	6878      	ldr	r0, [r7, #4]
     4f8:	f00f fd4e 	bl	ff98 <uart_irq_tx_enable>
		k_sleep(K_MSEC(2000));
     4fc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
     500:	f04f 0100 	mov.w	r1, #0
     504:	f00f fb2e 	bl	fb64 <k_ms_to_ticks_ceil64>
     508:	4602      	mov	r2, r0
     50a:	460b      	mov	r3, r1
     50c:	4610      	mov	r0, r2
     50e:	4619      	mov	r1, r3
     510:	f00f fc67 	bl	fde2 <k_sleep>
	while (1) {
     514:	e7ef      	b.n	4f6 <interrupt_driven+0x1a>
     516:	bf00      	nop
     518:	00000441 	.word	0x00000441

0000051c <main>:
		k_sleep(K_MSEC(100));
	}
}

void main(void)
{
     51c:	b580      	push	{r7, lr}
     51e:	b082      	sub	sp, #8
     520:	af00      	add	r7, sp, #0
	const struct device *lpuart;

	k_msleep(1000);
     522:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     526:	f00f fc42 	bl	fdae <k_msleep>

	lpuart = device_get_binding("LPUART");
     52a:	480d      	ldr	r0, [pc, #52]	; (560 <main+0x44>)
     52c:	f00f fc67 	bl	fdfe <device_get_binding>
     530:	6078      	str	r0, [r7, #4]
	__ASSERT(lpuart, "Failed to get the device");
     532:	687b      	ldr	r3, [r7, #4]
     534:	2b00      	cmp	r3, #0
     536:	d10c      	bne.n	552 <main+0x36>
     538:	2383      	movs	r3, #131	; 0x83
     53a:	4a0a      	ldr	r2, [pc, #40]	; (564 <main+0x48>)
     53c:	490a      	ldr	r1, [pc, #40]	; (568 <main+0x4c>)
     53e:	480b      	ldr	r0, [pc, #44]	; (56c <main+0x50>)
     540:	f00f fd92 	bl	10068 <printk>
     544:	480a      	ldr	r0, [pc, #40]	; (570 <main+0x54>)
     546:	f00f fd8f 	bl	10068 <printk>
     54a:	2183      	movs	r1, #131	; 0x83
     54c:	4805      	ldr	r0, [pc, #20]	; (564 <main+0x48>)
     54e:	f010 fbd3 	bl	10cf8 <assert_post_action>

	if (IS_ENABLED(CONFIG_NRF_SW_LPUART_INT_DRIVEN)) {
		interrupt_driven(lpuart);
     552:	6878      	ldr	r0, [r7, #4]
     554:	f7ff ffc2 	bl	4dc <interrupt_driven>
	} else {
		async(lpuart);
	}
}
     558:	bf00      	nop
     55a:	3708      	adds	r7, #8
     55c:	46bd      	mov	sp, r7
     55e:	bd80      	pop	{r7, pc}
     560:	0001893c 	.word	0x0001893c
     564:	0001884c 	.word	0x0001884c
     568:	00018944 	.word	0x00018944
     56c:	00018868 	.word	0x00018868
     570:	0001894c 	.word	0x0001894c

00000574 <sys_notify_finalize>:
	return rv;
}

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
     574:	b580      	push	{r7, lr}
     576:	b086      	sub	sp, #24
     578:	af00      	add	r7, sp, #0
     57a:	6078      	str	r0, [r7, #4]
     57c:	6039      	str	r1, [r7, #0]
	struct k_poll_signal *sig = NULL;
     57e:	2300      	movs	r3, #0
     580:	613b      	str	r3, [r7, #16]
	sys_notify_generic_callback rv = 0;
     582:	2300      	movs	r3, #0
     584:	617b      	str	r3, [r7, #20]
	uint32_t method = sys_notify_get_method(notify);
     586:	6878      	ldr	r0, [r7, #4]
     588:	f00f fd27 	bl	ffda <sys_notify_get_method>
     58c:	60f8      	str	r0, [r7, #12]

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
     58e:	687b      	ldr	r3, [r7, #4]
     590:	683a      	ldr	r2, [r7, #0]
     592:	609a      	str	r2, [r3, #8]
	switch (method) {
     594:	68fb      	ldr	r3, [r7, #12]
     596:	2b03      	cmp	r3, #3
     598:	d009      	beq.n	5ae <sys_notify_finalize+0x3a>
     59a:	68fb      	ldr	r3, [r7, #12]
     59c:	2b03      	cmp	r3, #3
     59e:	d80e      	bhi.n	5be <sys_notify_finalize+0x4a>
     5a0:	68fb      	ldr	r3, [r7, #12]
     5a2:	2b01      	cmp	r3, #1
     5a4:	d016      	beq.n	5d4 <sys_notify_finalize+0x60>
     5a6:	68fb      	ldr	r3, [r7, #12]
     5a8:	2b02      	cmp	r3, #2
     5aa:	d004      	beq.n	5b6 <sys_notify_finalize+0x42>
     5ac:	e007      	b.n	5be <sys_notify_finalize+0x4a>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
     5ae:	687b      	ldr	r3, [r7, #4]
     5b0:	681b      	ldr	r3, [r3, #0]
     5b2:	617b      	str	r3, [r7, #20]
		break;
     5b4:	e00f      	b.n	5d6 <sys_notify_finalize+0x62>
	case SYS_NOTIFY_METHOD_SIGNAL:
		sig = notify->method.signal;
     5b6:	687b      	ldr	r3, [r7, #4]
     5b8:	681b      	ldr	r3, [r3, #0]
     5ba:	613b      	str	r3, [r7, #16]
		break;
     5bc:	e00b      	b.n	5d6 <sys_notify_finalize+0x62>
	default:
		__ASSERT_NO_MSG(false);
     5be:	2345      	movs	r3, #69	; 0x45
     5c0:	4a09      	ldr	r2, [pc, #36]	; (5e8 <sys_notify_finalize+0x74>)
     5c2:	490a      	ldr	r1, [pc, #40]	; (5ec <sys_notify_finalize+0x78>)
     5c4:	480a      	ldr	r0, [pc, #40]	; (5f0 <sys_notify_finalize+0x7c>)
     5c6:	f00f fd4f 	bl	10068 <printk>
     5ca:	2145      	movs	r1, #69	; 0x45
     5cc:	4806      	ldr	r0, [pc, #24]	; (5e8 <sys_notify_finalize+0x74>)
     5ce:	f010 fb93 	bl	10cf8 <assert_post_action>
     5d2:	e000      	b.n	5d6 <sys_notify_finalize+0x62>
		break;
     5d4:	bf00      	nop
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
     5d6:	687b      	ldr	r3, [r7, #4]
     5d8:	2200      	movs	r2, #0
     5da:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
     5dc:	697b      	ldr	r3, [r7, #20]
}
     5de:	4618      	mov	r0, r3
     5e0:	3718      	adds	r7, #24
     5e2:	46bd      	mov	sp, r7
     5e4:	bd80      	pop	{r7, pc}
     5e6:	bf00      	nop
     5e8:	00018968 	.word	0x00018968
     5ec:	0001898c 	.word	0x0001898c
     5f0:	00018990 	.word	0x00018990

000005f4 <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
     5f4:	b480      	push	{r7}
     5f6:	b083      	sub	sp, #12
     5f8:	af00      	add	r7, sp, #0
     5fa:	6078      	str	r0, [r7, #4]
	_char_out = fn;
     5fc:	4a03      	ldr	r2, [pc, #12]	; (60c <__printk_hook_install+0x18>)
     5fe:	687b      	ldr	r3, [r7, #4]
     600:	6013      	str	r3, [r2, #0]
}
     602:	bf00      	nop
     604:	370c      	adds	r7, #12
     606:	46bd      	mov	sp, r7
     608:	bc80      	pop	{r7}
     60a:	4770      	bx	lr
     60c:	200000c0 	.word	0x200000c0

00000610 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
     610:	b580      	push	{r7, lr}
     612:	b084      	sub	sp, #16
     614:	af00      	add	r7, sp, #0
     616:	6078      	str	r0, [r7, #4]
     618:	6039      	str	r1, [r7, #0]
	struct out_context *ctx = ctx_p;
     61a:	683b      	ldr	r3, [r7, #0]
     61c:	60fb      	str	r3, [r7, #12]

	ctx->count++;
     61e:	68fb      	ldr	r3, [r7, #12]
     620:	681b      	ldr	r3, [r3, #0]
     622:	1c5a      	adds	r2, r3, #1
     624:	68fb      	ldr	r3, [r7, #12]
     626:	601a      	str	r2, [r3, #0]
	return _char_out(c);
     628:	4b04      	ldr	r3, [pc, #16]	; (63c <char_out+0x2c>)
     62a:	681b      	ldr	r3, [r3, #0]
     62c:	6878      	ldr	r0, [r7, #4]
     62e:	4798      	blx	r3
     630:	4603      	mov	r3, r0
}
     632:	4618      	mov	r0, r3
     634:	3710      	adds	r7, #16
     636:	46bd      	mov	sp, r7
     638:	bd80      	pop	{r7, pc}
     63a:	bf00      	nop
     63c:	200000c0 	.word	0x200000c0

00000640 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
     640:	b580      	push	{r7, lr}
     642:	b084      	sub	sp, #16
     644:	af00      	add	r7, sp, #0
     646:	6078      	str	r0, [r7, #4]
     648:	6039      	str	r1, [r7, #0]
	struct out_context ctx = { 0 };
     64a:	2300      	movs	r3, #0
     64c:	60fb      	str	r3, [r7, #12]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
     64e:	f107 010c 	add.w	r1, r7, #12
     652:	683b      	ldr	r3, [r7, #0]
     654:	687a      	ldr	r2, [r7, #4]
     656:	4803      	ldr	r0, [pc, #12]	; (664 <vprintk+0x24>)
     658:	f000 ffce 	bl	15f8 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
     65c:	bf00      	nop
     65e:	3710      	adds	r7, #16
     660:	46bd      	mov	sp, r7
     662:	bd80      	pop	{r7, pc}
     664:	00000611 	.word	0x00000611

00000668 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     668:	b580      	push	{r7, lr}
     66a:	b088      	sub	sp, #32
     66c:	af00      	add	r7, sp, #0
     66e:	60f8      	str	r0, [r7, #12]
     670:	60b9      	str	r1, [r7, #8]
     672:	607a      	str	r2, [r7, #4]
     674:	603b      	str	r3, [r7, #0]
	struct str_context ctx = { str, size, 0 };
     676:	68fb      	ldr	r3, [r7, #12]
     678:	617b      	str	r3, [r7, #20]
     67a:	68bb      	ldr	r3, [r7, #8]
     67c:	61bb      	str	r3, [r7, #24]
     67e:	2300      	movs	r3, #0
     680:	61fb      	str	r3, [r7, #28]

	cbvprintf(str_out, &ctx, fmt, ap);
     682:	f107 0114 	add.w	r1, r7, #20
     686:	683b      	ldr	r3, [r7, #0]
     688:	687a      	ldr	r2, [r7, #4]
     68a:	4809      	ldr	r0, [pc, #36]	; (6b0 <vsnprintk+0x48>)
     68c:	f000 ffb4 	bl	15f8 <cbvprintf>

	if (ctx.count < ctx.max) {
     690:	69fa      	ldr	r2, [r7, #28]
     692:	69bb      	ldr	r3, [r7, #24]
     694:	429a      	cmp	r2, r3
     696:	da05      	bge.n	6a4 <vsnprintk+0x3c>
		str[ctx.count] = '\0';
     698:	69fb      	ldr	r3, [r7, #28]
     69a:	461a      	mov	r2, r3
     69c:	68fb      	ldr	r3, [r7, #12]
     69e:	4413      	add	r3, r2
     6a0:	2200      	movs	r2, #0
     6a2:	701a      	strb	r2, [r3, #0]
	}

	return ctx.count;
     6a4:	69fb      	ldr	r3, [r7, #28]
}
     6a6:	4618      	mov	r0, r3
     6a8:	3720      	adds	r7, #32
     6aa:	46bd      	mov	sp, r7
     6ac:	bd80      	pop	{r7, pc}
     6ae:	bf00      	nop
     6b0:	0001008d 	.word	0x0001008d

000006b4 <transition_complete>:
			  int evt,
			  k_spinlock_key_t key);

static void transition_complete(struct onoff_manager *mgr,
				int res)
{
     6b4:	b580      	push	{r7, lr}
     6b6:	b088      	sub	sp, #32
     6b8:	af00      	add	r7, sp, #0
     6ba:	6078      	str	r0, [r7, #4]
     6bc:	6039      	str	r1, [r7, #0]
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
     6be:	687b      	ldr	r3, [r7, #4]
     6c0:	3314      	adds	r3, #20
     6c2:	61fb      	str	r3, [r7, #28]
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
     6c4:	f04f 0320 	mov.w	r3, #32
     6c8:	f3ef 8211 	mrs	r2, BASEPRI
     6cc:	f383 8811 	msr	BASEPRI, r3
     6d0:	f3bf 8f6f 	isb	sy
     6d4:	61ba      	str	r2, [r7, #24]
     6d6:	617b      	str	r3, [r7, #20]
		: "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return key;
     6d8:	69bb      	ldr	r3, [r7, #24]

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
     6da:	60fb      	str	r3, [r7, #12]

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
     6dc:	69f8      	ldr	r0, [r7, #28]
     6de:	f00e f9bb 	bl	ea58 <z_spin_lock_valid>
     6e2:	4603      	mov	r3, r0
     6e4:	f083 0301 	eor.w	r3, r3, #1
     6e8:	b2db      	uxtb	r3, r3
     6ea:	2b00      	cmp	r3, #0
     6ec:	d00d      	beq.n	70a <transition_complete+0x56>
     6ee:	2378      	movs	r3, #120	; 0x78
     6f0:	4a0e      	ldr	r2, [pc, #56]	; (72c <transition_complete+0x78>)
     6f2:	490f      	ldr	r1, [pc, #60]	; (730 <transition_complete+0x7c>)
     6f4:	480f      	ldr	r0, [pc, #60]	; (734 <transition_complete+0x80>)
     6f6:	f00f fcb7 	bl	10068 <printk>
     6fa:	69f9      	ldr	r1, [r7, #28]
     6fc:	480e      	ldr	r0, [pc, #56]	; (738 <transition_complete+0x84>)
     6fe:	f00f fcb3 	bl	10068 <printk>
     702:	2178      	movs	r1, #120	; 0x78
     704:	4809      	ldr	r0, [pc, #36]	; (72c <transition_complete+0x78>)
     706:	f010 faf7 	bl	10cf8 <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
     70a:	69f8      	ldr	r0, [r7, #28]
     70c:	f00e f9dc 	bl	eac8 <z_spin_lock_set_owner>
#endif
	return k;
     710:	68fb      	ldr	r3, [r7, #12]
     712:	613b      	str	r3, [r7, #16]

	mgr->last_res = res;
     714:	687b      	ldr	r3, [r7, #4]
     716:	683a      	ldr	r2, [r7, #0]
     718:	619a      	str	r2, [r3, #24]
	process_event(mgr, EVT_COMPLETE, key);
     71a:	693a      	ldr	r2, [r7, #16]
     71c:	2101      	movs	r1, #1
     71e:	6878      	ldr	r0, [r7, #4]
     720:	f000 f8bc 	bl	89c <process_event>
}
     724:	bf00      	nop
     726:	3720      	adds	r7, #32
     728:	46bd      	mov	sp, r7
     72a:	bd80      	pop	{r7, pc}
     72c:	000189b0 	.word	0x000189b0
     730:	000189d8 	.word	0x000189d8
     734:	000189f0 	.word	0x000189f0
     738:	00018a10 	.word	0x00018a10

0000073c <process_complete>:
 * from the manager to the output list for notification.
 */
static void process_complete(struct onoff_manager *mgr,
			     sys_slist_t *clients,
			     int res)
{
     73c:	b580      	push	{r7, lr}
     73e:	b086      	sub	sp, #24
     740:	af00      	add	r7, sp, #0
     742:	60f8      	str	r0, [r7, #12]
     744:	60b9      	str	r1, [r7, #8]
     746:	607a      	str	r2, [r7, #4]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     748:	68fb      	ldr	r3, [r7, #12]
     74a:	8b9b      	ldrh	r3, [r3, #28]
     74c:	f003 0307 	and.w	r3, r3, #7
     750:	613b      	str	r3, [r7, #16]

	if (res < 0) {
     752:	687b      	ldr	r3, [r7, #4]
     754:	2b00      	cmp	r3, #0
     756:	da0e      	bge.n	776 <process_complete+0x3a>
		/* Enter ERROR state and notify all clients. */
		*clients = mgr->clients;
     758:	68bb      	ldr	r3, [r7, #8]
     75a:	68fa      	ldr	r2, [r7, #12]
     75c:	e892 0003 	ldmia.w	r2, {r0, r1}
     760:	e883 0003 	stmia.w	r3, {r0, r1}
		sys_slist_init(&mgr->clients);
     764:	68fb      	ldr	r3, [r7, #12]
     766:	4618      	mov	r0, r3
     768:	f00f fce1 	bl	1012e <sys_slist_init>
		set_state(mgr, ONOFF_STATE_ERROR);
     76c:	2101      	movs	r1, #1
     76e:	68f8      	ldr	r0, [r7, #12]
     770:	f00f fdae 	bl	102d0 <set_state>
			mgr->flags |= ONOFF_FLAG_RECHECK;
		}
	} else {
		__ASSERT_NO_MSG(false);
	}
}
     774:	e085      	b.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
	} else if ((state == ONOFF_STATE_TO_ON)
     776:	693b      	ldr	r3, [r7, #16]
     778:	2b06      	cmp	r3, #6
     77a:	d002      	beq.n	782 <process_complete+0x46>
		   || (state == ONOFF_STATE_RESETTING)) {
     77c:	693b      	ldr	r3, [r7, #16]
     77e:	2b05      	cmp	r3, #5
     780:	d15d      	bne.n	83e <CONFIG_ISR_STACK_SIZE+0x3e>
		*clients = mgr->clients;
     782:	68bb      	ldr	r3, [r7, #8]
     784:	68fa      	ldr	r2, [r7, #12]
     786:	e892 0003 	ldmia.w	r2, {r0, r1}
     78a:	e883 0003 	stmia.w	r3, {r0, r1}
		sys_slist_init(&mgr->clients);
     78e:	68fb      	ldr	r3, [r7, #12]
     790:	4618      	mov	r0, r3
     792:	f00f fccc 	bl	1012e <sys_slist_init>
		if (state == ONOFF_STATE_TO_ON) {
     796:	693b      	ldr	r3, [r7, #16]
     798:	2b06      	cmp	r3, #6
     79a:	d12f      	bne.n	7fc <process_complete+0xc0>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     79c:	68b8      	ldr	r0, [r7, #8]
     79e:	f00f fd07 	bl	101b0 <sys_slist_peek_head>
     7a2:	4603      	mov	r3, r0
     7a4:	2b00      	cmp	r3, #0
     7a6:	d004      	beq.n	7b2 <process_complete+0x76>
     7a8:	68b8      	ldr	r0, [r7, #8]
     7aa:	f00f fd01 	bl	101b0 <sys_slist_peek_head>
     7ae:	4603      	mov	r3, r0
     7b0:	e000      	b.n	7b4 <process_complete+0x78>
     7b2:	2300      	movs	r3, #0
     7b4:	617b      	str	r3, [r7, #20]
     7b6:	e019      	b.n	7ec <process_complete+0xb0>
				mgr->refs += 1U;
     7b8:	68fb      	ldr	r3, [r7, #12]
     7ba:	8bdb      	ldrh	r3, [r3, #30]
     7bc:	3301      	adds	r3, #1
     7be:	b29a      	uxth	r2, r3
     7c0:	68fb      	ldr	r3, [r7, #12]
     7c2:	83da      	strh	r2, [r3, #30]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     7c4:	697b      	ldr	r3, [r7, #20]
     7c6:	2b00      	cmp	r3, #0
     7c8:	d00e      	beq.n	7e8 <process_complete+0xac>
     7ca:	697b      	ldr	r3, [r7, #20]
     7cc:	4618      	mov	r0, r3
     7ce:	f00f fd22 	bl	10216 <sys_slist_peek_next>
     7d2:	4603      	mov	r3, r0
     7d4:	2b00      	cmp	r3, #0
     7d6:	d005      	beq.n	7e4 <process_complete+0xa8>
     7d8:	697b      	ldr	r3, [r7, #20]
     7da:	4618      	mov	r0, r3
     7dc:	f00f fd1b 	bl	10216 <sys_slist_peek_next>
     7e0:	4603      	mov	r3, r0
     7e2:	e002      	b.n	7ea <process_complete+0xae>
     7e4:	2300      	movs	r3, #0
     7e6:	e000      	b.n	7ea <process_complete+0xae>
     7e8:	2300      	movs	r3, #0
     7ea:	617b      	str	r3, [r7, #20]
     7ec:	697b      	ldr	r3, [r7, #20]
     7ee:	2b00      	cmp	r3, #0
     7f0:	d1e2      	bne.n	7b8 <process_complete+0x7c>
			set_state(mgr, ONOFF_STATE_ON);
     7f2:	2102      	movs	r1, #2
     7f4:	68f8      	ldr	r0, [r7, #12]
     7f6:	f00f fd6b 	bl	102d0 <set_state>
     7fa:	e012      	b.n	822 <CONFIG_ISR_STACK_SIZE+0x22>
			__ASSERT_NO_MSG(state == ONOFF_STATE_RESETTING);
     7fc:	693b      	ldr	r3, [r7, #16]
     7fe:	2b05      	cmp	r3, #5
     800:	d00b      	beq.n	81a <CONFIG_ISR_STACK_SIZE+0x1a>
     802:	f240 1307 	movw	r3, #263	; 0x107
     806:	4a21      	ldr	r2, [pc, #132]	; (88c <CONFIG_ISR_STACK_SIZE+0x8c>)
     808:	4921      	ldr	r1, [pc, #132]	; (890 <CONFIG_ISR_STACK_SIZE+0x90>)
     80a:	4822      	ldr	r0, [pc, #136]	; (894 <CONFIG_ISR_STACK_SIZE+0x94>)
     80c:	f00f fc2c 	bl	10068 <printk>
     810:	f240 1107 	movw	r1, #263	; 0x107
     814:	481d      	ldr	r0, [pc, #116]	; (88c <CONFIG_ISR_STACK_SIZE+0x8c>)
     816:	f010 fa6f 	bl	10cf8 <assert_post_action>
			set_state(mgr, ONOFF_STATE_OFF);
     81a:	2100      	movs	r1, #0
     81c:	68f8      	ldr	r0, [r7, #12]
     81e:	f00f fd57 	bl	102d0 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
     822:	68f8      	ldr	r0, [r7, #12]
     824:	f00f fe43 	bl	104ae <process_recheck>
     828:	4603      	mov	r3, r0
     82a:	2b00      	cmp	r3, #0
     82c:	d029      	beq.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     82e:	68fb      	ldr	r3, [r7, #12]
     830:	8b9b      	ldrh	r3, [r3, #28]
     832:	f043 0320 	orr.w	r3, r3, #32
     836:	b29a      	uxth	r2, r3
     838:	68fb      	ldr	r3, [r7, #12]
     83a:	839a      	strh	r2, [r3, #28]
		if (process_recheck(mgr) != EVT_NOP) {
     83c:	e021      	b.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
	} else if (state == ONOFF_STATE_TO_OFF) {
     83e:	693b      	ldr	r3, [r7, #16]
     840:	2b04      	cmp	r3, #4
     842:	d111      	bne.n	868 <CONFIG_ISR_STACK_SIZE+0x68>
		set_state(mgr, ONOFF_STATE_OFF);
     844:	2100      	movs	r1, #0
     846:	68f8      	ldr	r0, [r7, #12]
     848:	f00f fd42 	bl	102d0 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
     84c:	68f8      	ldr	r0, [r7, #12]
     84e:	f00f fe2e 	bl	104ae <process_recheck>
     852:	4603      	mov	r3, r0
     854:	2b00      	cmp	r3, #0
     856:	d014      	beq.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     858:	68fb      	ldr	r3, [r7, #12]
     85a:	8b9b      	ldrh	r3, [r3, #28]
     85c:	f043 0320 	orr.w	r3, r3, #32
     860:	b29a      	uxth	r2, r3
     862:	68fb      	ldr	r3, [r7, #12]
     864:	839a      	strh	r2, [r3, #28]
}
     866:	e00c      	b.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
		__ASSERT_NO_MSG(false);
     868:	f240 1319 	movw	r3, #281	; 0x119
     86c:	4a07      	ldr	r2, [pc, #28]	; (88c <CONFIG_ISR_STACK_SIZE+0x8c>)
     86e:	490a      	ldr	r1, [pc, #40]	; (898 <CONFIG_ISR_STACK_SIZE+0x98>)
     870:	4808      	ldr	r0, [pc, #32]	; (894 <CONFIG_ISR_STACK_SIZE+0x94>)
     872:	f00f fbf9 	bl	10068 <printk>
     876:	f240 1119 	movw	r1, #281	; 0x119
     87a:	4804      	ldr	r0, [pc, #16]	; (88c <CONFIG_ISR_STACK_SIZE+0x8c>)
     87c:	f010 fa3c 	bl	10cf8 <assert_post_action>
}
     880:	e7ff      	b.n	882 <CONFIG_ISR_STACK_SIZE+0x82>
     882:	bf00      	nop
     884:	3718      	adds	r7, #24
     886:	46bd      	mov	sp, r7
     888:	bd80      	pop	{r7, pc}
     88a:	bf00      	nop
     88c:	00018a28 	.word	0x00018a28
     890:	00018a4c 	.word	0x00018a4c
     894:	000189f0 	.word	0x000189f0
     898:	00018a74 	.word	0x00018a74

0000089c <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     89c:	b580      	push	{r7, lr}
     89e:	b096      	sub	sp, #88	; 0x58
     8a0:	af00      	add	r7, sp, #0
     8a2:	60f8      	str	r0, [r7, #12]
     8a4:	60b9      	str	r1, [r7, #8]
     8a6:	607a      	str	r2, [r7, #4]
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     8a8:	68fb      	ldr	r3, [r7, #12]
     8aa:	8b9b      	ldrh	r3, [r3, #28]
     8ac:	f003 0307 	and.w	r3, r3, #7
     8b0:	657b      	str	r3, [r7, #84]	; 0x54
	int res = 0;
     8b2:	2300      	movs	r3, #0
     8b4:	653b      	str	r3, [r7, #80]	; 0x50
	bool processing = ((mgr->flags & ONOFF_FLAG_PROCESSING) != 0);
     8b6:	68fb      	ldr	r3, [r7, #12]
     8b8:	8b9b      	ldrh	r3, [r3, #28]
     8ba:	f003 0308 	and.w	r3, r3, #8
     8be:	2b00      	cmp	r3, #0
     8c0:	bf14      	ite	ne
     8c2:	2301      	movne	r3, #1
     8c4:	2300      	moveq	r3, #0
     8c6:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b

	__ASSERT_NO_MSG(evt != EVT_NOP);
     8ca:	68bb      	ldr	r3, [r7, #8]
     8cc:	2b00      	cmp	r3, #0
     8ce:	d10b      	bne.n	8e8 <process_event+0x4c>
     8d0:	f240 1331 	movw	r3, #305	; 0x131
     8d4:	4a92      	ldr	r2, [pc, #584]	; (b20 <process_event+0x284>)
     8d6:	4993      	ldr	r1, [pc, #588]	; (b24 <process_event+0x288>)
     8d8:	4893      	ldr	r0, [pc, #588]	; (b28 <process_event+0x28c>)
     8da:	f00f fbc5 	bl	10068 <printk>
     8de:	f240 1131 	movw	r1, #305	; 0x131
     8e2:	488f      	ldr	r0, [pc, #572]	; (b20 <process_event+0x284>)
     8e4:	f010 fa08 	bl	10cf8 <assert_post_action>

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     8e8:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
     8ec:	2b00      	cmp	r3, #0
     8ee:	d021      	beq.n	934 <process_event+0x98>
		if (evt == EVT_COMPLETE) {
     8f0:	68bb      	ldr	r3, [r7, #8]
     8f2:	2b01      	cmp	r3, #1
     8f4:	d107      	bne.n	906 <process_event+0x6a>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     8f6:	68fb      	ldr	r3, [r7, #12]
     8f8:	8b9b      	ldrh	r3, [r3, #28]
     8fa:	f043 0310 	orr.w	r3, r3, #16
     8fe:	b29a      	uxth	r2, r3
     900:	68fb      	ldr	r3, [r7, #12]
     902:	839a      	strh	r2, [r3, #28]
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
		}

		goto out;
     904:	e1f6      	b.n	cf4 <process_event+0x458>
			__ASSERT_NO_MSG(evt == EVT_RECHECK);
     906:	68bb      	ldr	r3, [r7, #8]
     908:	2b02      	cmp	r3, #2
     90a:	d00b      	beq.n	924 <process_event+0x88>
     90c:	f44f 739d 	mov.w	r3, #314	; 0x13a
     910:	4a83      	ldr	r2, [pc, #524]	; (b20 <process_event+0x284>)
     912:	4986      	ldr	r1, [pc, #536]	; (b2c <process_event+0x290>)
     914:	4884      	ldr	r0, [pc, #528]	; (b28 <process_event+0x28c>)
     916:	f00f fba7 	bl	10068 <printk>
     91a:	f44f 719d 	mov.w	r1, #314	; 0x13a
     91e:	4880      	ldr	r0, [pc, #512]	; (b20 <process_event+0x284>)
     920:	f010 f9ea 	bl	10cf8 <assert_post_action>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     924:	68fb      	ldr	r3, [r7, #12]
     926:	8b9b      	ldrh	r3, [r3, #28]
     928:	f043 0320 	orr.w	r3, r3, #32
     92c:	b29a      	uxth	r2, r3
     92e:	68fb      	ldr	r3, [r7, #12]
     930:	839a      	strh	r2, [r3, #28]
		goto out;
     932:	e1df      	b.n	cf4 <process_event+0x458>
	}

	sys_slist_init(&clients);
     934:	f107 0320 	add.w	r3, r7, #32
     938:	4618      	mov	r0, r3
     93a:	f00f fbf8 	bl	1012e <sys_slist_init>
	do {
		onoff_transition_fn transit = NULL;
     93e:	2300      	movs	r3, #0
     940:	64fb      	str	r3, [r7, #76]	; 0x4c

		if (evt == EVT_RECHECK) {
     942:	68bb      	ldr	r3, [r7, #8]
     944:	2b02      	cmp	r3, #2
     946:	d103      	bne.n	950 <process_event+0xb4>
			evt = process_recheck(mgr);
     948:	68f8      	ldr	r0, [r7, #12]
     94a:	f00f fdb0 	bl	104ae <process_recheck>
     94e:	60b8      	str	r0, [r7, #8]
		}

		if (evt == EVT_NOP) {
     950:	68bb      	ldr	r3, [r7, #8]
     952:	2b00      	cmp	r3, #0
     954:	f000 81cd 	beq.w	cf2 <process_event+0x456>
			break;
		}

		res = 0;
     958:	2300      	movs	r3, #0
     95a:	653b      	str	r3, [r7, #80]	; 0x50
		if (evt == EVT_COMPLETE) {
     95c:	68bb      	ldr	r3, [r7, #8]
     95e:	2b01      	cmp	r3, #1
     960:	d10a      	bne.n	978 <process_event+0xdc>
			res = mgr->last_res;
     962:	68fb      	ldr	r3, [r7, #12]
     964:	699b      	ldr	r3, [r3, #24]
     966:	653b      	str	r3, [r7, #80]	; 0x50
			process_complete(mgr, &clients, res);
     968:	f107 0320 	add.w	r3, r7, #32
     96c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
     96e:	4619      	mov	r1, r3
     970:	68f8      	ldr	r0, [r7, #12]
     972:	f7ff fee3 	bl	73c <process_complete>
     976:	e0bf      	b.n	af8 <process_event+0x25c>
			/* NB: This can trigger a RECHECK */
		} else if (evt == EVT_START) {
     978:	68bb      	ldr	r3, [r7, #8]
     97a:	2b03      	cmp	r3, #3
     97c:	d139      	bne.n	9f2 <process_event+0x156>
			__ASSERT_NO_MSG(state == ONOFF_STATE_OFF);
     97e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     980:	2b00      	cmp	r3, #0
     982:	d00b      	beq.n	99c <process_event+0x100>
     984:	f44f 73aa 	mov.w	r3, #340	; 0x154
     988:	4a65      	ldr	r2, [pc, #404]	; (b20 <process_event+0x284>)
     98a:	4969      	ldr	r1, [pc, #420]	; (b30 <process_event+0x294>)
     98c:	4866      	ldr	r0, [pc, #408]	; (b28 <process_event+0x28c>)
     98e:	f00f fb6b 	bl	10068 <printk>
     992:	f44f 71aa 	mov.w	r1, #340	; 0x154
     996:	4862      	ldr	r0, [pc, #392]	; (b20 <process_event+0x284>)
     998:	f010 f9ae 	bl	10cf8 <assert_post_action>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
     99c:	68fb      	ldr	r3, [r7, #12]
     99e:	4618      	mov	r0, r3
     9a0:	f00f fc1c 	bl	101dc <sys_slist_is_empty>
     9a4:	4603      	mov	r3, r0
     9a6:	2b00      	cmp	r3, #0
     9a8:	d00b      	beq.n	9c2 <process_event+0x126>
     9aa:	f240 1355 	movw	r3, #341	; 0x155
     9ae:	4a5c      	ldr	r2, [pc, #368]	; (b20 <process_event+0x284>)
     9b0:	4960      	ldr	r1, [pc, #384]	; (b34 <process_event+0x298>)
     9b2:	485d      	ldr	r0, [pc, #372]	; (b28 <process_event+0x28c>)
     9b4:	f00f fb58 	bl	10068 <printk>
     9b8:	f240 1155 	movw	r1, #341	; 0x155
     9bc:	4858      	ldr	r0, [pc, #352]	; (b20 <process_event+0x284>)
     9be:	f010 f99b 	bl	10cf8 <assert_post_action>

			transit = mgr->transitions->start;
     9c2:	68fb      	ldr	r3, [r7, #12]
     9c4:	691b      	ldr	r3, [r3, #16]
     9c6:	681b      	ldr	r3, [r3, #0]
     9c8:	64fb      	str	r3, [r7, #76]	; 0x4c
			__ASSERT_NO_MSG(transit != NULL);
     9ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     9cc:	2b00      	cmp	r3, #0
     9ce:	d10b      	bne.n	9e8 <process_event+0x14c>
     9d0:	f44f 73ac 	mov.w	r3, #344	; 0x158
     9d4:	4a52      	ldr	r2, [pc, #328]	; (b20 <process_event+0x284>)
     9d6:	4958      	ldr	r1, [pc, #352]	; (b38 <process_event+0x29c>)
     9d8:	4853      	ldr	r0, [pc, #332]	; (b28 <process_event+0x28c>)
     9da:	f00f fb45 	bl	10068 <printk>
     9de:	f44f 71ac 	mov.w	r1, #344	; 0x158
     9e2:	484f      	ldr	r0, [pc, #316]	; (b20 <process_event+0x284>)
     9e4:	f010 f988 	bl	10cf8 <assert_post_action>
			set_state(mgr, ONOFF_STATE_TO_ON);
     9e8:	2106      	movs	r1, #6
     9ea:	68f8      	ldr	r0, [r7, #12]
     9ec:	f00f fc70 	bl	102d0 <set_state>
     9f0:	e082      	b.n	af8 <process_event+0x25c>
		} else if (evt == EVT_STOP) {
     9f2:	68bb      	ldr	r3, [r7, #8]
     9f4:	2b04      	cmp	r3, #4
     9f6:	d136      	bne.n	a66 <process_event+0x1ca>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ON);
     9f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     9fa:	2b02      	cmp	r3, #2
     9fc:	d00b      	beq.n	a16 <process_event+0x17a>
     9fe:	f240 135b 	movw	r3, #347	; 0x15b
     a02:	4a47      	ldr	r2, [pc, #284]	; (b20 <process_event+0x284>)
     a04:	494d      	ldr	r1, [pc, #308]	; (b3c <process_event+0x2a0>)
     a06:	4848      	ldr	r0, [pc, #288]	; (b28 <process_event+0x28c>)
     a08:	f00f fb2e 	bl	10068 <printk>
     a0c:	f240 115b 	movw	r1, #347	; 0x15b
     a10:	4843      	ldr	r0, [pc, #268]	; (b20 <process_event+0x284>)
     a12:	f010 f971 	bl	10cf8 <assert_post_action>
			__ASSERT_NO_MSG(mgr->refs == 0);
     a16:	68fb      	ldr	r3, [r7, #12]
     a18:	8bdb      	ldrh	r3, [r3, #30]
     a1a:	2b00      	cmp	r3, #0
     a1c:	d00b      	beq.n	a36 <process_event+0x19a>
     a1e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
     a22:	4a3f      	ldr	r2, [pc, #252]	; (b20 <process_event+0x284>)
     a24:	4946      	ldr	r1, [pc, #280]	; (b40 <process_event+0x2a4>)
     a26:	4840      	ldr	r0, [pc, #256]	; (b28 <process_event+0x28c>)
     a28:	f00f fb1e 	bl	10068 <printk>
     a2c:	f44f 71ae 	mov.w	r1, #348	; 0x15c
     a30:	483b      	ldr	r0, [pc, #236]	; (b20 <process_event+0x284>)
     a32:	f010 f961 	bl	10cf8 <assert_post_action>

			transit = mgr->transitions->stop;
     a36:	68fb      	ldr	r3, [r7, #12]
     a38:	691b      	ldr	r3, [r3, #16]
     a3a:	685b      	ldr	r3, [r3, #4]
     a3c:	64fb      	str	r3, [r7, #76]	; 0x4c
			__ASSERT_NO_MSG(transit != NULL);
     a3e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     a40:	2b00      	cmp	r3, #0
     a42:	d10b      	bne.n	a5c <process_event+0x1c0>
     a44:	f240 135f 	movw	r3, #351	; 0x15f
     a48:	4a35      	ldr	r2, [pc, #212]	; (b20 <process_event+0x284>)
     a4a:	493b      	ldr	r1, [pc, #236]	; (b38 <process_event+0x29c>)
     a4c:	4836      	ldr	r0, [pc, #216]	; (b28 <process_event+0x28c>)
     a4e:	f00f fb0b 	bl	10068 <printk>
     a52:	f240 115f 	movw	r1, #351	; 0x15f
     a56:	4832      	ldr	r0, [pc, #200]	; (b20 <process_event+0x284>)
     a58:	f010 f94e 	bl	10cf8 <assert_post_action>
			set_state(mgr, ONOFF_STATE_TO_OFF);
     a5c:	2104      	movs	r1, #4
     a5e:	68f8      	ldr	r0, [r7, #12]
     a60:	f00f fc36 	bl	102d0 <set_state>
     a64:	e048      	b.n	af8 <process_event+0x25c>
		} else if (evt == EVT_RESET) {
     a66:	68bb      	ldr	r3, [r7, #8]
     a68:	2b05      	cmp	r3, #5
     a6a:	d139      	bne.n	ae0 <process_event+0x244>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
     a6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     a6e:	2b01      	cmp	r3, #1
     a70:	d00b      	beq.n	a8a <process_event+0x1ee>
     a72:	f44f 73b1 	mov.w	r3, #354	; 0x162
     a76:	4a2a      	ldr	r2, [pc, #168]	; (b20 <process_event+0x284>)
     a78:	4932      	ldr	r1, [pc, #200]	; (b44 <process_event+0x2a8>)
     a7a:	482b      	ldr	r0, [pc, #172]	; (b28 <process_event+0x28c>)
     a7c:	f00f faf4 	bl	10068 <printk>
     a80:	f44f 71b1 	mov.w	r1, #354	; 0x162
     a84:	4826      	ldr	r0, [pc, #152]	; (b20 <process_event+0x284>)
     a86:	f010 f937 	bl	10cf8 <assert_post_action>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
     a8a:	68fb      	ldr	r3, [r7, #12]
     a8c:	4618      	mov	r0, r3
     a8e:	f00f fba5 	bl	101dc <sys_slist_is_empty>
     a92:	4603      	mov	r3, r0
     a94:	2b00      	cmp	r3, #0
     a96:	d00b      	beq.n	ab0 <process_event+0x214>
     a98:	f240 1363 	movw	r3, #355	; 0x163
     a9c:	4a20      	ldr	r2, [pc, #128]	; (b20 <process_event+0x284>)
     a9e:	4925      	ldr	r1, [pc, #148]	; (b34 <process_event+0x298>)
     aa0:	4821      	ldr	r0, [pc, #132]	; (b28 <process_event+0x28c>)
     aa2:	f00f fae1 	bl	10068 <printk>
     aa6:	f240 1163 	movw	r1, #355	; 0x163
     aaa:	481d      	ldr	r0, [pc, #116]	; (b20 <process_event+0x284>)
     aac:	f010 f924 	bl	10cf8 <assert_post_action>

			transit = mgr->transitions->reset;
     ab0:	68fb      	ldr	r3, [r7, #12]
     ab2:	691b      	ldr	r3, [r3, #16]
     ab4:	689b      	ldr	r3, [r3, #8]
     ab6:	64fb      	str	r3, [r7, #76]	; 0x4c
			__ASSERT_NO_MSG(transit != NULL);
     ab8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     aba:	2b00      	cmp	r3, #0
     abc:	d10b      	bne.n	ad6 <process_event+0x23a>
     abe:	f44f 73b3 	mov.w	r3, #358	; 0x166
     ac2:	4a17      	ldr	r2, [pc, #92]	; (b20 <process_event+0x284>)
     ac4:	491c      	ldr	r1, [pc, #112]	; (b38 <process_event+0x29c>)
     ac6:	4818      	ldr	r0, [pc, #96]	; (b28 <process_event+0x28c>)
     ac8:	f00f face 	bl	10068 <printk>
     acc:	f44f 71b3 	mov.w	r1, #358	; 0x166
     ad0:	4813      	ldr	r0, [pc, #76]	; (b20 <process_event+0x284>)
     ad2:	f010 f911 	bl	10cf8 <assert_post_action>
			set_state(mgr, ONOFF_STATE_RESETTING);
     ad6:	2105      	movs	r1, #5
     ad8:	68f8      	ldr	r0, [r7, #12]
     ada:	f00f fbf9 	bl	102d0 <set_state>
     ade:	e00b      	b.n	af8 <process_event+0x25c>
		} else {
			__ASSERT_NO_MSG(false);
     ae0:	f240 1369 	movw	r3, #361	; 0x169
     ae4:	4a0e      	ldr	r2, [pc, #56]	; (b20 <process_event+0x284>)
     ae6:	4918      	ldr	r1, [pc, #96]	; (b48 <process_event+0x2ac>)
     ae8:	480f      	ldr	r0, [pc, #60]	; (b28 <process_event+0x28c>)
     aea:	f00f fabd 	bl	10068 <printk>
     aee:	f240 1169 	movw	r1, #361	; 0x169
     af2:	480b      	ldr	r0, [pc, #44]	; (b20 <process_event+0x284>)
     af4:	f010 f900 	bl	10cf8 <assert_post_action>
		/* Have to unlock and do something if any of:
		 * * We changed state and there are monitors;
		 * * We completed a transition and there are clients to notify;
		 * * We need to initiate a transition.
		 */
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     af8:	68fb      	ldr	r3, [r7, #12]
     afa:	8b9b      	ldrh	r3, [r3, #28]
     afc:	f003 0307 	and.w	r3, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     b00:	6d7a      	ldr	r2, [r7, #84]	; 0x54
     b02:	429a      	cmp	r2, r3
     b04:	d022      	beq.n	b4c <process_event+0x2b0>
     b06:	68fb      	ldr	r3, [r7, #12]
     b08:	3308      	adds	r3, #8
     b0a:	4618      	mov	r0, r3
     b0c:	f00f fb66 	bl	101dc <sys_slist_is_empty>
     b10:	4603      	mov	r3, r0
     b12:	f083 0301 	eor.w	r3, r3, #1
     b16:	b2db      	uxtb	r3, r3
     b18:	2b00      	cmp	r3, #0
     b1a:	d017      	beq.n	b4c <process_event+0x2b0>
     b1c:	2301      	movs	r3, #1
     b1e:	e016      	b.n	b4e <process_event+0x2b2>
     b20:	00018a28 	.word	0x00018a28
     b24:	00018a78 	.word	0x00018a78
     b28:	000189f0 	.word	0x000189f0
     b2c:	00018a88 	.word	0x00018a88
     b30:	00018a9c 	.word	0x00018a9c
     b34:	00018aa8 	.word	0x00018aa8
     b38:	00018acc 	.word	0x00018acc
     b3c:	00018ae4 	.word	0x00018ae4
     b40:	00018afc 	.word	0x00018afc
     b44:	00018b0c 	.word	0x00018b0c
     b48:	00018a74 	.word	0x00018a74
     b4c:	2300      	movs	r3, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     b4e:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
     b52:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
     b56:	f003 0301 	and.w	r3, r3, #1
     b5a:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a

		evt = EVT_NOP;
     b5e:	2300      	movs	r3, #0
     b60:	60bb      	str	r3, [r7, #8]
		if (do_monitors
     b62:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
     b66:	2b00      	cmp	r3, #0
     b68:	d10e      	bne.n	b88 <process_event+0x2ec>
		    || !sys_slist_is_empty(&clients)
     b6a:	f107 0320 	add.w	r3, r7, #32
     b6e:	4618      	mov	r0, r3
     b70:	f00f fb34 	bl	101dc <sys_slist_is_empty>
     b74:	4603      	mov	r3, r0
     b76:	f083 0301 	eor.w	r3, r3, #1
     b7a:	b2db      	uxtb	r3, r3
     b7c:	2b00      	cmp	r3, #0
     b7e:	d103      	bne.n	b88 <process_event+0x2ec>
		    || (transit != NULL)) {
     b80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     b82:	2b00      	cmp	r3, #0
     b84:	f000 808c 	beq.w	ca0 <process_event+0x404>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     b88:	68fb      	ldr	r3, [r7, #12]
     b8a:	8b9b      	ldrh	r3, [r3, #28]
     b8c:	f043 0308 	orr.w	r3, r3, #8
     b90:	b29b      	uxth	r3, r3
     b92:	647b      	str	r3, [r7, #68]	; 0x44

			mgr->flags = flags;
     b94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     b96:	b29a      	uxth	r2, r3
     b98:	68fb      	ldr	r3, [r7, #12]
     b9a:	839a      	strh	r2, [r3, #28]
			state = flags & ONOFF_STATE_MASK;
     b9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     b9e:	f003 0307 	and.w	r3, r3, #7
     ba2:	657b      	str	r3, [r7, #84]	; 0x54

			k_spin_unlock(&mgr->lock, key);
     ba4:	68fb      	ldr	r3, [r7, #12]
     ba6:	3314      	adds	r3, #20
     ba8:	643b      	str	r3, [r7, #64]	; 0x40
     baa:	687b      	ldr	r3, [r7, #4]
     bac:	617b      	str	r3, [r7, #20]
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     bae:	6c38      	ldr	r0, [r7, #64]	; 0x40
     bb0:	f00d ff6e 	bl	ea90 <z_spin_unlock_valid>
     bb4:	4603      	mov	r3, r0
     bb6:	f083 0301 	eor.w	r3, r3, #1
     bba:	b2db      	uxtb	r3, r3
     bbc:	2b00      	cmp	r3, #0
     bbe:	d00d      	beq.n	bdc <process_event+0x340>
     bc0:	23a3      	movs	r3, #163	; 0xa3
     bc2:	4a61      	ldr	r2, [pc, #388]	; (d48 <process_event+0x4ac>)
     bc4:	4961      	ldr	r1, [pc, #388]	; (d4c <process_event+0x4b0>)
     bc6:	4862      	ldr	r0, [pc, #392]	; (d50 <process_event+0x4b4>)
     bc8:	f00f fa4e 	bl	10068 <printk>
     bcc:	6c39      	ldr	r1, [r7, #64]	; 0x40
     bce:	4861      	ldr	r0, [pc, #388]	; (d54 <process_event+0x4b8>)
     bd0:	f00f fa4a 	bl	10068 <printk>
     bd4:	21a3      	movs	r1, #163	; 0xa3
     bd6:	485c      	ldr	r0, [pc, #368]	; (d48 <process_event+0x4ac>)
     bd8:	f010 f88e 	bl	10cf8 <assert_post_action>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
     bdc:	697b      	ldr	r3, [r7, #20]
     bde:	63fb      	str	r3, [r7, #60]	; 0x3c
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     be0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     be2:	f383 8811 	msr	BASEPRI, r3
     be6:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
     bea:	bf00      	nop
}
     bec:	bf00      	nop

			if (do_monitors) {
     bee:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
     bf2:	2b00      	cmp	r3, #0
     bf4:	d004      	beq.n	c00 <process_event+0x364>
				notify_monitors(mgr, state, res);
     bf6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
     bf8:	6d79      	ldr	r1, [r7, #84]	; 0x54
     bfa:	68f8      	ldr	r0, [r7, #12]
     bfc:	f00f fbca 	bl	10394 <notify_monitors>
			}

			if (!sys_slist_is_empty(&clients)) {
     c00:	f107 0320 	add.w	r3, r7, #32
     c04:	4618      	mov	r0, r3
     c06:	f00f fae9 	bl	101dc <sys_slist_is_empty>
     c0a:	4603      	mov	r3, r0
     c0c:	f083 0301 	eor.w	r3, r3, #1
     c10:	b2db      	uxtb	r3, r3
     c12:	2b00      	cmp	r3, #0
     c14:	d006      	beq.n	c24 <process_event+0x388>
				notify_all(mgr, &clients, state, res);
     c16:	f107 0120 	add.w	r1, r7, #32
     c1a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
     c1c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
     c1e:	68f8      	ldr	r0, [r7, #12]
     c20:	f00f fc23 	bl	1046a <notify_all>
			}

			if (transit != NULL) {
     c24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     c26:	2b00      	cmp	r3, #0
     c28:	d003      	beq.n	c32 <process_event+0x396>
				transit(mgr, transition_complete);
     c2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     c2c:	494a      	ldr	r1, [pc, #296]	; (d58 <process_event+0x4bc>)
     c2e:	68f8      	ldr	r0, [r7, #12]
     c30:	4798      	blx	r3
			}

			key = k_spin_lock(&mgr->lock);
     c32:	68fb      	ldr	r3, [r7, #12]
     c34:	3314      	adds	r3, #20
     c36:	63bb      	str	r3, [r7, #56]	; 0x38
	__asm__ volatile(
     c38:	f04f 0320 	mov.w	r3, #32
     c3c:	f3ef 8211 	mrs	r2, BASEPRI
     c40:	f383 8811 	msr	BASEPRI, r3
     c44:	f3bf 8f6f 	isb	sy
     c48:	637a      	str	r2, [r7, #52]	; 0x34
     c4a:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
     c4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	k.key = arch_irq_lock();
     c4e:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
     c50:	6bb8      	ldr	r0, [r7, #56]	; 0x38
     c52:	f00d ff01 	bl	ea58 <z_spin_lock_valid>
     c56:	4603      	mov	r3, r0
     c58:	f083 0301 	eor.w	r3, r3, #1
     c5c:	b2db      	uxtb	r3, r3
     c5e:	2b00      	cmp	r3, #0
     c60:	d00d      	beq.n	c7e <process_event+0x3e2>
     c62:	2378      	movs	r3, #120	; 0x78
     c64:	4a38      	ldr	r2, [pc, #224]	; (d48 <process_event+0x4ac>)
     c66:	493d      	ldr	r1, [pc, #244]	; (d5c <process_event+0x4c0>)
     c68:	4839      	ldr	r0, [pc, #228]	; (d50 <process_event+0x4b4>)
     c6a:	f00f f9fd 	bl	10068 <printk>
     c6e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
     c70:	483b      	ldr	r0, [pc, #236]	; (d60 <process_event+0x4c4>)
     c72:	f00f f9f9 	bl	10068 <printk>
     c76:	2178      	movs	r1, #120	; 0x78
     c78:	4833      	ldr	r0, [pc, #204]	; (d48 <process_event+0x4ac>)
     c7a:	f010 f83d 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
     c7e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
     c80:	f00d ff22 	bl	eac8 <z_spin_lock_set_owner>
	return k;
     c84:	69bb      	ldr	r3, [r7, #24]
     c86:	607b      	str	r3, [r7, #4]
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     c88:	68fb      	ldr	r3, [r7, #12]
     c8a:	8b9b      	ldrh	r3, [r3, #28]
     c8c:	f023 0308 	bic.w	r3, r3, #8
     c90:	b29a      	uxth	r2, r3
     c92:	68fb      	ldr	r3, [r7, #12]
     c94:	839a      	strh	r2, [r3, #28]
			state = mgr->flags & ONOFF_STATE_MASK;
     c96:	68fb      	ldr	r3, [r7, #12]
     c98:	8b9b      	ldrh	r3, [r3, #28]
     c9a:	f003 0307 	and.w	r3, r3, #7
     c9e:	657b      	str	r3, [r7, #84]	; 0x54
		}

		/* Process deferred events.  Completion takes priority
		 * over recheck.
		 */
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     ca0:	68fb      	ldr	r3, [r7, #12]
     ca2:	8b9b      	ldrh	r3, [r3, #28]
     ca4:	f003 0310 	and.w	r3, r3, #16
     ca8:	2b00      	cmp	r3, #0
     caa:	d009      	beq.n	cc0 <process_event+0x424>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     cac:	68fb      	ldr	r3, [r7, #12]
     cae:	8b9b      	ldrh	r3, [r3, #28]
     cb0:	f023 0310 	bic.w	r3, r3, #16
     cb4:	b29a      	uxth	r2, r3
     cb6:	68fb      	ldr	r3, [r7, #12]
     cb8:	839a      	strh	r2, [r3, #28]
			evt = EVT_COMPLETE;
     cba:	2301      	movs	r3, #1
     cbc:	60bb      	str	r3, [r7, #8]
     cbe:	e00e      	b.n	cde <process_event+0x442>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     cc0:	68fb      	ldr	r3, [r7, #12]
     cc2:	8b9b      	ldrh	r3, [r3, #28]
     cc4:	f003 0320 	and.w	r3, r3, #32
     cc8:	2b00      	cmp	r3, #0
     cca:	d008      	beq.n	cde <process_event+0x442>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     ccc:	68fb      	ldr	r3, [r7, #12]
     cce:	8b9b      	ldrh	r3, [r3, #28]
     cd0:	f023 0320 	bic.w	r3, r3, #32
     cd4:	b29a      	uxth	r2, r3
     cd6:	68fb      	ldr	r3, [r7, #12]
     cd8:	839a      	strh	r2, [r3, #28]
			evt = EVT_RECHECK;
     cda:	2302      	movs	r3, #2
     cdc:	60bb      	str	r3, [r7, #8]
		}

		state = mgr->flags & ONOFF_STATE_MASK;
     cde:	68fb      	ldr	r3, [r7, #12]
     ce0:	8b9b      	ldrh	r3, [r3, #28]
     ce2:	f003 0307 	and.w	r3, r3, #7
     ce6:	657b      	str	r3, [r7, #84]	; 0x54
	} while (evt != EVT_NOP);
     ce8:	68bb      	ldr	r3, [r7, #8]
     cea:	2b00      	cmp	r3, #0
     cec:	f47f ae27 	bne.w	93e <process_event+0xa2>

out:
     cf0:	e000      	b.n	cf4 <process_event+0x458>
			break;
     cf2:	bf00      	nop
	k_spin_unlock(&mgr->lock, key);
     cf4:	68fb      	ldr	r3, [r7, #12]
     cf6:	3314      	adds	r3, #20
     cf8:	62fb      	str	r3, [r7, #44]	; 0x2c
     cfa:	687b      	ldr	r3, [r7, #4]
     cfc:	61fb      	str	r3, [r7, #28]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     cfe:	6af8      	ldr	r0, [r7, #44]	; 0x2c
     d00:	f00d fec6 	bl	ea90 <z_spin_unlock_valid>
     d04:	4603      	mov	r3, r0
     d06:	f083 0301 	eor.w	r3, r3, #1
     d0a:	b2db      	uxtb	r3, r3
     d0c:	2b00      	cmp	r3, #0
     d0e:	d00d      	beq.n	d2c <process_event+0x490>
     d10:	23a3      	movs	r3, #163	; 0xa3
     d12:	4a0d      	ldr	r2, [pc, #52]	; (d48 <process_event+0x4ac>)
     d14:	490d      	ldr	r1, [pc, #52]	; (d4c <process_event+0x4b0>)
     d16:	480e      	ldr	r0, [pc, #56]	; (d50 <process_event+0x4b4>)
     d18:	f00f f9a6 	bl	10068 <printk>
     d1c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
     d1e:	480d      	ldr	r0, [pc, #52]	; (d54 <process_event+0x4b8>)
     d20:	f00f f9a2 	bl	10068 <printk>
     d24:	21a3      	movs	r1, #163	; 0xa3
     d26:	4808      	ldr	r0, [pc, #32]	; (d48 <process_event+0x4ac>)
     d28:	f00f ffe6 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
     d2c:	69fb      	ldr	r3, [r7, #28]
     d2e:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
     d30:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d32:	f383 8811 	msr	BASEPRI, r3
     d36:	f3bf 8f6f 	isb	sy
}
     d3a:	bf00      	nop
}
     d3c:	bf00      	nop
}
     d3e:	bf00      	nop
     d40:	3758      	adds	r7, #88	; 0x58
     d42:	46bd      	mov	sp, r7
     d44:	bd80      	pop	{r7, pc}
     d46:	bf00      	nop
     d48:	000189b0 	.word	0x000189b0
     d4c:	00018b24 	.word	0x00018b24
     d50:	000189f0 	.word	0x000189f0
     d54:	00018b3c 	.word	0x00018b3c
     d58:	000006b5 	.word	0x000006b5
     d5c:	000189d8 	.word	0x000189d8
     d60:	00018a10 	.word	0x00018a10

00000d64 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
     d64:	b580      	push	{r7, lr}
     d66:	b08e      	sub	sp, #56	; 0x38
     d68:	af00      	add	r7, sp, #0
     d6a:	6078      	str	r0, [r7, #4]
     d6c:	6039      	str	r1, [r7, #0]
	bool add_client = false;        /* add client to pending list */
     d6e:	2300      	movs	r3, #0
     d70:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	bool start = false;             /* trigger a start transition */
     d74:	2300      	movs	r3, #0
     d76:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
	bool notify = false;            /* do client notification */
     d7a:	2300      	movs	r3, #0
     d7c:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	int rv = validate_args(mgr, cli);
     d80:	6839      	ldr	r1, [r7, #0]
     d82:	6878      	ldr	r0, [r7, #4]
     d84:	f00f fabc 	bl	10300 <validate_args>
     d88:	6338      	str	r0, [r7, #48]	; 0x30

	if (rv < 0) {
     d8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     d8c:	2b00      	cmp	r3, #0
     d8e:	da01      	bge.n	d94 <onoff_request+0x30>
		return rv;
     d90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     d92:	e0b9      	b.n	f08 <onoff_request+0x1a4>
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
     d94:	687b      	ldr	r3, [r7, #4]
     d96:	3314      	adds	r3, #20
     d98:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
     d9a:	f04f 0320 	mov.w	r3, #32
     d9e:	f3ef 8211 	mrs	r2, BASEPRI
     da2:	f383 8811 	msr	BASEPRI, r3
     da6:	f3bf 8f6f 	isb	sy
     daa:	627a      	str	r2, [r7, #36]	; 0x24
     dac:	623b      	str	r3, [r7, #32]
	return key;
     dae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
     db0:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
     db2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     db4:	f00d fe50 	bl	ea58 <z_spin_lock_valid>
     db8:	4603      	mov	r3, r0
     dba:	f083 0301 	eor.w	r3, r3, #1
     dbe:	b2db      	uxtb	r3, r3
     dc0:	2b00      	cmp	r3, #0
     dc2:	d00d      	beq.n	de0 <onoff_request+0x7c>
     dc4:	2378      	movs	r3, #120	; 0x78
     dc6:	4a52      	ldr	r2, [pc, #328]	; (f10 <onoff_request+0x1ac>)
     dc8:	4952      	ldr	r1, [pc, #328]	; (f14 <onoff_request+0x1b0>)
     dca:	4853      	ldr	r0, [pc, #332]	; (f18 <onoff_request+0x1b4>)
     dcc:	f00f f94c 	bl	10068 <printk>
     dd0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
     dd2:	4852      	ldr	r0, [pc, #328]	; (f1c <onoff_request+0x1b8>)
     dd4:	f00f f948 	bl	10068 <printk>
     dd8:	2178      	movs	r1, #120	; 0x78
     dda:	484d      	ldr	r0, [pc, #308]	; (f10 <onoff_request+0x1ac>)
     ddc:	f00f ff8c 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
     de0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     de2:	f00d fe71 	bl	eac8 <z_spin_lock_set_owner>
	return k;
     de6:	68fb      	ldr	r3, [r7, #12]
     de8:	617b      	str	r3, [r7, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     dea:	687b      	ldr	r3, [r7, #4]
     dec:	8b9b      	ldrh	r3, [r3, #28]
     dee:	f003 0307 	and.w	r3, r3, #7
     df2:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
     df4:	687b      	ldr	r3, [r7, #4]
     df6:	8bdb      	ldrh	r3, [r3, #30]
     df8:	f64f 72ff 	movw	r2, #65535	; 0xffff
     dfc:	4293      	cmp	r3, r2
     dfe:	d103      	bne.n	e08 <onoff_request+0xa4>
		rv = -EAGAIN;
     e00:	f06f 030a 	mvn.w	r3, #10
     e04:	633b      	str	r3, [r7, #48]	; 0x30
		goto out;
     e06:	e03b      	b.n	e80 <onoff_request+0x11c>
	}

	rv = state;
     e08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e0a:	633b      	str	r3, [r7, #48]	; 0x30
	if (state == ONOFF_STATE_ON) {
     e0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e0e:	2b02      	cmp	r3, #2
     e10:	d109      	bne.n	e26 <onoff_request+0xc2>
		/* Increment reference count, notify in exit */
		notify = true;
     e12:	2301      	movs	r3, #1
     e14:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
		mgr->refs += 1U;
     e18:	687b      	ldr	r3, [r7, #4]
     e1a:	8bdb      	ldrh	r3, [r3, #30]
     e1c:	3301      	adds	r3, #1
     e1e:	b29a      	uxth	r2, r3
     e20:	687b      	ldr	r3, [r7, #4]
     e22:	83da      	strh	r2, [r3, #30]
     e24:	e02c      	b.n	e80 <onoff_request+0x11c>
	} else if ((state == ONOFF_STATE_OFF)
     e26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e28:	2b00      	cmp	r3, #0
     e2a:	d005      	beq.n	e38 <onoff_request+0xd4>
		   || (state == ONOFF_STATE_TO_OFF)
     e2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e2e:	2b04      	cmp	r3, #4
     e30:	d002      	beq.n	e38 <onoff_request+0xd4>
		   || (state == ONOFF_STATE_TO_ON)) {
     e32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e34:	2b06      	cmp	r3, #6
     e36:	d10a      	bne.n	e4e <onoff_request+0xea>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
     e38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e3a:	2b00      	cmp	r3, #0
     e3c:	bf0c      	ite	eq
     e3e:	2301      	moveq	r3, #1
     e40:	2300      	movne	r3, #0
     e42:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
		add_client = true;
     e46:	2301      	movs	r3, #1
     e48:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
     e4c:	e018      	b.n	e80 <onoff_request+0x11c>
	} else if (state == ONOFF_STATE_RESETTING) {
     e4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e50:	2b05      	cmp	r3, #5
     e52:	d103      	bne.n	e5c <onoff_request+0xf8>
		rv = -ENOTSUP;
     e54:	f06f 0322 	mvn.w	r3, #34	; 0x22
     e58:	633b      	str	r3, [r7, #48]	; 0x30
     e5a:	e011      	b.n	e80 <onoff_request+0x11c>
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
     e5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e5e:	2b01      	cmp	r3, #1
     e60:	d00b      	beq.n	e7a <onoff_request+0x116>
     e62:	f240 13c5 	movw	r3, #453	; 0x1c5
     e66:	4a2e      	ldr	r2, [pc, #184]	; (f20 <onoff_request+0x1bc>)
     e68:	492e      	ldr	r1, [pc, #184]	; (f24 <onoff_request+0x1c0>)
     e6a:	482b      	ldr	r0, [pc, #172]	; (f18 <onoff_request+0x1b4>)
     e6c:	f00f f8fc 	bl	10068 <printk>
     e70:	f240 11c5 	movw	r1, #453	; 0x1c5
     e74:	482a      	ldr	r0, [pc, #168]	; (f20 <onoff_request+0x1bc>)
     e76:	f00f ff3f 	bl	10cf8 <assert_post_action>
		rv = -EIO;
     e7a:	f06f 0304 	mvn.w	r3, #4
     e7e:	633b      	str	r3, [r7, #48]	; 0x30
	}

out:
	if (add_client) {
     e80:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
     e84:	2b00      	cmp	r3, #0
     e86:	d005      	beq.n	e94 <onoff_request+0x130>
		sys_slist_append(&mgr->clients, &cli->node);
     e88:	687b      	ldr	r3, [r7, #4]
     e8a:	683a      	ldr	r2, [r7, #0]
     e8c:	4611      	mov	r1, r2
     e8e:	4618      	mov	r0, r3
     e90:	f00f f9d2 	bl	10238 <sys_slist_append>
	}

	if (start) {
     e94:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
     e98:	2b00      	cmp	r3, #0
     e9a:	d005      	beq.n	ea8 <onoff_request+0x144>
		process_event(mgr, EVT_RECHECK, key);
     e9c:	697a      	ldr	r2, [r7, #20]
     e9e:	2102      	movs	r1, #2
     ea0:	6878      	ldr	r0, [r7, #4]
     ea2:	f7ff fcfb 	bl	89c <process_event>
     ea6:	e02e      	b.n	f06 <onoff_request+0x1a2>
	} else {
		k_spin_unlock(&mgr->lock, key);
     ea8:	687b      	ldr	r3, [r7, #4]
     eaa:	3314      	adds	r3, #20
     eac:	61fb      	str	r3, [r7, #28]
     eae:	697b      	ldr	r3, [r7, #20]
     eb0:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
     eb2:	69f8      	ldr	r0, [r7, #28]
     eb4:	f00d fdec 	bl	ea90 <z_spin_unlock_valid>
     eb8:	4603      	mov	r3, r0
     eba:	f083 0301 	eor.w	r3, r3, #1
     ebe:	b2db      	uxtb	r3, r3
     ec0:	2b00      	cmp	r3, #0
     ec2:	d00d      	beq.n	ee0 <onoff_request+0x17c>
     ec4:	23a3      	movs	r3, #163	; 0xa3
     ec6:	4a12      	ldr	r2, [pc, #72]	; (f10 <onoff_request+0x1ac>)
     ec8:	4917      	ldr	r1, [pc, #92]	; (f28 <onoff_request+0x1c4>)
     eca:	4813      	ldr	r0, [pc, #76]	; (f18 <onoff_request+0x1b4>)
     ecc:	f00f f8cc 	bl	10068 <printk>
     ed0:	69f9      	ldr	r1, [r7, #28]
     ed2:	4816      	ldr	r0, [pc, #88]	; (f2c <onoff_request+0x1c8>)
     ed4:	f00f f8c8 	bl	10068 <printk>
     ed8:	21a3      	movs	r1, #163	; 0xa3
     eda:	480d      	ldr	r0, [pc, #52]	; (f10 <onoff_request+0x1ac>)
     edc:	f00f ff0c 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
     ee0:	693b      	ldr	r3, [r7, #16]
     ee2:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
     ee4:	69bb      	ldr	r3, [r7, #24]
     ee6:	f383 8811 	msr	BASEPRI, r3
     eea:	f3bf 8f6f 	isb	sy
}
     eee:	bf00      	nop
}
     ef0:	bf00      	nop

		if (notify) {
     ef2:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
     ef6:	2b00      	cmp	r3, #0
     ef8:	d005      	beq.n	f06 <onoff_request+0x1a2>
			notify_one(mgr, cli, state, 0);
     efa:	2300      	movs	r3, #0
     efc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     efe:	6839      	ldr	r1, [r7, #0]
     f00:	6878      	ldr	r0, [r7, #4]
     f02:	f00f fa97 	bl	10434 <notify_one>
		}
	}

	return rv;
     f06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
     f08:	4618      	mov	r0, r3
     f0a:	3738      	adds	r7, #56	; 0x38
     f0c:	46bd      	mov	sp, r7
     f0e:	bd80      	pop	{r7, pc}
     f10:	000189b0 	.word	0x000189b0
     f14:	000189d8 	.word	0x000189d8
     f18:	000189f0 	.word	0x000189f0
     f1c:	00018a10 	.word	0x00018a10
     f20:	00018a28 	.word	0x00018a28
     f24:	00018b0c 	.word	0x00018b0c
     f28:	00018b24 	.word	0x00018b24
     f2c:	00018b3c 	.word	0x00018b3c

00000f30 <sys_heap_init>:
	set_chunk_used(h, c, true);
	return mem;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
     f30:	b580      	push	{r7, lr}
     f32:	b08c      	sub	sp, #48	; 0x30
     f34:	af00      	add	r7, sp, #0
     f36:	60f8      	str	r0, [r7, #12]
     f38:	60b9      	str	r1, [r7, #8]
     f3a:	607a      	str	r2, [r7, #4]
	/* Must fit in a 32 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0xffffffffU, "heap size is too big");

	/* Reserve the final marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
     f3c:	6878      	ldr	r0, [r7, #4]
     f3e:	f00f fc6a 	bl	10816 <heap_footer_bytes>
     f42:	4602      	mov	r2, r0
     f44:	687b      	ldr	r3, [r7, #4]
     f46:	4293      	cmp	r3, r2
     f48:	d80e      	bhi.n	f68 <sys_heap_init+0x38>
     f4a:	f44f 7397 	mov.w	r3, #302	; 0x12e
     f4e:	4a5a      	ldr	r2, [pc, #360]	; (10b8 <sys_heap_init+0x188>)
     f50:	495a      	ldr	r1, [pc, #360]	; (10bc <sys_heap_init+0x18c>)
     f52:	485b      	ldr	r0, [pc, #364]	; (10c0 <sys_heap_init+0x190>)
     f54:	f00f f888 	bl	10068 <printk>
     f58:	485a      	ldr	r0, [pc, #360]	; (10c4 <sys_heap_init+0x194>)
     f5a:	f00f f885 	bl	10068 <printk>
     f5e:	f44f 7197 	mov.w	r1, #302	; 0x12e
     f62:	4855      	ldr	r0, [pc, #340]	; (10b8 <sys_heap_init+0x188>)
     f64:	f00f fec8 	bl	10cf8 <assert_post_action>
	bytes -= heap_footer_bytes(bytes);
     f68:	6878      	ldr	r0, [r7, #4]
     f6a:	f00f fc54 	bl	10816 <heap_footer_bytes>
     f6e:	4602      	mov	r2, r0
     f70:	687b      	ldr	r3, [r7, #4]
     f72:	1a9b      	subs	r3, r3, r2
     f74:	607b      	str	r3, [r7, #4]

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
     f76:	68bb      	ldr	r3, [r7, #8]
     f78:	3307      	adds	r3, #7
     f7a:	f023 0307 	bic.w	r3, r3, #7
     f7e:	62bb      	str	r3, [r7, #40]	; 0x28
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
     f80:	68ba      	ldr	r2, [r7, #8]
     f82:	687b      	ldr	r3, [r7, #4]
     f84:	4413      	add	r3, r2
     f86:	f023 0307 	bic.w	r3, r3, #7
     f8a:	627b      	str	r3, [r7, #36]	; 0x24
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
     f8c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     f8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
     f90:	1ad3      	subs	r3, r2, r3
     f92:	08db      	lsrs	r3, r3, #3
     f94:	623b      	str	r3, [r7, #32]

	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
     f96:	2010      	movs	r0, #16
     f98:	f00f fc4e 	bl	10838 <chunksz>
     f9c:	4602      	mov	r2, r0
     f9e:	6a3b      	ldr	r3, [r7, #32]
     fa0:	4293      	cmp	r3, r2
     fa2:	d80e      	bhi.n	fc2 <sys_heap_init+0x92>
     fa4:	f240 1337 	movw	r3, #311	; 0x137
     fa8:	4a43      	ldr	r2, [pc, #268]	; (10b8 <sys_heap_init+0x188>)
     faa:	4947      	ldr	r1, [pc, #284]	; (10c8 <sys_heap_init+0x198>)
     fac:	4844      	ldr	r0, [pc, #272]	; (10c0 <sys_heap_init+0x190>)
     fae:	f00f f85b 	bl	10068 <printk>
     fb2:	4844      	ldr	r0, [pc, #272]	; (10c4 <sys_heap_init+0x194>)
     fb4:	f00f f858 	bl	10068 <printk>
     fb8:	f240 1137 	movw	r1, #311	; 0x137
     fbc:	483e      	ldr	r0, [pc, #248]	; (10b8 <sys_heap_init+0x188>)
     fbe:	f00f fe9b 	bl	10cf8 <assert_post_action>

	struct z_heap *h = (struct z_heap *)addr;
     fc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
     fc4:	61fb      	str	r3, [r7, #28]
	heap->heap = h;
     fc6:	68fb      	ldr	r3, [r7, #12]
     fc8:	69fa      	ldr	r2, [r7, #28]
     fca:	601a      	str	r2, [r3, #0]
	h->chunk0_hdr_area = 0;
     fcc:	69f9      	ldr	r1, [r7, #28]
     fce:	f04f 0200 	mov.w	r2, #0
     fd2:	f04f 0300 	mov.w	r3, #0
     fd6:	e9c1 2300 	strd	r2, r3, [r1]
	h->len = buf_sz;
     fda:	69fb      	ldr	r3, [r7, #28]
     fdc:	6a3a      	ldr	r2, [r7, #32]
     fde:	609a      	str	r2, [r3, #8]
	h->avail_buckets = 0;
     fe0:	69fb      	ldr	r3, [r7, #28]
     fe2:	2200      	movs	r2, #0
     fe4:	60da      	str	r2, [r3, #12]

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
     fe6:	6a39      	ldr	r1, [r7, #32]
     fe8:	69f8      	ldr	r0, [r7, #28]
     fea:	f00f fc51 	bl	10890 <bucket_idx>
     fee:	4603      	mov	r3, r0
     ff0:	3301      	adds	r3, #1
     ff2:	61bb      	str	r3, [r7, #24]
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
     ff4:	69bb      	ldr	r3, [r7, #24]
     ff6:	3304      	adds	r3, #4
     ff8:	009b      	lsls	r3, r3, #2
     ffa:	4618      	mov	r0, r3
     ffc:	f00f fc1c 	bl	10838 <chunksz>
    1000:	6178      	str	r0, [r7, #20]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");
    1002:	69f8      	ldr	r0, [r7, #28]
    1004:	f00f fc37 	bl	10876 <min_chunk_size>
    1008:	4603      	mov	r3, r0
    100a:	461a      	mov	r2, r3
    100c:	697b      	ldr	r3, [r7, #20]
    100e:	4413      	add	r3, r2
    1010:	6a3a      	ldr	r2, [r7, #32]
    1012:	429a      	cmp	r2, r3
    1014:	d80e      	bhi.n	1034 <sys_heap_init+0x104>
    1016:	f240 1343 	movw	r3, #323	; 0x143
    101a:	4a27      	ldr	r2, [pc, #156]	; (10b8 <sys_heap_init+0x188>)
    101c:	492b      	ldr	r1, [pc, #172]	; (10cc <sys_heap_init+0x19c>)
    101e:	4828      	ldr	r0, [pc, #160]	; (10c0 <sys_heap_init+0x190>)
    1020:	f00f f822 	bl	10068 <printk>
    1024:	4827      	ldr	r0, [pc, #156]	; (10c4 <sys_heap_init+0x194>)
    1026:	f00f f81f 	bl	10068 <printk>
    102a:	f240 1143 	movw	r1, #323	; 0x143
    102e:	4822      	ldr	r0, [pc, #136]	; (10b8 <sys_heap_init+0x188>)
    1030:	f00f fe62 	bl	10cf8 <assert_post_action>

	for (int i = 0; i < nb_buckets; i++) {
    1034:	2300      	movs	r3, #0
    1036:	62fb      	str	r3, [r7, #44]	; 0x2c
    1038:	e008      	b.n	104c <sys_heap_init+0x11c>
		h->buckets[i].next = 0;
    103a:	69fb      	ldr	r3, [r7, #28]
    103c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    103e:	3204      	adds	r2, #4
    1040:	2100      	movs	r1, #0
    1042:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
    1046:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1048:	3301      	adds	r3, #1
    104a:	62fb      	str	r3, [r7, #44]	; 0x2c
    104c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    104e:	69bb      	ldr	r3, [r7, #24]
    1050:	429a      	cmp	r2, r3
    1052:	dbf2      	blt.n	103a <sys_heap_init+0x10a>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
    1054:	697a      	ldr	r2, [r7, #20]
    1056:	2100      	movs	r1, #0
    1058:	69f8      	ldr	r0, [r7, #28]
    105a:	f00f fb5f 	bl	1071c <set_chunk_size>
	set_chunk_used(h, 0, true);
    105e:	2201      	movs	r2, #1
    1060:	2100      	movs	r1, #0
    1062:	69f8      	ldr	r0, [r7, #28]
    1064:	f00f fb15 	bl	10692 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
    1068:	6a3a      	ldr	r2, [r7, #32]
    106a:	697b      	ldr	r3, [r7, #20]
    106c:	1ad3      	subs	r3, r2, r3
    106e:	461a      	mov	r2, r3
    1070:	6979      	ldr	r1, [r7, #20]
    1072:	69f8      	ldr	r0, [r7, #28]
    1074:	f00f fb52 	bl	1071c <set_chunk_size>
	set_left_chunk_size(h, chunk0_size, chunk0_size);
    1078:	697a      	ldr	r2, [r7, #20]
    107a:	6979      	ldr	r1, [r7, #20]
    107c:	69f8      	ldr	r0, [r7, #28]
    107e:	f00f fb8d 	bl	1079c <set_left_chunk_size>

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
    1082:	2200      	movs	r2, #0
    1084:	6a39      	ldr	r1, [r7, #32]
    1086:	69f8      	ldr	r0, [r7, #28]
    1088:	f00f fb48 	bl	1071c <set_chunk_size>
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
    108c:	6a3a      	ldr	r2, [r7, #32]
    108e:	697b      	ldr	r3, [r7, #20]
    1090:	1ad3      	subs	r3, r2, r3
    1092:	461a      	mov	r2, r3
    1094:	6a39      	ldr	r1, [r7, #32]
    1096:	69f8      	ldr	r0, [r7, #28]
    1098:	f00f fb80 	bl	1079c <set_left_chunk_size>
	set_chunk_used(h, buf_sz, true);
    109c:	2201      	movs	r2, #1
    109e:	6a39      	ldr	r1, [r7, #32]
    10a0:	69f8      	ldr	r0, [r7, #28]
    10a2:	f00f faf6 	bl	10692 <set_chunk_used>

	free_list_add(h, chunk0_size);
    10a6:	6979      	ldr	r1, [r7, #20]
    10a8:	69f8      	ldr	r0, [r7, #28]
    10aa:	f00f fc4f 	bl	1094c <free_list_add>
}
    10ae:	bf00      	nop
    10b0:	3730      	adds	r7, #48	; 0x30
    10b2:	46bd      	mov	sp, r7
    10b4:	bd80      	pop	{r7, pc}
    10b6:	bf00      	nop
    10b8:	00018be0 	.word	0x00018be0
    10bc:	00018cd4 	.word	0x00018cd4
    10c0:	00018c18 	.word	0x00018c18
    10c4:	00018cf8 	.word	0x00018cf8
    10c8:	00018d14 	.word	0x00018d14
    10cc:	00018d3c 	.word	0x00018d3c

000010d0 <extract_flags>:
 *
 * @return a pointer the first character that follows the flags.
 */
static inline const char *extract_flags(struct conversion *conv,
					const char *sp)
{
    10d0:	b480      	push	{r7}
    10d2:	b085      	sub	sp, #20
    10d4:	af00      	add	r7, sp, #0
    10d6:	6078      	str	r0, [r7, #4]
    10d8:	6039      	str	r1, [r7, #0]
	bool loop = true;
    10da:	2301      	movs	r3, #1
    10dc:	73fb      	strb	r3, [r7, #15]

	do {
		switch (*sp) {
    10de:	683b      	ldr	r3, [r7, #0]
    10e0:	781b      	ldrb	r3, [r3, #0]
    10e2:	3b20      	subs	r3, #32
    10e4:	2b10      	cmp	r3, #16
    10e6:	d843      	bhi.n	1170 <extract_flags+0xa0>
    10e8:	a201      	add	r2, pc, #4	; (adr r2, 10f0 <extract_flags+0x20>)
    10ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    10ee:	bf00      	nop
    10f0:	0000114d 	.word	0x0000114d
    10f4:	00001171 	.word	0x00001171
    10f8:	00001171 	.word	0x00001171
    10fc:	00001159 	.word	0x00001159
    1100:	00001171 	.word	0x00001171
    1104:	00001171 	.word	0x00001171
    1108:	00001171 	.word	0x00001171
    110c:	00001171 	.word	0x00001171
    1110:	00001171 	.word	0x00001171
    1114:	00001171 	.word	0x00001171
    1118:	00001171 	.word	0x00001171
    111c:	00001141 	.word	0x00001141
    1120:	00001171 	.word	0x00001171
    1124:	00001135 	.word	0x00001135
    1128:	00001171 	.word	0x00001171
    112c:	00001171 	.word	0x00001171
    1130:	00001165 	.word	0x00001165
		case '-':
			conv->flag_dash = true;
    1134:	687a      	ldr	r2, [r7, #4]
    1136:	7813      	ldrb	r3, [r2, #0]
    1138:	f043 0304 	orr.w	r3, r3, #4
    113c:	7013      	strb	r3, [r2, #0]
			break;
    113e:	e019      	b.n	1174 <extract_flags+0xa4>
		case '+':
			conv->flag_plus = true;
    1140:	687a      	ldr	r2, [r7, #4]
    1142:	7813      	ldrb	r3, [r2, #0]
    1144:	f043 0308 	orr.w	r3, r3, #8
    1148:	7013      	strb	r3, [r2, #0]
			break;
    114a:	e013      	b.n	1174 <extract_flags+0xa4>
		case ' ':
			conv->flag_space = true;
    114c:	687a      	ldr	r2, [r7, #4]
    114e:	7813      	ldrb	r3, [r2, #0]
    1150:	f043 0310 	orr.w	r3, r3, #16
    1154:	7013      	strb	r3, [r2, #0]
			break;
    1156:	e00d      	b.n	1174 <extract_flags+0xa4>
		case '#':
			conv->flag_hash = true;
    1158:	687a      	ldr	r2, [r7, #4]
    115a:	7813      	ldrb	r3, [r2, #0]
    115c:	f043 0320 	orr.w	r3, r3, #32
    1160:	7013      	strb	r3, [r2, #0]
			break;
    1162:	e007      	b.n	1174 <extract_flags+0xa4>
		case '0':
			conv->flag_zero = true;
    1164:	687a      	ldr	r2, [r7, #4]
    1166:	7813      	ldrb	r3, [r2, #0]
    1168:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    116c:	7013      	strb	r3, [r2, #0]
			break;
    116e:	e001      	b.n	1174 <extract_flags+0xa4>
		default:
			loop = false;
    1170:	2300      	movs	r3, #0
    1172:	73fb      	strb	r3, [r7, #15]
		}
		if (loop) {
    1174:	7bfb      	ldrb	r3, [r7, #15]
    1176:	2b00      	cmp	r3, #0
    1178:	d002      	beq.n	1180 <extract_flags+0xb0>
			++sp;
    117a:	683b      	ldr	r3, [r7, #0]
    117c:	3301      	adds	r3, #1
    117e:	603b      	str	r3, [r7, #0]
		}
	} while (loop);
    1180:	7bfb      	ldrb	r3, [r7, #15]
    1182:	2b00      	cmp	r3, #0
    1184:	d1ab      	bne.n	10de <extract_flags+0xe>

	/* zero && dash => !zero */
	if (conv->flag_zero && conv->flag_dash) {
    1186:	687b      	ldr	r3, [r7, #4]
    1188:	781b      	ldrb	r3, [r3, #0]
    118a:	f003 0340 	and.w	r3, r3, #64	; 0x40
    118e:	b2db      	uxtb	r3, r3
    1190:	2b00      	cmp	r3, #0
    1192:	d00b      	beq.n	11ac <extract_flags+0xdc>
    1194:	687b      	ldr	r3, [r7, #4]
    1196:	781b      	ldrb	r3, [r3, #0]
    1198:	f003 0304 	and.w	r3, r3, #4
    119c:	b2db      	uxtb	r3, r3
    119e:	2b00      	cmp	r3, #0
    11a0:	d004      	beq.n	11ac <extract_flags+0xdc>
		conv->flag_zero = false;
    11a2:	687a      	ldr	r2, [r7, #4]
    11a4:	7813      	ldrb	r3, [r2, #0]
    11a6:	f36f 1386 	bfc	r3, #6, #1
    11aa:	7013      	strb	r3, [r2, #0]
	}

	/* space && plus => !plus, handled in emitter code */

	return sp;
    11ac:	683b      	ldr	r3, [r7, #0]
}
    11ae:	4618      	mov	r0, r3
    11b0:	3714      	adds	r7, #20
    11b2:	46bd      	mov	sp, r7
    11b4:	bc80      	pop	{r7}
    11b6:	4770      	bx	lr

000011b8 <extract_length>:
 *
 * @return a pointer the first character that follows the precision.
 */
static inline const char *extract_length(struct conversion *conv,
					 const char *sp)
{
    11b8:	b480      	push	{r7}
    11ba:	b083      	sub	sp, #12
    11bc:	af00      	add	r7, sp, #0
    11be:	6078      	str	r0, [r7, #4]
    11c0:	6039      	str	r1, [r7, #0]
	switch (*sp) {
    11c2:	683b      	ldr	r3, [r7, #0]
    11c4:	781b      	ldrb	r3, [r3, #0]
    11c6:	3b4c      	subs	r3, #76	; 0x4c
    11c8:	2b2e      	cmp	r3, #46	; 0x2e
    11ca:	f200 80be 	bhi.w	134a <extract_length+0x192>
    11ce:	a201      	add	r2, pc, #4	; (adr r2, 11d4 <extract_length+0x1c>)
    11d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    11d4:	0000132d 	.word	0x0000132d
    11d8:	0000134b 	.word	0x0000134b
    11dc:	0000134b 	.word	0x0000134b
    11e0:	0000134b 	.word	0x0000134b
    11e4:	0000134b 	.word	0x0000134b
    11e8:	0000134b 	.word	0x0000134b
    11ec:	0000134b 	.word	0x0000134b
    11f0:	0000134b 	.word	0x0000134b
    11f4:	0000134b 	.word	0x0000134b
    11f8:	0000134b 	.word	0x0000134b
    11fc:	0000134b 	.word	0x0000134b
    1200:	0000134b 	.word	0x0000134b
    1204:	0000134b 	.word	0x0000134b
    1208:	0000134b 	.word	0x0000134b
    120c:	0000134b 	.word	0x0000134b
    1210:	0000134b 	.word	0x0000134b
    1214:	0000134b 	.word	0x0000134b
    1218:	0000134b 	.word	0x0000134b
    121c:	0000134b 	.word	0x0000134b
    1220:	0000134b 	.word	0x0000134b
    1224:	0000134b 	.word	0x0000134b
    1228:	0000134b 	.word	0x0000134b
    122c:	0000134b 	.word	0x0000134b
    1230:	0000134b 	.word	0x0000134b
    1234:	0000134b 	.word	0x0000134b
    1238:	0000134b 	.word	0x0000134b
    123c:	0000134b 	.word	0x0000134b
    1240:	0000134b 	.word	0x0000134b
    1244:	00001291 	.word	0x00001291
    1248:	0000134b 	.word	0x0000134b
    124c:	000012f1 	.word	0x000012f1
    1250:	0000134b 	.word	0x0000134b
    1254:	000012c1 	.word	0x000012c1
    1258:	0000134b 	.word	0x0000134b
    125c:	0000134b 	.word	0x0000134b
    1260:	0000134b 	.word	0x0000134b
    1264:	0000134b 	.word	0x0000134b
    1268:	0000134b 	.word	0x0000134b
    126c:	0000134b 	.word	0x0000134b
    1270:	0000134b 	.word	0x0000134b
    1274:	00001319 	.word	0x00001319
    1278:	0000134b 	.word	0x0000134b
    127c:	0000134b 	.word	0x0000134b
    1280:	0000134b 	.word	0x0000134b
    1284:	0000134b 	.word	0x0000134b
    1288:	0000134b 	.word	0x0000134b
    128c:	00001305 	.word	0x00001305
	case 'h':
		if (*++sp == 'h') {
    1290:	683b      	ldr	r3, [r7, #0]
    1292:	3301      	adds	r3, #1
    1294:	603b      	str	r3, [r7, #0]
    1296:	683b      	ldr	r3, [r7, #0]
    1298:	781b      	ldrb	r3, [r3, #0]
    129a:	2b68      	cmp	r3, #104	; 0x68
    129c:	d109      	bne.n	12b2 <extract_length+0xfa>
			conv->length_mod = LENGTH_HH;
    129e:	687a      	ldr	r2, [r7, #4]
    12a0:	7853      	ldrb	r3, [r2, #1]
    12a2:	2101      	movs	r1, #1
    12a4:	f361 03c6 	bfi	r3, r1, #3, #4
    12a8:	7053      	strb	r3, [r2, #1]
			++sp;
    12aa:	683b      	ldr	r3, [r7, #0]
    12ac:	3301      	adds	r3, #1
    12ae:	603b      	str	r3, [r7, #0]
		} else {
			conv->length_mod = LENGTH_H;
		}
		break;
    12b0:	e051      	b.n	1356 <extract_length+0x19e>
			conv->length_mod = LENGTH_H;
    12b2:	687a      	ldr	r2, [r7, #4]
    12b4:	7853      	ldrb	r3, [r2, #1]
    12b6:	2102      	movs	r1, #2
    12b8:	f361 03c6 	bfi	r3, r1, #3, #4
    12bc:	7053      	strb	r3, [r2, #1]
		break;
    12be:	e04a      	b.n	1356 <extract_length+0x19e>
	case 'l':
		if (*++sp == 'l') {
    12c0:	683b      	ldr	r3, [r7, #0]
    12c2:	3301      	adds	r3, #1
    12c4:	603b      	str	r3, [r7, #0]
    12c6:	683b      	ldr	r3, [r7, #0]
    12c8:	781b      	ldrb	r3, [r3, #0]
    12ca:	2b6c      	cmp	r3, #108	; 0x6c
    12cc:	d109      	bne.n	12e2 <extract_length+0x12a>
			conv->length_mod = LENGTH_LL;
    12ce:	687a      	ldr	r2, [r7, #4]
    12d0:	7853      	ldrb	r3, [r2, #1]
    12d2:	2104      	movs	r1, #4
    12d4:	f361 03c6 	bfi	r3, r1, #3, #4
    12d8:	7053      	strb	r3, [r2, #1]
			++sp;
    12da:	683b      	ldr	r3, [r7, #0]
    12dc:	3301      	adds	r3, #1
    12de:	603b      	str	r3, [r7, #0]
		} else {
			conv->length_mod = LENGTH_L;
		}
		break;
    12e0:	e039      	b.n	1356 <extract_length+0x19e>
			conv->length_mod = LENGTH_L;
    12e2:	687a      	ldr	r2, [r7, #4]
    12e4:	7853      	ldrb	r3, [r2, #1]
    12e6:	2103      	movs	r1, #3
    12e8:	f361 03c6 	bfi	r3, r1, #3, #4
    12ec:	7053      	strb	r3, [r2, #1]
		break;
    12ee:	e032      	b.n	1356 <extract_length+0x19e>
	case 'j':
		conv->length_mod = LENGTH_J;
    12f0:	687a      	ldr	r2, [r7, #4]
    12f2:	7853      	ldrb	r3, [r2, #1]
    12f4:	2105      	movs	r1, #5
    12f6:	f361 03c6 	bfi	r3, r1, #3, #4
    12fa:	7053      	strb	r3, [r2, #1]
		++sp;
    12fc:	683b      	ldr	r3, [r7, #0]
    12fe:	3301      	adds	r3, #1
    1300:	603b      	str	r3, [r7, #0]
		break;
    1302:	e028      	b.n	1356 <extract_length+0x19e>
	case 'z':
		conv->length_mod = LENGTH_Z;
    1304:	687a      	ldr	r2, [r7, #4]
    1306:	7853      	ldrb	r3, [r2, #1]
    1308:	2106      	movs	r1, #6
    130a:	f361 03c6 	bfi	r3, r1, #3, #4
    130e:	7053      	strb	r3, [r2, #1]
		++sp;
    1310:	683b      	ldr	r3, [r7, #0]
    1312:	3301      	adds	r3, #1
    1314:	603b      	str	r3, [r7, #0]
		break;
    1316:	e01e      	b.n	1356 <extract_length+0x19e>
	case 't':
		conv->length_mod = LENGTH_T;
    1318:	687a      	ldr	r2, [r7, #4]
    131a:	7853      	ldrb	r3, [r2, #1]
    131c:	2107      	movs	r1, #7
    131e:	f361 03c6 	bfi	r3, r1, #3, #4
    1322:	7053      	strb	r3, [r2, #1]
		++sp;
    1324:	683b      	ldr	r3, [r7, #0]
    1326:	3301      	adds	r3, #1
    1328:	603b      	str	r3, [r7, #0]
		break;
    132a:	e014      	b.n	1356 <extract_length+0x19e>
	case 'L':
		conv->length_mod = LENGTH_UPPER_L;
    132c:	687a      	ldr	r2, [r7, #4]
    132e:	7853      	ldrb	r3, [r2, #1]
    1330:	2108      	movs	r1, #8
    1332:	f361 03c6 	bfi	r3, r1, #3, #4
    1336:	7053      	strb	r3, [r2, #1]
		++sp;
    1338:	683b      	ldr	r3, [r7, #0]
    133a:	3301      	adds	r3, #1
    133c:	603b      	str	r3, [r7, #0]

		/* We recognize and consume these, but can't format
		 * them.
		 */
		conv->unsupported = true;
    133e:	687a      	ldr	r2, [r7, #4]
    1340:	7813      	ldrb	r3, [r2, #0]
    1342:	f043 0302 	orr.w	r3, r3, #2
    1346:	7013      	strb	r3, [r2, #0]
		break;
    1348:	e005      	b.n	1356 <extract_length+0x19e>
	default:
		conv->length_mod = LENGTH_NONE;
    134a:	687a      	ldr	r2, [r7, #4]
    134c:	7853      	ldrb	r3, [r2, #1]
    134e:	f36f 03c6 	bfc	r3, #3, #4
    1352:	7053      	strb	r3, [r2, #1]
		break;
    1354:	bf00      	nop
	}
	return sp;
    1356:	683b      	ldr	r3, [r7, #0]
}
    1358:	4618      	mov	r0, r3
    135a:	370c      	adds	r7, #12
    135c:	46bd      	mov	sp, r7
    135e:	bc80      	pop	{r7}
    1360:	4770      	bx	lr
    1362:	bf00      	nop

00001364 <extract_specifier>:
 *
 * @return a pointer the first character that follows the specifier.
 */
static inline const char *extract_specifier(struct conversion *conv,
					    const char *sp)
{
    1364:	b480      	push	{r7}
    1366:	b085      	sub	sp, #20
    1368:	af00      	add	r7, sp, #0
    136a:	6078      	str	r0, [r7, #4]
    136c:	6039      	str	r1, [r7, #0]
	bool unsupported = false;
    136e:	2300      	movs	r3, #0
    1370:	73fb      	strb	r3, [r7, #15]

	conv->specifier = *sp++;
    1372:	683b      	ldr	r3, [r7, #0]
    1374:	1c5a      	adds	r2, r3, #1
    1376:	603a      	str	r2, [r7, #0]
    1378:	781a      	ldrb	r2, [r3, #0]
    137a:	687b      	ldr	r3, [r7, #4]
    137c:	70da      	strb	r2, [r3, #3]

	switch (conv->specifier) {
    137e:	687b      	ldr	r3, [r7, #4]
    1380:	78db      	ldrb	r3, [r3, #3]
    1382:	3b41      	subs	r3, #65	; 0x41
    1384:	2b37      	cmp	r3, #55	; 0x37
    1386:	f200 80c6 	bhi.w	1516 <extract_specifier+0x1b2>
    138a:	a201      	add	r2, pc, #4	; (adr r2, 1390 <extract_specifier+0x2c>)
    138c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1390:	000014c5 	.word	0x000014c5
    1394:	00001517 	.word	0x00001517
    1398:	00001517 	.word	0x00001517
    139c:	00001517 	.word	0x00001517
    13a0:	000014c5 	.word	0x000014c5
    13a4:	000014c5 	.word	0x000014c5
    13a8:	000014c5 	.word	0x000014c5
    13ac:	00001517 	.word	0x00001517
    13b0:	00001517 	.word	0x00001517
    13b4:	00001517 	.word	0x00001517
    13b8:	00001517 	.word	0x00001517
    13bc:	00001517 	.word	0x00001517
    13c0:	00001517 	.word	0x00001517
    13c4:	00001517 	.word	0x00001517
    13c8:	00001517 	.word	0x00001517
    13cc:	00001517 	.word	0x00001517
    13d0:	00001517 	.word	0x00001517
    13d4:	00001517 	.word	0x00001517
    13d8:	00001517 	.word	0x00001517
    13dc:	00001517 	.word	0x00001517
    13e0:	00001517 	.word	0x00001517
    13e4:	00001517 	.word	0x00001517
    13e8:	00001517 	.word	0x00001517
    13ec:	0000147f 	.word	0x0000147f
    13f0:	00001517 	.word	0x00001517
    13f4:	00001517 	.word	0x00001517
    13f8:	00001517 	.word	0x00001517
    13fc:	00001517 	.word	0x00001517
    1400:	00001517 	.word	0x00001517
    1404:	00001517 	.word	0x00001517
    1408:	00001517 	.word	0x00001517
    140c:	00001517 	.word	0x00001517
    1410:	000014c5 	.word	0x000014c5
    1414:	00001517 	.word	0x00001517
    1418:	0000147f 	.word	0x0000147f
    141c:	00001471 	.word	0x00001471
    1420:	000014c5 	.word	0x000014c5
    1424:	000014c5 	.word	0x000014c5
    1428:	000014c5 	.word	0x000014c5
    142c:	00001517 	.word	0x00001517
    1430:	00001471 	.word	0x00001471
    1434:	00001517 	.word	0x00001517
    1438:	00001517 	.word	0x00001517
    143c:	00001517 	.word	0x00001517
    1440:	00001517 	.word	0x00001517
    1444:	000014d7 	.word	0x000014d7
    1448:	0000147f 	.word	0x0000147f
    144c:	000014f7 	.word	0x000014f7
    1450:	00001517 	.word	0x00001517
    1454:	00001517 	.word	0x00001517
    1458:	000014f7 	.word	0x000014f7
    145c:	00001517 	.word	0x00001517
    1460:	0000147f 	.word	0x0000147f
    1464:	00001517 	.word	0x00001517
    1468:	00001517 	.word	0x00001517
    146c:	0000147f 	.word	0x0000147f
	case SINT_CONV_CASES:
		conv->specifier_cat = SPECIFIER_SINT;
    1470:	687a      	ldr	r2, [r7, #4]
    1472:	7893      	ldrb	r3, [r2, #2]
    1474:	2101      	movs	r1, #1
    1476:	f361 0302 	bfi	r3, r1, #0, #3
    147a:	7093      	strb	r3, [r2, #2]
		goto int_conv;
    147c:	e005      	b.n	148a <extract_specifier+0x126>
	case UINT_CONV_CASES:
		conv->specifier_cat = SPECIFIER_UINT;
    147e:	687a      	ldr	r2, [r7, #4]
    1480:	7893      	ldrb	r3, [r2, #2]
    1482:	2102      	movs	r1, #2
    1484:	f361 0302 	bfi	r3, r1, #0, #3
    1488:	7093      	strb	r3, [r2, #2]
int_conv:
		/* L length specifier not acceptable */
		if (conv->length_mod == LENGTH_UPPER_L) {
    148a:	687b      	ldr	r3, [r7, #4]
    148c:	785b      	ldrb	r3, [r3, #1]
    148e:	f003 0378 	and.w	r3, r3, #120	; 0x78
    1492:	b2db      	uxtb	r3, r3
    1494:	2b40      	cmp	r3, #64	; 0x40
    1496:	d104      	bne.n	14a2 <extract_specifier+0x13e>
			conv->invalid = true;
    1498:	687a      	ldr	r2, [r7, #4]
    149a:	7813      	ldrb	r3, [r2, #0]
    149c:	f043 0301 	orr.w	r3, r3, #1
    14a0:	7013      	strb	r3, [r2, #0]
		}

		/* For c LENGTH_NONE and LENGTH_L would be ok,
		 * but we don't support wide characters.
		 */
		if (conv->specifier == 'c') {
    14a2:	687b      	ldr	r3, [r7, #4]
    14a4:	78db      	ldrb	r3, [r3, #3]
    14a6:	2b63      	cmp	r3, #99	; 0x63
    14a8:	d10a      	bne.n	14c0 <extract_specifier+0x15c>
			unsupported = (conv->length_mod != LENGTH_NONE);
    14aa:	687b      	ldr	r3, [r7, #4]
    14ac:	785b      	ldrb	r3, [r3, #1]
    14ae:	f003 0378 	and.w	r3, r3, #120	; 0x78
    14b2:	b2db      	uxtb	r3, r3
    14b4:	2b00      	cmp	r3, #0
    14b6:	bf14      	ite	ne
    14b8:	2301      	movne	r3, #1
    14ba:	2300      	moveq	r3, #0
    14bc:	73fb      	strb	r3, [r7, #15]
				break;
			default:
				break;
			}
		}
		break;
    14be:	e033      	b.n	1528 <extract_specifier+0x1c4>
		}
    14c0:	bf00      	nop
		break;
    14c2:	e031      	b.n	1528 <extract_specifier+0x1c4>

	case FP_CONV_CASES:
		conv->specifier_cat = SPECIFIER_FP;
    14c4:	687a      	ldr	r2, [r7, #4]
    14c6:	7893      	ldrb	r3, [r2, #2]
    14c8:	2104      	movs	r1, #4
    14ca:	f361 0302 	bfi	r3, r1, #0, #3
    14ce:	7093      	strb	r3, [r2, #2]

		/* Don't support if disabled */
		if (!IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)) {
			unsupported = true;
    14d0:	2301      	movs	r3, #1
    14d2:	73fb      	strb	r3, [r7, #15]
			break;
    14d4:	e028      	b.n	1528 <extract_specifier+0x1c4>

		break;

		/* PTR cases are distinct */
	case 'n':
		conv->specifier_cat = SPECIFIER_PTR;
    14d6:	687a      	ldr	r2, [r7, #4]
    14d8:	7893      	ldrb	r3, [r2, #2]
    14da:	2103      	movs	r1, #3
    14dc:	f361 0302 	bfi	r3, r1, #0, #3
    14e0:	7093      	strb	r3, [r2, #2]
		/* Anything except L */
		if (conv->length_mod == LENGTH_UPPER_L) {
    14e2:	687b      	ldr	r3, [r7, #4]
    14e4:	785b      	ldrb	r3, [r3, #1]
    14e6:	f003 0378 	and.w	r3, r3, #120	; 0x78
    14ea:	b2db      	uxtb	r3, r3
    14ec:	2b40      	cmp	r3, #64	; 0x40
    14ee:	d118      	bne.n	1522 <extract_specifier+0x1be>
			unsupported = true;
    14f0:	2301      	movs	r3, #1
    14f2:	73fb      	strb	r3, [r7, #15]
		}
		break;
    14f4:	e015      	b.n	1522 <extract_specifier+0x1be>

	case 's':
	case 'p':
		conv->specifier_cat = SPECIFIER_PTR;
    14f6:	687a      	ldr	r2, [r7, #4]
    14f8:	7893      	ldrb	r3, [r2, #2]
    14fa:	2103      	movs	r1, #3
    14fc:	f361 0302 	bfi	r3, r1, #0, #3
    1500:	7093      	strb	r3, [r2, #2]
		/* p: only LENGTH_NONE
		 *
		 * s: LENGTH_NONE or LENGTH_L but wide
		 * characters not supported.
		 */
		if (conv->length_mod != LENGTH_NONE) {
    1502:	687b      	ldr	r3, [r7, #4]
    1504:	785b      	ldrb	r3, [r3, #1]
    1506:	f003 0378 	and.w	r3, r3, #120	; 0x78
    150a:	b2db      	uxtb	r3, r3
    150c:	2b00      	cmp	r3, #0
    150e:	d00a      	beq.n	1526 <extract_specifier+0x1c2>
			unsupported = true;
    1510:	2301      	movs	r3, #1
    1512:	73fb      	strb	r3, [r7, #15]
		}
		break;
    1514:	e007      	b.n	1526 <extract_specifier+0x1c2>

	default:
		conv->invalid = true;
    1516:	687a      	ldr	r2, [r7, #4]
    1518:	7813      	ldrb	r3, [r2, #0]
    151a:	f043 0301 	orr.w	r3, r3, #1
    151e:	7013      	strb	r3, [r2, #0]
		break;
    1520:	e002      	b.n	1528 <extract_specifier+0x1c4>
		break;
    1522:	bf00      	nop
    1524:	e000      	b.n	1528 <extract_specifier+0x1c4>
		break;
    1526:	bf00      	nop
	}

	conv->unsupported |= unsupported;
    1528:	687b      	ldr	r3, [r7, #4]
    152a:	781b      	ldrb	r3, [r3, #0]
    152c:	f3c3 0340 	ubfx	r3, r3, #1, #1
    1530:	b2da      	uxtb	r2, r3
    1532:	7bfb      	ldrb	r3, [r7, #15]
    1534:	4313      	orrs	r3, r2
    1536:	b2db      	uxtb	r3, r3
    1538:	2b00      	cmp	r3, #0
    153a:	bf14      	ite	ne
    153c:	2301      	movne	r3, #1
    153e:	2300      	moveq	r3, #0
    1540:	b2d9      	uxtb	r1, r3
    1542:	687a      	ldr	r2, [r7, #4]
    1544:	7813      	ldrb	r3, [r2, #0]
    1546:	f361 0341 	bfi	r3, r1, #1, #1
    154a:	7013      	strb	r3, [r2, #0]

	return sp;
    154c:	683b      	ldr	r3, [r7, #0]
}
    154e:	4618      	mov	r0, r3
    1550:	3714      	adds	r7, #20
    1552:	46bd      	mov	sp, r7
    1554:	bc80      	pop	{r7}
    1556:	4770      	bx	lr

00001558 <store_count>:
 * @param count the count to be stored.
 */
static inline void store_count(const struct conversion *conv,
			       void *dp,
			       int count)
{
    1558:	b480      	push	{r7}
    155a:	b085      	sub	sp, #20
    155c:	af00      	add	r7, sp, #0
    155e:	60f8      	str	r0, [r7, #12]
    1560:	60b9      	str	r1, [r7, #8]
    1562:	607a      	str	r2, [r7, #4]
	switch ((enum length_mod_enum)conv->length_mod) {
    1564:	68fb      	ldr	r3, [r7, #12]
    1566:	785b      	ldrb	r3, [r3, #1]
    1568:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    156c:	b2db      	uxtb	r3, r3
    156e:	2b07      	cmp	r3, #7
    1570:	d83c      	bhi.n	15ec <store_count+0x94>
    1572:	a201      	add	r2, pc, #4	; (adr r2, 1578 <store_count+0x20>)
    1574:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1578:	00001599 	.word	0x00001599
    157c:	000015a1 	.word	0x000015a1
    1580:	000015ab 	.word	0x000015ab
    1584:	000015b5 	.word	0x000015b5
    1588:	000015bd 	.word	0x000015bd
    158c:	000015cd 	.word	0x000015cd
    1590:	000015dd 	.word	0x000015dd
    1594:	000015e5 	.word	0x000015e5
	case LENGTH_NONE:
		*(int *)dp = count;
    1598:	68bb      	ldr	r3, [r7, #8]
    159a:	687a      	ldr	r2, [r7, #4]
    159c:	601a      	str	r2, [r3, #0]
		break;
    159e:	e026      	b.n	15ee <store_count+0x96>
	case LENGTH_HH:
		*(signed char *)dp = (signed char)count;
    15a0:	687b      	ldr	r3, [r7, #4]
    15a2:	b25a      	sxtb	r2, r3
    15a4:	68bb      	ldr	r3, [r7, #8]
    15a6:	701a      	strb	r2, [r3, #0]
		break;
    15a8:	e021      	b.n	15ee <store_count+0x96>
	case LENGTH_H:
		*(short *)dp = (short)count;
    15aa:	687b      	ldr	r3, [r7, #4]
    15ac:	b21a      	sxth	r2, r3
    15ae:	68bb      	ldr	r3, [r7, #8]
    15b0:	801a      	strh	r2, [r3, #0]
		break;
    15b2:	e01c      	b.n	15ee <store_count+0x96>
	case LENGTH_L:
		*(long *)dp = (long)count;
    15b4:	68bb      	ldr	r3, [r7, #8]
    15b6:	687a      	ldr	r2, [r7, #4]
    15b8:	601a      	str	r2, [r3, #0]
		break;
    15ba:	e018      	b.n	15ee <store_count+0x96>
	case LENGTH_LL:
		*(long long *)dp = (long long)count;
    15bc:	687b      	ldr	r3, [r7, #4]
    15be:	461a      	mov	r2, r3
    15c0:	ea4f 73e2 	mov.w	r3, r2, asr #31
    15c4:	68b9      	ldr	r1, [r7, #8]
    15c6:	e9c1 2300 	strd	r2, r3, [r1]
		break;
    15ca:	e010      	b.n	15ee <store_count+0x96>
	case LENGTH_J:
		*(intmax_t *)dp = (intmax_t)count;
    15cc:	687b      	ldr	r3, [r7, #4]
    15ce:	461a      	mov	r2, r3
    15d0:	ea4f 73e2 	mov.w	r3, r2, asr #31
    15d4:	68b9      	ldr	r1, [r7, #8]
    15d6:	e9c1 2300 	strd	r2, r3, [r1]
		break;
    15da:	e008      	b.n	15ee <store_count+0x96>
	case LENGTH_Z:
		*(size_t *)dp = (size_t)count;
    15dc:	687a      	ldr	r2, [r7, #4]
    15de:	68bb      	ldr	r3, [r7, #8]
    15e0:	601a      	str	r2, [r3, #0]
		break;
    15e2:	e004      	b.n	15ee <store_count+0x96>
	case LENGTH_T:
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    15e4:	68bb      	ldr	r3, [r7, #8]
    15e6:	687a      	ldr	r2, [r7, #4]
    15e8:	601a      	str	r2, [r3, #0]
		break;
    15ea:	e000      	b.n	15ee <store_count+0x96>
	default:
		break;
    15ec:	bf00      	nop
	}
}
    15ee:	bf00      	nop
    15f0:	3714      	adds	r7, #20
    15f2:	46bd      	mov	sp, r7
    15f4:	bc80      	pop	{r7}
    15f6:	4770      	bx	lr

000015f8 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    15f8:	b590      	push	{r4, r7, lr}
    15fa:	b0ab      	sub	sp, #172	; 0xac
    15fc:	af02      	add	r7, sp, #8
    15fe:	60f8      	str	r0, [r7, #12]
    1600:	60b9      	str	r1, [r7, #8]
    1602:	607a      	str	r2, [r7, #4]
    1604:	603b      	str	r3, [r7, #0]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    1606:	2300      	movs	r3, #0
    1608:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    160c:	f000 bc40 	b.w	1e90 <cbvprintf+0x898>
		if (*fp != '%') {
    1610:	687b      	ldr	r3, [r7, #4]
    1612:	781b      	ldrb	r3, [r3, #0]
    1614:	2b25      	cmp	r3, #37	; 0x25
    1616:	d016      	beq.n	1646 <cbvprintf+0x4e>
			OUTC(*fp++);
    1618:	687b      	ldr	r3, [r7, #4]
    161a:	1c5a      	adds	r2, r3, #1
    161c:	607a      	str	r2, [r7, #4]
    161e:	781b      	ldrb	r3, [r3, #0]
    1620:	461a      	mov	r2, r3
    1622:	68fb      	ldr	r3, [r7, #12]
    1624:	68b9      	ldr	r1, [r7, #8]
    1626:	4610      	mov	r0, r2
    1628:	4798      	blx	r3
    162a:	6478      	str	r0, [r7, #68]	; 0x44
    162c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    162e:	2b00      	cmp	r3, #0
    1630:	da02      	bge.n	1638 <cbvprintf+0x40>
    1632:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    1634:	f000 bc33 	b.w	1e9e <cbvprintf+0x8a6>
    1638:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    163c:	3301      	adds	r3, #1
    163e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			continue;
    1642:	f000 bc25 	b.w	1e90 <cbvprintf+0x898>
		}

		const char *sp = fp;
    1646:	687b      	ldr	r3, [r7, #4]
    1648:	67fb      	str	r3, [r7, #124]	; 0x7c
		struct conversion conv;
		int width = -1;
    164a:	f04f 33ff 	mov.w	r3, #4294967295
    164e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
		int precision = -1;
    1652:	f04f 33ff 	mov.w	r3, #4294967295
    1656:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		const char *bps = NULL;
    165a:	2300      	movs	r3, #0
    165c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
		const char *bpe = buf + sizeof(buf);
    1660:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    1664:	3316      	adds	r3, #22
    1666:	61fb      	str	r3, [r7, #28]
		char sign = 0;
    1668:	2300      	movs	r3, #0
    166a:	76fb      	strb	r3, [r7, #27]

		fp = extract_conversion(&conv, sp);
    166c:	f107 0320 	add.w	r3, r7, #32
    1670:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
    1672:	4618      	mov	r0, r3
    1674:	f00f fa52 	bl	10b1c <extract_conversion>
    1678:	6078      	str	r0, [r7, #4]

		/* If dynamic width is specified, process it,
		 * otherwise set with if present.
		 */
		if (conv.width_star) {
    167a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    167e:	f003 0301 	and.w	r3, r3, #1
    1682:	b2db      	uxtb	r3, r3
    1684:	2b00      	cmp	r3, #0
    1686:	d015      	beq.n	16b4 <cbvprintf+0xbc>
			width = va_arg(ap, int);
    1688:	683b      	ldr	r3, [r7, #0]
    168a:	1d1a      	adds	r2, r3, #4
    168c:	603a      	str	r2, [r7, #0]
    168e:	681b      	ldr	r3, [r3, #0]
    1690:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

			if (width < 0) {
    1694:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    1698:	2b00      	cmp	r3, #0
    169a:	da15      	bge.n	16c8 <cbvprintf+0xd0>
				conv.flag_dash = true;
    169c:	f897 3020 	ldrb.w	r3, [r7, #32]
    16a0:	f043 0304 	orr.w	r3, r3, #4
    16a4:	f887 3020 	strb.w	r3, [r7, #32]
				width = -width;
    16a8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    16ac:	425b      	negs	r3, r3
    16ae:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    16b2:	e009      	b.n	16c8 <cbvprintf+0xd0>
			}
		} else if (conv.width_present) {
    16b4:	f897 3020 	ldrb.w	r3, [r7, #32]
    16b8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    16bc:	b2db      	uxtb	r3, r3
    16be:	2b00      	cmp	r3, #0
    16c0:	d002      	beq.n	16c8 <cbvprintf+0xd0>
			width = conv.width_value;
    16c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    16c4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv.prec_star) {
    16c8:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    16cc:	f003 0304 	and.w	r3, r3, #4
    16d0:	b2db      	uxtb	r3, r3
    16d2:	2b00      	cmp	r3, #0
    16d4:	d012      	beq.n	16fc <cbvprintf+0x104>
			int arg = va_arg(ap, int);
    16d6:	683b      	ldr	r3, [r7, #0]
    16d8:	1d1a      	adds	r2, r3, #4
    16da:	603a      	str	r2, [r7, #0]
    16dc:	681b      	ldr	r3, [r3, #0]
    16de:	67bb      	str	r3, [r7, #120]	; 0x78

			if (arg < 0) {
    16e0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    16e2:	2b00      	cmp	r3, #0
    16e4:	da06      	bge.n	16f4 <cbvprintf+0xfc>
				conv.prec_present = false;
    16e6:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    16ea:	f36f 0341 	bfc	r3, #1, #1
    16ee:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    16f2:	e00d      	b.n	1710 <cbvprintf+0x118>
			} else {
				precision = arg;
    16f4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    16f6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    16fa:	e009      	b.n	1710 <cbvprintf+0x118>
			}
		} else if (conv.prec_present) {
    16fc:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    1700:	f003 0302 	and.w	r3, r3, #2
    1704:	b2db      	uxtb	r3, r3
    1706:	2b00      	cmp	r3, #0
    1708:	d002      	beq.n	1710 <cbvprintf+0x118>
			precision = conv.prec_value;
    170a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    170c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv.pad0_value = 0;
    1710:	2300      	movs	r3, #0
    1712:	627b      	str	r3, [r7, #36]	; 0x24
		conv.pad0_pre_exp = 0;
    1714:	2300      	movs	r3, #0
    1716:	62bb      	str	r3, [r7, #40]	; 0x28
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv.specifier_cat;
    1718:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    171c:	f3c3 0302 	ubfx	r3, r3, #0, #3
    1720:	b2db      	uxtb	r3, r3
		enum specifier_cat_enum specifier_cat
    1722:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv.length_mod;
    1726:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    172a:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    172e:	b2db      	uxtb	r3, r3
		enum length_mod_enum length_mod
    1730:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
		union argument_value value = (union argument_value){
    1734:	f04f 0200 	mov.w	r2, #0
    1738:	f04f 0300 	mov.w	r3, #0
    173c:	e9c7 2304 	strd	r2, r3, [r7, #16]
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    1740:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
    1744:	2b01      	cmp	r3, #1
    1746:	d162      	bne.n	180e <cbvprintf+0x216>
			switch (length_mod) {
    1748:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    174c:	3b03      	subs	r3, #3
    174e:	2b04      	cmp	r3, #4
    1750:	d80c      	bhi.n	176c <cbvprintf+0x174>
    1752:	a201      	add	r2, pc, #4	; (adr r2, 1758 <cbvprintf+0x160>)
    1754:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1758:	00001781 	.word	0x00001781
    175c:	00001795 	.word	0x00001795
    1760:	000017ad 	.word	0x000017ad
    1764:	000017c5 	.word	0x000017c5
    1768:	000017c5 	.word	0x000017c5
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value.sint = va_arg(ap, int);
    176c:	683b      	ldr	r3, [r7, #0]
    176e:	1d1a      	adds	r2, r3, #4
    1770:	603a      	str	r2, [r7, #0]
    1772:	681b      	ldr	r3, [r3, #0]
    1774:	461a      	mov	r2, r3
    1776:	ea4f 73e2 	mov.w	r3, r2, asr #31
    177a:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    177e:	e02b      	b.n	17d8 <cbvprintf+0x1e0>
			case LENGTH_L:
				value.sint = va_arg(ap, long);
    1780:	683b      	ldr	r3, [r7, #0]
    1782:	1d1a      	adds	r2, r3, #4
    1784:	603a      	str	r2, [r7, #0]
    1786:	681b      	ldr	r3, [r3, #0]
    1788:	461a      	mov	r2, r3
    178a:	ea4f 73e2 	mov.w	r3, r2, asr #31
    178e:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    1792:	e021      	b.n	17d8 <cbvprintf+0x1e0>
			case LENGTH_LL:
				value.sint =
					(sint_value_type)va_arg(ap, long long);
    1794:	683b      	ldr	r3, [r7, #0]
    1796:	3307      	adds	r3, #7
    1798:	f023 0307 	bic.w	r3, r3, #7
    179c:	f103 0208 	add.w	r2, r3, #8
    17a0:	603a      	str	r2, [r7, #0]
    17a2:	e9d3 2300 	ldrd	r2, r3, [r3]
				value.sint =
    17a6:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    17aa:	e015      	b.n	17d8 <cbvprintf+0x1e0>
			case LENGTH_J:
				value.sint =
					(sint_value_type)va_arg(ap, intmax_t);
    17ac:	683b      	ldr	r3, [r7, #0]
    17ae:	3307      	adds	r3, #7
    17b0:	f023 0307 	bic.w	r3, r3, #7
    17b4:	f103 0208 	add.w	r2, r3, #8
    17b8:	603a      	str	r2, [r7, #0]
    17ba:	e9d3 2300 	ldrd	r2, r3, [r3]
				value.sint =
    17be:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    17c2:	e009      	b.n	17d8 <cbvprintf+0x1e0>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value.sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    17c4:	683b      	ldr	r3, [r7, #0]
    17c6:	1d1a      	adds	r2, r3, #4
    17c8:	603a      	str	r2, [r7, #0]
    17ca:	681b      	ldr	r3, [r3, #0]
    17cc:	461a      	mov	r2, r3
    17ce:	ea4f 73e2 	mov.w	r3, r2, asr #31
				value.sint =
    17d2:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    17d6:	bf00      	nop
			}
			if (length_mod == LENGTH_HH) {
    17d8:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    17dc:	2b01      	cmp	r3, #1
    17de:	d108      	bne.n	17f2 <cbvprintf+0x1fa>
				value.sint = (char)value.sint;
    17e0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    17e4:	b2d3      	uxtb	r3, r2
    17e6:	b2da      	uxtb	r2, r3
    17e8:	f04f 0300 	mov.w	r3, #0
    17ec:	e9c7 2304 	strd	r2, r3, [r7, #16]
    17f0:	e09d      	b.n	192e <cbvprintf+0x336>
			} else if (length_mod == LENGTH_H) {
    17f2:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    17f6:	2b02      	cmp	r3, #2
    17f8:	f040 8099 	bne.w	192e <cbvprintf+0x336>
				value.sint = (short)value.sint;
    17fc:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    1800:	b213      	sxth	r3, r2
    1802:	b21a      	sxth	r2, r3
    1804:	ea4f 73e2 	mov.w	r3, r2, asr #31
    1808:	e9c7 2304 	strd	r2, r3, [r7, #16]
    180c:	e08f      	b.n	192e <cbvprintf+0x336>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    180e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
    1812:	2b02      	cmp	r3, #2
    1814:	d162      	bne.n	18dc <cbvprintf+0x2e4>
			switch (length_mod) {
    1816:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    181a:	3b03      	subs	r3, #3
    181c:	2b04      	cmp	r3, #4
    181e:	d80d      	bhi.n	183c <cbvprintf+0x244>
    1820:	a201      	add	r2, pc, #4	; (adr r2, 1828 <cbvprintf+0x230>)
    1822:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1826:	bf00      	nop
    1828:	00001851 	.word	0x00001851
    182c:	00001865 	.word	0x00001865
    1830:	0000187d 	.word	0x0000187d
    1834:	00001895 	.word	0x00001895
    1838:	00001895 	.word	0x00001895
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value.uint = va_arg(ap, unsigned int);
    183c:	683b      	ldr	r3, [r7, #0]
    183e:	1d1a      	adds	r2, r3, #4
    1840:	603a      	str	r2, [r7, #0]
    1842:	681b      	ldr	r3, [r3, #0]
    1844:	461a      	mov	r2, r3
    1846:	f04f 0300 	mov.w	r3, #0
    184a:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    184e:	e02b      	b.n	18a8 <cbvprintf+0x2b0>
			case LENGTH_L:
				value.uint = va_arg(ap, unsigned long);
    1850:	683b      	ldr	r3, [r7, #0]
    1852:	1d1a      	adds	r2, r3, #4
    1854:	603a      	str	r2, [r7, #0]
    1856:	681b      	ldr	r3, [r3, #0]
    1858:	461a      	mov	r2, r3
    185a:	f04f 0300 	mov.w	r3, #0
    185e:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    1862:	e021      	b.n	18a8 <cbvprintf+0x2b0>
			case LENGTH_LL:
				value.uint =
					(uint_value_type)va_arg(ap,
    1864:	683b      	ldr	r3, [r7, #0]
    1866:	3307      	adds	r3, #7
    1868:	f023 0307 	bic.w	r3, r3, #7
    186c:	f103 0208 	add.w	r2, r3, #8
    1870:	603a      	str	r2, [r7, #0]
    1872:	e9d3 2300 	ldrd	r2, r3, [r3]
				value.uint =
    1876:	e9c7 2304 	strd	r2, r3, [r7, #16]
						unsigned long long);
				break;
    187a:	e015      	b.n	18a8 <cbvprintf+0x2b0>
			case LENGTH_J:
				value.uint =
					(uint_value_type)va_arg(ap,
    187c:	683b      	ldr	r3, [r7, #0]
    187e:	3307      	adds	r3, #7
    1880:	f023 0307 	bic.w	r3, r3, #7
    1884:	f103 0208 	add.w	r2, r3, #8
    1888:	603a      	str	r2, [r7, #0]
    188a:	e9d3 2300 	ldrd	r2, r3, [r3]
				value.uint =
    188e:	e9c7 2304 	strd	r2, r3, [r7, #16]
								uintmax_t);
				break;
    1892:	e009      	b.n	18a8 <cbvprintf+0x2b0>
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value.uint =
					(uint_value_type)va_arg(ap, size_t);
    1894:	683b      	ldr	r3, [r7, #0]
    1896:	1d1a      	adds	r2, r3, #4
    1898:	603a      	str	r2, [r7, #0]
    189a:	681b      	ldr	r3, [r3, #0]
    189c:	461a      	mov	r2, r3
    189e:	f04f 0300 	mov.w	r3, #0
				value.uint =
    18a2:	e9c7 2304 	strd	r2, r3, [r7, #16]
				break;
    18a6:	bf00      	nop
			}
			if (length_mod == LENGTH_HH) {
    18a8:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    18ac:	2b01      	cmp	r3, #1
    18ae:	d108      	bne.n	18c2 <cbvprintf+0x2ca>
				value.uint = (unsigned char)value.uint;
    18b0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    18b4:	b2d3      	uxtb	r3, r2
    18b6:	b2da      	uxtb	r2, r3
    18b8:	f04f 0300 	mov.w	r3, #0
    18bc:	e9c7 2304 	strd	r2, r3, [r7, #16]
    18c0:	e035      	b.n	192e <cbvprintf+0x336>
			} else if (length_mod == LENGTH_H) {
    18c2:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    18c6:	2b02      	cmp	r3, #2
    18c8:	d131      	bne.n	192e <cbvprintf+0x336>
				value.uint = (unsigned short)value.uint;
    18ca:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    18ce:	b293      	uxth	r3, r2
    18d0:	b29a      	uxth	r2, r3
    18d2:	f04f 0300 	mov.w	r3, #0
    18d6:	e9c7 2304 	strd	r2, r3, [r7, #16]
    18da:	e028      	b.n	192e <cbvprintf+0x336>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    18dc:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
    18e0:	2b04      	cmp	r3, #4
    18e2:	d11b      	bne.n	191c <cbvprintf+0x324>
			if (length_mod == LENGTH_UPPER_L) {
    18e4:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
    18e8:	2b08      	cmp	r3, #8
    18ea:	d10b      	bne.n	1904 <cbvprintf+0x30c>
				value.ldbl = va_arg(ap, long double);
    18ec:	683b      	ldr	r3, [r7, #0]
    18ee:	3307      	adds	r3, #7
    18f0:	f023 0307 	bic.w	r3, r3, #7
    18f4:	f103 0208 	add.w	r2, r3, #8
    18f8:	603a      	str	r2, [r7, #0]
    18fa:	e9d3 2300 	ldrd	r2, r3, [r3]
    18fe:	e9c7 2304 	strd	r2, r3, [r7, #16]
    1902:	e014      	b.n	192e <cbvprintf+0x336>
			} else {
				value.dbl = va_arg(ap, double);
    1904:	683b      	ldr	r3, [r7, #0]
    1906:	3307      	adds	r3, #7
    1908:	f023 0307 	bic.w	r3, r3, #7
    190c:	f103 0208 	add.w	r2, r3, #8
    1910:	603a      	str	r2, [r7, #0]
    1912:	e9d3 2300 	ldrd	r2, r3, [r3]
    1916:	e9c7 2304 	strd	r2, r3, [r7, #16]
    191a:	e008      	b.n	192e <cbvprintf+0x336>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    191c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
    1920:	2b03      	cmp	r3, #3
    1922:	d104      	bne.n	192e <cbvprintf+0x336>
			value.ptr = va_arg(ap, void *);
    1924:	683b      	ldr	r3, [r7, #0]
    1926:	1d1a      	adds	r2, r3, #4
    1928:	603a      	str	r2, [r7, #0]
    192a:	681b      	ldr	r3, [r3, #0]
    192c:	613b      	str	r3, [r7, #16]
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv.invalid || conv.unsupported) {
    192e:	f897 3020 	ldrb.w	r3, [r7, #32]
    1932:	f003 0301 	and.w	r3, r3, #1
    1936:	b2db      	uxtb	r3, r3
    1938:	2b00      	cmp	r3, #0
    193a:	d106      	bne.n	194a <cbvprintf+0x352>
    193c:	f897 3020 	ldrb.w	r3, [r7, #32]
    1940:	f003 0302 	and.w	r3, r3, #2
    1944:	b2db      	uxtb	r3, r3
    1946:	2b00      	cmp	r3, #0
    1948:	d012      	beq.n	1970 <cbvprintf+0x378>
			OUTS(sp, fp);
    194a:	687b      	ldr	r3, [r7, #4]
    194c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
    194e:	68b9      	ldr	r1, [r7, #8]
    1950:	68f8      	ldr	r0, [r7, #12]
    1952:	f00f f9a5 	bl	10ca0 <outs>
    1956:	64b8      	str	r0, [r7, #72]	; 0x48
    1958:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    195a:	2b00      	cmp	r3, #0
    195c:	da01      	bge.n	1962 <cbvprintf+0x36a>
    195e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1960:	e29d      	b.n	1e9e <cbvprintf+0x8a6>
    1962:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1964:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
    1968:	4413      	add	r3, r2
    196a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			continue;
    196e:	e28f      	b.n	1e90 <cbvprintf+0x898>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv.specifier) {
    1970:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    1974:	3b25      	subs	r3, #37	; 0x25
    1976:	2b53      	cmp	r3, #83	; 0x53
    1978:	f200 8163 	bhi.w	1c42 <cbvprintf+0x64a>
    197c:	a201      	add	r2, pc, #4	; (adr r2, 1984 <cbvprintf+0x38c>)
    197e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1982:	bf00      	nop
    1984:	00001ad5 	.word	0x00001ad5
    1988:	00001c43 	.word	0x00001c43
    198c:	00001c43 	.word	0x00001c43
    1990:	00001c43 	.word	0x00001c43
    1994:	00001c43 	.word	0x00001c43
    1998:	00001c43 	.word	0x00001c43
    199c:	00001c43 	.word	0x00001c43
    19a0:	00001c43 	.word	0x00001c43
    19a4:	00001c43 	.word	0x00001c43
    19a8:	00001c43 	.word	0x00001c43
    19ac:	00001c43 	.word	0x00001c43
    19b0:	00001c43 	.word	0x00001c43
    19b4:	00001c43 	.word	0x00001c43
    19b8:	00001c43 	.word	0x00001c43
    19bc:	00001c43 	.word	0x00001c43
    19c0:	00001c43 	.word	0x00001c43
    19c4:	00001c43 	.word	0x00001c43
    19c8:	00001c43 	.word	0x00001c43
    19cc:	00001c43 	.word	0x00001c43
    19d0:	00001c43 	.word	0x00001c43
    19d4:	00001c43 	.word	0x00001c43
    19d8:	00001c43 	.word	0x00001c43
    19dc:	00001c43 	.word	0x00001c43
    19e0:	00001c43 	.word	0x00001c43
    19e4:	00001c43 	.word	0x00001c43
    19e8:	00001c43 	.word	0x00001c43
    19ec:	00001c43 	.word	0x00001c43
    19f0:	00001c43 	.word	0x00001c43
    19f4:	00001c43 	.word	0x00001c43
    19f8:	00001c43 	.word	0x00001c43
    19fc:	00001c43 	.word	0x00001c43
    1a00:	00001c43 	.word	0x00001c43
    1a04:	00001c43 	.word	0x00001c43
    1a08:	00001c43 	.word	0x00001c43
    1a0c:	00001c43 	.word	0x00001c43
    1a10:	00001c43 	.word	0x00001c43
    1a14:	00001c43 	.word	0x00001c43
    1a18:	00001c43 	.word	0x00001c43
    1a1c:	00001c43 	.word	0x00001c43
    1a20:	00001c43 	.word	0x00001c43
    1a24:	00001c43 	.word	0x00001c43
    1a28:	00001c43 	.word	0x00001c43
    1a2c:	00001c43 	.word	0x00001c43
    1a30:	00001c43 	.word	0x00001c43
    1a34:	00001c43 	.word	0x00001c43
    1a38:	00001c43 	.word	0x00001c43
    1a3c:	00001c43 	.word	0x00001c43
    1a40:	00001c43 	.word	0x00001c43
    1a44:	00001c43 	.word	0x00001c43
    1a48:	00001c43 	.word	0x00001c43
    1a4c:	00001c43 	.word	0x00001c43
    1a50:	00001b99 	.word	0x00001b99
    1a54:	00001c43 	.word	0x00001c43
    1a58:	00001c43 	.word	0x00001c43
    1a5c:	00001c43 	.word	0x00001c43
    1a60:	00001c43 	.word	0x00001c43
    1a64:	00001c43 	.word	0x00001c43
    1a68:	00001c43 	.word	0x00001c43
    1a6c:	00001c43 	.word	0x00001c43
    1a70:	00001c43 	.word	0x00001c43
    1a74:	00001c43 	.word	0x00001c43
    1a78:	00001c43 	.word	0x00001c43
    1a7c:	00001b39 	.word	0x00001b39
    1a80:	00001b55 	.word	0x00001b55
    1a84:	00001c43 	.word	0x00001c43
    1a88:	00001c43 	.word	0x00001c43
    1a8c:	00001c43 	.word	0x00001c43
    1a90:	00001c43 	.word	0x00001c43
    1a94:	00001b55 	.word	0x00001b55
    1a98:	00001c43 	.word	0x00001c43
    1a9c:	00001c43 	.word	0x00001c43
    1aa0:	00001c43 	.word	0x00001c43
    1aa4:	00001c43 	.word	0x00001c43
    1aa8:	00001c2f 	.word	0x00001c2f
    1aac:	00001b99 	.word	0x00001b99
    1ab0:	00001be7 	.word	0x00001be7
    1ab4:	00001c43 	.word	0x00001c43
    1ab8:	00001c43 	.word	0x00001c43
    1abc:	00001af5 	.word	0x00001af5
    1ac0:	00001c43 	.word	0x00001c43
    1ac4:	00001b99 	.word	0x00001b99
    1ac8:	00001c43 	.word	0x00001c43
    1acc:	00001c43 	.word	0x00001c43
    1ad0:	00001b99 	.word	0x00001b99
		case '%':
			OUTC('%');
    1ad4:	68fb      	ldr	r3, [r7, #12]
    1ad6:	68b9      	ldr	r1, [r7, #8]
    1ad8:	2025      	movs	r0, #37	; 0x25
    1ada:	4798      	blx	r3
    1adc:	66f8      	str	r0, [r7, #108]	; 0x6c
    1ade:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    1ae0:	2b00      	cmp	r3, #0
    1ae2:	da01      	bge.n	1ae8 <cbvprintf+0x4f0>
    1ae4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    1ae6:	e1da      	b.n	1e9e <cbvprintf+0x8a6>
    1ae8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1aec:	3301      	adds	r3, #1
    1aee:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			break;
    1af2:	e0a6      	b.n	1c42 <cbvprintf+0x64a>
		case 's': {
			bps = (const char *)value.ptr;
    1af4:	693b      	ldr	r3, [r7, #16]
    1af6:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

			size_t len = strlen(bps);
    1afa:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
    1afe:	f011 fadf 	bl	130c0 <strlen>
    1b02:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c

			if ((precision >= 0)
    1b06:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    1b0a:	2b00      	cmp	r3, #0
    1b0c:	db09      	blt.n	1b22 <cbvprintf+0x52a>
			    && ((size_t)precision < len)) {
    1b0e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    1b12:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
    1b16:	429a      	cmp	r2, r3
    1b18:	d903      	bls.n	1b22 <cbvprintf+0x52a>
				len = (size_t)precision;
    1b1a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    1b1e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
			}

			bpe = bps + len;
    1b22:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
    1b26:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    1b2a:	4413      	add	r3, r2
    1b2c:	61fb      	str	r3, [r7, #28]
			precision = -1;
    1b2e:	f04f 33ff 	mov.w	r3, #4294967295
    1b32:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

			break;
    1b36:	e084      	b.n	1c42 <cbvprintf+0x64a>
		}
		case 'c':
			bps = buf;
    1b38:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    1b3c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
			buf[0] = value.uint;
    1b40:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    1b44:	b2d3      	uxtb	r3, r2
    1b46:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
			bpe = buf + 1;
    1b4a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    1b4e:	3301      	adds	r3, #1
    1b50:	61fb      	str	r3, [r7, #28]
			break;
    1b52:	e076      	b.n	1c42 <cbvprintf+0x64a>
		case 'd':
		case 'i':
			if (conv.flag_plus) {
    1b54:	f897 3020 	ldrb.w	r3, [r7, #32]
    1b58:	f003 0308 	and.w	r3, r3, #8
    1b5c:	b2db      	uxtb	r3, r3
    1b5e:	2b00      	cmp	r3, #0
    1b60:	d002      	beq.n	1b68 <cbvprintf+0x570>
				sign = '+';
    1b62:	232b      	movs	r3, #43	; 0x2b
    1b64:	76fb      	strb	r3, [r7, #27]
    1b66:	e008      	b.n	1b7a <cbvprintf+0x582>
			} else if (conv.flag_space) {
    1b68:	f897 3020 	ldrb.w	r3, [r7, #32]
    1b6c:	f003 0310 	and.w	r3, r3, #16
    1b70:	b2db      	uxtb	r3, r3
    1b72:	2b00      	cmp	r3, #0
    1b74:	d001      	beq.n	1b7a <cbvprintf+0x582>
				sign = ' ';
    1b76:	2320      	movs	r3, #32
    1b78:	76fb      	strb	r3, [r7, #27]
			}

			if (value.sint < 0) {
    1b7a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    1b7e:	2a00      	cmp	r2, #0
    1b80:	f173 0300 	sbcs.w	r3, r3, #0
    1b84:	da08      	bge.n	1b98 <cbvprintf+0x5a0>
				sign = '-';
    1b86:	232d      	movs	r3, #45	; 0x2d
    1b88:	76fb      	strb	r3, [r7, #27]
				value.uint = -value.sint;
    1b8a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    1b8e:	4252      	negs	r2, r2
    1b90:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    1b94:	e9c7 2304 	strd	r2, r3, [r7, #16]
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value.uint, &conv, buf, bpe);
    1b98:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    1b9c:	69fb      	ldr	r3, [r7, #28]
    1b9e:	f107 042c 	add.w	r4, r7, #44	; 0x2c
    1ba2:	f107 0220 	add.w	r2, r7, #32
    1ba6:	9300      	str	r3, [sp, #0]
    1ba8:	4623      	mov	r3, r4
    1baa:	f00f f80b 	bl	10bc4 <encode_uint>
    1bae:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    1bb2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    1bb6:	2b00      	cmp	r3, #0
    1bb8:	db42      	blt.n	1c40 <cbvprintf+0x648>
				size_t len = bpe - bps;
    1bba:	69fa      	ldr	r2, [r7, #28]
    1bbc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    1bc0:	1ad3      	subs	r3, r2, r3
    1bc2:	673b      	str	r3, [r7, #112]	; 0x70

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv.flag_zero = false;
    1bc4:	f897 3020 	ldrb.w	r3, [r7, #32]
    1bc8:	f36f 1386 	bfc	r3, #6, #1
    1bcc:	f887 3020 	strb.w	r3, [r7, #32]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    1bd0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    1bd4:	6f3a      	ldr	r2, [r7, #112]	; 0x70
    1bd6:	429a      	cmp	r2, r3
    1bd8:	d232      	bcs.n	1c40 <cbvprintf+0x648>
					conv.pad0_value = precision - (int)len;
    1bda:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    1bdc:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
    1be0:	1ad3      	subs	r3, r2, r3
    1be2:	627b      	str	r3, [r7, #36]	; 0x24
				}
			}

			break;
    1be4:	e02c      	b.n	1c40 <cbvprintf+0x648>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value.ptr != NULL) {
    1be6:	693b      	ldr	r3, [r7, #16]
    1be8:	2b00      	cmp	r3, #0
    1bea:	d018      	beq.n	1c1e <cbvprintf+0x626>
				bps = encode_uint((uintptr_t)value.ptr, &conv,
    1bec:	693b      	ldr	r3, [r7, #16]
    1bee:	4618      	mov	r0, r3
    1bf0:	f04f 0100 	mov.w	r1, #0
    1bf4:	69fb      	ldr	r3, [r7, #28]
    1bf6:	f107 042c 	add.w	r4, r7, #44	; 0x2c
    1bfa:	f107 0220 	add.w	r2, r7, #32
    1bfe:	9300      	str	r3, [sp, #0]
    1c00:	4623      	mov	r3, r4
    1c02:	f00e ffdf 	bl	10bc4 <encode_uint>
    1c06:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
						  buf, bpe);

				/* Use 0x prefix */
				conv.altform_0c = true;
    1c0a:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1c0e:	f043 0310 	orr.w	r3, r3, #16
    1c12:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
				conv.specifier = 'x';
    1c16:	2378      	movs	r3, #120	; 0x78
    1c18:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

				goto prec_int_pad0;
    1c1c:	e7c9      	b.n	1bb2 <cbvprintf+0x5ba>
			}

			bps = "(nil)";
    1c1e:	4ba2      	ldr	r3, [pc, #648]	; (1ea8 <cbvprintf+0x8b0>)
    1c20:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
			bpe = bps + 5;
    1c24:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    1c28:	3305      	adds	r3, #5
    1c2a:	61fb      	str	r3, [r7, #28]

			break;
    1c2c:	e009      	b.n	1c42 <cbvprintf+0x64a>
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(&conv, value.ptr, count);
    1c2e:	6939      	ldr	r1, [r7, #16]
    1c30:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
    1c34:	f107 0320 	add.w	r3, r7, #32
    1c38:	4618      	mov	r0, r3
    1c3a:	f7ff fc8d 	bl	1558 <store_count>
			}

			break;
    1c3e:	e000      	b.n	1c42 <cbvprintf+0x64a>
			break;
    1c40:	bf00      	nop
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    1c42:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    1c46:	2b00      	cmp	r3, #0
    1c48:	f000 8121 	beq.w	1e8e <cbvprintf+0x896>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    1c4c:	69fa      	ldr	r2, [r7, #28]
    1c4e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    1c52:	1ad3      	subs	r3, r2, r3
    1c54:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
		int pad_len = 0;
    1c58:	2300      	movs	r3, #0
    1c5a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

		if (sign != 0) {
    1c5e:	7efb      	ldrb	r3, [r7, #27]
    1c60:	2b00      	cmp	r3, #0
    1c62:	d004      	beq.n	1c6e <cbvprintf+0x676>
			nj_len += 1U;
    1c64:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1c68:	3301      	adds	r3, #1
    1c6a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
		}

		if (conv.altform_0c) {
    1c6e:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1c72:	f003 0310 	and.w	r3, r3, #16
    1c76:	b2db      	uxtb	r3, r3
    1c78:	2b00      	cmp	r3, #0
    1c7a:	d005      	beq.n	1c88 <cbvprintf+0x690>
			nj_len += 2U;
    1c7c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1c80:	3302      	adds	r3, #2
    1c82:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    1c86:	e00b      	b.n	1ca0 <cbvprintf+0x6a8>
		} else if (conv.altform_0) {
    1c88:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1c8c:	f003 0308 	and.w	r3, r3, #8
    1c90:	b2db      	uxtb	r3, r3
    1c92:	2b00      	cmp	r3, #0
    1c94:	d004      	beq.n	1ca0 <cbvprintf+0x6a8>
			nj_len += 1U;
    1c96:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1c9a:	3301      	adds	r3, #1
    1c9c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
		}

		nj_len += conv.pad0_value;
    1ca0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1ca2:	461a      	mov	r2, r3
    1ca4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1ca8:	4413      	add	r3, r2
    1caa:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
		if (conv.pad_fp) {
    1cae:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1cb2:	f003 0340 	and.w	r3, r3, #64	; 0x40
    1cb6:	b2db      	uxtb	r3, r3
    1cb8:	2b00      	cmp	r3, #0
    1cba:	d006      	beq.n	1cca <cbvprintf+0x6d2>
			nj_len += conv.pad0_pre_exp;
    1cbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1cbe:	461a      	mov	r2, r3
    1cc0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1cc4:	4413      	add	r3, r2
    1cc6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    1cca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    1cce:	2b00      	cmp	r3, #0
    1cd0:	dd4c      	ble.n	1d6c <cbvprintf+0x774>
			width -= (int)nj_len;
    1cd2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
    1cd6:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
    1cda:	1ad3      	subs	r3, r2, r3
    1cdc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

			if (!conv.flag_dash) {
    1ce0:	f897 3020 	ldrb.w	r3, [r7, #32]
    1ce4:	f3c3 0380 	ubfx	r3, r3, #2, #1
    1ce8:	b2db      	uxtb	r3, r3
    1cea:	f083 0301 	eor.w	r3, r3, #1
    1cee:	b2db      	uxtb	r3, r3
    1cf0:	2b00      	cmp	r3, #0
    1cf2:	d03b      	beq.n	1d6c <cbvprintf+0x774>
				char pad = ' ';
    1cf4:	2320      	movs	r3, #32
    1cf6:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv.flag_zero) {
    1cfa:	f897 3020 	ldrb.w	r3, [r7, #32]
    1cfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
    1d02:	b2db      	uxtb	r3, r3
    1d04:	2b00      	cmp	r3, #0
    1d06:	d02a      	beq.n	1d5e <cbvprintf+0x766>
					if (sign != 0) {
    1d08:	7efb      	ldrb	r3, [r7, #27]
    1d0a:	2b00      	cmp	r3, #0
    1d0c:	d012      	beq.n	1d34 <cbvprintf+0x73c>
						OUTC(sign);
    1d0e:	7efb      	ldrb	r3, [r7, #27]
    1d10:	461a      	mov	r2, r3
    1d12:	68fb      	ldr	r3, [r7, #12]
    1d14:	68b9      	ldr	r1, [r7, #8]
    1d16:	4610      	mov	r0, r2
    1d18:	4798      	blx	r3
    1d1a:	66b8      	str	r0, [r7, #104]	; 0x68
    1d1c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1d1e:	2b00      	cmp	r3, #0
    1d20:	da01      	bge.n	1d26 <cbvprintf+0x72e>
    1d22:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1d24:	e0bb      	b.n	1e9e <cbvprintf+0x8a6>
    1d26:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1d2a:	3301      	adds	r3, #1
    1d2c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
						sign = 0;
    1d30:	2300      	movs	r3, #0
    1d32:	76fb      	strb	r3, [r7, #27]
					}
					pad = '0';
    1d34:	2330      	movs	r3, #48	; 0x30
    1d36:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
				}

				while (width-- > 0) {
    1d3a:	e010      	b.n	1d5e <cbvprintf+0x766>
					OUTC(pad);
    1d3c:	f897 2097 	ldrb.w	r2, [r7, #151]	; 0x97
    1d40:	68fb      	ldr	r3, [r7, #12]
    1d42:	68b9      	ldr	r1, [r7, #8]
    1d44:	4610      	mov	r0, r2
    1d46:	4798      	blx	r3
    1d48:	6678      	str	r0, [r7, #100]	; 0x64
    1d4a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    1d4c:	2b00      	cmp	r3, #0
    1d4e:	da01      	bge.n	1d54 <cbvprintf+0x75c>
    1d50:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    1d52:	e0a4      	b.n	1e9e <cbvprintf+0x8a6>
    1d54:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1d58:	3301      	adds	r3, #1
    1d5a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
				while (width-- > 0) {
    1d5e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    1d62:	1e5a      	subs	r2, r3, #1
    1d64:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
    1d68:	2b00      	cmp	r3, #0
    1d6a:	dce7      	bgt.n	1d3c <cbvprintf+0x744>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    1d6c:	7efb      	ldrb	r3, [r7, #27]
    1d6e:	2b00      	cmp	r3, #0
    1d70:	d010      	beq.n	1d94 <cbvprintf+0x79c>
			OUTC(sign);
    1d72:	7efb      	ldrb	r3, [r7, #27]
    1d74:	461a      	mov	r2, r3
    1d76:	68fb      	ldr	r3, [r7, #12]
    1d78:	68b9      	ldr	r1, [r7, #8]
    1d7a:	4610      	mov	r0, r2
    1d7c:	4798      	blx	r3
    1d7e:	6638      	str	r0, [r7, #96]	; 0x60
    1d80:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    1d82:	2b00      	cmp	r3, #0
    1d84:	da01      	bge.n	1d8a <cbvprintf+0x792>
    1d86:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    1d88:	e089      	b.n	1e9e <cbvprintf+0x8a6>
    1d8a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1d8e:	3301      	adds	r3, #1
    1d90:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv.altform_0c | conv.altform_0) {
    1d94:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1d98:	f3c3 1300 	ubfx	r3, r3, #4, #1
    1d9c:	b2da      	uxtb	r2, r3
    1d9e:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1da2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    1da6:	b2db      	uxtb	r3, r3
    1da8:	4313      	orrs	r3, r2
    1daa:	b2db      	uxtb	r3, r3
    1dac:	2b00      	cmp	r3, #0
    1dae:	d00e      	beq.n	1dce <cbvprintf+0x7d6>
				OUTC('0');
    1db0:	68fb      	ldr	r3, [r7, #12]
    1db2:	68b9      	ldr	r1, [r7, #8]
    1db4:	2030      	movs	r0, #48	; 0x30
    1db6:	4798      	blx	r3
    1db8:	65f8      	str	r0, [r7, #92]	; 0x5c
    1dba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    1dbc:	2b00      	cmp	r3, #0
    1dbe:	da01      	bge.n	1dc4 <cbvprintf+0x7cc>
    1dc0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    1dc2:	e06c      	b.n	1e9e <cbvprintf+0x8a6>
    1dc4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1dc8:	3301      	adds	r3, #1
    1dca:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			}

			if (conv.altform_0c) {
    1dce:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    1dd2:	f003 0310 	and.w	r3, r3, #16
    1dd6:	b2db      	uxtb	r3, r3
    1dd8:	2b00      	cmp	r3, #0
    1dda:	d011      	beq.n	1e00 <cbvprintf+0x808>
				OUTC(conv.specifier);
    1ddc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    1de0:	461a      	mov	r2, r3
    1de2:	68fb      	ldr	r3, [r7, #12]
    1de4:	68b9      	ldr	r1, [r7, #8]
    1de6:	4610      	mov	r0, r2
    1de8:	4798      	blx	r3
    1dea:	65b8      	str	r0, [r7, #88]	; 0x58
    1dec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1dee:	2b00      	cmp	r3, #0
    1df0:	da01      	bge.n	1df6 <cbvprintf+0x7fe>
    1df2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1df4:	e053      	b.n	1e9e <cbvprintf+0x8a6>
    1df6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1dfa:	3301      	adds	r3, #1
    1dfc:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			}

			pad_len = conv.pad0_value;
    1e00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e02:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
			while (pad_len-- > 0) {
    1e06:	e00e      	b.n	1e26 <cbvprintf+0x82e>
				OUTC('0');
    1e08:	68fb      	ldr	r3, [r7, #12]
    1e0a:	68b9      	ldr	r1, [r7, #8]
    1e0c:	2030      	movs	r0, #48	; 0x30
    1e0e:	4798      	blx	r3
    1e10:	64f8      	str	r0, [r7, #76]	; 0x4c
    1e12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    1e14:	2b00      	cmp	r3, #0
    1e16:	da01      	bge.n	1e1c <cbvprintf+0x824>
    1e18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    1e1a:	e040      	b.n	1e9e <cbvprintf+0x8a6>
    1e1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1e20:	3301      	adds	r3, #1
    1e22:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			while (pad_len-- > 0) {
    1e26:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
    1e2a:	1e5a      	subs	r2, r3, #1
    1e2c:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
    1e30:	2b00      	cmp	r3, #0
    1e32:	dce9      	bgt.n	1e08 <cbvprintf+0x810>
			}

			OUTS(bps, bpe);
    1e34:	69fb      	ldr	r3, [r7, #28]
    1e36:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
    1e3a:	68b9      	ldr	r1, [r7, #8]
    1e3c:	68f8      	ldr	r0, [r7, #12]
    1e3e:	f00e ff2f 	bl	10ca0 <outs>
    1e42:	6578      	str	r0, [r7, #84]	; 0x54
    1e44:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    1e46:	2b00      	cmp	r3, #0
    1e48:	da01      	bge.n	1e4e <cbvprintf+0x856>
    1e4a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    1e4c:	e027      	b.n	1e9e <cbvprintf+0x8a6>
    1e4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    1e50:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
    1e54:	4413      	add	r3, r2
    1e56:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
		}

		/* Finish left justification */
		while (width > 0) {
    1e5a:	e013      	b.n	1e84 <cbvprintf+0x88c>
			OUTC(' ');
    1e5c:	68fb      	ldr	r3, [r7, #12]
    1e5e:	68b9      	ldr	r1, [r7, #8]
    1e60:	2020      	movs	r0, #32
    1e62:	4798      	blx	r3
    1e64:	6538      	str	r0, [r7, #80]	; 0x50
    1e66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1e68:	2b00      	cmp	r3, #0
    1e6a:	da01      	bge.n	1e70 <cbvprintf+0x878>
    1e6c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1e6e:	e016      	b.n	1e9e <cbvprintf+0x8a6>
    1e70:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    1e74:	3301      	adds	r3, #1
    1e76:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			--width;
    1e7a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    1e7e:	3b01      	subs	r3, #1
    1e80:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
		while (width > 0) {
    1e84:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    1e88:	2b00      	cmp	r3, #0
    1e8a:	dce7      	bgt.n	1e5c <cbvprintf+0x864>
    1e8c:	e000      	b.n	1e90 <cbvprintf+0x898>
			continue;
    1e8e:	bf00      	nop
	while (*fp != 0) {
    1e90:	687b      	ldr	r3, [r7, #4]
    1e92:	781b      	ldrb	r3, [r3, #0]
    1e94:	2b00      	cmp	r3, #0
    1e96:	f47f abbb 	bne.w	1610 <cbvprintf+0x18>
		}
	}

	return count;
    1e9a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
#undef OUTS
#undef OUTC
}
    1e9e:	4618      	mov	r0, r3
    1ea0:	37a4      	adds	r7, #164	; 0xa4
    1ea2:	46bd      	mov	sp, r7
    1ea4:	bd90      	pop	{r4, r7, pc}
    1ea6:	bf00      	nop
    1ea8:	00018d68 	.word	0x00018d68

00001eac <nrfx_coredep_delay_us>:
}

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    1eac:	b580      	push	{r7, lr}
    1eae:	b084      	sub	sp, #16
    1eb0:	af00      	add	r7, sp, #0
    1eb2:	6078      	str	r0, [r7, #4]
    if (time_us == 0)
    1eb4:	687b      	ldr	r3, [r7, #4]
    1eb6:	2b00      	cmp	r3, #0
    1eb8:	d00a      	beq.n	1ed0 <nrfx_coredep_delay_us+0x24>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    1eba:	4b07      	ldr	r3, [pc, #28]	; (1ed8 <nrfx_coredep_delay_us+0x2c>)
    1ebc:	f043 0301 	orr.w	r3, r3, #1
    const delay_func_t delay_cycles =
    1ec0:	60fb      	str	r3, [r7, #12]
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    1ec2:	687b      	ldr	r3, [r7, #4]
    1ec4:	019b      	lsls	r3, r3, #6
    1ec6:	60bb      	str	r3, [r7, #8]
    delay_cycles(cycles);
    1ec8:	68fb      	ldr	r3, [r7, #12]
    1eca:	68b8      	ldr	r0, [r7, #8]
    1ecc:	4798      	blx	r3
    1ece:	e000      	b.n	1ed2 <nrfx_coredep_delay_us+0x26>
        return;
    1ed0:	bf00      	nop
}
    1ed2:	3710      	adds	r7, #16
    1ed4:	46bd      	mov	sp, r7
    1ed6:	bd80      	pop	{r7, pc}
    1ed8:	0001ca50 	.word	0x0001ca50

00001edc <nordicsemi_nrf91_init>:

#define LOG_LEVEL CONFIG_SOC_LOG_LEVEL
LOG_MODULE_REGISTER(soc);

static int nordicsemi_nrf91_init(const struct device *arg)
{
    1edc:	b480      	push	{r7}
    1ede:	b087      	sub	sp, #28
    1ee0:	af00      	add	r7, sp, #0
    1ee2:	6078      	str	r0, [r7, #4]
	__asm__ volatile(
    1ee4:	f04f 0320 	mov.w	r3, #32
    1ee8:	f3ef 8211 	mrs	r2, BASEPRI
    1eec:	f383 8811 	msr	BASEPRI, r3
    1ef0:	f3bf 8f6f 	isb	sy
    1ef4:	60fa      	str	r2, [r7, #12]
    1ef6:	60bb      	str	r3, [r7, #8]
	return key;
    1ef8:	68fb      	ldr	r3, [r7, #12]
	uint32_t key;

	ARG_UNUSED(arg);

	key = irq_lock();
    1efa:	617b      	str	r3, [r7, #20]

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    1efc:	4b08      	ldr	r3, [pc, #32]	; (1f20 <nordicsemi_nrf91_init+0x44>)
    1efe:	2201      	movs	r2, #1
    1f00:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    1f04:	697b      	ldr	r3, [r7, #20]
    1f06:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
    1f08:	693b      	ldr	r3, [r7, #16]
    1f0a:	f383 8811 	msr	BASEPRI, r3
    1f0e:	f3bf 8f6f 	isb	sy
}
    1f12:	bf00      	nop
	*/
	NMI_INIT();

	irq_unlock(key);

	return 0;
    1f14:	2300      	movs	r3, #0
}
    1f16:	4618      	mov	r0, r3
    1f18:	371c      	adds	r7, #28
    1f1a:	46bd      	mov	sp, r7
    1f1c:	bc80      	pop	{r7}
    1f1e:	4770      	bx	lr
    1f20:	50039000 	.word	0x50039000

00001f24 <log_name_get>:
 *
 * @param source_id Source ID.
 * @return Name.
 */
static inline const char *log_name_get(uint32_t source_id)
{
    1f24:	b480      	push	{r7}
    1f26:	b083      	sub	sp, #12
    1f28:	af00      	add	r7, sp, #0
    1f2a:	6078      	str	r0, [r7, #4]
	return __log_const_start[source_id].name;
    1f2c:	4a04      	ldr	r2, [pc, #16]	; (1f40 <log_name_get+0x1c>)
    1f2e:	687b      	ldr	r3, [r7, #4]
    1f30:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
}
    1f34:	4618      	mov	r0, r3
    1f36:	370c      	adds	r7, #12
    1f38:	46bd      	mov	sp, r7
    1f3a:	bc80      	pop	{r7}
    1f3c:	4770      	bx	lr
    1f3e:	bf00      	nop
    1f40:	00018788 	.word	0x00018788

00001f44 <log_const_source_id>:
 *
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
    1f44:	b480      	push	{r7}
    1f46:	b083      	sub	sp, #12
    1f48:	af00      	add	r7, sp, #0
    1f4a:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    1f4c:	687b      	ldr	r3, [r7, #4]
    1f4e:	4a04      	ldr	r2, [pc, #16]	; (1f60 <log_const_source_id+0x1c>)
    1f50:	1a9b      	subs	r3, r3, r2
    1f52:	08db      	lsrs	r3, r3, #3
			sizeof(struct log_source_const_data);
}
    1f54:	4618      	mov	r0, r3
    1f56:	370c      	adds	r7, #12
    1f58:	46bd      	mov	sp, r7
    1f5a:	bc80      	pop	{r7}
    1f5c:	4770      	bx	lr
    1f5e:	bf00      	nop
    1f60:	00018788 	.word	0x00018788

00001f64 <log_sources_count>:

/** @brief Get number of registered sources. */
static inline uint32_t log_sources_count(void)
{
    1f64:	b580      	push	{r7, lr}
    1f66:	af00      	add	r7, sp, #0
	return log_const_source_id(__log_const_end);
    1f68:	4802      	ldr	r0, [pc, #8]	; (1f74 <log_sources_count+0x10>)
    1f6a:	f7ff ffeb 	bl	1f44 <log_const_source_id>
    1f6e:	4603      	mov	r3, r0
}
    1f70:	4618      	mov	r0, r3
    1f72:	bd80      	pop	{r7, pc}
    1f74:	000187d8 	.word	0x000187d8

00001f78 <log_backend_put>:
 * @param[in] backend  Pointer to the backend instance.
 * @param[in] msg      Pointer to message with log entry.
 */
static inline void log_backend_put(const struct log_backend *const backend,
				   struct log_msg *msg)
{
    1f78:	b580      	push	{r7, lr}
    1f7a:	b082      	sub	sp, #8
    1f7c:	af00      	add	r7, sp, #0
    1f7e:	6078      	str	r0, [r7, #4]
    1f80:	6039      	str	r1, [r7, #0]
	__ASSERT_NO_MSG(backend != NULL);
    1f82:	687b      	ldr	r3, [r7, #4]
    1f84:	2b00      	cmp	r3, #0
    1f86:	d109      	bne.n	1f9c <log_backend_put+0x24>
    1f88:	2364      	movs	r3, #100	; 0x64
    1f8a:	4a10      	ldr	r2, [pc, #64]	; (1fcc <log_backend_put+0x54>)
    1f8c:	4910      	ldr	r1, [pc, #64]	; (1fd0 <log_backend_put+0x58>)
    1f8e:	4811      	ldr	r0, [pc, #68]	; (1fd4 <log_backend_put+0x5c>)
    1f90:	f00e f86a 	bl	10068 <printk>
    1f94:	2164      	movs	r1, #100	; 0x64
    1f96:	480d      	ldr	r0, [pc, #52]	; (1fcc <log_backend_put+0x54>)
    1f98:	f00e feae 	bl	10cf8 <assert_post_action>
	__ASSERT_NO_MSG(msg != NULL);
    1f9c:	683b      	ldr	r3, [r7, #0]
    1f9e:	2b00      	cmp	r3, #0
    1fa0:	d109      	bne.n	1fb6 <log_backend_put+0x3e>
    1fa2:	2365      	movs	r3, #101	; 0x65
    1fa4:	4a09      	ldr	r2, [pc, #36]	; (1fcc <log_backend_put+0x54>)
    1fa6:	490c      	ldr	r1, [pc, #48]	; (1fd8 <log_backend_put+0x60>)
    1fa8:	480a      	ldr	r0, [pc, #40]	; (1fd4 <log_backend_put+0x5c>)
    1faa:	f00e f85d 	bl	10068 <printk>
    1fae:	2165      	movs	r1, #101	; 0x65
    1fb0:	4806      	ldr	r0, [pc, #24]	; (1fcc <log_backend_put+0x54>)
    1fb2:	f00e fea1 	bl	10cf8 <assert_post_action>
	backend->api->put(backend, msg);
    1fb6:	687b      	ldr	r3, [r7, #4]
    1fb8:	681b      	ldr	r3, [r3, #0]
    1fba:	681b      	ldr	r3, [r3, #0]
    1fbc:	6839      	ldr	r1, [r7, #0]
    1fbe:	6878      	ldr	r0, [r7, #4]
    1fc0:	4798      	blx	r3
}
    1fc2:	bf00      	nop
    1fc4:	3708      	adds	r7, #8
    1fc6:	46bd      	mov	sp, r7
    1fc8:	bd80      	pop	{r7, pc}
    1fca:	bf00      	nop
    1fcc:	00018d74 	.word	0x00018d74
    1fd0:	00018da8 	.word	0x00018da8
    1fd4:	00018dc0 	.word	0x00018dc0
    1fd8:	00018de0 	.word	0x00018de0

00001fdc <log_backend_dropped>:
 * @param[in] backend  Pointer to the backend instance.
 * @param[in] cnt      Number of dropped logs since last notification.
 */
static inline void log_backend_dropped(const struct log_backend *const backend,
				       uint32_t cnt)
{
    1fdc:	b580      	push	{r7, lr}
    1fde:	b082      	sub	sp, #8
    1fe0:	af00      	add	r7, sp, #0
    1fe2:	6078      	str	r0, [r7, #4]
    1fe4:	6039      	str	r1, [r7, #0]
	__ASSERT_NO_MSG(backend != NULL);
    1fe6:	687b      	ldr	r3, [r7, #4]
    1fe8:	2b00      	cmp	r3, #0
    1fea:	d109      	bne.n	2000 <CONFIG_NRF_SPU_RAM_REGION_SIZE>
    1fec:	23a3      	movs	r3, #163	; 0xa3
    1fee:	4a0c      	ldr	r2, [pc, #48]	; (2020 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x20>)
    1ff0:	490c      	ldr	r1, [pc, #48]	; (2024 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x24>)
    1ff2:	480d      	ldr	r0, [pc, #52]	; (2028 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x28>)
    1ff4:	f00e f838 	bl	10068 <printk>
    1ff8:	21a3      	movs	r1, #163	; 0xa3
    1ffa:	4809      	ldr	r0, [pc, #36]	; (2020 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x20>)
    1ffc:	f00e fe7c 	bl	10cf8 <assert_post_action>

	if (backend->api->dropped != NULL) {
    2000:	687b      	ldr	r3, [r7, #4]
    2002:	681b      	ldr	r3, [r3, #0]
    2004:	68db      	ldr	r3, [r3, #12]
    2006:	2b00      	cmp	r3, #0
    2008:	d005      	beq.n	2016 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x16>
		backend->api->dropped(backend, cnt);
    200a:	687b      	ldr	r3, [r7, #4]
    200c:	681b      	ldr	r3, [r3, #0]
    200e:	68db      	ldr	r3, [r3, #12]
    2010:	6839      	ldr	r1, [r7, #0]
    2012:	6878      	ldr	r0, [r7, #4]
    2014:	4798      	blx	r3
	}
}
    2016:	bf00      	nop
    2018:	3708      	adds	r7, #8
    201a:	46bd      	mov	sp, r7
    201c:	bd80      	pop	{r7, pc}
    201e:	bf00      	nop
    2020:	00018d74 	.word	0x00018d74
    2024:	00018da8 	.word	0x00018da8
    2028:	00018dc0 	.word	0x00018dc0

0000202c <log_backend_panic>:
 * @brief Reconfigure backend to panic mode.
 *
 * @param[in] backend  Pointer to the backend instance.
 */
static inline void log_backend_panic(const struct log_backend *const backend)
{
    202c:	b580      	push	{r7, lr}
    202e:	b082      	sub	sp, #8
    2030:	af00      	add	r7, sp, #0
    2032:	6078      	str	r0, [r7, #4]
	__ASSERT_NO_MSG(backend != NULL);
    2034:	687b      	ldr	r3, [r7, #4]
    2036:	2b00      	cmp	r3, #0
    2038:	d109      	bne.n	204e <log_backend_panic+0x22>
    203a:	23b1      	movs	r3, #177	; 0xb1
    203c:	4a08      	ldr	r2, [pc, #32]	; (2060 <log_backend_panic+0x34>)
    203e:	4909      	ldr	r1, [pc, #36]	; (2064 <log_backend_panic+0x38>)
    2040:	4809      	ldr	r0, [pc, #36]	; (2068 <log_backend_panic+0x3c>)
    2042:	f00e f811 	bl	10068 <printk>
    2046:	21b1      	movs	r1, #177	; 0xb1
    2048:	4805      	ldr	r0, [pc, #20]	; (2060 <log_backend_panic+0x34>)
    204a:	f00e fe55 	bl	10cf8 <assert_post_action>
	backend->api->panic(backend);
    204e:	687b      	ldr	r3, [r7, #4]
    2050:	681b      	ldr	r3, [r3, #0]
    2052:	691b      	ldr	r3, [r3, #16]
    2054:	6878      	ldr	r0, [r7, #4]
    2056:	4798      	blx	r3
}
    2058:	bf00      	nop
    205a:	3708      	adds	r7, #8
    205c:	46bd      	mov	sp, r7
    205e:	bd80      	pop	{r7, pc}
    2060:	00018d74 	.word	0x00018d74
    2064:	00018da8 	.word	0x00018da8
    2068:	00018dc0 	.word	0x00018dc0

0000206c <log_backend_id_set>:
 * @param backend  Pointer to the backend instance.
 * @param id       ID.
 */
static inline void log_backend_id_set(const struct log_backend *const backend,
				      uint8_t id)
{
    206c:	b580      	push	{r7, lr}
    206e:	b082      	sub	sp, #8
    2070:	af00      	add	r7, sp, #0
    2072:	6078      	str	r0, [r7, #4]
    2074:	460b      	mov	r3, r1
    2076:	70fb      	strb	r3, [r7, #3]
	__ASSERT_NO_MSG(backend != NULL);
    2078:	687b      	ldr	r3, [r7, #4]
    207a:	2b00      	cmp	r3, #0
    207c:	d109      	bne.n	2092 <log_backend_id_set+0x26>
    207e:	23c0      	movs	r3, #192	; 0xc0
    2080:	4a08      	ldr	r2, [pc, #32]	; (20a4 <log_backend_id_set+0x38>)
    2082:	4909      	ldr	r1, [pc, #36]	; (20a8 <log_backend_id_set+0x3c>)
    2084:	4809      	ldr	r0, [pc, #36]	; (20ac <log_backend_id_set+0x40>)
    2086:	f00d ffef 	bl	10068 <printk>
    208a:	21c0      	movs	r1, #192	; 0xc0
    208c:	4805      	ldr	r0, [pc, #20]	; (20a4 <log_backend_id_set+0x38>)
    208e:	f00e fe33 	bl	10cf8 <assert_post_action>
	backend->cb->id = id;
    2092:	687b      	ldr	r3, [r7, #4]
    2094:	685b      	ldr	r3, [r3, #4]
    2096:	78fa      	ldrb	r2, [r7, #3]
    2098:	711a      	strb	r2, [r3, #4]
}
    209a:	bf00      	nop
    209c:	3708      	adds	r7, #8
    209e:	46bd      	mov	sp, r7
    20a0:	bd80      	pop	{r7, pc}
    20a2:	bf00      	nop
    20a4:	00018d74 	.word	0x00018d74
    20a8:	00018da8 	.word	0x00018da8
    20ac:	00018dc0 	.word	0x00018dc0

000020b0 <log_backend_get>:
 * @param[in] idx  Pointer to the backend instance.
 *
 * @return    Pointer to the backend instance.
 */
static inline const struct log_backend *log_backend_get(uint32_t idx)
{
    20b0:	b480      	push	{r7}
    20b2:	b083      	sub	sp, #12
    20b4:	af00      	add	r7, sp, #0
    20b6:	6078      	str	r0, [r7, #4]
	return &__log_backends_start[idx];
    20b8:	687b      	ldr	r3, [r7, #4]
    20ba:	011b      	lsls	r3, r3, #4
    20bc:	4a03      	ldr	r2, [pc, #12]	; (20cc <log_backend_get+0x1c>)
    20be:	4413      	add	r3, r2
}
    20c0:	4618      	mov	r0, r3
    20c2:	370c      	adds	r7, #12
    20c4:	46bd      	mov	sp, r7
    20c6:	bc80      	pop	{r7}
    20c8:	4770      	bx	lr
    20ca:	bf00      	nop
    20cc:	000187d8 	.word	0x000187d8

000020d0 <log_backend_count_get>:
 * @brief Get number of backends.
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
    20d0:	b480      	push	{r7}
    20d2:	af00      	add	r7, sp, #0
	return __log_backends_end - __log_backends_start;
    20d4:	4a03      	ldr	r2, [pc, #12]	; (20e4 <log_backend_count_get+0x14>)
    20d6:	4b04      	ldr	r3, [pc, #16]	; (20e8 <log_backend_count_get+0x18>)
    20d8:	1ad3      	subs	r3, r2, r3
    20da:	111b      	asrs	r3, r3, #4
}
    20dc:	4618      	mov	r0, r3
    20de:	46bd      	mov	sp, r7
    20e0:	bc80      	pop	{r7}
    20e2:	4770      	bx	lr
    20e4:	000187e8 	.word	0x000187e8
    20e8:	000187d8 	.word	0x000187d8

000020ec <log_backend_activate>:
 * @param[in] backend  Pointer to the backend instance.
 * @param[in] ctx      User context.
 */
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
    20ec:	b580      	push	{r7, lr}
    20ee:	b082      	sub	sp, #8
    20f0:	af00      	add	r7, sp, #0
    20f2:	6078      	str	r0, [r7, #4]
    20f4:	6039      	str	r1, [r7, #0]
	__ASSERT_NO_MSG(backend != NULL);
    20f6:	687b      	ldr	r3, [r7, #4]
    20f8:	2b00      	cmp	r3, #0
    20fa:	d109      	bne.n	2110 <log_backend_activate+0x24>
    20fc:	23f1      	movs	r3, #241	; 0xf1
    20fe:	4a0a      	ldr	r2, [pc, #40]	; (2128 <log_backend_activate+0x3c>)
    2100:	490a      	ldr	r1, [pc, #40]	; (212c <log_backend_activate+0x40>)
    2102:	480b      	ldr	r0, [pc, #44]	; (2130 <log_backend_activate+0x44>)
    2104:	f00d ffb0 	bl	10068 <printk>
    2108:	21f1      	movs	r1, #241	; 0xf1
    210a:	4807      	ldr	r0, [pc, #28]	; (2128 <log_backend_activate+0x3c>)
    210c:	f00e fdf4 	bl	10cf8 <assert_post_action>
	backend->cb->ctx = ctx;
    2110:	687b      	ldr	r3, [r7, #4]
    2112:	685b      	ldr	r3, [r3, #4]
    2114:	683a      	ldr	r2, [r7, #0]
    2116:	601a      	str	r2, [r3, #0]
	backend->cb->active = true;
    2118:	687b      	ldr	r3, [r7, #4]
    211a:	685b      	ldr	r3, [r3, #4]
    211c:	2201      	movs	r2, #1
    211e:	715a      	strb	r2, [r3, #5]
}
    2120:	bf00      	nop
    2122:	3708      	adds	r7, #8
    2124:	46bd      	mov	sp, r7
    2126:	bd80      	pop	{r7, pc}
    2128:	00018d74 	.word	0x00018d74
    212c:	00018da8 	.word	0x00018da8
    2130:	00018dc0 	.word	0x00018dc0

00002134 <log_backend_is_active>:
 *
 * @return True if backend is active, false otherwise.
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
    2134:	b580      	push	{r7, lr}
    2136:	b082      	sub	sp, #8
    2138:	af00      	add	r7, sp, #0
    213a:	6078      	str	r0, [r7, #4]
	__ASSERT_NO_MSG(backend != NULL);
    213c:	687b      	ldr	r3, [r7, #4]
    213e:	2b00      	cmp	r3, #0
    2140:	d10b      	bne.n	215a <log_backend_is_active+0x26>
    2142:	f44f 7386 	mov.w	r3, #268	; 0x10c
    2146:	4a08      	ldr	r2, [pc, #32]	; (2168 <log_backend_is_active+0x34>)
    2148:	4908      	ldr	r1, [pc, #32]	; (216c <log_backend_is_active+0x38>)
    214a:	4809      	ldr	r0, [pc, #36]	; (2170 <log_backend_is_active+0x3c>)
    214c:	f00d ff8c 	bl	10068 <printk>
    2150:	f44f 7186 	mov.w	r1, #268	; 0x10c
    2154:	4804      	ldr	r0, [pc, #16]	; (2168 <log_backend_is_active+0x34>)
    2156:	f00e fdcf 	bl	10cf8 <assert_post_action>
	return backend->cb->active;
    215a:	687b      	ldr	r3, [r7, #4]
    215c:	685b      	ldr	r3, [r3, #4]
    215e:	795b      	ldrb	r3, [r3, #5]
}
    2160:	4618      	mov	r0, r3
    2162:	3708      	adds	r7, #8
    2164:	46bd      	mov	sp, r7
    2166:	bd80      	pop	{r7, pc}
    2168:	00018d74 	.word	0x00018d74
    216c:	00018da8 	.word	0x00018da8
    2170:	00018dc0 	.word	0x00018dc0

00002174 <z_log_get_s_mask>:
{
	return 0;
}

uint32_t z_log_get_s_mask(const char *str, uint32_t nargs)
{
    2174:	b580      	push	{r7, lr}
    2176:	b086      	sub	sp, #24
    2178:	af00      	add	r7, sp, #0
    217a:	6078      	str	r0, [r7, #4]
    217c:	6039      	str	r1, [r7, #0]
	char curr;
	bool arm = false;
    217e:	2300      	movs	r3, #0
    2180:	75fb      	strb	r3, [r7, #23]
	uint32_t arg = 0;
    2182:	2300      	movs	r3, #0
    2184:	613b      	str	r3, [r7, #16]
	uint32_t mask = 0;
    2186:	2300      	movs	r3, #0
    2188:	60fb      	str	r3, [r7, #12]

	__ASSERT_NO_MSG(nargs <= 8*sizeof(mask));
    218a:	683b      	ldr	r3, [r7, #0]
    218c:	2b20      	cmp	r3, #32
    218e:	d935      	bls.n	21fc <z_log_get_s_mask+0x88>
    2190:	235b      	movs	r3, #91	; 0x5b
    2192:	4a23      	ldr	r2, [pc, #140]	; (2220 <z_log_get_s_mask+0xac>)
    2194:	4923      	ldr	r1, [pc, #140]	; (2224 <z_log_get_s_mask+0xb0>)
    2196:	4824      	ldr	r0, [pc, #144]	; (2228 <z_log_get_s_mask+0xb4>)
    2198:	f00d ff66 	bl	10068 <printk>
    219c:	215b      	movs	r1, #91	; 0x5b
    219e:	4820      	ldr	r0, [pc, #128]	; (2220 <z_log_get_s_mask+0xac>)
    21a0:	f00e fdaa 	bl	10cf8 <assert_post_action>

	while ((curr = *str++) && arg < nargs) {
    21a4:	e02a      	b.n	21fc <z_log_get_s_mask+0x88>
		if (curr == '%') {
    21a6:	7afb      	ldrb	r3, [r7, #11]
    21a8:	2b25      	cmp	r3, #37	; 0x25
    21aa:	d10e      	bne.n	21ca <z_log_get_s_mask+0x56>
			arm = !arm;
    21ac:	7dfb      	ldrb	r3, [r7, #23]
    21ae:	2b00      	cmp	r3, #0
    21b0:	bf14      	ite	ne
    21b2:	2301      	movne	r3, #1
    21b4:	2300      	moveq	r3, #0
    21b6:	b2db      	uxtb	r3, r3
    21b8:	f083 0301 	eor.w	r3, r3, #1
    21bc:	b2db      	uxtb	r3, r3
    21be:	75fb      	strb	r3, [r7, #23]
    21c0:	7dfb      	ldrb	r3, [r7, #23]
    21c2:	f003 0301 	and.w	r3, r3, #1
    21c6:	75fb      	strb	r3, [r7, #23]
    21c8:	e018      	b.n	21fc <z_log_get_s_mask+0x88>
		} else if (arm && isalpha((int)curr)) {
    21ca:	7dfb      	ldrb	r3, [r7, #23]
    21cc:	2b00      	cmp	r3, #0
    21ce:	d015      	beq.n	21fc <z_log_get_s_mask+0x88>
    21d0:	7afb      	ldrb	r3, [r7, #11]
    21d2:	4618      	mov	r0, r3
    21d4:	f00f fa0c 	bl	115f0 <isalpha>
    21d8:	4603      	mov	r3, r0
    21da:	2b00      	cmp	r3, #0
    21dc:	d00e      	beq.n	21fc <z_log_get_s_mask+0x88>
			if (curr == 's') {
    21de:	7afb      	ldrb	r3, [r7, #11]
    21e0:	2b73      	cmp	r3, #115	; 0x73
    21e2:	d106      	bne.n	21f2 <z_log_get_s_mask+0x7e>
				mask |= BIT(arg);
    21e4:	2201      	movs	r2, #1
    21e6:	693b      	ldr	r3, [r7, #16]
    21e8:	fa02 f303 	lsl.w	r3, r2, r3
    21ec:	68fa      	ldr	r2, [r7, #12]
    21ee:	4313      	orrs	r3, r2
    21f0:	60fb      	str	r3, [r7, #12]
			}
			arm = false;
    21f2:	2300      	movs	r3, #0
    21f4:	75fb      	strb	r3, [r7, #23]
			arg++;
    21f6:	693b      	ldr	r3, [r7, #16]
    21f8:	3301      	adds	r3, #1
    21fa:	613b      	str	r3, [r7, #16]
	while ((curr = *str++) && arg < nargs) {
    21fc:	687b      	ldr	r3, [r7, #4]
    21fe:	1c5a      	adds	r2, r3, #1
    2200:	607a      	str	r2, [r7, #4]
    2202:	781b      	ldrb	r3, [r3, #0]
    2204:	72fb      	strb	r3, [r7, #11]
    2206:	7afb      	ldrb	r3, [r7, #11]
    2208:	2b00      	cmp	r3, #0
    220a:	d003      	beq.n	2214 <z_log_get_s_mask+0xa0>
    220c:	693a      	ldr	r2, [r7, #16]
    220e:	683b      	ldr	r3, [r7, #0]
    2210:	429a      	cmp	r2, r3
    2212:	d3c8      	bcc.n	21a6 <z_log_get_s_mask+0x32>
		} else {
		}
	}

	return mask;
    2214:	68fb      	ldr	r3, [r7, #12]
}
    2216:	4618      	mov	r0, r3
    2218:	3718      	adds	r7, #24
    221a:	46bd      	mov	sp, r7
    221c:	bd80      	pop	{r7, pc}
    221e:	bf00      	nop
    2220:	00018e14 	.word	0x00018e14
    2224:	00018e44 	.word	0x00018e44
    2228:	00018dc0 	.word	0x00018dc0

0000222c <is_rodata>:
 * @param addr Address.
 *
 * @return True if address identified within read only section.
 */
static bool is_rodata(const void *addr)
{
    222c:	b480      	push	{r7}
    222e:	b083      	sub	sp, #12
    2230:	af00      	add	r7, sp, #0
    2232:	6078      	str	r0, [r7, #4]
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
    2234:	687b      	ldr	r3, [r7, #4]
    2236:	4a09      	ldr	r2, [pc, #36]	; (225c <is_rodata+0x30>)
    2238:	4293      	cmp	r3, r2
    223a:	d305      	bcc.n	2248 <is_rodata+0x1c>
    223c:	687b      	ldr	r3, [r7, #4]
    223e:	4a08      	ldr	r2, [pc, #32]	; (2260 <is_rodata+0x34>)
    2240:	4293      	cmp	r3, r2
    2242:	d201      	bcs.n	2248 <is_rodata+0x1c>
    2244:	2301      	movs	r3, #1
    2246:	e000      	b.n	224a <is_rodata+0x1e>
    2248:	2300      	movs	r3, #0
    224a:	f003 0301 	and.w	r3, r3, #1
    224e:	b2db      	uxtb	r3, r3
		((const char *)addr < (const char *)RO_END));
}
    2250:	4618      	mov	r0, r3
    2252:	370c      	adds	r7, #12
    2254:	46bd      	mov	sp, r7
    2256:	bc80      	pop	{r7}
    2258:	4770      	bx	lr
    225a:	bf00      	nop
    225c:	00018518 	.word	0x00018518
    2260:	0001cf34 	.word	0x0001cf34

00002264 <detect_missed_strdup>:
 *	  only memory and not yet duplicated.
 *
 * @param msg Log message.
 */
static void detect_missed_strdup(struct log_msg *msg)
{
    2264:	b580      	push	{r7, lr}
    2266:	b08c      	sub	sp, #48	; 0x30
    2268:	af00      	add	r7, sp, #0
    226a:	6078      	str	r0, [r7, #4]
	uint32_t idx;
	const char *str;
	const char *msg_str;
	uint32_t mask;

	if (!log_msg_is_std(msg)) {
    226c:	6878      	ldr	r0, [r7, #4]
    226e:	f00e fe1d 	bl	10eac <log_msg_is_std>
    2272:	4603      	mov	r3, r0
    2274:	f083 0301 	eor.w	r3, r3, #1
    2278:	b2db      	uxtb	r3, r3
    227a:	2b00      	cmp	r3, #0
    227c:	d155      	bne.n	232a <detect_missed_strdup+0xc6>
		return;
	}

	msg_str = log_msg_str_get(msg);
    227e:	6878      	ldr	r0, [r7, #4]
    2280:	f00f fca5 	bl	11bce <log_msg_str_get>
    2284:	62f8      	str	r0, [r7, #44]	; 0x2c
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    2286:	6878      	ldr	r0, [r7, #4]
    2288:	f00f fc41 	bl	11b0e <log_msg_nargs_get>
    228c:	4603      	mov	r3, r0
    228e:	4619      	mov	r1, r3
    2290:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    2292:	f7ff ff6f 	bl	2174 <z_log_get_s_mask>
    2296:	62b8      	str	r0, [r7, #40]	; 0x28

	while (mask) {
    2298:	e043      	b.n	2322 <detect_missed_strdup+0xbe>
		idx = 31 - __builtin_clz(mask);
    229a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    229c:	fab3 f383 	clz	r3, r3
    22a0:	f1c3 031f 	rsb	r3, r3, #31
    22a4:	627b      	str	r3, [r7, #36]	; 0x24
		str = (const char *)log_msg_arg_get(msg, idx);
    22a6:	6a79      	ldr	r1, [r7, #36]	; 0x24
    22a8:	6878      	ldr	r0, [r7, #4]
    22aa:	f00f fc67 	bl	11b7c <log_msg_arg_get>
    22ae:	4603      	mov	r3, r0
    22b0:	623b      	str	r3, [r7, #32]
		if (!is_rodata(str) && !log_is_strdup(str) &&
    22b2:	6a38      	ldr	r0, [r7, #32]
    22b4:	f7ff ffba 	bl	222c <is_rodata>
    22b8:	4603      	mov	r3, r0
    22ba:	f083 0301 	eor.w	r3, r3, #1
    22be:	b2db      	uxtb	r3, r3
    22c0:	2b00      	cmp	r3, #0
    22c2:	d026      	beq.n	2312 <detect_missed_strdup+0xae>
    22c4:	6a38      	ldr	r0, [r7, #32]
    22c6:	f000 fadb 	bl	2880 <log_is_strdup>
    22ca:	4603      	mov	r3, r0
    22cc:	f083 0301 	eor.w	r3, r3, #1
    22d0:	b2db      	uxtb	r3, r3
    22d2:	2b00      	cmp	r3, #0
    22d4:	d01d      	beq.n	2312 <detect_missed_strdup+0xae>
			(str != log_strdup_fail_msg)) {
    22d6:	4b17      	ldr	r3, [pc, #92]	; (2334 <detect_missed_strdup+0xd0>)
    22d8:	681b      	ldr	r3, [r3, #0]
		if (!is_rodata(str) && !log_is_strdup(str) &&
    22da:	6a3a      	ldr	r2, [r7, #32]
    22dc:	429a      	cmp	r2, r3
    22de:	d018      	beq.n	2312 <detect_missed_strdup+0xae>
			const char *src_name =
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    22e0:	6878      	ldr	r0, [r7, #4]
    22e2:	f00e fdd5 	bl	10e90 <log_msg_source_id_get>
    22e6:	4603      	mov	r3, r0
    22e8:	4619      	mov	r1, r3
    22ea:	2000      	movs	r0, #0
    22ec:	f00f fa23 	bl	11736 <log_source_name_get>
    22f0:	61f8      	str	r0, [r7, #28]
						    log_msg_source_id_get(msg));

			if (IS_ENABLED(CONFIG_ASSERT)) {
				__ASSERT(0, ERR_MSG, idx, src_name, msg_str);
    22f2:	23ae      	movs	r3, #174	; 0xae
    22f4:	4a10      	ldr	r2, [pc, #64]	; (2338 <detect_missed_strdup+0xd4>)
    22f6:	4911      	ldr	r1, [pc, #68]	; (233c <detect_missed_strdup+0xd8>)
    22f8:	4811      	ldr	r0, [pc, #68]	; (2340 <detect_missed_strdup+0xdc>)
    22fa:	f00d feb5 	bl	10068 <printk>
    22fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2300:	69fa      	ldr	r2, [r7, #28]
    2302:	6a79      	ldr	r1, [r7, #36]	; 0x24
    2304:	480f      	ldr	r0, [pc, #60]	; (2344 <detect_missed_strdup+0xe0>)
    2306:	f00d feaf 	bl	10068 <printk>
    230a:	21ae      	movs	r1, #174	; 0xae
    230c:	480a      	ldr	r0, [pc, #40]	; (2338 <detect_missed_strdup+0xd4>)
    230e:	f00e fcf3 	bl	10cf8 <assert_post_action>
			} else {
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
			}
		}

		mask &= ~BIT(idx);
    2312:	2201      	movs	r2, #1
    2314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2316:	fa02 f303 	lsl.w	r3, r2, r3
    231a:	43db      	mvns	r3, r3
    231c:	6aba      	ldr	r2, [r7, #40]	; 0x28
    231e:	4013      	ands	r3, r2
    2320:	62bb      	str	r3, [r7, #40]	; 0x28
	while (mask) {
    2322:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2324:	2b00      	cmp	r3, #0
    2326:	d1b8      	bne.n	229a <detect_missed_strdup+0x36>
    2328:	e000      	b.n	232c <detect_missed_strdup+0xc8>
		return;
    232a:	bf00      	nop
	}
#undef ERR_MSG
}
    232c:	3730      	adds	r7, #48	; 0x30
    232e:	46bd      	mov	sp, r7
    2330:	bd80      	pop	{r7, pc}
    2332:	bf00      	nop
    2334:	200000c4 	.word	0x200000c4
    2338:	00018e14 	.word	0x00018e14
    233c:	00018e5c 	.word	0x00018e5c
    2340:	00018dc0 	.word	0x00018dc0
    2344:	00018e60 	.word	0x00018e60

00002348 <msg_finalize>:

static inline void msg_finalize(struct log_msg *msg,
				struct log_msg_ids src_level)
{
    2348:	b580      	push	{r7, lr}
    234a:	b08c      	sub	sp, #48	; 0x30
    234c:	af02      	add	r7, sp, #8
    234e:	6078      	str	r0, [r7, #4]
    2350:	8039      	strh	r1, [r7, #0]
	unsigned int key;

	msg->hdr.ids = src_level;
    2352:	687b      	ldr	r3, [r7, #4]
    2354:	883a      	ldrh	r2, [r7, #0]
    2356:	815a      	strh	r2, [r3, #10]
	msg->hdr.timestamp = timestamp_func();
    2358:	4b36      	ldr	r3, [pc, #216]	; (2434 <msg_finalize+0xec>)
    235a:	681b      	ldr	r3, [r3, #0]
    235c:	4798      	blx	r3
    235e:	4602      	mov	r2, r0
    2360:	687b      	ldr	r3, [r7, #4]
    2362:	60da      	str	r2, [r3, #12]

	atomic_inc(&buffered_cnt);
    2364:	4834      	ldr	r0, [pc, #208]	; (2438 <msg_finalize+0xf0>)
    2366:	f00e fd66 	bl	10e36 <atomic_inc>
	__asm__ volatile(
    236a:	f04f 0320 	mov.w	r3, #32
    236e:	f3ef 8211 	mrs	r2, BASEPRI
    2372:	f383 8811 	msr	BASEPRI, r3
    2376:	f3bf 8f6f 	isb	sy
    237a:	61fa      	str	r2, [r7, #28]
    237c:	61bb      	str	r3, [r7, #24]
	return key;
    237e:	69fb      	ldr	r3, [r7, #28]

	key = irq_lock();
    2380:	627b      	str	r3, [r7, #36]	; 0x24

	log_list_add_tail(&list, msg);
    2382:	6879      	ldr	r1, [r7, #4]
    2384:	482d      	ldr	r0, [pc, #180]	; (243c <msg_finalize+0xf4>)
    2386:	f00e fced 	bl	10d64 <log_list_add_tail>
    238a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    238c:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    238e:	6a3b      	ldr	r3, [r7, #32]
    2390:	f383 8811 	msr	BASEPRI, r3
    2394:	f3bf 8f6f 	isb	sy
}
    2398:	bf00      	nop

	irq_unlock(key);

	if (panic_mode) {
    239a:	4b29      	ldr	r3, [pc, #164]	; (2440 <msg_finalize+0xf8>)
    239c:	781b      	ldrb	r3, [r3, #0]
    239e:	2b00      	cmp	r3, #0
    23a0:	d016      	beq.n	23d0 <msg_finalize+0x88>
	__asm__ volatile(
    23a2:	f04f 0320 	mov.w	r3, #32
    23a6:	f3ef 8211 	mrs	r2, BASEPRI
    23aa:	f383 8811 	msr	BASEPRI, r3
    23ae:	f3bf 8f6f 	isb	sy
    23b2:	613a      	str	r2, [r7, #16]
    23b4:	60fb      	str	r3, [r7, #12]
	return key;
    23b6:	693b      	ldr	r3, [r7, #16]
		key = irq_lock();
    23b8:	627b      	str	r3, [r7, #36]	; 0x24
		(void)log_process(false);
    23ba:	2000      	movs	r0, #0
    23bc:	f00f f90a 	bl	115d4 <log_process>
    23c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    23c2:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    23c4:	697b      	ldr	r3, [r7, #20]
    23c6:	f383 8811 	msr	BASEPRI, r3
    23ca:	f3bf 8f6f 	isb	sy
}
    23ce:	e02c      	b.n	242a <msg_finalize+0xe2>
		irq_unlock(key);
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    23d0:	4b1c      	ldr	r3, [pc, #112]	; (2444 <msg_finalize+0xfc>)
    23d2:	681b      	ldr	r3, [r3, #0]
    23d4:	2b00      	cmp	r3, #0
    23d6:	d019      	beq.n	240c <msg_finalize+0xc4>
    23d8:	4b17      	ldr	r3, [pc, #92]	; (2438 <msg_finalize+0xf0>)
    23da:	681b      	ldr	r3, [r3, #0]
    23dc:	2b01      	cmp	r3, #1
    23de:	d115      	bne.n	240c <msg_finalize+0xc4>
		k_timer_start(&log_process_thread_timer,
			K_MSEC(CONFIG_LOG_PROCESS_THREAD_SLEEP_MS), K_NO_WAIT);
    23e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    23e4:	f04f 0100 	mov.w	r1, #0
    23e8:	f00e fe14 	bl	11014 <k_ms_to_ticks_ceil64>
    23ec:	4602      	mov	r2, r0
    23ee:	460b      	mov	r3, r1
    23f0:	4610      	mov	r0, r2
    23f2:	4619      	mov	r1, r3
    23f4:	f04f 0200 	mov.w	r2, #0
    23f8:	f04f 0300 	mov.w	r3, #0
		k_timer_start(&log_process_thread_timer,
    23fc:	e9cd 2300 	strd	r2, r3, [sp]
    2400:	4602      	mov	r2, r0
    2402:	460b      	mov	r3, r1
    2404:	4810      	ldr	r0, [pc, #64]	; (2448 <msg_finalize+0x100>)
    2406:	f00f f8a3 	bl	11550 <k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    240a:	e00e      	b.n	242a <msg_finalize+0xe2>
	} else if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    240c:	4b0a      	ldr	r3, [pc, #40]	; (2438 <msg_finalize+0xf0>)
    240e:	681b      	ldr	r3, [r3, #0]
    2410:	2b0a      	cmp	r3, #10
    2412:	d10a      	bne.n	242a <msg_finalize+0xe2>
		    (proc_tid != NULL)) {
    2414:	4b0b      	ldr	r3, [pc, #44]	; (2444 <msg_finalize+0xfc>)
    2416:	681b      	ldr	r3, [r3, #0]
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    2418:	2b00      	cmp	r3, #0
    241a:	d006      	beq.n	242a <msg_finalize+0xe2>
			k_timer_stop(&log_process_thread_timer);
    241c:	480a      	ldr	r0, [pc, #40]	; (2448 <msg_finalize+0x100>)
    241e:	f00f f8aa 	bl	11576 <k_timer_stop>
			k_sem_give(&log_process_thread_sem);
    2422:	480a      	ldr	r0, [pc, #40]	; (244c <msg_finalize+0x104>)
    2424:	f00f f8cb 	bl	115be <k_sem_give>
		}
	} else {
	}
}
    2428:	e7ff      	b.n	242a <msg_finalize+0xe2>
    242a:	bf00      	nop
    242c:	3728      	adds	r7, #40	; 0x28
    242e:	46bd      	mov	sp, r7
    2430:	bd80      	pop	{r7, pc}
    2432:	bf00      	nop
    2434:	200000c8 	.word	0x200000c8
    2438:	20000668 	.word	0x20000668
    243c:	2000065c 	.word	0x2000065c
    2440:	20000d40 	.word	0x20000d40
    2444:	20000670 	.word	0x20000670
    2448:	200002c0 	.word	0x200002c0
    244c:	200002ac 	.word	0x200002ac

00002450 <log_core_init>:
	 */
	return k_cycle_get_32();
}

void log_core_init(void)
{
    2450:	b580      	push	{r7, lr}
    2452:	b082      	sub	sp, #8
    2454:	af00      	add	r7, sp, #0
	uint32_t freq;

	if (!IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		log_msg_pool_init();
    2456:	f000 fae5 	bl	2a24 <log_msg_pool_init>
		log_list_init(&list);
    245a:	4812      	ldr	r0, [pc, #72]	; (24a4 <log_core_init+0x54>)
    245c:	f00e fc73 	bl	10d46 <log_list_init>

		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    2460:	2304      	movs	r3, #4
    2462:	2228      	movs	r2, #40	; 0x28
    2464:	4910      	ldr	r1, [pc, #64]	; (24a8 <log_core_init+0x58>)
    2466:	4811      	ldr	r0, [pc, #68]	; (24ac <log_core_init+0x5c>)
    2468:	f014 fd02 	bl	16e70 <k_mem_slab_init>
					sizeof(struct log_strdup_buf),
					CONFIG_LOG_STRDUP_BUF_COUNT);
	}

	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
    246c:	f00e fdca 	bl	11004 <sys_clock_hw_cycles_per_sec>
    2470:	4603      	mov	r3, r0
    2472:	4a0f      	ldr	r2, [pc, #60]	; (24b0 <log_core_init+0x60>)
    2474:	4293      	cmp	r3, r2
    2476:	dd06      	ble.n	2486 <log_core_init+0x36>
		timestamp_func = k_uptime_get_32;
    2478:	4b0e      	ldr	r3, [pc, #56]	; (24b4 <log_core_init+0x64>)
    247a:	4a0f      	ldr	r2, [pc, #60]	; (24b8 <log_core_init+0x68>)
    247c:	601a      	str	r2, [r3, #0]
		freq = 1000;
    247e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    2482:	607b      	str	r3, [r7, #4]
    2484:	e006      	b.n	2494 <log_core_init+0x44>
	} else {
		timestamp_func = k_cycle_get_32_wrapper;
    2486:	4b0b      	ldr	r3, [pc, #44]	; (24b4 <log_core_init+0x64>)
    2488:	4a0c      	ldr	r2, [pc, #48]	; (24bc <log_core_init+0x6c>)
    248a:	601a      	str	r2, [r3, #0]
		freq = sys_clock_hw_cycles_per_sec();
    248c:	f00e fdba 	bl	11004 <sys_clock_hw_cycles_per_sec>
    2490:	4603      	mov	r3, r0
    2492:	607b      	str	r3, [r7, #4]
	}

	log_output_timestamp_freq_set(freq);
    2494:	6878      	ldr	r0, [r7, #4]
    2496:	f001 f963 	bl	3760 <log_output_timestamp_freq_set>
			LOG_FILTER_SLOT_SET(filters,
					    LOG_FILTER_AGGR_SLOT_IDX,
					    level);
		}
	}
}
    249a:	bf00      	nop
    249c:	3708      	adds	r7, #8
    249e:	46bd      	mov	sp, r7
    24a0:	bd80      	pop	{r7, pc}
    24a2:	bf00      	nop
    24a4:	2000065c 	.word	0x2000065c
    24a8:	20001e88 	.word	0x20001e88
    24ac:	20000640 	.word	0x20000640
    24b0:	000f4240 	.word	0x000f4240
    24b4:	200000c8 	.word	0x200000c8
    24b8:	000114c7 	.word	0x000114c7
    24bc:	00011713 	.word	0x00011713

000024c0 <log_init>:

void log_init(void)
{
    24c0:	b580      	push	{r7, lr}
    24c2:	b082      	sub	sp, #8
    24c4:	af00      	add	r7, sp, #0
	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    24c6:	f7ff fe03 	bl	20d0 <log_backend_count_get>
    24ca:	4603      	mov	r3, r0
    24cc:	2b09      	cmp	r3, #9
    24ce:	d90b      	bls.n	24e8 <log_init+0x28>
    24d0:	f240 230e 	movw	r3, #526	; 0x20e
    24d4:	4a1b      	ldr	r2, [pc, #108]	; (2544 <log_init+0x84>)
    24d6:	491c      	ldr	r1, [pc, #112]	; (2548 <log_init+0x88>)
    24d8:	481c      	ldr	r0, [pc, #112]	; (254c <log_init+0x8c>)
    24da:	f00d fdc5 	bl	10068 <printk>
    24de:	f240 210e 	movw	r1, #526	; 0x20e
    24e2:	4818      	ldr	r0, [pc, #96]	; (2544 <log_init+0x84>)
    24e4:	f00e fc08 	bl	10cf8 <assert_post_action>

	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_init();
	}

	if (atomic_inc(&initialized) != 0) {
    24e8:	4819      	ldr	r0, [pc, #100]	; (2550 <log_init+0x90>)
    24ea:	f00e fca4 	bl	10e36 <atomic_inc>
    24ee:	4603      	mov	r3, r0
    24f0:	2b00      	cmp	r3, #0
    24f2:	d123      	bne.n	253c <log_init+0x7c>
		return;
	}

	/* Assign ids to backends. */
	for (i = 0; i < log_backend_count_get(); i++) {
    24f4:	2300      	movs	r3, #0
    24f6:	607b      	str	r3, [r7, #4]
    24f8:	e019      	b.n	252e <log_init+0x6e>
		const struct log_backend *backend = log_backend_get(i);
    24fa:	687b      	ldr	r3, [r7, #4]
    24fc:	4618      	mov	r0, r3
    24fe:	f7ff fdd7 	bl	20b0 <log_backend_get>
    2502:	6038      	str	r0, [r7, #0]

		if (backend->autostart) {
    2504:	683b      	ldr	r3, [r7, #0]
    2506:	7b1b      	ldrb	r3, [r3, #12]
    2508:	2b00      	cmp	r3, #0
    250a:	d00d      	beq.n	2528 <log_init+0x68>
			if (backend->api->init != NULL) {
    250c:	683b      	ldr	r3, [r7, #0]
    250e:	681b      	ldr	r3, [r3, #0]
    2510:	695b      	ldr	r3, [r3, #20]
    2512:	2b00      	cmp	r3, #0
    2514:	d003      	beq.n	251e <log_init+0x5e>
				backend->api->init();
    2516:	683b      	ldr	r3, [r7, #0]
    2518:	681b      	ldr	r3, [r3, #0]
    251a:	695b      	ldr	r3, [r3, #20]
    251c:	4798      	blx	r3
			}

			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    251e:	2204      	movs	r2, #4
    2520:	2100      	movs	r1, #0
    2522:	6838      	ldr	r0, [r7, #0]
    2524:	f000 f934 	bl	2790 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    2528:	687b      	ldr	r3, [r7, #4]
    252a:	3301      	adds	r3, #1
    252c:	607b      	str	r3, [r7, #4]
    252e:	f7ff fdcf 	bl	20d0 <log_backend_count_get>
    2532:	4602      	mov	r2, r0
    2534:	687b      	ldr	r3, [r7, #4]
    2536:	4293      	cmp	r3, r2
    2538:	dbdf      	blt.n	24fa <log_init+0x3a>
    253a:	e000      	b.n	253e <log_init+0x7e>
		return;
    253c:	bf00      	nop
		}
	}
}
    253e:	3708      	adds	r7, #8
    2540:	46bd      	mov	sp, r7
    2542:	bd80      	pop	{r7, pc}
    2544:	00018e14 	.word	0x00018e14
    2548:	00018eb0 	.word	0x00018eb0
    254c:	00018dc0 	.word	0x00018dc0
    2550:	20000664 	.word	0x20000664

00002554 <thread_set>:

static void thread_set(k_tid_t process_tid)
{
    2554:	b580      	push	{r7, lr}
    2556:	b082      	sub	sp, #8
    2558:	af00      	add	r7, sp, #0
    255a:	6078      	str	r0, [r7, #4]
	proc_tid = process_tid;
    255c:	4a07      	ldr	r2, [pc, #28]	; (257c <thread_set+0x28>)
    255e:	687b      	ldr	r3, [r7, #4]
    2560:	6013      	str	r3, [r2, #0]

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		return;
	}

	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    2562:	687b      	ldr	r3, [r7, #4]
    2564:	2b00      	cmp	r3, #0
    2566:	d006      	beq.n	2576 <thread_set+0x22>
	    process_tid &&
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    2568:	4b05      	ldr	r3, [pc, #20]	; (2580 <thread_set+0x2c>)
    256a:	681b      	ldr	r3, [r3, #0]
	    process_tid &&
    256c:	2b09      	cmp	r3, #9
    256e:	dd02      	ble.n	2576 <thread_set+0x22>
		k_sem_give(&log_process_thread_sem);
    2570:	4804      	ldr	r0, [pc, #16]	; (2584 <thread_set+0x30>)
    2572:	f00f f824 	bl	115be <k_sem_give>
	}
}
    2576:	3708      	adds	r7, #8
    2578:	46bd      	mov	sp, r7
    257a:	bd80      	pop	{r7, pc}
    257c:	20000670 	.word	0x20000670
    2580:	20000668 	.word	0x20000668
    2584:	200002ac 	.word	0x200002ac

00002588 <z_impl_log_panic>:

	return 0;
}

void z_impl_log_panic(void)
{
    2588:	b580      	push	{r7, lr}
    258a:	b082      	sub	sp, #8
    258c:	af00      	add	r7, sp, #0
	struct log_backend const *backend;

	if (panic_mode) {
    258e:	4b17      	ldr	r3, [pc, #92]	; (25ec <z_impl_log_panic+0x64>)
    2590:	781b      	ldrb	r3, [r3, #0]
    2592:	2b00      	cmp	r3, #0
    2594:	d126      	bne.n	25e4 <z_impl_log_panic+0x5c>
	}

	/* If panic happened early logger might not be initialized.
	 * Forcing initialization of the logger and auto-starting backends.
	 */
	log_init();
    2596:	f7ff ff93 	bl	24c0 <log_init>

	for (int i = 0; i < log_backend_count_get(); i++) {
    259a:	2300      	movs	r3, #0
    259c:	607b      	str	r3, [r7, #4]
    259e:	e010      	b.n	25c2 <z_impl_log_panic+0x3a>
		backend = log_backend_get(i);
    25a0:	687b      	ldr	r3, [r7, #4]
    25a2:	4618      	mov	r0, r3
    25a4:	f7ff fd84 	bl	20b0 <log_backend_get>
    25a8:	6038      	str	r0, [r7, #0]

		if (log_backend_is_active(backend)) {
    25aa:	6838      	ldr	r0, [r7, #0]
    25ac:	f7ff fdc2 	bl	2134 <log_backend_is_active>
    25b0:	4603      	mov	r3, r0
    25b2:	2b00      	cmp	r3, #0
    25b4:	d002      	beq.n	25bc <z_impl_log_panic+0x34>
			log_backend_panic(backend);
    25b6:	6838      	ldr	r0, [r7, #0]
    25b8:	f7ff fd38 	bl	202c <log_backend_panic>
	for (int i = 0; i < log_backend_count_get(); i++) {
    25bc:	687b      	ldr	r3, [r7, #4]
    25be:	3301      	adds	r3, #1
    25c0:	607b      	str	r3, [r7, #4]
    25c2:	f7ff fd85 	bl	20d0 <log_backend_count_get>
    25c6:	4602      	mov	r2, r0
    25c8:	687b      	ldr	r3, [r7, #4]
    25ca:	4293      	cmp	r3, r2
    25cc:	dbe8      	blt.n	25a0 <z_impl_log_panic+0x18>
		}
	}

	if (!IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		/* Flush */
		while (log_process(false) == true) {
    25ce:	bf00      	nop
    25d0:	2000      	movs	r0, #0
    25d2:	f00e ffff 	bl	115d4 <log_process>
    25d6:	4603      	mov	r3, r0
    25d8:	2b00      	cmp	r3, #0
    25da:	d1f9      	bne.n	25d0 <z_impl_log_panic+0x48>
		}
	}

	panic_mode = true;
    25dc:	4b03      	ldr	r3, [pc, #12]	; (25ec <z_impl_log_panic+0x64>)
    25de:	2201      	movs	r2, #1
    25e0:	701a      	strb	r2, [r3, #0]
    25e2:	e000      	b.n	25e6 <z_impl_log_panic+0x5e>
		return;
    25e4:	bf00      	nop
}
    25e6:	3708      	adds	r7, #8
    25e8:	46bd      	mov	sp, r7
    25ea:	bd80      	pop	{r7, pc}
    25ec:	20000d40 	.word	0x20000d40

000025f0 <msg_process>:
		return true;
	}
}

static void msg_process(struct log_msg *msg, bool bypass)
{
    25f0:	b580      	push	{r7, lr}
    25f2:	b084      	sub	sp, #16
    25f4:	af00      	add	r7, sp, #0
    25f6:	6078      	str	r0, [r7, #4]
    25f8:	460b      	mov	r3, r1
    25fa:	70fb      	strb	r3, [r7, #3]
	struct log_backend const *backend;

	if (!bypass) {
    25fc:	78fb      	ldrb	r3, [r7, #3]
    25fe:	f083 0301 	eor.w	r3, r3, #1
    2602:	b2db      	uxtb	r3, r3
    2604:	2b00      	cmp	r3, #0
    2606:	d02b      	beq.n	2660 <msg_process+0x70>
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
		    !panic_mode) {
    2608:	4b19      	ldr	r3, [pc, #100]	; (2670 <msg_process+0x80>)
    260a:	781b      	ldrb	r3, [r3, #0]
    260c:	f083 0301 	eor.w	r3, r3, #1
    2610:	b2db      	uxtb	r3, r3
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
    2612:	2b00      	cmp	r3, #0
    2614:	d002      	beq.n	261c <msg_process+0x2c>
			detect_missed_strdup(msg);
    2616:	6878      	ldr	r0, [r7, #4]
    2618:	f7ff fe24 	bl	2264 <detect_missed_strdup>
		}

		for (int i = 0; i < log_backend_count_get(); i++) {
    261c:	2300      	movs	r3, #0
    261e:	60fb      	str	r3, [r7, #12]
    2620:	e018      	b.n	2654 <msg_process+0x64>
			backend = log_backend_get(i);
    2622:	68fb      	ldr	r3, [r7, #12]
    2624:	4618      	mov	r0, r3
    2626:	f7ff fd43 	bl	20b0 <log_backend_get>
    262a:	60b8      	str	r0, [r7, #8]

			if (log_backend_is_active(backend) &&
    262c:	68b8      	ldr	r0, [r7, #8]
    262e:	f7ff fd81 	bl	2134 <log_backend_is_active>
    2632:	4603      	mov	r3, r0
    2634:	2b00      	cmp	r3, #0
    2636:	d00a      	beq.n	264e <msg_process+0x5e>
			    msg_filter_check(backend, msg)) {
    2638:	6879      	ldr	r1, [r7, #4]
    263a:	68b8      	ldr	r0, [r7, #8]
    263c:	f00f f870 	bl	11720 <msg_filter_check>
    2640:	4603      	mov	r3, r0
			if (log_backend_is_active(backend) &&
    2642:	2b00      	cmp	r3, #0
    2644:	d003      	beq.n	264e <msg_process+0x5e>
				log_backend_put(backend, msg);
    2646:	6879      	ldr	r1, [r7, #4]
    2648:	68b8      	ldr	r0, [r7, #8]
    264a:	f7ff fc95 	bl	1f78 <log_backend_put>
		for (int i = 0; i < log_backend_count_get(); i++) {
    264e:	68fb      	ldr	r3, [r7, #12]
    2650:	3301      	adds	r3, #1
    2652:	60fb      	str	r3, [r7, #12]
    2654:	f7ff fd3c 	bl	20d0 <log_backend_count_get>
    2658:	4602      	mov	r2, r0
    265a:	68fb      	ldr	r3, [r7, #12]
    265c:	4293      	cmp	r3, r2
    265e:	dbe0      	blt.n	2622 <msg_process+0x32>
			}
		}
	}

	log_msg_put(msg);
    2660:	6878      	ldr	r0, [r7, #4]
    2662:	f00f fa40 	bl	11ae6 <log_msg_put>
}
    2666:	bf00      	nop
    2668:	3710      	adds	r7, #16
    266a:	46bd      	mov	sp, r7
    266c:	bd80      	pop	{r7, pc}
    266e:	bf00      	nop
    2670:	20000d40 	.word	0x20000d40

00002674 <dropped_notify>:

void dropped_notify(void)
{
    2674:	b580      	push	{r7, lr}
    2676:	b084      	sub	sp, #16
    2678:	af00      	add	r7, sp, #0
	uint32_t dropped = atomic_set(&dropped_cnt, 0);
    267a:	2100      	movs	r1, #0
    267c:	4812      	ldr	r0, [pc, #72]	; (26c8 <dropped_notify+0x54>)
    267e:	f00e fbf4 	bl	10e6a <atomic_set>
    2682:	4603      	mov	r3, r0
    2684:	60bb      	str	r3, [r7, #8]

	for (int i = 0; i < log_backend_count_get(); i++) {
    2686:	2300      	movs	r3, #0
    2688:	60fb      	str	r3, [r7, #12]
    268a:	e011      	b.n	26b0 <dropped_notify+0x3c>
		struct log_backend const *backend = log_backend_get(i);
    268c:	68fb      	ldr	r3, [r7, #12]
    268e:	4618      	mov	r0, r3
    2690:	f7ff fd0e 	bl	20b0 <log_backend_get>
    2694:	6078      	str	r0, [r7, #4]

		if (log_backend_is_active(backend)) {
    2696:	6878      	ldr	r0, [r7, #4]
    2698:	f7ff fd4c 	bl	2134 <log_backend_is_active>
    269c:	4603      	mov	r3, r0
    269e:	2b00      	cmp	r3, #0
    26a0:	d003      	beq.n	26aa <dropped_notify+0x36>
			log_backend_dropped(backend, dropped);
    26a2:	68b9      	ldr	r1, [r7, #8]
    26a4:	6878      	ldr	r0, [r7, #4]
    26a6:	f7ff fc99 	bl	1fdc <log_backend_dropped>
	for (int i = 0; i < log_backend_count_get(); i++) {
    26aa:	68fb      	ldr	r3, [r7, #12]
    26ac:	3301      	adds	r3, #1
    26ae:	60fb      	str	r3, [r7, #12]
    26b0:	f7ff fd0e 	bl	20d0 <log_backend_count_get>
    26b4:	4602      	mov	r2, r0
    26b6:	68fb      	ldr	r3, [r7, #12]
    26b8:	4293      	cmp	r3, r2
    26ba:	dbe7      	blt.n	268c <dropped_notify+0x18>
		}
	}
}
    26bc:	bf00      	nop
    26be:	bf00      	nop
    26c0:	3710      	adds	r7, #16
    26c2:	46bd      	mov	sp, r7
    26c4:	bd80      	pop	{r7, pc}
    26c6:	bf00      	nop
    26c8:	2000066c 	.word	0x2000066c

000026cc <z_impl_log_process>:

bool z_impl_log_process(bool bypass)
{
    26cc:	b580      	push	{r7, lr}
    26ce:	b088      	sub	sp, #32
    26d0:	af00      	add	r7, sp, #0
    26d2:	4603      	mov	r3, r0
    26d4:	71fb      	strb	r3, [r7, #7]
	struct log_msg *msg;

	if (!backend_attached && !bypass) {
    26d6:	4b25      	ldr	r3, [pc, #148]	; (276c <z_impl_log_process+0xa0>)
    26d8:	781b      	ldrb	r3, [r3, #0]
    26da:	f083 0301 	eor.w	r3, r3, #1
    26de:	b2db      	uxtb	r3, r3
    26e0:	2b00      	cmp	r3, #0
    26e2:	d007      	beq.n	26f4 <z_impl_log_process+0x28>
    26e4:	79fb      	ldrb	r3, [r7, #7]
    26e6:	f083 0301 	eor.w	r3, r3, #1
    26ea:	b2db      	uxtb	r3, r3
    26ec:	2b00      	cmp	r3, #0
    26ee:	d001      	beq.n	26f4 <z_impl_log_process+0x28>
		return false;
    26f0:	2300      	movs	r3, #0
    26f2:	e037      	b.n	2764 <z_impl_log_process+0x98>
	__asm__ volatile(
    26f4:	f04f 0320 	mov.w	r3, #32
    26f8:	f3ef 8211 	mrs	r2, BASEPRI
    26fc:	f383 8811 	msr	BASEPRI, r3
    2700:	f3bf 8f6f 	isb	sy
    2704:	613a      	str	r2, [r7, #16]
    2706:	60fb      	str	r3, [r7, #12]
	return key;
    2708:	693b      	ldr	r3, [r7, #16]
	}
	unsigned int key = irq_lock();
    270a:	61fb      	str	r3, [r7, #28]

	msg = log_list_head_get(&list);
    270c:	4818      	ldr	r0, [pc, #96]	; (2770 <z_impl_log_process+0xa4>)
    270e:	f00e fb50 	bl	10db2 <log_list_head_get>
    2712:	61b8      	str	r0, [r7, #24]
    2714:	69fb      	ldr	r3, [r7, #28]
    2716:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    2718:	697b      	ldr	r3, [r7, #20]
    271a:	f383 8811 	msr	BASEPRI, r3
    271e:	f3bf 8f6f 	isb	sy
}
    2722:	bf00      	nop
	irq_unlock(key);

	if (msg != NULL) {
    2724:	69bb      	ldr	r3, [r7, #24]
    2726:	2b00      	cmp	r3, #0
    2728:	d007      	beq.n	273a <z_impl_log_process+0x6e>
		atomic_dec(&buffered_cnt);
    272a:	4812      	ldr	r0, [pc, #72]	; (2774 <z_impl_log_process+0xa8>)
    272c:	f00e fb90 	bl	10e50 <atomic_dec>
		msg_process(msg, bypass);
    2730:	79fb      	ldrb	r3, [r7, #7]
    2732:	4619      	mov	r1, r3
    2734:	69b8      	ldr	r0, [r7, #24]
    2736:	f7ff ff5b 	bl	25f0 <msg_process>
	}

	if (!bypass && dropped_cnt) {
    273a:	79fb      	ldrb	r3, [r7, #7]
    273c:	f083 0301 	eor.w	r3, r3, #1
    2740:	b2db      	uxtb	r3, r3
    2742:	2b00      	cmp	r3, #0
    2744:	d005      	beq.n	2752 <z_impl_log_process+0x86>
    2746:	4b0c      	ldr	r3, [pc, #48]	; (2778 <z_impl_log_process+0xac>)
    2748:	681b      	ldr	r3, [r3, #0]
    274a:	2b00      	cmp	r3, #0
    274c:	d001      	beq.n	2752 <z_impl_log_process+0x86>
		dropped_notify();
    274e:	f7ff ff91 	bl	2674 <dropped_notify>
	}

	return (log_list_head_peek(&list) != NULL);
    2752:	4807      	ldr	r0, [pc, #28]	; (2770 <z_impl_log_process+0xa4>)
    2754:	f00e fb22 	bl	10d9c <log_list_head_peek>
    2758:	4603      	mov	r3, r0
    275a:	2b00      	cmp	r3, #0
    275c:	bf14      	ite	ne
    275e:	2301      	movne	r3, #1
    2760:	2300      	moveq	r3, #0
    2762:	b2db      	uxtb	r3, r3
}
    2764:	4618      	mov	r0, r3
    2766:	3720      	adds	r7, #32
    2768:	46bd      	mov	sp, r7
    276a:	bd80      	pop	{r7, pc}
    276c:	20000d41 	.word	0x20000d41
    2770:	2000065c 	.word	0x2000065c
    2774:	20000668 	.word	0x20000668
    2778:	2000066c 	.word	0x2000066c

0000277c <log_dropped>:
}
#include <syscalls/log_buffered_cnt_mrsh.c>
#endif

void log_dropped(void)
{
    277c:	b580      	push	{r7, lr}
    277e:	af00      	add	r7, sp, #0
	atomic_inc(&dropped_cnt);
    2780:	4802      	ldr	r0, [pc, #8]	; (278c <log_dropped+0x10>)
    2782:	f00e fb58 	bl	10e36 <atomic_inc>
}
    2786:	bf00      	nop
    2788:	bd80      	pop	{r7, pc}
    278a:	bf00      	nop
    278c:	2000066c 	.word	0x2000066c

00002790 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			uint32_t level)
{
    2790:	b580      	push	{r7, lr}
    2792:	b086      	sub	sp, #24
    2794:	af00      	add	r7, sp, #0
    2796:	60f8      	str	r0, [r7, #12]
    2798:	60b9      	str	r1, [r7, #8]
    279a:	607a      	str	r2, [r7, #4]
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
    279c:	2301      	movs	r3, #1
    279e:	617b      	str	r3, [r7, #20]

	id += backend - log_backend_get(0);
    27a0:	2000      	movs	r0, #0
    27a2:	f7ff fc85 	bl	20b0 <log_backend_get>
    27a6:	4602      	mov	r2, r0
    27a8:	68fb      	ldr	r3, [r7, #12]
    27aa:	1a9b      	subs	r3, r3, r2
    27ac:	111b      	asrs	r3, r3, #4
    27ae:	461a      	mov	r2, r3
    27b0:	697b      	ldr	r3, [r7, #20]
    27b2:	4413      	add	r3, r2
    27b4:	617b      	str	r3, [r7, #20]

	log_backend_id_set(backend, id);
    27b6:	697b      	ldr	r3, [r7, #20]
    27b8:	b2db      	uxtb	r3, r3
    27ba:	4619      	mov	r1, r3
    27bc:	68f8      	ldr	r0, [r7, #12]
    27be:	f7ff fc55 	bl	206c <log_backend_id_set>
	backend_filter_set(backend, level);
    27c2:	6879      	ldr	r1, [r7, #4]
    27c4:	68f8      	ldr	r0, [r7, #12]
    27c6:	f00e ffcb 	bl	11760 <backend_filter_set>
	log_backend_activate(backend, ctx);
    27ca:	68b9      	ldr	r1, [r7, #8]
    27cc:	68f8      	ldr	r0, [r7, #12]
    27ce:	f7ff fc8d 	bl	20ec <log_backend_activate>

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
    27d2:	4b08      	ldr	r3, [pc, #32]	; (27f4 <log_backend_enable+0x64>)
    27d4:	781b      	ldrb	r3, [r3, #0]
    27d6:	f083 0301 	eor.w	r3, r3, #1
    27da:	b2db      	uxtb	r3, r3
    27dc:	2b00      	cmp	r3, #0
    27de:	d002      	beq.n	27e6 <log_backend_enable+0x56>
		k_sem_give(&log_process_thread_sem);
    27e0:	4805      	ldr	r0, [pc, #20]	; (27f8 <log_backend_enable+0x68>)
    27e2:	f00e feec 	bl	115be <k_sem_give>
	}

	backend_attached = true;
    27e6:	4b03      	ldr	r3, [pc, #12]	; (27f4 <log_backend_enable+0x64>)
    27e8:	2201      	movs	r2, #1
    27ea:	701a      	strb	r2, [r3, #0]
}
    27ec:	bf00      	nop
    27ee:	3718      	adds	r7, #24
    27f0:	46bd      	mov	sp, r7
    27f2:	bd80      	pop	{r7, pc}
    27f4:	20000d41 	.word	0x20000d41
    27f8:	200002ac 	.word	0x200002ac

000027fc <log_strdup>:
		return log_compiled_level_get(src_id);
	}
}

char *log_strdup(const char *str)
{
    27fc:	b590      	push	{r4, r7, lr}
    27fe:	b087      	sub	sp, #28
    2800:	af00      	add	r7, sp, #0
    2802:	6078      	str	r0, [r7, #4]
	struct log_strdup_buf *dup;
	int err;

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
	    is_rodata(str) || _is_user_context()) {
    2804:	6878      	ldr	r0, [r7, #4]
    2806:	f7ff fd11 	bl	222c <is_rodata>
    280a:	4603      	mov	r3, r0
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    280c:	2b00      	cmp	r3, #0
    280e:	d104      	bne.n	281a <log_strdup+0x1e>
	    is_rodata(str) || _is_user_context()) {
    2810:	f00e fbea 	bl	10fe8 <_is_user_context>
    2814:	4603      	mov	r3, r0
    2816:	2b00      	cmp	r3, #0
    2818:	d001      	beq.n	281e <log_strdup+0x22>
		return (char *)str;
    281a:	687b      	ldr	r3, [r7, #4]
    281c:	e028      	b.n	2870 <log_strdup+0x74>
	}

	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    281e:	f04f 0000 	mov.w	r0, #0
    2822:	f04f 0100 	mov.w	r1, #0
    2826:	f107 0410 	add.w	r4, r7, #16
    282a:	4602      	mov	r2, r0
    282c:	460b      	mov	r3, r1
    282e:	4621      	mov	r1, r4
    2830:	4811      	ldr	r0, [pc, #68]	; (2878 <log_strdup+0x7c>)
    2832:	f008 fe0d 	bl	b450 <k_mem_slab_alloc>
    2836:	6178      	str	r0, [r7, #20]
	if (err != 0) {
    2838:	697b      	ldr	r3, [r7, #20]
    283a:	2b00      	cmp	r3, #0
    283c:	d002      	beq.n	2844 <log_strdup+0x48>
		/* failed to allocate */
		return (char *)log_strdup_fail_msg;
    283e:	4b0f      	ldr	r3, [pc, #60]	; (287c <log_strdup+0x80>)
    2840:	681b      	ldr	r3, [r3, #0]
    2842:	e015      	b.n	2870 <log_strdup+0x74>
		log_strdup_longest = MAX(slen, log_strdup_longest);
		k_spin_unlock(&lock, key);
	}

	/* Set 'allocated' flag. */
	(void)atomic_set(&dup->refcount, 1);
    2844:	693b      	ldr	r3, [r7, #16]
    2846:	2101      	movs	r1, #1
    2848:	4618      	mov	r0, r3
    284a:	f00e fb0e 	bl	10e6a <atomic_set>

	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    284e:	693b      	ldr	r3, [r7, #16]
    2850:	3304      	adds	r3, #4
    2852:	221f      	movs	r2, #31
    2854:	6879      	ldr	r1, [r7, #4]
    2856:	4618      	mov	r0, r3
    2858:	f010 fc02 	bl	13060 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    285c:	693b      	ldr	r3, [r7, #16]
    285e:	227e      	movs	r2, #126	; 0x7e
    2860:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    2864:	693b      	ldr	r3, [r7, #16]
    2866:	2200      	movs	r2, #0
    2868:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

	return dup->buf;
    286c:	693b      	ldr	r3, [r7, #16]
    286e:	3304      	adds	r3, #4
}
    2870:	4618      	mov	r0, r3
    2872:	371c      	adds	r7, #28
    2874:	46bd      	mov	sp, r7
    2876:	bd90      	pop	{r4, r7, pc}
    2878:	20000640 	.word	0x20000640
    287c:	200000c4 	.word	0x200000c4

00002880 <log_is_strdup>:
	return IS_ENABLED(CONFIG_LOG_STRDUP_POOL_PROFILING) ?
			log_strdup_longest : 0;
}

bool log_is_strdup(const void *buf)
{
    2880:	b480      	push	{r7}
    2882:	b083      	sub	sp, #12
    2884:	af00      	add	r7, sp, #0
    2886:	6078      	str	r0, [r7, #4]
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    2888:	687b      	ldr	r3, [r7, #4]
    288a:	2b00      	cmp	r3, #0
    288c:	d009      	beq.n	28a2 <log_is_strdup+0x22>
    288e:	687b      	ldr	r3, [r7, #4]
    2890:	4a08      	ldr	r2, [pc, #32]	; (28b4 <log_is_strdup+0x34>)
    2892:	4293      	cmp	r3, r2
    2894:	d305      	bcc.n	28a2 <log_is_strdup+0x22>
    2896:	687b      	ldr	r3, [r7, #4]
    2898:	4a07      	ldr	r2, [pc, #28]	; (28b8 <log_is_strdup+0x38>)
    289a:	4293      	cmp	r3, r2
    289c:	d201      	bcs.n	28a2 <log_is_strdup+0x22>
    289e:	2301      	movs	r3, #1
    28a0:	e000      	b.n	28a4 <log_is_strdup+0x24>
    28a2:	2300      	movs	r3, #0
    28a4:	f003 0301 	and.w	r3, r3, #1
    28a8:	b2db      	uxtb	r3, r3

}
    28aa:	4618      	mov	r0, r3
    28ac:	370c      	adds	r7, #12
    28ae:	46bd      	mov	sp, r7
    28b0:	bc80      	pop	{r7}
    28b2:	4770      	bx	lr
    28b4:	20001e88 	.word	0x20001e88
    28b8:	20001f28 	.word	0x20001f28

000028bc <log_free>:

void log_free(void *str)
{
    28bc:	b580      	push	{r7, lr}
    28be:	b084      	sub	sp, #16
    28c0:	af00      	add	r7, sp, #0
    28c2:	6078      	str	r0, [r7, #4]
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    28c4:	687b      	ldr	r3, [r7, #4]
    28c6:	3b04      	subs	r3, #4
    28c8:	60fb      	str	r3, [r7, #12]
						  buf);

	if (atomic_dec(&dup->refcount) == 1) {
    28ca:	68fb      	ldr	r3, [r7, #12]
    28cc:	4618      	mov	r0, r3
    28ce:	f00e fabf 	bl	10e50 <atomic_dec>
    28d2:	4603      	mov	r3, r0
    28d4:	2b01      	cmp	r3, #1
    28d6:	d105      	bne.n	28e4 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    28d8:	f107 030c 	add.w	r3, r7, #12
    28dc:	4619      	mov	r1, r3
    28de:	4803      	ldr	r0, [pc, #12]	; (28ec <log_free+0x30>)
    28e0:	f008 fe5c 	bl	b59c <k_mem_slab_free>
		if (IS_ENABLED(CONFIG_LOG_STRDUP_POOL_PROFILING)) {
			atomic_dec((atomic_t *)&log_strdup_in_use);
		}
	}
}
    28e4:	bf00      	nop
    28e6:	3710      	adds	r7, #16
    28e8:	46bd      	mov	sp, r7
    28ea:	bd80      	pop	{r7, pc}
    28ec:	20000640 	.word	0x20000640

000028f0 <log_from_user>:

	__ASSERT_NO_MSG(false);
}

void log_from_user(struct log_msg_ids src_level, const char *fmt, ...)
{
    28f0:	b40e      	push	{r1, r2, r3}
    28f2:	b580      	push	{r7, lr}
    28f4:	b083      	sub	sp, #12
    28f6:	af00      	add	r7, sp, #0
    28f8:	80b8      	strh	r0, [r7, #4]
	ARG_UNUSED(src_level);
	ARG_UNUSED(fmt);

	__ASSERT_NO_MSG(false);
    28fa:	f240 437c 	movw	r3, #1148	; 0x47c
    28fe:	4a08      	ldr	r2, [pc, #32]	; (2920 <log_from_user+0x30>)
    2900:	4908      	ldr	r1, [pc, #32]	; (2924 <log_from_user+0x34>)
    2902:	4809      	ldr	r0, [pc, #36]	; (2928 <log_from_user+0x38>)
    2904:	f00d fbb0 	bl	10068 <printk>
    2908:	f240 417c 	movw	r1, #1148	; 0x47c
    290c:	4804      	ldr	r0, [pc, #16]	; (2920 <log_from_user+0x30>)
    290e:	f00e f9f3 	bl	10cf8 <assert_post_action>
}
    2912:	bf00      	nop
    2914:	370c      	adds	r7, #12
    2916:	46bd      	mov	sp, r7
    2918:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    291c:	b003      	add	sp, #12
    291e:	4770      	bx	lr
    2920:	00018e14 	.word	0x00018e14
    2924:	00018e5c 	.word	0x00018e5c
    2928:	00018dc0 	.word	0x00018dc0

0000292c <log_process_thread_timer_expiry_fn>:
	__ASSERT_NO_MSG(false);
}
#endif /* !defined(CONFIG_USERSPACE) */

static void log_process_thread_timer_expiry_fn(struct k_timer *timer)
{
    292c:	b580      	push	{r7, lr}
    292e:	b082      	sub	sp, #8
    2930:	af00      	add	r7, sp, #0
    2932:	6078      	str	r0, [r7, #4]
	k_sem_give(&log_process_thread_sem);
    2934:	4803      	ldr	r0, [pc, #12]	; (2944 <log_process_thread_timer_expiry_fn+0x18>)
    2936:	f00e fe42 	bl	115be <k_sem_give>
}
    293a:	bf00      	nop
    293c:	3708      	adds	r7, #8
    293e:	46bd      	mov	sp, r7
    2940:	bd80      	pop	{r7, pc}
    2942:	bf00      	nop
    2944:	200002ac 	.word	0x200002ac

00002948 <log_process_thread_func>:

static void log_process_thread_func(void *dummy1, void *dummy2, void *dummy3)
{
    2948:	b580      	push	{r7, lr}
    294a:	b084      	sub	sp, #16
    294c:	af00      	add	r7, sp, #0
    294e:	60f8      	str	r0, [r7, #12]
    2950:	60b9      	str	r1, [r7, #8]
    2952:	607a      	str	r2, [r7, #4]
	__ASSERT_NO_MSG(log_backend_count_get() > 0);
    2954:	f7ff fbbc 	bl	20d0 <log_backend_count_get>
    2958:	4603      	mov	r3, r0
    295a:	2b00      	cmp	r3, #0
    295c:	dc0b      	bgt.n	2976 <log_process_thread_func+0x2e>
    295e:	f240 439c 	movw	r3, #1180	; 0x49c
    2962:	4a11      	ldr	r2, [pc, #68]	; (29a8 <log_process_thread_func+0x60>)
    2964:	4911      	ldr	r1, [pc, #68]	; (29ac <log_process_thread_func+0x64>)
    2966:	4812      	ldr	r0, [pc, #72]	; (29b0 <log_process_thread_func+0x68>)
    2968:	f00d fb7e 	bl	10068 <printk>
    296c:	f240 419c 	movw	r1, #1180	; 0x49c
    2970:	480d      	ldr	r0, [pc, #52]	; (29a8 <log_process_thread_func+0x60>)
    2972:	f00e f9c1 	bl	10cf8 <assert_post_action>

	log_init();
    2976:	f7ff fda3 	bl	24c0 <log_init>
	thread_set(k_current_get());
    297a:	f00e fdd4 	bl	11526 <k_current_get>
    297e:	4603      	mov	r3, r0
    2980:	4618      	mov	r0, r3
    2982:	f7ff fde7 	bl	2554 <thread_set>

	while (true) {
		if (log_process(false) == false) {
    2986:	2000      	movs	r0, #0
    2988:	f00e fe24 	bl	115d4 <log_process>
    298c:	4603      	mov	r3, r0
    298e:	f083 0301 	eor.w	r3, r3, #1
    2992:	b2db      	uxtb	r3, r3
    2994:	2b00      	cmp	r3, #0
    2996:	d0f6      	beq.n	2986 <log_process_thread_func+0x3e>
			k_sem_take(&log_process_thread_sem, K_FOREVER);
    2998:	f04f 32ff 	mov.w	r2, #4294967295
    299c:	f04f 33ff 	mov.w	r3, #4294967295
    29a0:	4804      	ldr	r0, [pc, #16]	; (29b4 <log_process_thread_func+0x6c>)
    29a2:	f00e fdfc 	bl	1159e <k_sem_take>
		if (log_process(false) == false) {
    29a6:	e7ee      	b.n	2986 <log_process_thread_func+0x3e>
    29a8:	00018e14 	.word	0x00018e14
    29ac:	00018ef4 	.word	0x00018ef4
    29b0:	00018dc0 	.word	0x00018dc0
    29b4:	200002ac 	.word	0x200002ac

000029b8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    29b8:	b580      	push	{r7, lr}
    29ba:	b08a      	sub	sp, #40	; 0x28
    29bc:	af08      	add	r7, sp, #32
    29be:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    29c0:	2200      	movs	r2, #0
    29c2:	4912      	ldr	r1, [pc, #72]	; (2a0c <enable_logger+0x54>)
    29c4:	4812      	ldr	r0, [pc, #72]	; (2a10 <enable_logger+0x58>)
    29c6:	f015 fd1e 	bl	18406 <k_timer_init>
				log_process_thread_timer_expiry_fn, NULL);
		/* start logging thread */
		k_thread_create(&logging_thread, logging_stack,
				K_KERNEL_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
    29ca:	f04f 0200 	mov.w	r2, #0
    29ce:	f04f 0300 	mov.w	r3, #0
		k_thread_create(&logging_thread, logging_stack,
    29d2:	e9cd 2306 	strd	r2, r3, [sp, #24]
    29d6:	2300      	movs	r3, #0
    29d8:	9304      	str	r3, [sp, #16]
    29da:	230e      	movs	r3, #14
    29dc:	9303      	str	r3, [sp, #12]
    29de:	2300      	movs	r3, #0
    29e0:	9302      	str	r3, [sp, #8]
    29e2:	2300      	movs	r3, #0
    29e4:	9301      	str	r3, [sp, #4]
    29e6:	2300      	movs	r3, #0
    29e8:	9300      	str	r3, [sp, #0]
    29ea:	4b0a      	ldr	r3, [pc, #40]	; (2a14 <enable_logger+0x5c>)
    29ec:	f44f 6280 	mov.w	r2, #1024	; 0x400
    29f0:	4909      	ldr	r1, [pc, #36]	; (2a18 <enable_logger+0x60>)
    29f2:	480a      	ldr	r0, [pc, #40]	; (2a1c <enable_logger+0x64>)
    29f4:	f00e fd77 	bl	114e6 <k_thread_create>
		k_thread_name_set(&logging_thread, "logging");
    29f8:	4909      	ldr	r1, [pc, #36]	; (2a20 <enable_logger+0x68>)
    29fa:	4808      	ldr	r0, [pc, #32]	; (2a1c <enable_logger+0x64>)
    29fc:	f00e fd9a 	bl	11534 <k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
    2a00:	2300      	movs	r3, #0
}
    2a02:	4618      	mov	r0, r3
    2a04:	3708      	adds	r7, #8
    2a06:	46bd      	mov	sp, r7
    2a08:	bd80      	pop	{r7, pc}
    2a0a:	bf00      	nop
    2a0c:	0000292d 	.word	0x0000292d
    2a10:	200002c0 	.word	0x200002c0
    2a14:	00002949 	.word	0x00002949
    2a18:	20000d48 	.word	0x20000d48
    2a1c:	200002f8 	.word	0x200002f8
    2a20:	00018f10 	.word	0x00018f10

00002a24 <log_msg_pool_init>:
struct k_mem_slab log_msg_pool;
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
    2a24:	b580      	push	{r7, lr}
    2a26:	af00      	add	r7, sp, #0
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    2a28:	2320      	movs	r3, #32
    2a2a:	2220      	movs	r2, #32
    2a2c:	4902      	ldr	r1, [pc, #8]	; (2a38 <log_msg_pool_init+0x14>)
    2a2e:	4803      	ldr	r0, [pc, #12]	; (2a3c <log_msg_pool_init+0x18>)
    2a30:	f014 fa1e 	bl	16e70 <k_mem_slab_init>
}
    2a34:	bf00      	nop
    2a36:	bd80      	pop	{r7, pc}
    2a38:	20001f28 	.word	0x20001f28
    2a3c:	20000674 	.word	0x20000674

00002a40 <log_msg_chunk_alloc>:

	return (!k_is_in_isr() && is_irq_unlocked());
}

union log_msg_chunk *log_msg_chunk_alloc(void)
{
    2a40:	b580      	push	{r7, lr}
    2a42:	b082      	sub	sp, #8
    2a44:	af00      	add	r7, sp, #0
	union log_msg_chunk *msg = NULL;
    2a46:	2300      	movs	r3, #0
    2a48:	603b      	str	r3, [r7, #0]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
		   block_on_alloc()
    2a4a:	f00f f838 	bl	11abe <block_on_alloc>
    2a4e:	4603      	mov	r3, r0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    2a50:	2b00      	cmp	r3, #0
    2a52:	d008      	beq.n	2a66 <log_msg_chunk_alloc+0x26>
		   ? K_MSEC(CONFIG_LOG_BLOCK_IN_THREAD_TIMEOUT_MS)
    2a54:	f04f 0000 	mov.w	r0, #0
    2a58:	f04f 0100 	mov.w	r1, #0
    2a5c:	f00e fed0 	bl	11800 <k_ms_to_ticks_ceil64>
    2a60:	4602      	mov	r2, r0
    2a62:	460b      	mov	r3, r1
    2a64:	e003      	b.n	2a6e <log_msg_chunk_alloc+0x2e>
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    2a66:	f04f 0200 	mov.w	r2, #0
    2a6a:	f04f 0300 	mov.w	r3, #0
    2a6e:	4639      	mov	r1, r7
    2a70:	4807      	ldr	r0, [pc, #28]	; (2a90 <log_msg_chunk_alloc+0x50>)
    2a72:	f008 fced 	bl	b450 <k_mem_slab_alloc>
    2a76:	6078      	str	r0, [r7, #4]
		   : K_NO_WAIT);

	if (err != 0) {
    2a78:	687b      	ldr	r3, [r7, #4]
    2a7a:	2b00      	cmp	r3, #0
    2a7c:	d003      	beq.n	2a86 <log_msg_chunk_alloc+0x46>
		msg = log_msg_no_space_handle();
    2a7e:	f000 f885 	bl	2b8c <log_msg_no_space_handle>
    2a82:	4603      	mov	r3, r0
    2a84:	603b      	str	r3, [r7, #0]
	}

	return msg;
    2a86:	683b      	ldr	r3, [r7, #0]
}
    2a88:	4618      	mov	r0, r3
    2a8a:	3708      	adds	r7, #8
    2a8c:	46bd      	mov	sp, r7
    2a8e:	bd80      	pop	{r7, pc}
    2a90:	20000674 	.word	0x20000674

00002a94 <cont_free>:
{
	atomic_inc(&msg->hdr.ref_cnt);
}

static void cont_free(struct log_msg_cont *cont)
{
    2a94:	b580      	push	{r7, lr}
    2a96:	b084      	sub	sp, #16
    2a98:	af00      	add	r7, sp, #0
    2a9a:	6078      	str	r0, [r7, #4]
	struct log_msg_cont *next;

	while (cont != NULL) {
    2a9c:	e009      	b.n	2ab2 <cont_free+0x1e>
		next = cont->next;
    2a9e:	687b      	ldr	r3, [r7, #4]
    2aa0:	681b      	ldr	r3, [r3, #0]
    2aa2:	60fb      	str	r3, [r7, #12]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    2aa4:	1d3b      	adds	r3, r7, #4
    2aa6:	4619      	mov	r1, r3
    2aa8:	4806      	ldr	r0, [pc, #24]	; (2ac4 <cont_free+0x30>)
    2aaa:	f008 fd77 	bl	b59c <k_mem_slab_free>
		cont = next;
    2aae:	68fb      	ldr	r3, [r7, #12]
    2ab0:	607b      	str	r3, [r7, #4]
	while (cont != NULL) {
    2ab2:	687b      	ldr	r3, [r7, #4]
    2ab4:	2b00      	cmp	r3, #0
    2ab6:	d1f2      	bne.n	2a9e <cont_free+0xa>
	}
}
    2ab8:	bf00      	nop
    2aba:	bf00      	nop
    2abc:	3710      	adds	r7, #16
    2abe:	46bd      	mov	sp, r7
    2ac0:	bd80      	pop	{r7, pc}
    2ac2:	bf00      	nop
    2ac4:	20000674 	.word	0x20000674

00002ac8 <msg_free>:

static void msg_free(struct log_msg *msg)
{
    2ac8:	b580      	push	{r7, lr}
    2aca:	b086      	sub	sp, #24
    2acc:	af00      	add	r7, sp, #0
    2ace:	6078      	str	r0, [r7, #4]
	uint32_t nargs = log_msg_nargs_get(msg);
    2ad0:	687b      	ldr	r3, [r7, #4]
    2ad2:	4618      	mov	r0, r3
    2ad4:	f00f f81b 	bl	11b0e <log_msg_nargs_get>
    2ad8:	60f8      	str	r0, [r7, #12]

	/* Free any transient string found in arguments. */
	if (log_msg_is_std(msg) && nargs) {
    2ada:	687b      	ldr	r3, [r7, #4]
    2adc:	4618      	mov	r0, r3
    2ade:	f00e ffb4 	bl	11a4a <log_msg_is_std>
    2ae2:	4603      	mov	r3, r0
    2ae4:	2b00      	cmp	r3, #0
    2ae6:	d039      	beq.n	2b5c <msg_free+0x94>
    2ae8:	68fb      	ldr	r3, [r7, #12]
    2aea:	2b00      	cmp	r3, #0
    2aec:	d036      	beq.n	2b5c <msg_free+0x94>
		uint32_t i;
		uint32_t smask = 0;
    2aee:	2300      	movs	r3, #0
    2af0:	613b      	str	r3, [r7, #16]

		for (i = 0; i < nargs; i++) {
    2af2:	2300      	movs	r3, #0
    2af4:	617b      	str	r3, [r7, #20]
    2af6:	e02a      	b.n	2b4e <msg_free+0x86>
			void *buf = (void *)log_msg_arg_get(msg, i);
    2af8:	687b      	ldr	r3, [r7, #4]
    2afa:	6979      	ldr	r1, [r7, #20]
    2afc:	4618      	mov	r0, r3
    2afe:	f00f f83d 	bl	11b7c <log_msg_arg_get>
    2b02:	4603      	mov	r3, r0
    2b04:	60bb      	str	r3, [r7, #8]

			if (log_is_strdup(buf)) {
    2b06:	68b8      	ldr	r0, [r7, #8]
    2b08:	f7ff feba 	bl	2880 <log_is_strdup>
    2b0c:	4603      	mov	r3, r0
    2b0e:	2b00      	cmp	r3, #0
    2b10:	d01a      	beq.n	2b48 <msg_free+0x80>
				if (smask == 0) {
    2b12:	693b      	ldr	r3, [r7, #16]
    2b14:	2b00      	cmp	r3, #0
    2b16:	d10c      	bne.n	2b32 <msg_free+0x6a>
					 * string duplication candidate detected
					 * since it is time consuming and free
					 * can be called from any context when
					 * log message is being dropped.
					 */
					smask = z_log_get_s_mask(
    2b18:	687b      	ldr	r3, [r7, #4]
    2b1a:	4618      	mov	r0, r3
    2b1c:	f00f f857 	bl	11bce <log_msg_str_get>
    2b20:	4603      	mov	r3, r0
    2b22:	68f9      	ldr	r1, [r7, #12]
    2b24:	4618      	mov	r0, r3
    2b26:	f7ff fb25 	bl	2174 <z_log_get_s_mask>
    2b2a:	6138      	str	r0, [r7, #16]
							log_msg_str_get(msg),
							nargs);
					if (smask == 0) {
    2b2c:	693b      	ldr	r3, [r7, #16]
    2b2e:	2b00      	cmp	r3, #0
    2b30:	d012      	beq.n	2b58 <msg_free+0x90>
						 * for candidates.
						 */
						break;
					}
				}
				if (smask & BIT(i)) {
    2b32:	693a      	ldr	r2, [r7, #16]
    2b34:	697b      	ldr	r3, [r7, #20]
    2b36:	fa22 f303 	lsr.w	r3, r2, r3
    2b3a:	f003 0301 	and.w	r3, r3, #1
    2b3e:	2b00      	cmp	r3, #0
    2b40:	d002      	beq.n	2b48 <msg_free+0x80>
					log_free(buf);
    2b42:	68b8      	ldr	r0, [r7, #8]
    2b44:	f7ff feba 	bl	28bc <log_free>
		for (i = 0; i < nargs; i++) {
    2b48:	697b      	ldr	r3, [r7, #20]
    2b4a:	3301      	adds	r3, #1
    2b4c:	617b      	str	r3, [r7, #20]
    2b4e:	697a      	ldr	r2, [r7, #20]
    2b50:	68fb      	ldr	r3, [r7, #12]
    2b52:	429a      	cmp	r2, r3
    2b54:	d3d0      	bcc.n	2af8 <msg_free+0x30>
	if (log_msg_is_std(msg) && nargs) {
    2b56:	e000      	b.n	2b5a <msg_free+0x92>
						break;
    2b58:	bf00      	nop
	if (log_msg_is_std(msg) && nargs) {
    2b5a:	bf00      	nop
			log_free((void *)(str));
		}
	} else {
	}

	if (msg->hdr.params.generic.ext == 1) {
    2b5c:	687b      	ldr	r3, [r7, #4]
    2b5e:	7a1b      	ldrb	r3, [r3, #8]
    2b60:	f003 0302 	and.w	r3, r3, #2
    2b64:	b2db      	uxtb	r3, r3
    2b66:	2b00      	cmp	r3, #0
    2b68:	d004      	beq.n	2b74 <msg_free+0xac>
		cont_free(msg->payload.ext.next);
    2b6a:	687b      	ldr	r3, [r7, #4]
    2b6c:	695b      	ldr	r3, [r3, #20]
    2b6e:	4618      	mov	r0, r3
    2b70:	f7ff ff90 	bl	2a94 <cont_free>
	}

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    2b74:	1d3b      	adds	r3, r7, #4
    2b76:	4619      	mov	r1, r3
    2b78:	4803      	ldr	r0, [pc, #12]	; (2b88 <msg_free+0xc0>)
    2b7a:	f008 fd0f 	bl	b59c <k_mem_slab_free>
}
    2b7e:	bf00      	nop
    2b80:	3718      	adds	r7, #24
    2b82:	46bd      	mov	sp, r7
    2b84:	bd80      	pop	{r7, pc}
    2b86:	bf00      	nop
    2b88:	20000674 	.word	0x20000674

00002b8c <log_msg_no_space_handle>:

union log_msg_chunk *log_msg_no_space_handle(void)
{
    2b8c:	b580      	push	{r7, lr}
    2b8e:	b084      	sub	sp, #16
    2b90:	af00      	add	r7, sp, #0
	union log_msg_chunk *msg = NULL;
    2b92:	2300      	movs	r3, #0
    2b94:	607b      	str	r3, [r7, #4]
	bool more;
	int err;

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
    2b96:	2001      	movs	r0, #1
    2b98:	f00e ff83 	bl	11aa2 <log_process>
    2b9c:	4603      	mov	r3, r0
    2b9e:	73fb      	strb	r3, [r7, #15]
			log_dropped();
    2ba0:	f7ff fdec 	bl	277c <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
					       (void **)&msg,
					       K_NO_WAIT);
    2ba4:	f04f 0200 	mov.w	r2, #0
    2ba8:	f04f 0300 	mov.w	r3, #0
			err = k_mem_slab_alloc(&log_msg_pool,
    2bac:	1d39      	adds	r1, r7, #4
    2bae:	4807      	ldr	r0, [pc, #28]	; (2bcc <log_msg_no_space_handle+0x40>)
    2bb0:	f008 fc4e 	bl	b450 <k_mem_slab_alloc>
    2bb4:	60b8      	str	r0, [r7, #8]
		} while ((err != 0) && more);
    2bb6:	68bb      	ldr	r3, [r7, #8]
    2bb8:	2b00      	cmp	r3, #0
    2bba:	d002      	beq.n	2bc2 <log_msg_no_space_handle+0x36>
    2bbc:	7bfb      	ldrb	r3, [r7, #15]
    2bbe:	2b00      	cmp	r3, #0
    2bc0:	d1e9      	bne.n	2b96 <log_msg_no_space_handle+0xa>
	} else {
		log_dropped();
	}
	return msg;
    2bc2:	687b      	ldr	r3, [r7, #4]

}
    2bc4:	4618      	mov	r0, r3
    2bc6:	3710      	adds	r7, #16
    2bc8:	46bd      	mov	sp, r7
    2bca:	bd80      	pop	{r7, pc}
    2bcc:	20000674 	.word	0x20000674

00002bd0 <log_msg_create_n>:
		cont = cont->next;
	}
}

struct log_msg *log_msg_create_n(const char *str, log_arg_t *args, uint32_t nargs)
{
    2bd0:	b580      	push	{r7, lr}
    2bd2:	b086      	sub	sp, #24
    2bd4:	af00      	add	r7, sp, #0
    2bd6:	60f8      	str	r0, [r7, #12]
    2bd8:	60b9      	str	r1, [r7, #8]
    2bda:	607a      	str	r2, [r7, #4]
	__ASSERT_NO_MSG(nargs < LOG_MAX_NARGS);
    2bdc:	687b      	ldr	r3, [r7, #4]
    2bde:	2b0e      	cmp	r3, #14
    2be0:	d90b      	bls.n	2bfa <log_msg_create_n+0x2a>
    2be2:	f240 1337 	movw	r3, #311	; 0x137
    2be6:	4a14      	ldr	r2, [pc, #80]	; (2c38 <log_msg_create_n+0x68>)
    2be8:	4914      	ldr	r1, [pc, #80]	; (2c3c <log_msg_create_n+0x6c>)
    2bea:	4815      	ldr	r0, [pc, #84]	; (2c40 <log_msg_create_n+0x70>)
    2bec:	f00d fa3c 	bl	10068 <printk>
    2bf0:	f240 1137 	movw	r1, #311	; 0x137
    2bf4:	4810      	ldr	r0, [pc, #64]	; (2c38 <log_msg_create_n+0x68>)
    2bf6:	f00e f87f 	bl	10cf8 <assert_post_action>

	struct  log_msg *msg = NULL;
    2bfa:	2300      	movs	r3, #0
    2bfc:	617b      	str	r3, [r7, #20]

	msg = msg_alloc(nargs);
    2bfe:	6878      	ldr	r0, [r7, #4]
    2c00:	f00e fff0 	bl	11be4 <msg_alloc>
    2c04:	6178      	str	r0, [r7, #20]

	if (msg != NULL) {
    2c06:	697b      	ldr	r3, [r7, #20]
    2c08:	2b00      	cmp	r3, #0
    2c0a:	d010      	beq.n	2c2e <log_msg_create_n+0x5e>
		msg->str = str;
    2c0c:	697b      	ldr	r3, [r7, #20]
    2c0e:	68fa      	ldr	r2, [r7, #12]
    2c10:	611a      	str	r2, [r3, #16]
		msg->hdr.params.std.nargs = nargs;
    2c12:	687b      	ldr	r3, [r7, #4]
    2c14:	f003 030f 	and.w	r3, r3, #15
    2c18:	b2d9      	uxtb	r1, r3
    2c1a:	697a      	ldr	r2, [r7, #20]
    2c1c:	7a53      	ldrb	r3, [r2, #9]
    2c1e:	f361 1307 	bfi	r3, r1, #4, #4
    2c22:	7253      	strb	r3, [r2, #9]
		copy_args_to_msg(msg, args, nargs);
    2c24:	687a      	ldr	r2, [r7, #4]
    2c26:	68b9      	ldr	r1, [r7, #8]
    2c28:	6978      	ldr	r0, [r7, #20]
    2c2a:	f00f f81e 	bl	11c6a <copy_args_to_msg>
	}

	return msg;
    2c2e:	697b      	ldr	r3, [r7, #20]
}
    2c30:	4618      	mov	r0, r3
    2c32:	3718      	adds	r7, #24
    2c34:	46bd      	mov	sp, r7
    2c36:	bd80      	pop	{r7, pc}
    2c38:	00018f18 	.word	0x00018f18
    2c3c:	00018f44 	.word	0x00018f44
    2c40:	00018f50 	.word	0x00018f50

00002c44 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
    2c44:	b580      	push	{r7, lr}
    2c46:	b084      	sub	sp, #16
    2c48:	af00      	add	r7, sp, #0
    2c4a:	6078      	str	r0, [r7, #4]
    2c4c:	6039      	str	r1, [r7, #0]
	const struct log_output *out_ctx =
    2c4e:	683b      	ldr	r3, [r7, #0]
    2c50:	60fb      	str	r3, [r7, #12]
		/* Backend must be thread safe in synchronous operation. */
		out_ctx->func((uint8_t *)&c, 1, out_ctx->control_block->ctx);
		return 0;
	}

	if (out_ctx->control_block->offset == out_ctx->size) {
    2c52:	68fb      	ldr	r3, [r7, #12]
    2c54:	685b      	ldr	r3, [r3, #4]
    2c56:	681b      	ldr	r3, [r3, #0]
    2c58:	68fa      	ldr	r2, [r7, #12]
    2c5a:	68d2      	ldr	r2, [r2, #12]
    2c5c:	4293      	cmp	r3, r2
    2c5e:	d102      	bne.n	2c66 <out_func+0x22>
		log_output_flush(out_ctx);
    2c60:	68f8      	ldr	r0, [r7, #12]
    2c62:	f00f f9a5 	bl	11fb0 <log_output_flush>
	}

	idx = atomic_inc(&out_ctx->control_block->offset);
    2c66:	68fb      	ldr	r3, [r7, #12]
    2c68:	685b      	ldr	r3, [r3, #4]
    2c6a:	4618      	mov	r0, r3
    2c6c:	f00f f91c 	bl	11ea8 <atomic_inc>
    2c70:	60b8      	str	r0, [r7, #8]
	out_ctx->buf[idx] = (uint8_t)c;
    2c72:	6879      	ldr	r1, [r7, #4]
    2c74:	68fb      	ldr	r3, [r7, #12]
    2c76:	689a      	ldr	r2, [r3, #8]
    2c78:	68bb      	ldr	r3, [r7, #8]
    2c7a:	4413      	add	r3, r2
    2c7c:	b2ca      	uxtb	r2, r1
    2c7e:	701a      	strb	r2, [r3, #0]

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);
    2c80:	68fb      	ldr	r3, [r7, #12]
    2c82:	685b      	ldr	r3, [r3, #4]
    2c84:	681b      	ldr	r3, [r3, #0]
    2c86:	461a      	mov	r2, r3
    2c88:	68fb      	ldr	r3, [r7, #12]
    2c8a:	68db      	ldr	r3, [r3, #12]
    2c8c:	429a      	cmp	r2, r3
    2c8e:	d909      	bls.n	2ca4 <out_func+0x60>
    2c90:	2374      	movs	r3, #116	; 0x74
    2c92:	4a07      	ldr	r2, [pc, #28]	; (2cb0 <out_func+0x6c>)
    2c94:	4907      	ldr	r1, [pc, #28]	; (2cb4 <out_func+0x70>)
    2c96:	4808      	ldr	r0, [pc, #32]	; (2cb8 <out_func+0x74>)
    2c98:	f00d f9e6 	bl	10068 <printk>
    2c9c:	2174      	movs	r1, #116	; 0x74
    2c9e:	4804      	ldr	r0, [pc, #16]	; (2cb0 <out_func+0x6c>)
    2ca0:	f00e f82a 	bl	10cf8 <assert_post_action>

	return 0;
    2ca4:	2300      	movs	r3, #0
}
    2ca6:	4618      	mov	r0, r3
    2ca8:	3710      	adds	r7, #16
    2caa:	46bd      	mov	sp, r7
    2cac:	bd80      	pop	{r7, pc}
    2cae:	bf00      	nop
    2cb0:	00018f90 	.word	0x00018f90
    2cb4:	00018fc0 	.word	0x00018fc0
    2cb8:	00018ff0 	.word	0x00018ff0

00002cbc <print_formatted>:

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    2cbc:	b40e      	push	{r1, r2, r3}
    2cbe:	b580      	push	{r7, lr}
    2cc0:	b085      	sub	sp, #20
    2cc2:	af00      	add	r7, sp, #0
    2cc4:	6078      	str	r0, [r7, #4]
	va_list args;
	int length = 0;
    2cc6:	2300      	movs	r3, #0
    2cc8:	60fb      	str	r3, [r7, #12]

	va_start(args, fmt);
    2cca:	f107 0320 	add.w	r3, r7, #32
    2cce:	60bb      	str	r3, [r7, #8]
	length = cbvprintf(out_func, (void *)log_output, fmt, args);
    2cd0:	68bb      	ldr	r3, [r7, #8]
    2cd2:	69fa      	ldr	r2, [r7, #28]
    2cd4:	6879      	ldr	r1, [r7, #4]
    2cd6:	4806      	ldr	r0, [pc, #24]	; (2cf0 <print_formatted+0x34>)
    2cd8:	f7fe fc8e 	bl	15f8 <cbvprintf>
    2cdc:	60f8      	str	r0, [r7, #12]
	va_end(args);

	return length;
    2cde:	68fb      	ldr	r3, [r7, #12]
}
    2ce0:	4618      	mov	r0, r3
    2ce2:	3714      	adds	r7, #20
    2ce4:	46bd      	mov	sp, r7
    2ce6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    2cea:	b003      	add	sp, #12
    2cec:	4770      	bx	lr
    2cee:	bf00      	nop
    2cf0:	00002c45 	.word	0x00002c45

00002cf4 <timestamp_print>:
	log_output->control_block->offset = 0;
}

static int timestamp_print(const struct log_output *log_output,
			   uint32_t flags, uint32_t timestamp)
{
    2cf4:	b580      	push	{r7, lr}
    2cf6:	b092      	sub	sp, #72	; 0x48
    2cf8:	af04      	add	r7, sp, #16
    2cfa:	60f8      	str	r0, [r7, #12]
    2cfc:	60b9      	str	r1, [r7, #8]
    2cfe:	607a      	str	r2, [r7, #4]
	int length;
	bool format =
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
    2d00:	68bb      	ldr	r3, [r7, #8]
    2d02:	f003 0344 	and.w	r3, r3, #68	; 0x44
	bool format =
    2d06:	2b00      	cmp	r3, #0
    2d08:	bf14      	ite	ne
    2d0a:	2301      	movne	r3, #1
    2d0c:	2300      	moveq	r3, #0
    2d0e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG);


	if (!format) {
    2d12:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    2d16:	f083 0301 	eor.w	r3, r3, #1
    2d1a:	b2db      	uxtb	r3, r3
    2d1c:	2b00      	cmp	r3, #0
    2d1e:	d006      	beq.n	2d2e <timestamp_print+0x3a>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    2d20:	687a      	ldr	r2, [r7, #4]
    2d22:	4938      	ldr	r1, [pc, #224]	; (2e04 <timestamp_print+0x110>)
    2d24:	68f8      	ldr	r0, [r7, #12]
    2d26:	f7ff ffc9 	bl	2cbc <print_formatted>
    2d2a:	6378      	str	r0, [r7, #52]	; 0x34
    2d2c:	e065      	b.n	2dfa <timestamp_print+0x106>
	} else if (freq != 0U) {
    2d2e:	4b36      	ldr	r3, [pc, #216]	; (2e08 <timestamp_print+0x114>)
    2d30:	681b      	ldr	r3, [r3, #0]
    2d32:	2b00      	cmp	r3, #0
    2d34:	d05f      	beq.n	2df6 <timestamp_print+0x102>
		uint32_t hours;
		uint32_t mins;
		uint32_t ms;
		uint32_t us;

		timestamp /= timestamp_div;
    2d36:	4b35      	ldr	r3, [pc, #212]	; (2e0c <timestamp_print+0x118>)
    2d38:	681b      	ldr	r3, [r3, #0]
    2d3a:	687a      	ldr	r2, [r7, #4]
    2d3c:	fbb2 f3f3 	udiv	r3, r2, r3
    2d40:	607b      	str	r3, [r7, #4]
		total_seconds = timestamp / freq;
    2d42:	4b31      	ldr	r3, [pc, #196]	; (2e08 <timestamp_print+0x114>)
    2d44:	681b      	ldr	r3, [r3, #0]
    2d46:	687a      	ldr	r2, [r7, #4]
    2d48:	fbb2 f3f3 	udiv	r3, r2, r3
    2d4c:	62fb      	str	r3, [r7, #44]	; 0x2c
		seconds = total_seconds;
    2d4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2d50:	62bb      	str	r3, [r7, #40]	; 0x28
		hours = seconds / 3600U;
    2d52:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2d54:	4a2e      	ldr	r2, [pc, #184]	; (2e10 <timestamp_print+0x11c>)
    2d56:	fba2 2303 	umull	r2, r3, r2, r3
    2d5a:	0adb      	lsrs	r3, r3, #11
    2d5c:	627b      	str	r3, [r7, #36]	; 0x24
		seconds -= hours * 3600U;
    2d5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d60:	f44f 6261 	mov.w	r2, #3600	; 0xe10
    2d64:	fb02 f303 	mul.w	r3, r2, r3
    2d68:	6aba      	ldr	r2, [r7, #40]	; 0x28
    2d6a:	1ad3      	subs	r3, r2, r3
    2d6c:	62bb      	str	r3, [r7, #40]	; 0x28
		mins = seconds / 60U;
    2d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2d70:	4a28      	ldr	r2, [pc, #160]	; (2e14 <timestamp_print+0x120>)
    2d72:	fba2 2303 	umull	r2, r3, r2, r3
    2d76:	095b      	lsrs	r3, r3, #5
    2d78:	623b      	str	r3, [r7, #32]
		seconds -= mins * 60U;
    2d7a:	6a3a      	ldr	r2, [r7, #32]
    2d7c:	4613      	mov	r3, r2
    2d7e:	011b      	lsls	r3, r3, #4
    2d80:	1a9b      	subs	r3, r3, r2
    2d82:	009b      	lsls	r3, r3, #2
    2d84:	461a      	mov	r2, r3
    2d86:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2d88:	1a9b      	subs	r3, r3, r2
    2d8a:	62bb      	str	r3, [r7, #40]	; 0x28

		remainder = timestamp % freq;
    2d8c:	4b1e      	ldr	r3, [pc, #120]	; (2e08 <timestamp_print+0x114>)
    2d8e:	681a      	ldr	r2, [r3, #0]
    2d90:	687b      	ldr	r3, [r7, #4]
    2d92:	fbb3 f1f2 	udiv	r1, r3, r2
    2d96:	fb02 f201 	mul.w	r2, r2, r1
    2d9a:	1a9b      	subs	r3, r3, r2
    2d9c:	61fb      	str	r3, [r7, #28]
		ms = (remainder * 1000U) / freq;
    2d9e:	69fb      	ldr	r3, [r7, #28]
    2da0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2da4:	fb02 f203 	mul.w	r2, r2, r3
    2da8:	4b17      	ldr	r3, [pc, #92]	; (2e08 <timestamp_print+0x114>)
    2daa:	681b      	ldr	r3, [r3, #0]
    2dac:	fbb2 f3f3 	udiv	r3, r2, r3
    2db0:	61bb      	str	r3, [r7, #24]
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    2db2:	69fb      	ldr	r3, [r7, #28]
    2db4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2db8:	fb02 f203 	mul.w	r2, r2, r3
    2dbc:	4b12      	ldr	r3, [pc, #72]	; (2e08 <timestamp_print+0x114>)
    2dbe:	681b      	ldr	r3, [r3, #0]
    2dc0:	69b9      	ldr	r1, [r7, #24]
    2dc2:	fb01 f303 	mul.w	r3, r1, r3
    2dc6:	1ad3      	subs	r3, r2, r3
    2dc8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2dcc:	fb02 f203 	mul.w	r2, r2, r3
    2dd0:	4b0d      	ldr	r3, [pc, #52]	; (2e08 <timestamp_print+0x114>)
    2dd2:	681b      	ldr	r3, [r3, #0]
    2dd4:	fbb2 f3f3 	udiv	r3, r2, r3
    2dd8:	617b      	str	r3, [r7, #20]
			length = print_formatted(log_output,
					"1970-01-01T%02d:%02d:%02d.%06dZ ",
					hours, mins, seconds, ms * 1000U + us);
#endif
		} else {
			length = print_formatted(log_output,
    2dda:	697b      	ldr	r3, [r7, #20]
    2ddc:	9302      	str	r3, [sp, #8]
    2dde:	69bb      	ldr	r3, [r7, #24]
    2de0:	9301      	str	r3, [sp, #4]
    2de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2de4:	9300      	str	r3, [sp, #0]
    2de6:	6a3b      	ldr	r3, [r7, #32]
    2de8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    2dea:	490b      	ldr	r1, [pc, #44]	; (2e18 <timestamp_print+0x124>)
    2dec:	68f8      	ldr	r0, [r7, #12]
    2dee:	f7ff ff65 	bl	2cbc <print_formatted>
    2df2:	6378      	str	r0, [r7, #52]	; 0x34
    2df4:	e001      	b.n	2dfa <timestamp_print+0x106>
						 "[%02d:%02d:%02d.%03d,%03d] ",
						 hours, mins, seconds, ms, us);
		}
	} else {
		length = 0;
    2df6:	2300      	movs	r3, #0
    2df8:	637b      	str	r3, [r7, #52]	; 0x34
	}

	return length;
    2dfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
    2dfc:	4618      	mov	r0, r3
    2dfe:	3738      	adds	r7, #56	; 0x38
    2e00:	46bd      	mov	sp, r7
    2e02:	bd80      	pop	{r7, pc}
    2e04:	00019010 	.word	0x00019010
    2e08:	20000690 	.word	0x20000690
    2e0c:	20000694 	.word	0x20000694
    2e10:	91a2b3c5 	.word	0x91a2b3c5
    2e14:	88888889 	.word	0x88888889
    2e18:	0001901c 	.word	0x0001901c

00002e1c <color_print>:

static void color_print(const struct log_output *log_output,
			bool color, bool start, uint32_t level)
{
    2e1c:	b580      	push	{r7, lr}
    2e1e:	b086      	sub	sp, #24
    2e20:	af00      	add	r7, sp, #0
    2e22:	60f8      	str	r0, [r7, #12]
    2e24:	607b      	str	r3, [r7, #4]
    2e26:	460b      	mov	r3, r1
    2e28:	72fb      	strb	r3, [r7, #11]
    2e2a:	4613      	mov	r3, r2
    2e2c:	72bb      	strb	r3, [r7, #10]
	if (color) {
    2e2e:	7afb      	ldrb	r3, [r7, #11]
    2e30:	2b00      	cmp	r3, #0
    2e32:	d014      	beq.n	2e5e <color_print+0x42>
		const char *log_color = start && (colors[level] != NULL) ?
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    2e34:	7abb      	ldrb	r3, [r7, #10]
    2e36:	2b00      	cmp	r3, #0
    2e38:	d00a      	beq.n	2e50 <color_print+0x34>
		const char *log_color = start && (colors[level] != NULL) ?
    2e3a:	4a0b      	ldr	r2, [pc, #44]	; (2e68 <color_print+0x4c>)
    2e3c:	687b      	ldr	r3, [r7, #4]
    2e3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2e42:	2b00      	cmp	r3, #0
    2e44:	d004      	beq.n	2e50 <color_print+0x34>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    2e46:	4a08      	ldr	r2, [pc, #32]	; (2e68 <color_print+0x4c>)
    2e48:	687b      	ldr	r3, [r7, #4]
    2e4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2e4e:	e000      	b.n	2e52 <color_print+0x36>
    2e50:	4b06      	ldr	r3, [pc, #24]	; (2e6c <color_print+0x50>)
		const char *log_color = start && (colors[level] != NULL) ?
    2e52:	617b      	str	r3, [r7, #20]
		print_formatted(log_output, "%s", log_color);
    2e54:	697a      	ldr	r2, [r7, #20]
    2e56:	4906      	ldr	r1, [pc, #24]	; (2e70 <color_print+0x54>)
    2e58:	68f8      	ldr	r0, [r7, #12]
    2e5a:	f7ff ff2f 	bl	2cbc <print_formatted>
	}
}
    2e5e:	bf00      	nop
    2e60:	3718      	adds	r7, #24
    2e62:	46bd      	mov	sp, r7
    2e64:	bd80      	pop	{r7, pc}
    2e66:	bf00      	nop
    2e68:	0001ca6c 	.word	0x0001ca6c
    2e6c:	00019038 	.word	0x00019038
    2e70:	00019040 	.word	0x00019040

00002e74 <ids_print>:
}


static int ids_print(const struct log_output *log_output, bool level_on,
		    bool func_on, uint32_t domain_id, uint32_t source_id, uint32_t level)
{
    2e74:	b590      	push	{r4, r7, lr}
    2e76:	b087      	sub	sp, #28
    2e78:	af00      	add	r7, sp, #0
    2e7a:	60f8      	str	r0, [r7, #12]
    2e7c:	607b      	str	r3, [r7, #4]
    2e7e:	460b      	mov	r3, r1
    2e80:	72fb      	strb	r3, [r7, #11]
    2e82:	4613      	mov	r3, r2
    2e84:	72bb      	strb	r3, [r7, #10]
	int total = 0;
    2e86:	2300      	movs	r3, #0
    2e88:	617b      	str	r3, [r7, #20]

	if (level_on) {
    2e8a:	7afb      	ldrb	r3, [r7, #11]
    2e8c:	2b00      	cmp	r3, #0
    2e8e:	d00c      	beq.n	2eaa <ids_print+0x36>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    2e90:	4a16      	ldr	r2, [pc, #88]	; (2eec <ids_print+0x78>)
    2e92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2e94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2e98:	461a      	mov	r2, r3
    2e9a:	4915      	ldr	r1, [pc, #84]	; (2ef0 <ids_print+0x7c>)
    2e9c:	68f8      	ldr	r0, [r7, #12]
    2e9e:	f7ff ff0d 	bl	2cbc <print_formatted>
    2ea2:	4602      	mov	r2, r0
    2ea4:	697b      	ldr	r3, [r7, #20]
    2ea6:	4413      	add	r3, r2
    2ea8:	617b      	str	r3, [r7, #20]
	}

	total += print_formatted(log_output,
    2eaa:	7abb      	ldrb	r3, [r7, #10]
    2eac:	2b00      	cmp	r3, #0
    2eae:	d009      	beq.n	2ec4 <ids_print+0x50>
				(func_on &&
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    2eb0:	2201      	movs	r2, #1
    2eb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2eb4:	fa02 f303 	lsl.w	r3, r2, r3
    2eb8:	f003 0310 	and.w	r3, r3, #16
				(func_on &&
    2ebc:	2b00      	cmp	r3, #0
    2ebe:	d001      	beq.n	2ec4 <ids_print+0x50>
	total += print_formatted(log_output,
    2ec0:	4c0c      	ldr	r4, [pc, #48]	; (2ef4 <ids_print+0x80>)
    2ec2:	e000      	b.n	2ec6 <ids_print+0x52>
    2ec4:	4c0c      	ldr	r4, [pc, #48]	; (2ef8 <ids_print+0x84>)
    2ec6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    2ec8:	6878      	ldr	r0, [r7, #4]
    2eca:	f00e fc34 	bl	11736 <log_source_name_get>
    2ece:	4603      	mov	r3, r0
    2ed0:	461a      	mov	r2, r3
    2ed2:	4621      	mov	r1, r4
    2ed4:	68f8      	ldr	r0, [r7, #12]
    2ed6:	f7ff fef1 	bl	2cbc <print_formatted>
    2eda:	4602      	mov	r2, r0
    2edc:	697b      	ldr	r3, [r7, #20]
    2ede:	4413      	add	r3, r2
    2ee0:	617b      	str	r3, [r7, #20]
				"%s." : "%s: ",
				log_source_name_get(domain_id, source_id));

	return total;
    2ee2:	697b      	ldr	r3, [r7, #20]
}
    2ee4:	4618      	mov	r0, r3
    2ee6:	371c      	adds	r7, #28
    2ee8:	46bd      	mov	sp, r7
    2eea:	bd90      	pop	{r4, r7, pc}
    2eec:	0001ca58 	.word	0x0001ca58
    2ef0:	00019044 	.word	0x00019044
    2ef4:	0001904c 	.word	0x0001904c
    2ef8:	00019050 	.word	0x00019050

00002efc <newline_print>:

static void newline_print(const struct log_output *ctx, uint32_t flags)
{
    2efc:	b580      	push	{r7, lr}
    2efe:	b082      	sub	sp, #8
    2f00:	af00      	add	r7, sp, #0
    2f02:	6078      	str	r0, [r7, #4]
    2f04:	6039      	str	r1, [r7, #0]
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2f06:	683b      	ldr	r3, [r7, #0]
    2f08:	f003 0310 	and.w	r3, r3, #16
    2f0c:	2b00      	cmp	r3, #0
    2f0e:	d10e      	bne.n	2f2e <newline_print+0x32>
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    2f10:	683b      	ldr	r3, [r7, #0]
    2f12:	f003 0320 	and.w	r3, r3, #32
    2f16:	2b00      	cmp	r3, #0
    2f18:	d004      	beq.n	2f24 <newline_print+0x28>
		print_formatted(ctx, "\n");
    2f1a:	4907      	ldr	r1, [pc, #28]	; (2f38 <newline_print+0x3c>)
    2f1c:	6878      	ldr	r0, [r7, #4]
    2f1e:	f7ff fecd 	bl	2cbc <print_formatted>
    2f22:	e005      	b.n	2f30 <newline_print+0x34>
	} else {
		print_formatted(ctx, "\r\n");
    2f24:	4905      	ldr	r1, [pc, #20]	; (2f3c <newline_print+0x40>)
    2f26:	6878      	ldr	r0, [r7, #4]
    2f28:	f7ff fec8 	bl	2cbc <print_formatted>
    2f2c:	e000      	b.n	2f30 <newline_print+0x34>
		return;
    2f2e:	bf00      	nop
	}
}
    2f30:	3708      	adds	r7, #8
    2f32:	46bd      	mov	sp, r7
    2f34:	bd80      	pop	{r7, pc}
    2f36:	bf00      	nop
    2f38:	00019058 	.word	0x00019058
    2f3c:	0001905c 	.word	0x0001905c

00002f40 <std_print>:

static void std_print(struct log_msg *msg,
		      const struct log_output *log_output)
{
    2f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f42:	b09d      	sub	sp, #116	; 0x74
    2f44:	af0e      	add	r7, sp, #56	; 0x38
    2f46:	6278      	str	r0, [r7, #36]	; 0x24
    2f48:	6239      	str	r1, [r7, #32]
	const char *str = log_msg_str_get(msg);
    2f4a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    2f4c:	f00e fe3f 	bl	11bce <log_msg_str_get>
    2f50:	6338      	str	r0, [r7, #48]	; 0x30
	uint32_t nargs = log_msg_nargs_get(msg);
    2f52:	6a78      	ldr	r0, [r7, #36]	; 0x24
    2f54:	f00e fddb 	bl	11b0e <log_msg_nargs_get>
    2f58:	62f8      	str	r0, [r7, #44]	; 0x2c
	uint32_t *args = alloca(sizeof(uint32_t)*nargs);
    2f5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2f5c:	009b      	lsls	r3, r3, #2
    2f5e:	3307      	adds	r3, #7
    2f60:	08db      	lsrs	r3, r3, #3
    2f62:	00db      	lsls	r3, r3, #3
    2f64:	ebad 0d03 	sub.w	sp, sp, r3
    2f68:	ab0e      	add	r3, sp, #56	; 0x38
    2f6a:	3307      	adds	r3, #7
    2f6c:	08db      	lsrs	r3, r3, #3
    2f6e:	00db      	lsls	r3, r3, #3
    2f70:	62bb      	str	r3, [r7, #40]	; 0x28
	int i;

	for (i = 0; i < nargs; i++) {
    2f72:	2300      	movs	r3, #0
    2f74:	637b      	str	r3, [r7, #52]	; 0x34
    2f76:	e00c      	b.n	2f92 <std_print+0x52>
		args[i] = log_msg_arg_get(msg, i);
    2f78:	6b79      	ldr	r1, [r7, #52]	; 0x34
    2f7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2f7c:	009b      	lsls	r3, r3, #2
    2f7e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    2f80:	18d4      	adds	r4, r2, r3
    2f82:	6a78      	ldr	r0, [r7, #36]	; 0x24
    2f84:	f00e fdfa 	bl	11b7c <log_msg_arg_get>
    2f88:	4603      	mov	r3, r0
    2f8a:	6023      	str	r3, [r4, #0]
	for (i = 0; i < nargs; i++) {
    2f8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2f8e:	3301      	adds	r3, #1
    2f90:	637b      	str	r3, [r7, #52]	; 0x34
    2f92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2f94:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    2f96:	429a      	cmp	r2, r3
    2f98:	d8ee      	bhi.n	2f78 <std_print+0x38>
	}

	switch (log_msg_nargs_get(msg)) {
    2f9a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    2f9c:	f00e fdb7 	bl	11b0e <log_msg_nargs_get>
    2fa0:	4603      	mov	r3, r0
    2fa2:	2b0f      	cmp	r3, #15
    2fa4:	f200 828f 	bhi.w	34c6 <std_print+0x586>
    2fa8:	a201      	add	r2, pc, #4	; (adr r2, 2fb0 <std_print+0x70>)
    2faa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2fae:	bf00      	nop
    2fb0:	00002ff1 	.word	0x00002ff1
    2fb4:	00002ffb 	.word	0x00002ffb
    2fb8:	0000300b 	.word	0x0000300b
    2fbc:	0000301f 	.word	0x0000301f
    2fc0:	0000303d 	.word	0x0000303d
    2fc4:	00003065 	.word	0x00003065
    2fc8:	00003095 	.word	0x00003095
    2fcc:	000030cd 	.word	0x000030cd
    2fd0:	0000310d 	.word	0x0000310d
    2fd4:	00003157 	.word	0x00003157
    2fd8:	000031ab 	.word	0x000031ab
    2fdc:	0000320f 	.word	0x0000320f
    2fe0:	00003283 	.word	0x00003283
    2fe4:	00003307 	.word	0x00003307
    2fe8:	0000339b 	.word	0x0000339b
    2fec:	0000342b 	.word	0x0000342b
	case 0:
		print_formatted(log_output, str);
    2ff0:	6b39      	ldr	r1, [r7, #48]	; 0x30
    2ff2:	6a38      	ldr	r0, [r7, #32]
    2ff4:	f7ff fe62 	bl	2cbc <print_formatted>
		break;
    2ff8:	e266      	b.n	34c8 <std_print+0x588>
	case 1:
		print_formatted(log_output, str, args[0]);
    2ffa:	6abb      	ldr	r3, [r7, #40]	; 0x28
    2ffc:	681b      	ldr	r3, [r3, #0]
    2ffe:	461a      	mov	r2, r3
    3000:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3002:	6a38      	ldr	r0, [r7, #32]
    3004:	f7ff fe5a 	bl	2cbc <print_formatted>
		break;
    3008:	e25e      	b.n	34c8 <std_print+0x588>
	case 2:
		print_formatted(log_output, str, args[0], args[1]);
    300a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    300c:	681a      	ldr	r2, [r3, #0]
    300e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3010:	3304      	adds	r3, #4
    3012:	681b      	ldr	r3, [r3, #0]
    3014:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3016:	6a38      	ldr	r0, [r7, #32]
    3018:	f7ff fe50 	bl	2cbc <print_formatted>
		break;
    301c:	e254      	b.n	34c8 <std_print+0x588>
	case 3:
		print_formatted(log_output, str, args[0], args[1], args[2]);
    301e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3020:	681a      	ldr	r2, [r3, #0]
    3022:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3024:	3304      	adds	r3, #4
    3026:	6819      	ldr	r1, [r3, #0]
    3028:	6abb      	ldr	r3, [r7, #40]	; 0x28
    302a:	3308      	adds	r3, #8
    302c:	681b      	ldr	r3, [r3, #0]
    302e:	9300      	str	r3, [sp, #0]
    3030:	460b      	mov	r3, r1
    3032:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3034:	6a38      	ldr	r0, [r7, #32]
    3036:	f7ff fe41 	bl	2cbc <print_formatted>
		break;
    303a:	e245      	b.n	34c8 <std_print+0x588>
	case 4:
		print_formatted(log_output, str, args[0], args[1], args[2],
    303c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    303e:	6819      	ldr	r1, [r3, #0]
    3040:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3042:	3304      	adds	r3, #4
    3044:	6818      	ldr	r0, [r3, #0]
    3046:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3048:	3308      	adds	r3, #8
    304a:	681b      	ldr	r3, [r3, #0]
				args[3]);
    304c:	6aba      	ldr	r2, [r7, #40]	; 0x28
    304e:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    3050:	6812      	ldr	r2, [r2, #0]
    3052:	9201      	str	r2, [sp, #4]
    3054:	9300      	str	r3, [sp, #0]
    3056:	4603      	mov	r3, r0
    3058:	460a      	mov	r2, r1
    305a:	6b39      	ldr	r1, [r7, #48]	; 0x30
    305c:	6a38      	ldr	r0, [r7, #32]
    305e:	f7ff fe2d 	bl	2cbc <print_formatted>
		break;
    3062:	e231      	b.n	34c8 <std_print+0x588>
	case 5:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3064:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3066:	6818      	ldr	r0, [r3, #0]
    3068:	6abb      	ldr	r3, [r7, #40]	; 0x28
    306a:	3304      	adds	r3, #4
    306c:	681c      	ldr	r4, [r3, #0]
    306e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3070:	3308      	adds	r3, #8
    3072:	681b      	ldr	r3, [r3, #0]
				args[3], args[4]);
    3074:	6aba      	ldr	r2, [r7, #40]	; 0x28
    3076:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    3078:	6812      	ldr	r2, [r2, #0]
				args[3], args[4]);
    307a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    307c:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    307e:	6809      	ldr	r1, [r1, #0]
    3080:	9102      	str	r1, [sp, #8]
    3082:	9201      	str	r2, [sp, #4]
    3084:	9300      	str	r3, [sp, #0]
    3086:	4623      	mov	r3, r4
    3088:	4602      	mov	r2, r0
    308a:	6b39      	ldr	r1, [r7, #48]	; 0x30
    308c:	6a38      	ldr	r0, [r7, #32]
    308e:	f7ff fe15 	bl	2cbc <print_formatted>
		break;
    3092:	e219      	b.n	34c8 <std_print+0x588>
	case 6:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3094:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3096:	681c      	ldr	r4, [r3, #0]
    3098:	6abb      	ldr	r3, [r7, #40]	; 0x28
    309a:	3304      	adds	r3, #4
    309c:	681d      	ldr	r5, [r3, #0]
    309e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    30a0:	3308      	adds	r3, #8
    30a2:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5]);
    30a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
    30a6:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    30a8:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5]);
    30aa:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    30ac:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    30ae:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5]);
    30b0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    30b2:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    30b4:	6800      	ldr	r0, [r0, #0]
    30b6:	9003      	str	r0, [sp, #12]
    30b8:	9102      	str	r1, [sp, #8]
    30ba:	9201      	str	r2, [sp, #4]
    30bc:	9300      	str	r3, [sp, #0]
    30be:	462b      	mov	r3, r5
    30c0:	4622      	mov	r2, r4
    30c2:	6b39      	ldr	r1, [r7, #48]	; 0x30
    30c4:	6a38      	ldr	r0, [r7, #32]
    30c6:	f7ff fdf9 	bl	2cbc <print_formatted>
		break;
    30ca:	e1fd      	b.n	34c8 <std_print+0x588>
	case 7:
		print_formatted(log_output, str, args[0], args[1], args[2],
    30cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    30ce:	681d      	ldr	r5, [r3, #0]
    30d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    30d2:	3304      	adds	r3, #4
    30d4:	681e      	ldr	r6, [r3, #0]
    30d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    30d8:	3308      	adds	r3, #8
    30da:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6]);
    30dc:	6aba      	ldr	r2, [r7, #40]	; 0x28
    30de:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    30e0:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6]);
    30e2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    30e4:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    30e6:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6]);
    30e8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    30ea:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    30ec:	6800      	ldr	r0, [r0, #0]
				args[3], args[4], args[5], args[6]);
    30ee:	6abc      	ldr	r4, [r7, #40]	; 0x28
    30f0:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    30f2:	6824      	ldr	r4, [r4, #0]
    30f4:	9404      	str	r4, [sp, #16]
    30f6:	9003      	str	r0, [sp, #12]
    30f8:	9102      	str	r1, [sp, #8]
    30fa:	9201      	str	r2, [sp, #4]
    30fc:	9300      	str	r3, [sp, #0]
    30fe:	4633      	mov	r3, r6
    3100:	462a      	mov	r2, r5
    3102:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3104:	6a38      	ldr	r0, [r7, #32]
    3106:	f7ff fdd9 	bl	2cbc <print_formatted>
		break;
    310a:	e1dd      	b.n	34c8 <std_print+0x588>
	case 8:
		print_formatted(log_output, str, args[0], args[1], args[2],
    310c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    310e:	681e      	ldr	r6, [r3, #0]
    3110:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3112:	3304      	adds	r3, #4
    3114:	681b      	ldr	r3, [r3, #0]
    3116:	61fb      	str	r3, [r7, #28]
    3118:	6abb      	ldr	r3, [r7, #40]	; 0x28
    311a:	3308      	adds	r3, #8
    311c:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6], args[7]);
    311e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    3120:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    3122:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6], args[7]);
    3124:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    3126:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    3128:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6], args[7]);
    312a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    312c:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    312e:	6800      	ldr	r0, [r0, #0]
				args[3], args[4], args[5], args[6], args[7]);
    3130:	6abc      	ldr	r4, [r7, #40]	; 0x28
    3132:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    3134:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6], args[7]);
    3136:	6abd      	ldr	r5, [r7, #40]	; 0x28
    3138:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    313a:	682d      	ldr	r5, [r5, #0]
    313c:	9505      	str	r5, [sp, #20]
    313e:	9404      	str	r4, [sp, #16]
    3140:	9003      	str	r0, [sp, #12]
    3142:	9102      	str	r1, [sp, #8]
    3144:	9201      	str	r2, [sp, #4]
    3146:	9300      	str	r3, [sp, #0]
    3148:	69fb      	ldr	r3, [r7, #28]
    314a:	4632      	mov	r2, r6
    314c:	6b39      	ldr	r1, [r7, #48]	; 0x30
    314e:	6a38      	ldr	r0, [r7, #32]
    3150:	f7ff fdb4 	bl	2cbc <print_formatted>
		break;
    3154:	e1b8      	b.n	34c8 <std_print+0x588>
	case 9:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3156:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3158:	681b      	ldr	r3, [r3, #0]
    315a:	61fb      	str	r3, [r7, #28]
    315c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    315e:	3304      	adds	r3, #4
    3160:	6819      	ldr	r1, [r3, #0]
    3162:	61b9      	str	r1, [r7, #24]
    3164:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3166:	3308      	adds	r3, #8
    3168:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    316a:	6aba      	ldr	r2, [r7, #40]	; 0x28
    316c:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    316e:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3170:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    3172:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    3174:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3176:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3178:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    317a:	6800      	ldr	r0, [r0, #0]
				args[3], args[4], args[5], args[6],  args[7],
    317c:	6abc      	ldr	r4, [r7, #40]	; 0x28
    317e:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    3180:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3182:	6abd      	ldr	r5, [r7, #40]	; 0x28
    3184:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    3186:	682d      	ldr	r5, [r5, #0]
				args[8]);
    3188:	6abe      	ldr	r6, [r7, #40]	; 0x28
    318a:	3620      	adds	r6, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    318c:	6836      	ldr	r6, [r6, #0]
    318e:	9606      	str	r6, [sp, #24]
    3190:	9505      	str	r5, [sp, #20]
    3192:	9404      	str	r4, [sp, #16]
    3194:	9003      	str	r0, [sp, #12]
    3196:	9102      	str	r1, [sp, #8]
    3198:	9201      	str	r2, [sp, #4]
    319a:	9300      	str	r3, [sp, #0]
    319c:	69bb      	ldr	r3, [r7, #24]
    319e:	69fa      	ldr	r2, [r7, #28]
    31a0:	6b39      	ldr	r1, [r7, #48]	; 0x30
    31a2:	6a38      	ldr	r0, [r7, #32]
    31a4:	f7ff fd8a 	bl	2cbc <print_formatted>
		break;
    31a8:	e18e      	b.n	34c8 <std_print+0x588>
	case 10:
		print_formatted(log_output, str, args[0], args[1], args[2],
    31aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
    31ac:	681b      	ldr	r3, [r3, #0]
    31ae:	61fb      	str	r3, [r7, #28]
    31b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    31b2:	3304      	adds	r3, #4
    31b4:	6819      	ldr	r1, [r3, #0]
    31b6:	61b9      	str	r1, [r7, #24]
    31b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    31ba:	3308      	adds	r3, #8
    31bc:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    31be:	6aba      	ldr	r2, [r7, #40]	; 0x28
    31c0:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    31c2:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6],  args[7],
    31c4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    31c6:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    31c8:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6],  args[7],
    31ca:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    31cc:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    31ce:	6800      	ldr	r0, [r0, #0]
    31d0:	6178      	str	r0, [r7, #20]
				args[3], args[4], args[5], args[6],  args[7],
    31d2:	6abc      	ldr	r4, [r7, #40]	; 0x28
    31d4:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    31d6:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6],  args[7],
    31d8:	6abd      	ldr	r5, [r7, #40]	; 0x28
    31da:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    31dc:	682d      	ldr	r5, [r5, #0]
				args[8], args[9]);
    31de:	6abe      	ldr	r6, [r7, #40]	; 0x28
    31e0:	3620      	adds	r6, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    31e2:	6836      	ldr	r6, [r6, #0]
				args[8], args[9]);
    31e4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    31e6:	f100 0c24 	add.w	ip, r0, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    31ea:	f8dc 0000 	ldr.w	r0, [ip]
    31ee:	9007      	str	r0, [sp, #28]
    31f0:	9606      	str	r6, [sp, #24]
    31f2:	9505      	str	r5, [sp, #20]
    31f4:	9404      	str	r4, [sp, #16]
    31f6:	6978      	ldr	r0, [r7, #20]
    31f8:	9003      	str	r0, [sp, #12]
    31fa:	9102      	str	r1, [sp, #8]
    31fc:	9201      	str	r2, [sp, #4]
    31fe:	9300      	str	r3, [sp, #0]
    3200:	69bb      	ldr	r3, [r7, #24]
    3202:	69fa      	ldr	r2, [r7, #28]
    3204:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3206:	6a38      	ldr	r0, [r7, #32]
    3208:	f7ff fd58 	bl	2cbc <print_formatted>
		break;
    320c:	e15c      	b.n	34c8 <std_print+0x588>
	case 11:
		print_formatted(log_output, str, args[0], args[1], args[2],
    320e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3210:	681b      	ldr	r3, [r3, #0]
    3212:	61fb      	str	r3, [r7, #28]
    3214:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3216:	3304      	adds	r3, #4
    3218:	6819      	ldr	r1, [r3, #0]
    321a:	61b9      	str	r1, [r7, #24]
    321c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    321e:	3308      	adds	r3, #8
    3220:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3222:	6aba      	ldr	r2, [r7, #40]	; 0x28
    3224:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    3226:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3228:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    322a:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    322c:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6],  args[7],
    322e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3230:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    3232:	6800      	ldr	r0, [r0, #0]
    3234:	6178      	str	r0, [r7, #20]
				args[3], args[4], args[5], args[6],  args[7],
    3236:	6abc      	ldr	r4, [r7, #40]	; 0x28
    3238:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    323a:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6],  args[7],
    323c:	6abd      	ldr	r5, [r7, #40]	; 0x28
    323e:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    3240:	682d      	ldr	r5, [r5, #0]
				args[8], args[9], args[10]);
    3242:	6abe      	ldr	r6, [r7, #40]	; 0x28
    3244:	3620      	adds	r6, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    3246:	6836      	ldr	r6, [r6, #0]
				args[8], args[9], args[10]);
    3248:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    324a:	f100 0c24 	add.w	ip, r0, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    324e:	f8dc 0000 	ldr.w	r0, [ip]
    3252:	6138      	str	r0, [r7, #16]
				args[8], args[9], args[10]);
    3254:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3256:	f100 0c28 	add.w	ip, r0, #40	; 0x28
		print_formatted(log_output, str, args[0], args[1], args[2],
    325a:	f8dc 0000 	ldr.w	r0, [ip]
    325e:	9008      	str	r0, [sp, #32]
    3260:	6938      	ldr	r0, [r7, #16]
    3262:	9007      	str	r0, [sp, #28]
    3264:	9606      	str	r6, [sp, #24]
    3266:	9505      	str	r5, [sp, #20]
    3268:	9404      	str	r4, [sp, #16]
    326a:	6978      	ldr	r0, [r7, #20]
    326c:	9003      	str	r0, [sp, #12]
    326e:	9102      	str	r1, [sp, #8]
    3270:	9201      	str	r2, [sp, #4]
    3272:	9300      	str	r3, [sp, #0]
    3274:	69bb      	ldr	r3, [r7, #24]
    3276:	69fa      	ldr	r2, [r7, #28]
    3278:	6b39      	ldr	r1, [r7, #48]	; 0x30
    327a:	6a38      	ldr	r0, [r7, #32]
    327c:	f7ff fd1e 	bl	2cbc <print_formatted>
		break;
    3280:	e122      	b.n	34c8 <std_print+0x588>
	case 12:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3282:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3284:	681b      	ldr	r3, [r3, #0]
    3286:	61fb      	str	r3, [r7, #28]
    3288:	6abb      	ldr	r3, [r7, #40]	; 0x28
    328a:	3304      	adds	r3, #4
    328c:	6819      	ldr	r1, [r3, #0]
    328e:	61b9      	str	r1, [r7, #24]
    3290:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3292:	3308      	adds	r3, #8
    3294:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3296:	6aba      	ldr	r2, [r7, #40]	; 0x28
    3298:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    329a:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6],  args[7],
    329c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    329e:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    32a0:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6],  args[7],
    32a2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    32a4:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    32a6:	6800      	ldr	r0, [r0, #0]
    32a8:	6178      	str	r0, [r7, #20]
				args[3], args[4], args[5], args[6],  args[7],
    32aa:	6abc      	ldr	r4, [r7, #40]	; 0x28
    32ac:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    32ae:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6],  args[7],
    32b0:	6abd      	ldr	r5, [r7, #40]	; 0x28
    32b2:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    32b4:	682d      	ldr	r5, [r5, #0]
				args[8], args[9], args[10], args[11]);
    32b6:	6abe      	ldr	r6, [r7, #40]	; 0x28
    32b8:	3620      	adds	r6, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    32ba:	6836      	ldr	r6, [r6, #0]
				args[8], args[9], args[10], args[11]);
    32bc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    32be:	f100 0c24 	add.w	ip, r0, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    32c2:	f8dc 0000 	ldr.w	r0, [ip]
    32c6:	6138      	str	r0, [r7, #16]
				args[8], args[9], args[10], args[11]);
    32c8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    32ca:	f100 0c28 	add.w	ip, r0, #40	; 0x28
		print_formatted(log_output, str, args[0], args[1], args[2],
    32ce:	f8dc 0000 	ldr.w	r0, [ip]
    32d2:	60f8      	str	r0, [r7, #12]
				args[8], args[9], args[10], args[11]);
    32d4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    32d6:	f100 0c2c 	add.w	ip, r0, #44	; 0x2c
		print_formatted(log_output, str, args[0], args[1], args[2],
    32da:	f8dc 0000 	ldr.w	r0, [ip]
    32de:	9009      	str	r0, [sp, #36]	; 0x24
    32e0:	68f8      	ldr	r0, [r7, #12]
    32e2:	9008      	str	r0, [sp, #32]
    32e4:	6938      	ldr	r0, [r7, #16]
    32e6:	9007      	str	r0, [sp, #28]
    32e8:	9606      	str	r6, [sp, #24]
    32ea:	9505      	str	r5, [sp, #20]
    32ec:	9404      	str	r4, [sp, #16]
    32ee:	6978      	ldr	r0, [r7, #20]
    32f0:	9003      	str	r0, [sp, #12]
    32f2:	9102      	str	r1, [sp, #8]
    32f4:	9201      	str	r2, [sp, #4]
    32f6:	9300      	str	r3, [sp, #0]
    32f8:	69bb      	ldr	r3, [r7, #24]
    32fa:	69fa      	ldr	r2, [r7, #28]
    32fc:	6b39      	ldr	r1, [r7, #48]	; 0x30
    32fe:	6a38      	ldr	r0, [r7, #32]
    3300:	f7ff fcdc 	bl	2cbc <print_formatted>
		break;
    3304:	e0e0      	b.n	34c8 <std_print+0x588>
	case 13:
		print_formatted(log_output, str, args[0], args[1], args[2],
    3306:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3308:	681b      	ldr	r3, [r3, #0]
    330a:	61fb      	str	r3, [r7, #28]
    330c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    330e:	3304      	adds	r3, #4
    3310:	6819      	ldr	r1, [r3, #0]
    3312:	61b9      	str	r1, [r7, #24]
    3314:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3316:	3308      	adds	r3, #8
    3318:	681b      	ldr	r3, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    331a:	6aba      	ldr	r2, [r7, #40]	; 0x28
    331c:	320c      	adds	r2, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    331e:	6812      	ldr	r2, [r2, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3320:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    3322:	3110      	adds	r1, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    3324:	6809      	ldr	r1, [r1, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3326:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3328:	3014      	adds	r0, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    332a:	6800      	ldr	r0, [r0, #0]
    332c:	6178      	str	r0, [r7, #20]
				args[3], args[4], args[5], args[6],  args[7],
    332e:	6abc      	ldr	r4, [r7, #40]	; 0x28
    3330:	3418      	adds	r4, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    3332:	6824      	ldr	r4, [r4, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3334:	6abd      	ldr	r5, [r7, #40]	; 0x28
    3336:	351c      	adds	r5, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    3338:	682d      	ldr	r5, [r5, #0]
				args[8], args[9], args[10], args[11], args[12]);
    333a:	6abe      	ldr	r6, [r7, #40]	; 0x28
    333c:	3620      	adds	r6, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    333e:	6836      	ldr	r6, [r6, #0]
				args[8], args[9], args[10], args[11], args[12]);
    3340:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3342:	f100 0c24 	add.w	ip, r0, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    3346:	f8dc 0000 	ldr.w	r0, [ip]
    334a:	6138      	str	r0, [r7, #16]
				args[8], args[9], args[10], args[11], args[12]);
    334c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    334e:	f100 0c28 	add.w	ip, r0, #40	; 0x28
		print_formatted(log_output, str, args[0], args[1], args[2],
    3352:	f8dc 0000 	ldr.w	r0, [ip]
    3356:	60f8      	str	r0, [r7, #12]
				args[8], args[9], args[10], args[11], args[12]);
    3358:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    335a:	f100 0c2c 	add.w	ip, r0, #44	; 0x2c
		print_formatted(log_output, str, args[0], args[1], args[2],
    335e:	f8dc 0000 	ldr.w	r0, [ip]
    3362:	60b8      	str	r0, [r7, #8]
				args[8], args[9], args[10], args[11], args[12]);
    3364:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    3366:	f100 0c30 	add.w	ip, r0, #48	; 0x30
		print_formatted(log_output, str, args[0], args[1], args[2],
    336a:	f8dc 0000 	ldr.w	r0, [ip]
    336e:	900a      	str	r0, [sp, #40]	; 0x28
    3370:	68b8      	ldr	r0, [r7, #8]
    3372:	9009      	str	r0, [sp, #36]	; 0x24
    3374:	68f8      	ldr	r0, [r7, #12]
    3376:	9008      	str	r0, [sp, #32]
    3378:	6938      	ldr	r0, [r7, #16]
    337a:	9007      	str	r0, [sp, #28]
    337c:	9606      	str	r6, [sp, #24]
    337e:	9505      	str	r5, [sp, #20]
    3380:	9404      	str	r4, [sp, #16]
    3382:	6978      	ldr	r0, [r7, #20]
    3384:	9003      	str	r0, [sp, #12]
    3386:	9102      	str	r1, [sp, #8]
    3388:	9201      	str	r2, [sp, #4]
    338a:	9300      	str	r3, [sp, #0]
    338c:	69bb      	ldr	r3, [r7, #24]
    338e:	69fa      	ldr	r2, [r7, #28]
    3390:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3392:	6a38      	ldr	r0, [r7, #32]
    3394:	f7ff fc92 	bl	2cbc <print_formatted>
		break;
    3398:	e096      	b.n	34c8 <std_print+0x588>
	case 14:
		print_formatted(log_output, str, args[0], args[1], args[2],
    339a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    339c:	681b      	ldr	r3, [r3, #0]
    339e:	61fb      	str	r3, [r7, #28]
    33a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33a2:	3304      	adds	r3, #4
    33a4:	6819      	ldr	r1, [r3, #0]
    33a6:	61b9      	str	r1, [r7, #24]
    33a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33aa:	3308      	adds	r3, #8
    33ac:	681a      	ldr	r2, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    33ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33b0:	330c      	adds	r3, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    33b2:	6819      	ldr	r1, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    33b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33b6:	3310      	adds	r3, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    33b8:	6818      	ldr	r0, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    33ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33bc:	3314      	adds	r3, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    33be:	681c      	ldr	r4, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    33c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33c2:	3318      	adds	r3, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    33c4:	681d      	ldr	r5, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    33c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33c8:	331c      	adds	r3, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    33ca:	681e      	ldr	r6, [r3, #0]
				args[8], args[9], args[10], args[11], args[12],
    33cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33ce:	3320      	adds	r3, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    33d0:	681b      	ldr	r3, [r3, #0]
    33d2:	617b      	str	r3, [r7, #20]
				args[8], args[9], args[10], args[11], args[12],
    33d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33d6:	3324      	adds	r3, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    33d8:	681b      	ldr	r3, [r3, #0]
    33da:	613b      	str	r3, [r7, #16]
				args[8], args[9], args[10], args[11], args[12],
    33dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33de:	3328      	adds	r3, #40	; 0x28
		print_formatted(log_output, str, args[0], args[1], args[2],
    33e0:	681b      	ldr	r3, [r3, #0]
    33e2:	60fb      	str	r3, [r7, #12]
				args[8], args[9], args[10], args[11], args[12],
    33e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33e6:	332c      	adds	r3, #44	; 0x2c
		print_formatted(log_output, str, args[0], args[1], args[2],
    33e8:	681b      	ldr	r3, [r3, #0]
    33ea:	60bb      	str	r3, [r7, #8]
				args[8], args[9], args[10], args[11], args[12],
    33ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33ee:	3330      	adds	r3, #48	; 0x30
		print_formatted(log_output, str, args[0], args[1], args[2],
    33f0:	681b      	ldr	r3, [r3, #0]
    33f2:	607b      	str	r3, [r7, #4]
				args[13]);
    33f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    33f6:	3334      	adds	r3, #52	; 0x34
		print_formatted(log_output, str, args[0], args[1], args[2],
    33f8:	681b      	ldr	r3, [r3, #0]
    33fa:	930b      	str	r3, [sp, #44]	; 0x2c
    33fc:	687b      	ldr	r3, [r7, #4]
    33fe:	930a      	str	r3, [sp, #40]	; 0x28
    3400:	68bb      	ldr	r3, [r7, #8]
    3402:	9309      	str	r3, [sp, #36]	; 0x24
    3404:	68fb      	ldr	r3, [r7, #12]
    3406:	9308      	str	r3, [sp, #32]
    3408:	693b      	ldr	r3, [r7, #16]
    340a:	9307      	str	r3, [sp, #28]
    340c:	697b      	ldr	r3, [r7, #20]
    340e:	9306      	str	r3, [sp, #24]
    3410:	9605      	str	r6, [sp, #20]
    3412:	9504      	str	r5, [sp, #16]
    3414:	9403      	str	r4, [sp, #12]
    3416:	9002      	str	r0, [sp, #8]
    3418:	9101      	str	r1, [sp, #4]
    341a:	9200      	str	r2, [sp, #0]
    341c:	69bb      	ldr	r3, [r7, #24]
    341e:	69fa      	ldr	r2, [r7, #28]
    3420:	6b39      	ldr	r1, [r7, #48]	; 0x30
    3422:	6a38      	ldr	r0, [r7, #32]
    3424:	f7ff fc4a 	bl	2cbc <print_formatted>
		break;
    3428:	e04e      	b.n	34c8 <std_print+0x588>
	case 15:
		print_formatted(log_output, str, args[0], args[1], args[2],
    342a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    342c:	681b      	ldr	r3, [r3, #0]
    342e:	61fb      	str	r3, [r7, #28]
    3430:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3432:	3304      	adds	r3, #4
    3434:	6819      	ldr	r1, [r3, #0]
    3436:	61b9      	str	r1, [r7, #24]
    3438:	6abb      	ldr	r3, [r7, #40]	; 0x28
    343a:	3308      	adds	r3, #8
    343c:	6819      	ldr	r1, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    343e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3440:	330c      	adds	r3, #12
		print_formatted(log_output, str, args[0], args[1], args[2],
    3442:	6818      	ldr	r0, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3444:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3446:	3310      	adds	r3, #16
		print_formatted(log_output, str, args[0], args[1], args[2],
    3448:	681c      	ldr	r4, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    344a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    344c:	3314      	adds	r3, #20
		print_formatted(log_output, str, args[0], args[1], args[2],
    344e:	681d      	ldr	r5, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3450:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3452:	3318      	adds	r3, #24
		print_formatted(log_output, str, args[0], args[1], args[2],
    3454:	681e      	ldr	r6, [r3, #0]
				args[3], args[4], args[5], args[6],  args[7],
    3456:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3458:	331c      	adds	r3, #28
		print_formatted(log_output, str, args[0], args[1], args[2],
    345a:	681a      	ldr	r2, [r3, #0]
    345c:	617a      	str	r2, [r7, #20]
				args[8], args[9], args[10], args[11], args[12],
    345e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3460:	3320      	adds	r3, #32
		print_formatted(log_output, str, args[0], args[1], args[2],
    3462:	681b      	ldr	r3, [r3, #0]
    3464:	613b      	str	r3, [r7, #16]
				args[8], args[9], args[10], args[11], args[12],
    3466:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3468:	3324      	adds	r3, #36	; 0x24
		print_formatted(log_output, str, args[0], args[1], args[2],
    346a:	681a      	ldr	r2, [r3, #0]
    346c:	60fa      	str	r2, [r7, #12]
				args[8], args[9], args[10], args[11], args[12],
    346e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3470:	3328      	adds	r3, #40	; 0x28
		print_formatted(log_output, str, args[0], args[1], args[2],
    3472:	681b      	ldr	r3, [r3, #0]
    3474:	60bb      	str	r3, [r7, #8]
				args[8], args[9], args[10], args[11], args[12],
    3476:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3478:	332c      	adds	r3, #44	; 0x2c
		print_formatted(log_output, str, args[0], args[1], args[2],
    347a:	681a      	ldr	r2, [r3, #0]
    347c:	607a      	str	r2, [r7, #4]
				args[8], args[9], args[10], args[11], args[12],
    347e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3480:	3330      	adds	r3, #48	; 0x30
		print_formatted(log_output, str, args[0], args[1], args[2],
    3482:	681b      	ldr	r3, [r3, #0]
    3484:	603b      	str	r3, [r7, #0]
				args[13], args[14]);
    3486:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3488:	3334      	adds	r3, #52	; 0x34
		print_formatted(log_output, str, args[0], args[1], args[2],
    348a:	681a      	ldr	r2, [r3, #0]
				args[13], args[14]);
    348c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    348e:	3338      	adds	r3, #56	; 0x38
		print_formatted(log_output, str, args[0], args[1], args[2],
    3490:	681b      	ldr	r3, [r3, #0]
    3492:	930c      	str	r3, [sp, #48]	; 0x30
    3494:	920b      	str	r2, [sp, #44]	; 0x2c
    3496:	683b      	ldr	r3, [r7, #0]
    3498:	930a      	str	r3, [sp, #40]	; 0x28
    349a:	687a      	ldr	r2, [r7, #4]
    349c:	9209      	str	r2, [sp, #36]	; 0x24
    349e:	68bb      	ldr	r3, [r7, #8]
    34a0:	9308      	str	r3, [sp, #32]
    34a2:	68fa      	ldr	r2, [r7, #12]
    34a4:	9207      	str	r2, [sp, #28]
    34a6:	693b      	ldr	r3, [r7, #16]
    34a8:	9306      	str	r3, [sp, #24]
    34aa:	697a      	ldr	r2, [r7, #20]
    34ac:	9205      	str	r2, [sp, #20]
    34ae:	9604      	str	r6, [sp, #16]
    34b0:	9503      	str	r5, [sp, #12]
    34b2:	9402      	str	r4, [sp, #8]
    34b4:	9001      	str	r0, [sp, #4]
    34b6:	9100      	str	r1, [sp, #0]
    34b8:	69bb      	ldr	r3, [r7, #24]
    34ba:	69fa      	ldr	r2, [r7, #28]
    34bc:	6b39      	ldr	r1, [r7, #48]	; 0x30
    34be:	6a38      	ldr	r0, [r7, #32]
    34c0:	f7ff fbfc 	bl	2cbc <print_formatted>
		break;
    34c4:	e000      	b.n	34c8 <std_print+0x588>
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
    34c6:	bf00      	nop
	}
}
    34c8:	bf00      	nop
    34ca:	373c      	adds	r7, #60	; 0x3c
    34cc:	46bd      	mov	sp, r7
    34ce:	bdf0      	pop	{r4, r5, r6, r7, pc}

000034d0 <hexdump_line_print>:

static void hexdump_line_print(const struct log_output *log_output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    34d0:	b580      	push	{r7, lr}
    34d2:	b088      	sub	sp, #32
    34d4:	af00      	add	r7, sp, #0
    34d6:	60f8      	str	r0, [r7, #12]
    34d8:	60b9      	str	r1, [r7, #8]
    34da:	607a      	str	r2, [r7, #4]
    34dc:	603b      	str	r3, [r7, #0]
	newline_print(log_output, flags);
    34de:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    34e0:	68f8      	ldr	r0, [r7, #12]
    34e2:	f7ff fd0b 	bl	2efc <newline_print>

	for (int i = 0; i < prefix_offset; i++) {
    34e6:	2300      	movs	r3, #0
    34e8:	61fb      	str	r3, [r7, #28]
    34ea:	e006      	b.n	34fa <hexdump_line_print+0x2a>
		print_formatted(log_output, " ");
    34ec:	4936      	ldr	r1, [pc, #216]	; (35c8 <hexdump_line_print+0xf8>)
    34ee:	68f8      	ldr	r0, [r7, #12]
    34f0:	f7ff fbe4 	bl	2cbc <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    34f4:	69fb      	ldr	r3, [r7, #28]
    34f6:	3301      	adds	r3, #1
    34f8:	61fb      	str	r3, [r7, #28]
    34fa:	69fa      	ldr	r2, [r7, #28]
    34fc:	683b      	ldr	r3, [r7, #0]
    34fe:	429a      	cmp	r2, r3
    3500:	dbf4      	blt.n	34ec <hexdump_line_print+0x1c>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    3502:	2300      	movs	r3, #0
    3504:	61bb      	str	r3, [r7, #24]
    3506:	e020      	b.n	354a <hexdump_line_print+0x7a>
		if (i > 0 && !(i % 8)) {
    3508:	69bb      	ldr	r3, [r7, #24]
    350a:	2b00      	cmp	r3, #0
    350c:	dd08      	ble.n	3520 <hexdump_line_print+0x50>
    350e:	69bb      	ldr	r3, [r7, #24]
    3510:	f003 0307 	and.w	r3, r3, #7
    3514:	2b00      	cmp	r3, #0
    3516:	d103      	bne.n	3520 <hexdump_line_print+0x50>
			print_formatted(log_output, " ");
    3518:	492b      	ldr	r1, [pc, #172]	; (35c8 <hexdump_line_print+0xf8>)
    351a:	68f8      	ldr	r0, [r7, #12]
    351c:	f7ff fbce 	bl	2cbc <print_formatted>
		}

		if (i < length) {
    3520:	69bb      	ldr	r3, [r7, #24]
    3522:	687a      	ldr	r2, [r7, #4]
    3524:	429a      	cmp	r2, r3
    3526:	d909      	bls.n	353c <hexdump_line_print+0x6c>
			print_formatted(log_output, "%02x ", data[i]);
    3528:	69bb      	ldr	r3, [r7, #24]
    352a:	68ba      	ldr	r2, [r7, #8]
    352c:	4413      	add	r3, r2
    352e:	781b      	ldrb	r3, [r3, #0]
    3530:	461a      	mov	r2, r3
    3532:	4926      	ldr	r1, [pc, #152]	; (35cc <hexdump_line_print+0xfc>)
    3534:	68f8      	ldr	r0, [r7, #12]
    3536:	f7ff fbc1 	bl	2cbc <print_formatted>
    353a:	e003      	b.n	3544 <hexdump_line_print+0x74>
		} else {
			print_formatted(log_output, "   ");
    353c:	4924      	ldr	r1, [pc, #144]	; (35d0 <hexdump_line_print+0x100>)
    353e:	68f8      	ldr	r0, [r7, #12]
    3540:	f7ff fbbc 	bl	2cbc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    3544:	69bb      	ldr	r3, [r7, #24]
    3546:	3301      	adds	r3, #1
    3548:	61bb      	str	r3, [r7, #24]
    354a:	69bb      	ldr	r3, [r7, #24]
    354c:	2b0f      	cmp	r3, #15
    354e:	dddb      	ble.n	3508 <hexdump_line_print+0x38>
		}
	}

	print_formatted(log_output, "|");
    3550:	4920      	ldr	r1, [pc, #128]	; (35d4 <hexdump_line_print+0x104>)
    3552:	68f8      	ldr	r0, [r7, #12]
    3554:	f7ff fbb2 	bl	2cbc <print_formatted>

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    3558:	2300      	movs	r3, #0
    355a:	617b      	str	r3, [r7, #20]
    355c:	e02b      	b.n	35b6 <hexdump_line_print+0xe6>
		if (i > 0 && !(i % 8)) {
    355e:	697b      	ldr	r3, [r7, #20]
    3560:	2b00      	cmp	r3, #0
    3562:	dd08      	ble.n	3576 <hexdump_line_print+0xa6>
    3564:	697b      	ldr	r3, [r7, #20]
    3566:	f003 0307 	and.w	r3, r3, #7
    356a:	2b00      	cmp	r3, #0
    356c:	d103      	bne.n	3576 <hexdump_line_print+0xa6>
			print_formatted(log_output, " ");
    356e:	4916      	ldr	r1, [pc, #88]	; (35c8 <hexdump_line_print+0xf8>)
    3570:	68f8      	ldr	r0, [r7, #12]
    3572:	f7ff fba3 	bl	2cbc <print_formatted>
		}

		if (i < length) {
    3576:	697b      	ldr	r3, [r7, #20]
    3578:	687a      	ldr	r2, [r7, #4]
    357a:	429a      	cmp	r2, r3
    357c:	d914      	bls.n	35a8 <hexdump_line_print+0xd8>
			char c = (char)data[i];
    357e:	697b      	ldr	r3, [r7, #20]
    3580:	68ba      	ldr	r2, [r7, #8]
    3582:	4413      	add	r3, r2
    3584:	781b      	ldrb	r3, [r3, #0]
    3586:	74fb      	strb	r3, [r7, #19]

			print_formatted(log_output, "%c",
			      isprint((int)c) ? c : '.');
    3588:	7cfb      	ldrb	r3, [r7, #19]
    358a:	4618      	mov	r0, r3
    358c:	f00e fce1 	bl	11f52 <isprint>
    3590:	4603      	mov	r3, r0
			print_formatted(log_output, "%c",
    3592:	2b00      	cmp	r3, #0
    3594:	d001      	beq.n	359a <hexdump_line_print+0xca>
    3596:	7cfb      	ldrb	r3, [r7, #19]
    3598:	e000      	b.n	359c <hexdump_line_print+0xcc>
    359a:	232e      	movs	r3, #46	; 0x2e
    359c:	461a      	mov	r2, r3
    359e:	490e      	ldr	r1, [pc, #56]	; (35d8 <hexdump_line_print+0x108>)
    35a0:	68f8      	ldr	r0, [r7, #12]
    35a2:	f7ff fb8b 	bl	2cbc <print_formatted>
    35a6:	e003      	b.n	35b0 <hexdump_line_print+0xe0>
		} else {
			print_formatted(log_output, " ");
    35a8:	4907      	ldr	r1, [pc, #28]	; (35c8 <hexdump_line_print+0xf8>)
    35aa:	68f8      	ldr	r0, [r7, #12]
    35ac:	f7ff fb86 	bl	2cbc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    35b0:	697b      	ldr	r3, [r7, #20]
    35b2:	3301      	adds	r3, #1
    35b4:	617b      	str	r3, [r7, #20]
    35b6:	697b      	ldr	r3, [r7, #20]
    35b8:	2b0f      	cmp	r3, #15
    35ba:	ddd0      	ble.n	355e <hexdump_line_print+0x8e>
		}
	}
}
    35bc:	bf00      	nop
    35be:	bf00      	nop
    35c0:	3720      	adds	r7, #32
    35c2:	46bd      	mov	sp, r7
    35c4:	bd80      	pop	{r7, pc}
    35c6:	bf00      	nop
    35c8:	00019060 	.word	0x00019060
    35cc:	00019064 	.word	0x00019064
    35d0:	0001906c 	.word	0x0001906c
    35d4:	00019070 	.word	0x00019070
    35d8:	00019074 	.word	0x00019074

000035dc <hexdump_print>:

static void hexdump_print(struct log_msg *msg,
			  const struct log_output *log_output,
			  int prefix_offset, uint32_t flags)
{
    35dc:	b580      	push	{r7, lr}
    35de:	b08c      	sub	sp, #48	; 0x30
    35e0:	af02      	add	r7, sp, #8
    35e2:	60f8      	str	r0, [r7, #12]
    35e4:	60b9      	str	r1, [r7, #8]
    35e6:	607a      	str	r2, [r7, #4]
    35e8:	603b      	str	r3, [r7, #0]
	uint32_t offset = 0U;
    35ea:	2300      	movs	r3, #0
    35ec:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t buf[HEXDUMP_BYTES_IN_LINE];
	size_t length;

	print_formatted(log_output, "%s", log_msg_str_get(msg));
    35ee:	68f8      	ldr	r0, [r7, #12]
    35f0:	f00e faed 	bl	11bce <log_msg_str_get>
    35f4:	4603      	mov	r3, r0
    35f6:	461a      	mov	r2, r3
    35f8:	4911      	ldr	r1, [pc, #68]	; (3640 <hexdump_print+0x64>)
    35fa:	68b8      	ldr	r0, [r7, #8]
    35fc:	f7ff fb5e 	bl	2cbc <print_formatted>

	do {
		length = sizeof(buf);
    3600:	2310      	movs	r3, #16
    3602:	613b      	str	r3, [r7, #16]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    3604:	f107 0210 	add.w	r2, r7, #16
    3608:	f107 0114 	add.w	r1, r7, #20
    360c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    360e:	68f8      	ldr	r0, [r7, #12]
    3610:	f00e fc21 	bl	11e56 <log_msg_hexdump_data_get>

		if (length) {
    3614:	693b      	ldr	r3, [r7, #16]
    3616:	2b00      	cmp	r3, #0
    3618:	d00d      	beq.n	3636 <hexdump_print+0x5a>
			hexdump_line_print(log_output, buf, length,
    361a:	693a      	ldr	r2, [r7, #16]
    361c:	f107 0114 	add.w	r1, r7, #20
    3620:	683b      	ldr	r3, [r7, #0]
    3622:	9300      	str	r3, [sp, #0]
    3624:	687b      	ldr	r3, [r7, #4]
    3626:	68b8      	ldr	r0, [r7, #8]
    3628:	f7ff ff52 	bl	34d0 <hexdump_line_print>
					   prefix_offset, flags);
			offset += length;
    362c:	693b      	ldr	r3, [r7, #16]
    362e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    3630:	4413      	add	r3, r2
    3632:	627b      	str	r3, [r7, #36]	; 0x24
		length = sizeof(buf);
    3634:	e7e4      	b.n	3600 <hexdump_print+0x24>
		} else {
			break;
    3636:	bf00      	nop
		}
	} while (true);
}
    3638:	bf00      	nop
    363a:	3728      	adds	r7, #40	; 0x28
    363c:	46bd      	mov	sp, r7
    363e:	bd80      	pop	{r7, pc}
    3640:	00019040 	.word	0x00019040

00003644 <raw_string_print>:

static void raw_string_print(struct log_msg *msg,
			     const struct log_output *log_output)
{
    3644:	b580      	push	{r7, lr}
    3646:	b086      	sub	sp, #24
    3648:	af00      	add	r7, sp, #0
    364a:	6078      	str	r0, [r7, #4]
    364c:	6039      	str	r1, [r7, #0]
	__ASSERT_NO_MSG(log_output->size);
    364e:	683b      	ldr	r3, [r7, #0]
    3650:	68db      	ldr	r3, [r3, #12]
    3652:	2b00      	cmp	r3, #0
    3654:	d10b      	bne.n	366e <raw_string_print+0x2a>
    3656:	f44f 73d9 	mov.w	r3, #434	; 0x1b2
    365a:	4a20      	ldr	r2, [pc, #128]	; (36dc <raw_string_print+0x98>)
    365c:	4920      	ldr	r1, [pc, #128]	; (36e0 <raw_string_print+0x9c>)
    365e:	4821      	ldr	r0, [pc, #132]	; (36e4 <raw_string_print+0xa0>)
    3660:	f00c fd02 	bl	10068 <printk>
    3664:	f44f 71d9 	mov.w	r1, #434	; 0x1b2
    3668:	481c      	ldr	r0, [pc, #112]	; (36dc <raw_string_print+0x98>)
    366a:	f00d fb45 	bl	10cf8 <assert_post_action>

	size_t offset = 0;
    366e:	2300      	movs	r3, #0
    3670:	617b      	str	r3, [r7, #20]
	size_t length;
	bool eol = false;
    3672:	2300      	movs	r3, #0
    3674:	74fb      	strb	r3, [r7, #19]

	do {
		length = log_output->size;
    3676:	683b      	ldr	r3, [r7, #0]
    3678:	68db      	ldr	r3, [r3, #12]
    367a:	60fb      	str	r3, [r7, #12]
		/* Sting is stored in a hexdump message. */
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    367c:	683b      	ldr	r3, [r7, #0]
    367e:	6899      	ldr	r1, [r3, #8]
    3680:	f107 020c 	add.w	r2, r7, #12
    3684:	697b      	ldr	r3, [r7, #20]
    3686:	6878      	ldr	r0, [r7, #4]
    3688:	f00e fbe5 	bl	11e56 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    368c:	68fa      	ldr	r2, [r7, #12]
    368e:	683b      	ldr	r3, [r7, #0]
    3690:	685b      	ldr	r3, [r3, #4]
    3692:	601a      	str	r2, [r3, #0]

		if (length != 0) {
    3694:	68fb      	ldr	r3, [r7, #12]
    3696:	2b00      	cmp	r3, #0
    3698:	d00a      	beq.n	36b0 <raw_string_print+0x6c>
			eol = (log_output->buf[length - 1] == '\n');
    369a:	683b      	ldr	r3, [r7, #0]
    369c:	689a      	ldr	r2, [r3, #8]
    369e:	68fb      	ldr	r3, [r7, #12]
    36a0:	3b01      	subs	r3, #1
    36a2:	4413      	add	r3, r2
    36a4:	781b      	ldrb	r3, [r3, #0]
    36a6:	2b0a      	cmp	r3, #10
    36a8:	bf0c      	ite	eq
    36aa:	2301      	moveq	r3, #1
    36ac:	2300      	movne	r3, #0
    36ae:	74fb      	strb	r3, [r7, #19]
		}

		log_output_flush(log_output);
    36b0:	6838      	ldr	r0, [r7, #0]
    36b2:	f00e fc7d 	bl	11fb0 <log_output_flush>
		offset += length;
    36b6:	68fb      	ldr	r3, [r7, #12]
    36b8:	697a      	ldr	r2, [r7, #20]
    36ba:	4413      	add	r3, r2
    36bc:	617b      	str	r3, [r7, #20]
	} while (length > 0);
    36be:	68fb      	ldr	r3, [r7, #12]
    36c0:	2b00      	cmp	r3, #0
    36c2:	d1d8      	bne.n	3676 <raw_string_print+0x32>

	if (eol) {
    36c4:	7cfb      	ldrb	r3, [r7, #19]
    36c6:	2b00      	cmp	r3, #0
    36c8:	d003      	beq.n	36d2 <raw_string_print+0x8e>
		print_formatted(log_output, "\r");
    36ca:	4907      	ldr	r1, [pc, #28]	; (36e8 <raw_string_print+0xa4>)
    36cc:	6838      	ldr	r0, [r7, #0]
    36ce:	f7ff faf5 	bl	2cbc <print_formatted>
	}
}
    36d2:	bf00      	nop
    36d4:	3718      	adds	r7, #24
    36d6:	46bd      	mov	sp, r7
    36d8:	bd80      	pop	{r7, pc}
    36da:	bf00      	nop
    36dc:	00018f90 	.word	0x00018f90
    36e0:	00019078 	.word	0x00019078
    36e4:	00018ff0 	.word	0x00018ff0
    36e8:	0001908c 	.word	0x0001908c

000036ec <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, uint32_t cnt)
{
    36ec:	b580      	push	{r7, lr}
    36ee:	b086      	sub	sp, #24
    36f0:	af00      	add	r7, sp, #0
    36f2:	6078      	str	r0, [r7, #4]
    36f4:	6039      	str	r1, [r7, #0]
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
    36f6:	687b      	ldr	r3, [r7, #4]
    36f8:	681b      	ldr	r3, [r3, #0]
    36fa:	617b      	str	r3, [r7, #20]

	cnt = MIN(cnt, 9999);
    36fc:	683b      	ldr	r3, [r7, #0]
    36fe:	f242 720f 	movw	r2, #9999	; 0x270f
    3702:	4293      	cmp	r3, r2
    3704:	bf28      	it	cs
    3706:	4613      	movcs	r3, r2
    3708:	603b      	str	r3, [r7, #0]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    370a:	f107 0008 	add.w	r0, r7, #8
    370e:	683b      	ldr	r3, [r7, #0]
    3710:	4a10      	ldr	r2, [pc, #64]	; (3754 <log_output_dropped_process+0x68>)
    3712:	2105      	movs	r1, #5
    3714:	f00c fcf3 	bl	100fe <snprintk>
    3718:	6138      	str	r0, [r7, #16]

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
		     log_output->control_block->ctx);
    371a:	687b      	ldr	r3, [r7, #4]
    371c:	685b      	ldr	r3, [r3, #4]
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    371e:	685b      	ldr	r3, [r3, #4]
    3720:	220b      	movs	r2, #11
    3722:	490d      	ldr	r1, [pc, #52]	; (3758 <log_output_dropped_process+0x6c>)
    3724:	6978      	ldr	r0, [r7, #20]
    3726:	f00e fc26 	bl	11f76 <buffer_write>
	buffer_write(outf, buf, len, log_output->control_block->ctx);
    372a:	693a      	ldr	r2, [r7, #16]
    372c:	687b      	ldr	r3, [r7, #4]
    372e:	685b      	ldr	r3, [r3, #4]
    3730:	685b      	ldr	r3, [r3, #4]
    3732:	f107 0108 	add.w	r1, r7, #8
    3736:	6978      	ldr	r0, [r7, #20]
    3738:	f00e fc1d 	bl	11f76 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
		     log_output->control_block->ctx);
    373c:	687b      	ldr	r3, [r7, #4]
    373e:	685b      	ldr	r3, [r3, #4]
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    3740:	685b      	ldr	r3, [r3, #4]
    3742:	221b      	movs	r2, #27
    3744:	4905      	ldr	r1, [pc, #20]	; (375c <log_output_dropped_process+0x70>)
    3746:	6978      	ldr	r0, [r7, #20]
    3748:	f00e fc15 	bl	11f76 <buffer_write>
}
    374c:	bf00      	nop
    374e:	3718      	adds	r7, #24
    3750:	46bd      	mov	sp, r7
    3752:	bd80      	pop	{r7, pc}
    3754:	00019090 	.word	0x00019090
    3758:	0001ca80 	.word	0x0001ca80
    375c:	0001ca8c 	.word	0x0001ca8c

00003760 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
    3760:	b480      	push	{r7}
    3762:	b083      	sub	sp, #12
    3764:	af00      	add	r7, sp, #0
    3766:	6078      	str	r0, [r7, #4]
	timestamp_div = 1U;
    3768:	4b0b      	ldr	r3, [pc, #44]	; (3798 <log_output_timestamp_freq_set+0x38>)
    376a:	2201      	movs	r2, #1
    376c:	601a      	str	r2, [r3, #0]
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    376e:	e007      	b.n	3780 <log_output_timestamp_freq_set+0x20>
		frequency /= 2U;
    3770:	687b      	ldr	r3, [r7, #4]
    3772:	085b      	lsrs	r3, r3, #1
    3774:	607b      	str	r3, [r7, #4]
		timestamp_div *= 2U;
    3776:	4b08      	ldr	r3, [pc, #32]	; (3798 <log_output_timestamp_freq_set+0x38>)
    3778:	681b      	ldr	r3, [r3, #0]
    377a:	005b      	lsls	r3, r3, #1
    377c:	4a06      	ldr	r2, [pc, #24]	; (3798 <log_output_timestamp_freq_set+0x38>)
    377e:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    3780:	687b      	ldr	r3, [r7, #4]
    3782:	4a06      	ldr	r2, [pc, #24]	; (379c <log_output_timestamp_freq_set+0x3c>)
    3784:	4293      	cmp	r3, r2
    3786:	d8f3      	bhi.n	3770 <log_output_timestamp_freq_set+0x10>
	}

	freq = frequency;
    3788:	4a05      	ldr	r2, [pc, #20]	; (37a0 <log_output_timestamp_freq_set+0x40>)
    378a:	687b      	ldr	r3, [r7, #4]
    378c:	6013      	str	r3, [r2, #0]
}
    378e:	bf00      	nop
    3790:	370c      	adds	r7, #12
    3792:	46bd      	mov	sp, r7
    3794:	bc80      	pop	{r7}
    3796:	4770      	bx	lr
    3798:	20000694 	.word	0x20000694
    379c:	000f4240 	.word	0x000f4240
    37a0:	20000690 	.word	0x20000690

000037a4 <char_out>:
#include <sys/__assert.h>

static const struct device *uart_dev;

static int char_out(uint8_t *data, size_t length, void *ctx)
{
    37a4:	b580      	push	{r7, lr}
    37a6:	b086      	sub	sp, #24
    37a8:	af00      	add	r7, sp, #0
    37aa:	60f8      	str	r0, [r7, #12]
    37ac:	60b9      	str	r1, [r7, #8]
    37ae:	607a      	str	r2, [r7, #4]
	ARG_UNUSED(ctx);

	for (size_t i = 0; i < length; i++) {
    37b0:	2300      	movs	r3, #0
    37b2:	617b      	str	r3, [r7, #20]
    37b4:	e00b      	b.n	37ce <char_out+0x2a>
		uart_poll_out(uart_dev, data[i]);
    37b6:	4b0a      	ldr	r3, [pc, #40]	; (37e0 <char_out+0x3c>)
    37b8:	6818      	ldr	r0, [r3, #0]
    37ba:	68fa      	ldr	r2, [r7, #12]
    37bc:	697b      	ldr	r3, [r7, #20]
    37be:	4413      	add	r3, r2
    37c0:	781b      	ldrb	r3, [r3, #0]
    37c2:	4619      	mov	r1, r3
    37c4:	f00e fd55 	bl	12272 <uart_poll_out>
	for (size_t i = 0; i < length; i++) {
    37c8:	697b      	ldr	r3, [r7, #20]
    37ca:	3301      	adds	r3, #1
    37cc:	617b      	str	r3, [r7, #20]
    37ce:	697a      	ldr	r2, [r7, #20]
    37d0:	68bb      	ldr	r3, [r7, #8]
    37d2:	429a      	cmp	r2, r3
    37d4:	d3ef      	bcc.n	37b6 <char_out+0x12>
	}

	return length;
    37d6:	68bb      	ldr	r3, [r7, #8]
}
    37d8:	4618      	mov	r0, r3
    37da:	3718      	adds	r7, #24
    37dc:	46bd      	mov	sp, r7
    37de:	bd80      	pop	{r7, pc}
    37e0:	20000698 	.word	0x20000698

000037e4 <put>:

LOG_OUTPUT_DEFINE(log_output_uart, char_out, &uart_output_buf, 1);

static void put(const struct log_backend *const backend,
		struct log_msg *msg)
{
    37e4:	b580      	push	{r7, lr}
    37e6:	b084      	sub	sp, #16
    37e8:	af00      	add	r7, sp, #0
    37ea:	6078      	str	r0, [r7, #4]
    37ec:	6039      	str	r1, [r7, #0]
	uint32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_UART_SYST_ENABLE) ?
    37ee:	2300      	movs	r3, #0
    37f0:	60fb      	str	r3, [r7, #12]
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_put(&log_output_uart, flag, msg);
    37f2:	683a      	ldr	r2, [r7, #0]
    37f4:	68f9      	ldr	r1, [r7, #12]
    37f6:	4803      	ldr	r0, [pc, #12]	; (3804 <put+0x20>)
    37f8:	f00e fce3 	bl	121c2 <log_backend_std_put>
}
    37fc:	bf00      	nop
    37fe:	3710      	adds	r7, #16
    3800:	46bd      	mov	sp, r7
    3802:	bd80      	pop	{r7, pc}
    3804:	0001caa8 	.word	0x0001caa8

00003808 <log_backend_uart_init>:

static void log_backend_uart_init(void)
{
    3808:	b580      	push	{r7, lr}
    380a:	af00      	add	r7, sp, #0
	uart_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    380c:	480a      	ldr	r0, [pc, #40]	; (3838 <log_backend_uart_init+0x30>)
    380e:	f00e fd11 	bl	12234 <device_get_binding>
    3812:	4603      	mov	r3, r0
    3814:	4a09      	ldr	r2, [pc, #36]	; (383c <log_backend_uart_init+0x34>)
    3816:	6013      	str	r3, [r2, #0]
	__ASSERT_NO_MSG((void *)uart_dev);
    3818:	4b08      	ldr	r3, [pc, #32]	; (383c <log_backend_uart_init+0x34>)
    381a:	681b      	ldr	r3, [r3, #0]
    381c:	2b00      	cmp	r3, #0
    381e:	d109      	bne.n	3834 <log_backend_uart_init+0x2c>
    3820:	232d      	movs	r3, #45	; 0x2d
    3822:	4a07      	ldr	r2, [pc, #28]	; (3840 <log_backend_uart_init+0x38>)
    3824:	4907      	ldr	r1, [pc, #28]	; (3844 <log_backend_uart_init+0x3c>)
    3826:	4808      	ldr	r0, [pc, #32]	; (3848 <log_backend_uart_init+0x40>)
    3828:	f00c fc1e 	bl	10068 <printk>
    382c:	212d      	movs	r1, #45	; 0x2d
    382e:	4804      	ldr	r0, [pc, #16]	; (3840 <log_backend_uart_init+0x38>)
    3830:	f00d fa62 	bl	10cf8 <assert_post_action>
}
    3834:	bf00      	nop
    3836:	bd80      	pop	{r7, pc}
    3838:	00019094 	.word	0x00019094
    383c:	20000698 	.word	0x20000698
    3840:	0001909c 	.word	0x0001909c
    3844:	000190d4 	.word	0x000190d4
    3848:	000190e8 	.word	0x000190e8

0000384c <panic>:

static void panic(struct log_backend const *const backend)
{
    384c:	b580      	push	{r7, lr}
    384e:	b082      	sub	sp, #8
    3850:	af00      	add	r7, sp, #0
    3852:	6078      	str	r0, [r7, #4]
	log_backend_std_panic(&log_output_uart);
    3854:	4803      	ldr	r0, [pc, #12]	; (3864 <panic+0x18>)
    3856:	f00e fcd5 	bl	12204 <log_backend_std_panic>
}
    385a:	bf00      	nop
    385c:	3708      	adds	r7, #8
    385e:	46bd      	mov	sp, r7
    3860:	bd80      	pop	{r7, pc}
    3862:	bf00      	nop
    3864:	0001caa8 	.word	0x0001caa8

00003868 <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    3868:	b580      	push	{r7, lr}
    386a:	b082      	sub	sp, #8
    386c:	af00      	add	r7, sp, #0
    386e:	6078      	str	r0, [r7, #4]
    3870:	6039      	str	r1, [r7, #0]
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output_uart, cnt);
    3872:	6839      	ldr	r1, [r7, #0]
    3874:	4803      	ldr	r0, [pc, #12]	; (3884 <dropped+0x1c>)
    3876:	f00e fcd0 	bl	1221a <log_backend_std_dropped>
}
    387a:	bf00      	nop
    387c:	3708      	adds	r7, #8
    387e:	46bd      	mov	sp, r7
    3880:	bd80      	pop	{r7, pc}
    3882:	bf00      	nop
    3884:	0001caa8 	.word	0x0001caa8

00003888 <sys_reboot>:

extern void sys_arch_reboot(int type);
extern void sys_clock_disable(void);

void sys_reboot(int type)
{
    3888:	b580      	push	{r7, lr}
    388a:	b084      	sub	sp, #16
    388c:	af00      	add	r7, sp, #0
    388e:	6078      	str	r0, [r7, #4]
	__asm__ volatile(
    3890:	f04f 0320 	mov.w	r3, #32
    3894:	f3ef 8211 	mrs	r2, BASEPRI
    3898:	f383 8811 	msr	BASEPRI, r3
    389c:	f3bf 8f6f 	isb	sy
    38a0:	60fa      	str	r2, [r7, #12]
    38a2:	60bb      	str	r3, [r7, #8]
	(void)irq_lock();
#ifdef CONFIG_SYS_CLOCK_EXISTS
	sys_clock_disable();
    38a4:	f00f f8ec 	bl	12a80 <sys_clock_disable>
#endif

	sys_arch_reboot(type);
    38a8:	6878      	ldr	r0, [r7, #4]
    38aa:	f00f fb00 	bl	12eae <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
    38ae:	4803      	ldr	r0, [pc, #12]	; (38bc <sys_reboot+0x34>)
    38b0:	f00c fbda 	bl	10068 <printk>
	for (;;) {
		k_cpu_idle();
    38b4:	f00e fcec 	bl	12290 <k_cpu_idle>
    38b8:	e7fc      	b.n	38b4 <sys_reboot+0x2c>
    38ba:	bf00      	nop
    38bc:	000191e4 	.word	0x000191e4

000038c0 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    38c0:	b580      	push	{r7, lr}
    38c2:	b082      	sub	sp, #8
    38c4:	af00      	add	r7, sp, #0
    38c6:	6078      	str	r0, [r7, #4]
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    38c8:	687b      	ldr	r3, [r7, #4]
    38ca:	2b0a      	cmp	r3, #10
    38cc:	d105      	bne.n	38da <console_out+0x1a>
		uart_poll_out(uart_console_dev, '\r');
    38ce:	4b09      	ldr	r3, [pc, #36]	; (38f4 <console_out+0x34>)
    38d0:	681b      	ldr	r3, [r3, #0]
    38d2:	210d      	movs	r1, #13
    38d4:	4618      	mov	r0, r3
    38d6:	f00e fd00 	bl	122da <uart_poll_out>
	}
	uart_poll_out(uart_console_dev, c);
    38da:	4b06      	ldr	r3, [pc, #24]	; (38f4 <console_out+0x34>)
    38dc:	681b      	ldr	r3, [r3, #0]
    38de:	687a      	ldr	r2, [r7, #4]
    38e0:	b2d2      	uxtb	r2, r2
    38e2:	4611      	mov	r1, r2
    38e4:	4618      	mov	r0, r3
    38e6:	f00e fcf8 	bl	122da <uart_poll_out>

	return c;
    38ea:	687b      	ldr	r3, [r7, #4]
}
    38ec:	4618      	mov	r0, r3
    38ee:	3708      	adds	r7, #8
    38f0:	46bd      	mov	sp, r7
    38f2:	bd80      	pop	{r7, pc}
    38f4:	200006b0 	.word	0x200006b0

000038f8 <uart_console_hook_install>:
 *
 * @return N/A
 */

static void uart_console_hook_install(void)
{
    38f8:	b580      	push	{r7, lr}
    38fa:	af00      	add	r7, sp, #0
	__stdout_hook_install(console_out);
    38fc:	4803      	ldr	r0, [pc, #12]	; (390c <uart_console_hook_install+0x14>)
    38fe:	f003 fa09 	bl	6d14 <__stdout_hook_install>
	__printk_hook_install(console_out);
    3902:	4802      	ldr	r0, [pc, #8]	; (390c <uart_console_hook_install+0x14>)
    3904:	f7fc fe76 	bl	5f4 <__printk_hook_install>
}
    3908:	bf00      	nop
    390a:	bd80      	pop	{r7, pc}
    390c:	000038c1 	.word	0x000038c1

00003910 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    3910:	b580      	push	{r7, lr}
    3912:	b082      	sub	sp, #8
    3914:	af00      	add	r7, sp, #0
    3916:	6078      	str	r0, [r7, #4]

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    3918:	4806      	ldr	r0, [pc, #24]	; (3934 <uart_console_init+0x24>)
    391a:	f00e fcbf 	bl	1229c <device_get_binding>
    391e:	4603      	mov	r3, r0
    3920:	4a05      	ldr	r2, [pc, #20]	; (3938 <uart_console_init+0x28>)
    3922:	6013      	str	r3, [r2, #0]

	uart_console_hook_install();
    3924:	f7ff ffe8 	bl	38f8 <uart_console_hook_install>

	return 0;
    3928:	2300      	movs	r3, #0
}
    392a:	4618      	mov	r0, r3
    392c:	3708      	adds	r7, #8
    392e:	46bd      	mov	sp, r7
    3930:	bd80      	pop	{r7, pc}
    3932:	bf00      	nop
    3934:	00019210 	.word	0x00019210
    3938:	200006b0 	.word	0x200006b0

0000393c <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    393c:	b480      	push	{r7}
    393e:	b083      	sub	sp, #12
    3940:	af00      	add	r7, sp, #0
    3942:	4603      	mov	r3, r0
    3944:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    3946:	f997 3007 	ldrsb.w	r3, [r7, #7]
    394a:	2b00      	cmp	r3, #0
    394c:	db0c      	blt.n	3968 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    394e:	79fb      	ldrb	r3, [r7, #7]
    3950:	f003 021f 	and.w	r2, r3, #31
    3954:	4907      	ldr	r1, [pc, #28]	; (3974 <__NVIC_ClearPendingIRQ+0x38>)
    3956:	f997 3007 	ldrsb.w	r3, [r7, #7]
    395a:	095b      	lsrs	r3, r3, #5
    395c:	2001      	movs	r0, #1
    395e:	fa00 f202 	lsl.w	r2, r0, r2
    3962:	3360      	adds	r3, #96	; 0x60
    3964:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    3968:	bf00      	nop
    396a:	370c      	adds	r7, #12
    396c:	46bd      	mov	sp, r7
    396e:	bc80      	pop	{r7}
    3970:	4770      	bx	lr
    3972:	bf00      	nop
    3974:	e000e100 	.word	0xe000e100

00003978 <k_is_pre_kernel>:
 *
 * @return true if invoked before post-kernel initialization
 * @return false if invoked during/after post-kernel initialization
 */
static inline bool k_is_pre_kernel(void)
{
    3978:	b480      	push	{r7}
    397a:	af00      	add	r7, sp, #0
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    397c:	4b08      	ldr	r3, [pc, #32]	; (39a0 <k_is_pre_kernel+0x28>)
    397e:	781b      	ldrb	r3, [r3, #0]
    3980:	2b00      	cmp	r3, #0
    3982:	bf14      	ite	ne
    3984:	2301      	movne	r3, #1
    3986:	2300      	moveq	r3, #0
    3988:	b2db      	uxtb	r3, r3
    398a:	f083 0301 	eor.w	r3, r3, #1
    398e:	b2db      	uxtb	r3, r3
    3990:	f003 0301 	and.w	r3, r3, #1
    3994:	b2db      	uxtb	r3, r3
}
    3996:	4618      	mov	r0, r3
    3998:	46bd      	mov	sp, r7
    399a:	bc80      	pop	{r7}
    399c:	4770      	bx	lr
    399e:	bf00      	nop
    39a0:	20000d45 	.word	0x20000d45

000039a4 <sys_notify_init_spinwait>:
 * reinitialized before it can be re-used.
 *
 * @param notify pointer to the notification configuration object.
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
    39a4:	b580      	push	{r7, lr}
    39a6:	b086      	sub	sp, #24
    39a8:	af00      	add	r7, sp, #0
    39aa:	6078      	str	r0, [r7, #4]
	__ASSERT_NO_MSG(notify != NULL);
    39ac:	687b      	ldr	r3, [r7, #4]
    39ae:	2b00      	cmp	r3, #0
    39b0:	d10b      	bne.n	39ca <sys_notify_init_spinwait+0x26>
    39b2:	f44f 7385 	mov.w	r3, #266	; 0x10a
    39b6:	4a0b      	ldr	r2, [pc, #44]	; (39e4 <sys_notify_init_spinwait+0x40>)
    39b8:	490b      	ldr	r1, [pc, #44]	; (39e8 <sys_notify_init_spinwait+0x44>)
    39ba:	480c      	ldr	r0, [pc, #48]	; (39ec <sys_notify_init_spinwait+0x48>)
    39bc:	f00c fb54 	bl	10068 <printk>
    39c0:	f44f 7185 	mov.w	r1, #266	; 0x10a
    39c4:	4807      	ldr	r0, [pc, #28]	; (39e4 <sys_notify_init_spinwait+0x40>)
    39c6:	f00d f997 	bl	10cf8 <assert_post_action>

	*notify = (struct sys_notify){
    39ca:	687b      	ldr	r3, [r7, #4]
    39cc:	461a      	mov	r2, r3
    39ce:	2300      	movs	r3, #0
    39d0:	6013      	str	r3, [r2, #0]
    39d2:	6053      	str	r3, [r2, #4]
    39d4:	6093      	str	r3, [r2, #8]
    39d6:	687b      	ldr	r3, [r7, #4]
    39d8:	2201      	movs	r2, #1
    39da:	605a      	str	r2, [r3, #4]
		.flags = SYS_NOTIFY_METHOD_SPINWAIT,
	};
}
    39dc:	bf00      	nop
    39de:	3718      	adds	r7, #24
    39e0:	46bd      	mov	sp, r7
    39e2:	bd80      	pop	{r7, pc}
    39e4:	00019218 	.word	0x00019218
    39e8:	00019240 	.word	0x00019240
    39ec:	00019258 	.word	0x00019258

000039f0 <nrf_clock_is_running>:
}

NRF_STATIC_INLINE bool nrf_clock_is_running(NRF_CLOCK_Type const * p_reg,
                                            nrf_clock_domain_t     domain,
                                            void *                 p_clk_src)
{
    39f0:	b580      	push	{r7, lr}
    39f2:	b084      	sub	sp, #16
    39f4:	af00      	add	r7, sp, #0
    39f6:	60f8      	str	r0, [r7, #12]
    39f8:	460b      	mov	r3, r1
    39fa:	607a      	str	r2, [r7, #4]
    39fc:	72fb      	strb	r3, [r7, #11]
    switch (domain)
    39fe:	7afb      	ldrb	r3, [r7, #11]
    3a00:	2b00      	cmp	r3, #0
    3a02:	d002      	beq.n	3a0a <nrf_clock_is_running+0x1a>
    3a04:	2b01      	cmp	r3, #1
    3a06:	d015      	beq.n	3a34 <nrf_clock_is_running+0x44>
    3a08:	e029      	b.n	3a5e <nrf_clock_is_running+0x6e>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
            if (p_clk_src != NULL)
    3a0a:	687b      	ldr	r3, [r7, #4]
    3a0c:	2b00      	cmp	r3, #0
    3a0e:	d008      	beq.n	3a22 <nrf_clock_is_running+0x32>
            {
                (*(nrf_clock_lfclk_t *)p_clk_src) =
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    3a10:	68fb      	ldr	r3, [r7, #12]
    3a12:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    3a16:	b2db      	uxtb	r3, r3
    3a18:	f003 0303 	and.w	r3, r3, #3
    3a1c:	b2da      	uxtb	r2, r3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    3a1e:	687b      	ldr	r3, [r7, #4]
    3a20:	701a      	strb	r2, [r3, #0]
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    3a22:	68fb      	ldr	r3, [r7, #12]
    3a24:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    3a28:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    3a2c:	2b00      	cmp	r3, #0
    3a2e:	d024      	beq.n	3a7a <nrf_clock_is_running+0x8a>
                >> CLOCK_LFCLKSTAT_STATE_Pos)
            {
                return true;
    3a30:	2301      	movs	r3, #1
    3a32:	e026      	b.n	3a82 <nrf_clock_is_running+0x92>
            }
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
    3a34:	687b      	ldr	r3, [r7, #4]
    3a36:	2b00      	cmp	r3, #0
    3a38:	d008      	beq.n	3a4c <nrf_clock_is_running+0x5c>
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    3a3a:	68fb      	ldr	r3, [r7, #12]
    3a3c:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    3a40:	b2db      	uxtb	r3, r3
    3a42:	f003 0301 	and.w	r3, r3, #1
    3a46:	b2da      	uxtb	r2, r3
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    3a48:	687b      	ldr	r3, [r7, #4]
    3a4a:	701a      	strb	r2, [r3, #0]
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    3a4c:	68fb      	ldr	r3, [r7, #12]
    3a4e:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    3a52:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    3a56:	2b00      	cmp	r3, #0
    3a58:	d011      	beq.n	3a7e <nrf_clock_is_running+0x8e>
                >> CLOCK_HFCLKSTAT_STATE_Pos)
            {
                return true;
    3a5a:	2301      	movs	r3, #1
    3a5c:	e011      	b.n	3a82 <nrf_clock_is_running+0x92>
        case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
                   CLOCK_HFCLKAUDIOSTAT_STATE_Msk;
#endif
        default:
            NRFX_ASSERT(0);
    3a5e:	f240 3342 	movw	r3, #834	; 0x342
    3a62:	4a0a      	ldr	r2, [pc, #40]	; (3a8c <nrf_clock_is_running+0x9c>)
    3a64:	490a      	ldr	r1, [pc, #40]	; (3a90 <nrf_clock_is_running+0xa0>)
    3a66:	480b      	ldr	r0, [pc, #44]	; (3a94 <nrf_clock_is_running+0xa4>)
    3a68:	f00c fafe 	bl	10068 <printk>
    3a6c:	f240 3142 	movw	r1, #834	; 0x342
    3a70:	4806      	ldr	r0, [pc, #24]	; (3a8c <nrf_clock_is_running+0x9c>)
    3a72:	f00d f941 	bl	10cf8 <assert_post_action>
            return false;
    3a76:	2300      	movs	r3, #0
    3a78:	e003      	b.n	3a82 <nrf_clock_is_running+0x92>
            break;
    3a7a:	bf00      	nop
    3a7c:	e000      	b.n	3a80 <nrf_clock_is_running+0x90>
            break;
    3a7e:	bf00      	nop
    }
    return false;
    3a80:	2300      	movs	r3, #0
}
    3a82:	4618      	mov	r0, r3
    3a84:	3710      	adds	r7, #16
    3a86:	46bd      	mov	sp, r7
    3a88:	bd80      	pop	{r7, pc}
    3a8a:	bf00      	nop
    3a8c:	00019278 	.word	0x00019278
    3a90:	000192ac 	.word	0x000192ac
    3a94:	00019258 	.word	0x00019258

00003a98 <log_const_source_id>:
{
    3a98:	b480      	push	{r7}
    3a9a:	b083      	sub	sp, #12
    3a9c:	af00      	add	r7, sp, #0
    3a9e:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    3aa0:	687b      	ldr	r3, [r7, #4]
    3aa2:	4a04      	ldr	r2, [pc, #16]	; (3ab4 <log_const_source_id+0x1c>)
    3aa4:	1a9b      	subs	r3, r3, r2
    3aa6:	08db      	lsrs	r3, r3, #3
}
    3aa8:	4618      	mov	r0, r3
    3aaa:	370c      	adds	r7, #12
    3aac:	46bd      	mov	sp, r7
    3aae:	bc80      	pop	{r7}
    3ab0:	4770      	bx	lr
    3ab2:	bf00      	nop
    3ab4:	00018788 	.word	0x00018788

00003ab8 <get_status>:
				(enum clock_control_nrf_type)sys);
}

static enum clock_control_status get_status(const struct device *dev,
					    clock_control_subsys_t subsys)
{
    3ab8:	b580      	push	{r7, lr}
    3aba:	b084      	sub	sp, #16
    3abc:	af00      	add	r7, sp, #0
    3abe:	6078      	str	r0, [r7, #4]
    3ac0:	6039      	str	r1, [r7, #0]
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    3ac2:	683b      	ldr	r3, [r7, #0]
    3ac4:	73fb      	strb	r3, [r7, #15]

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3ac6:	7bfb      	ldrb	r3, [r7, #15]
    3ac8:	2b01      	cmp	r3, #1
    3aca:	d909      	bls.n	3ae0 <get_status+0x28>
    3acc:	237d      	movs	r3, #125	; 0x7d
    3ace:	4a0c      	ldr	r2, [pc, #48]	; (3b00 <get_status+0x48>)
    3ad0:	490c      	ldr	r1, [pc, #48]	; (3b04 <get_status+0x4c>)
    3ad2:	480d      	ldr	r0, [pc, #52]	; (3b08 <get_status+0x50>)
    3ad4:	f00c fac8 	bl	10068 <printk>
    3ad8:	217d      	movs	r1, #125	; 0x7d
    3ada:	4809      	ldr	r0, [pc, #36]	; (3b00 <get_status+0x48>)
    3adc:	f00d f90c 	bl	10cf8 <assert_post_action>

	return GET_STATUS(get_sub_data(dev, type)->flags);
    3ae0:	7bfb      	ldrb	r3, [r7, #15]
    3ae2:	4619      	mov	r1, r3
    3ae4:	6878      	ldr	r0, [r7, #4]
    3ae6:	f00e fe64 	bl	127b2 <get_sub_data>
    3aea:	4603      	mov	r3, r0
    3aec:	689b      	ldr	r3, [r3, #8]
    3aee:	b2db      	uxtb	r3, r3
    3af0:	f003 0307 	and.w	r3, r3, #7
    3af4:	b2db      	uxtb	r3, r3
}
    3af6:	4618      	mov	r0, r3
    3af8:	3710      	adds	r7, #16
    3afa:	46bd      	mov	sp, r7
    3afc:	bd80      	pop	{r7, pc}
    3afe:	bf00      	nop
    3b00:	000192c8 	.word	0x000192c8
    3b04:	00019308 	.word	0x00019308
    3b08:	00019258 	.word	0x00019258

00003b0c <clkstarted_handle>:
	irq_unlock(key);
}

static void clkstarted_handle(const struct device *dev,
			      enum clock_control_nrf_type type)
{
    3b0c:	b590      	push	{r4, r7, lr}
    3b0e:	b087      	sub	sp, #28
    3b10:	af00      	add	r7, sp, #0
    3b12:	6078      	str	r0, [r7, #4]
    3b14:	460b      	mov	r3, r1
    3b16:	70fb      	strb	r3, [r7, #3]
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    3b18:	78fb      	ldrb	r3, [r7, #3]
    3b1a:	4619      	mov	r1, r3
    3b1c:	6878      	ldr	r0, [r7, #4]
    3b1e:	f00e fe48 	bl	127b2 <get_sub_data>
    3b22:	6138      	str	r0, [r7, #16]
	clock_control_cb_t callback = sub_data->cb;
    3b24:	693b      	ldr	r3, [r7, #16]
    3b26:	681b      	ldr	r3, [r3, #0]
    3b28:	60fb      	str	r3, [r7, #12]
	void *user_data = sub_data->user_data;
    3b2a:	693b      	ldr	r3, [r7, #16]
    3b2c:	685b      	ldr	r3, [r3, #4]
    3b2e:	617b      	str	r3, [r7, #20]

	sub_data->cb = NULL;
    3b30:	693b      	ldr	r3, [r7, #16]
    3b32:	2200      	movs	r2, #0
    3b34:	601a      	str	r2, [r3, #0]
	set_on_state(&sub_data->flags);
    3b36:	693b      	ldr	r3, [r7, #16]
    3b38:	3308      	adds	r3, #8
    3b3a:	4618      	mov	r0, r3
    3b3c:	f00e fee5 	bl	1290a <set_on_state>
	DBG(dev, type, "Clock started");
    3b40:	2303      	movs	r3, #3
    3b42:	2b03      	cmp	r3, #3
    3b44:	d93c      	bls.n	3bc0 <clkstarted_handle+0xb4>
    3b46:	f00e fc0b 	bl	12360 <_is_user_context>
    3b4a:	4603      	mov	r3, r0
    3b4c:	72fb      	strb	r3, [r7, #11]
    3b4e:	7a3b      	ldrb	r3, [r7, #8]
    3b50:	2204      	movs	r2, #4
    3b52:	f362 0302 	bfi	r3, r2, #0, #3
    3b56:	723b      	strb	r3, [r7, #8]
    3b58:	7a3b      	ldrb	r3, [r7, #8]
    3b5a:	f36f 03c5 	bfc	r3, #3, #3
    3b5e:	723b      	strb	r3, [r7, #8]
    3b60:	2303      	movs	r3, #3
    3b62:	2b00      	cmp	r3, #0
    3b64:	d009      	beq.n	3b7a <clkstarted_handle+0x6e>
    3b66:	4b1d      	ldr	r3, [pc, #116]	; (3bdc <clkstarted_handle+0xd0>)
    3b68:	681b      	ldr	r3, [r3, #0]
    3b6a:	4618      	mov	r0, r3
    3b6c:	f7ff ff94 	bl	3a98 <log_const_source_id>
    3b70:	4603      	mov	r3, r0
    3b72:	f3c3 0309 	ubfx	r3, r3, #0, #10
    3b76:	b29a      	uxth	r2, r3
    3b78:	e000      	b.n	3b7c <clkstarted_handle+0x70>
    3b7a:	2200      	movs	r2, #0
    3b7c:	893b      	ldrh	r3, [r7, #8]
    3b7e:	f362 138f 	bfi	r3, r2, #6, #10
    3b82:	813b      	strh	r3, [r7, #8]
    3b84:	7afb      	ldrb	r3, [r7, #11]
    3b86:	2b00      	cmp	r3, #0
    3b88:	d00c      	beq.n	3ba4 <clkstarted_handle+0x98>
    3b8a:	78fb      	ldrb	r3, [r7, #3]
    3b8c:	4619      	mov	r1, r3
    3b8e:	6878      	ldr	r0, [r7, #4]
    3b90:	f00e fe25 	bl	127de <get_sub_config>
    3b94:	4603      	mov	r3, r0
    3b96:	689b      	ldr	r3, [r3, #8]
    3b98:	4a11      	ldr	r2, [pc, #68]	; (3be0 <clkstarted_handle+0xd4>)
    3b9a:	4912      	ldr	r1, [pc, #72]	; (3be4 <clkstarted_handle+0xd8>)
    3b9c:	8938      	ldrh	r0, [r7, #8]
    3b9e:	f7fe fea7 	bl	28f0 <log_from_user>
    3ba2:	e00d      	b.n	3bc0 <clkstarted_handle+0xb4>
    3ba4:	4c0e      	ldr	r4, [pc, #56]	; (3be0 <clkstarted_handle+0xd4>)
    3ba6:	78fb      	ldrb	r3, [r7, #3]
    3ba8:	4619      	mov	r1, r3
    3baa:	6878      	ldr	r0, [r7, #4]
    3bac:	f00e fe17 	bl	127de <get_sub_config>
    3bb0:	4603      	mov	r3, r0
    3bb2:	689b      	ldr	r3, [r3, #8]
    3bb4:	461a      	mov	r2, r3
    3bb6:	893b      	ldrh	r3, [r7, #8]
    3bb8:	4621      	mov	r1, r4
    3bba:	480a      	ldr	r0, [pc, #40]	; (3be4 <clkstarted_handle+0xd8>)
    3bbc:	f00d fd5d 	bl	1167a <log_2>

	if (callback) {
    3bc0:	68fb      	ldr	r3, [r7, #12]
    3bc2:	2b00      	cmp	r3, #0
    3bc4:	d005      	beq.n	3bd2 <clkstarted_handle+0xc6>
		callback(dev, (clock_control_subsys_t)type, user_data);
    3bc6:	78fb      	ldrb	r3, [r7, #3]
    3bc8:	4619      	mov	r1, r3
    3bca:	68fb      	ldr	r3, [r7, #12]
    3bcc:	697a      	ldr	r2, [r7, #20]
    3bce:	6878      	ldr	r0, [r7, #4]
    3bd0:	4798      	blx	r3
	}
}
    3bd2:	bf00      	nop
    3bd4:	371c      	adds	r7, #28
    3bd6:	46bd      	mov	sp, r7
    3bd8:	bd90      	pop	{r4, r7, pc}
    3bda:	bf00      	nop
    3bdc:	200000cc 	.word	0x200000cc
    3be0:	0001cafc 	.word	0x0001cafc
    3be4:	0001932c 	.word	0x0001932c

00003be8 <get_hf_flags>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
}
#endif

static uint32_t *get_hf_flags(void)
{
    3be8:	b480      	push	{r7}
    3bea:	b083      	sub	sp, #12
    3bec:	af00      	add	r7, sp, #0
	struct nrf_clock_control_data *data = DEVICE_GET(clock_nrf)->data;
    3bee:	4b04      	ldr	r3, [pc, #16]	; (3c00 <get_hf_flags+0x18>)
    3bf0:	607b      	str	r3, [r7, #4]

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
    3bf2:	687b      	ldr	r3, [r7, #4]
    3bf4:	3348      	adds	r3, #72	; 0x48
}
    3bf6:	4618      	mov	r0, r3
    3bf8:	370c      	adds	r7, #12
    3bfa:	46bd      	mov	sp, r7
    3bfc:	bc80      	pop	{r7}
    3bfe:	4770      	bx	lr
    3c00:	200006b8 	.word	0x200006b8

00003c04 <generic_hfclk_start>:

static void generic_hfclk_start(void)
{
    3c04:	b580      	push	{r7, lr}
    3c06:	b086      	sub	sp, #24
    3c08:	af00      	add	r7, sp, #0
	nrf_clock_hfclk_t type;
	bool already_started = false;
    3c0a:	2300      	movs	r3, #0
    3c0c:	75fb      	strb	r3, [r7, #23]
    3c0e:	f04f 0320 	mov.w	r3, #32
    3c12:	f3ef 8211 	mrs	r2, BASEPRI
    3c16:	f383 8811 	msr	BASEPRI, r3
    3c1a:	f3bf 8f6f 	isb	sy
    3c1e:	60fa      	str	r2, [r7, #12]
    3c20:	60bb      	str	r3, [r7, #8]
	return key;
    3c22:	68fb      	ldr	r3, [r7, #12]
	int key = irq_lock();
    3c24:	613b      	str	r3, [r7, #16]

	hfclk_users |= HF_USER_GENERIC;
    3c26:	4b19      	ldr	r3, [pc, #100]	; (3c8c <generic_hfclk_start+0x88>)
    3c28:	681b      	ldr	r3, [r3, #0]
    3c2a:	f043 0302 	orr.w	r3, r3, #2
    3c2e:	461a      	mov	r2, r3
    3c30:	4b16      	ldr	r3, [pc, #88]	; (3c8c <generic_hfclk_start+0x88>)
    3c32:	601a      	str	r2, [r3, #0]
	if (hfclk_users & HF_USER_BT) {
    3c34:	4b15      	ldr	r3, [pc, #84]	; (3c8c <generic_hfclk_start+0x88>)
    3c36:	681b      	ldr	r3, [r3, #0]
    3c38:	f003 0301 	and.w	r3, r3, #1
    3c3c:	2b00      	cmp	r3, #0
    3c3e:	d00f      	beq.n	3c60 <generic_hfclk_start+0x5c>
		(void)nrfx_clock_is_running(NRF_CLOCK_DOMAIN_HFCLK, &type);
    3c40:	1cfb      	adds	r3, r7, #3
    3c42:	4619      	mov	r1, r3
    3c44:	2001      	movs	r0, #1
    3c46:	f00e fda2 	bl	1278e <nrfx_clock_is_running>
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    3c4a:	78fb      	ldrb	r3, [r7, #3]
    3c4c:	2b01      	cmp	r3, #1
    3c4e:	d107      	bne.n	3c60 <generic_hfclk_start+0x5c>
			already_started = true;
    3c50:	2301      	movs	r3, #1
    3c52:	75fb      	strb	r3, [r7, #23]
			/* Set on state in case clock interrupt comes and we
			 * want to avoid handling that.
			 */
			set_on_state(get_hf_flags());
    3c54:	f7ff ffc8 	bl	3be8 <get_hf_flags>
    3c58:	4603      	mov	r3, r0
    3c5a:	4618      	mov	r0, r3
    3c5c:	f00e fe55 	bl	1290a <set_on_state>
		}
	}

	irq_unlock(key);
    3c60:	693b      	ldr	r3, [r7, #16]
    3c62:	607b      	str	r3, [r7, #4]
	__asm__ volatile(
    3c64:	687b      	ldr	r3, [r7, #4]
    3c66:	f383 8811 	msr	BASEPRI, r3
    3c6a:	f3bf 8f6f 	isb	sy
}
    3c6e:	bf00      	nop

	if (already_started) {
    3c70:	7dfb      	ldrb	r3, [r7, #23]
    3c72:	2b00      	cmp	r3, #0
    3c74:	d004      	beq.n	3c80 <generic_hfclk_start+0x7c>
		/* Clock already started by z_nrf_clock_bt_ctlr_hf_request */
		clkstarted_handle(DEVICE_GET(clock_nrf),
    3c76:	2100      	movs	r1, #0
    3c78:	4805      	ldr	r0, [pc, #20]	; (3c90 <generic_hfclk_start+0x8c>)
    3c7a:	f7ff ff47 	bl	3b0c <clkstarted_handle>
    3c7e:	e001      	b.n	3c84 <generic_hfclk_start+0x80>
				  CLOCK_CONTROL_NRF_TYPE_HFCLK);
		return;
	}

	hfclk_start();
    3c80:	f00e fe74 	bl	1296c <hfclk_start>
}
    3c84:	3718      	adds	r7, #24
    3c86:	46bd      	mov	sp, r7
    3c88:	bd80      	pop	{r7, pc}
    3c8a:	bf00      	nop
    3c8c:	200006b4 	.word	0x200006b4
    3c90:	200001e8 	.word	0x200001e8

00003c94 <generic_hfclk_stop>:

static void generic_hfclk_stop(void)
{
    3c94:	b580      	push	{r7, lr}
    3c96:	af00      	add	r7, sp, #0
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    3c98:	f06f 0102 	mvn.w	r1, #2
    3c9c:	4806      	ldr	r0, [pc, #24]	; (3cb8 <generic_hfclk_stop+0x24>)
    3c9e:	f00e fb3e 	bl	1231e <atomic_and>
    3ca2:	4603      	mov	r3, r0
    3ca4:	f003 0301 	and.w	r3, r3, #1
    3ca8:	2b00      	cmp	r3, #0
    3caa:	d102      	bne.n	3cb2 <generic_hfclk_stop+0x1e>
		/* bt still requesting the clock. */
		return;
	}

	hfclk_stop();
    3cac:	f00e fe64 	bl	12978 <hfclk_stop>
    3cb0:	e000      	b.n	3cb4 <generic_hfclk_stop+0x20>
		return;
    3cb2:	bf00      	nop
}
    3cb4:	bd80      	pop	{r7, pc}
    3cb6:	bf00      	nop
    3cb8:	200006b4 	.word	0x200006b4

00003cbc <stop>:
	hfclk_stop();
}

static int stop(const struct device *dev, clock_control_subsys_t subsys,
		uint32_t ctx)
{
    3cbc:	b580      	push	{r7, lr}
    3cbe:	b088      	sub	sp, #32
    3cc0:	af00      	add	r7, sp, #0
    3cc2:	60f8      	str	r0, [r7, #12]
    3cc4:	60b9      	str	r1, [r7, #8]
    3cc6:	607a      	str	r2, [r7, #4]
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    3cc8:	68bb      	ldr	r3, [r7, #8]
    3cca:	77fb      	strb	r3, [r7, #31]
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    3ccc:	7ffb      	ldrb	r3, [r7, #31]
    3cce:	4619      	mov	r1, r3
    3cd0:	68f8      	ldr	r0, [r7, #12]
    3cd2:	f00e fd6e 	bl	127b2 <get_sub_data>
    3cd6:	61b8      	str	r0, [r7, #24]
	int err;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
    3cd8:	7ffb      	ldrb	r3, [r7, #31]
    3cda:	2b01      	cmp	r3, #1
    3cdc:	d90b      	bls.n	3cf6 <stop+0x3a>
    3cde:	f240 1345 	movw	r3, #325	; 0x145
    3ce2:	4a11      	ldr	r2, [pc, #68]	; (3d28 <stop+0x6c>)
    3ce4:	4911      	ldr	r1, [pc, #68]	; (3d2c <stop+0x70>)
    3ce6:	4812      	ldr	r0, [pc, #72]	; (3d30 <stop+0x74>)
    3ce8:	f00c f9be 	bl	10068 <printk>
    3cec:	f240 1145 	movw	r1, #325	; 0x145
    3cf0:	480d      	ldr	r0, [pc, #52]	; (3d28 <stop+0x6c>)
    3cf2:	f00d f801 	bl	10cf8 <assert_post_action>

	err = set_off_state(&subdata->flags, ctx);
    3cf6:	69bb      	ldr	r3, [r7, #24]
    3cf8:	3308      	adds	r3, #8
    3cfa:	6879      	ldr	r1, [r7, #4]
    3cfc:	4618      	mov	r0, r3
    3cfe:	f00e fd95 	bl	1282c <set_off_state>
    3d02:	6178      	str	r0, [r7, #20]
	if (err < 0) {
    3d04:	697b      	ldr	r3, [r7, #20]
    3d06:	2b00      	cmp	r3, #0
    3d08:	da01      	bge.n	3d0e <stop+0x52>
		return err;
    3d0a:	697b      	ldr	r3, [r7, #20]
    3d0c:	e008      	b.n	3d20 <stop+0x64>
	}

	get_sub_config(dev, type)->stop();
    3d0e:	7ffb      	ldrb	r3, [r7, #31]
    3d10:	4619      	mov	r1, r3
    3d12:	68f8      	ldr	r0, [r7, #12]
    3d14:	f00e fd63 	bl	127de <get_sub_config>
    3d18:	4603      	mov	r3, r0
    3d1a:	685b      	ldr	r3, [r3, #4]
    3d1c:	4798      	blx	r3

	return 0;
    3d1e:	2300      	movs	r3, #0
}
    3d20:	4618      	mov	r0, r3
    3d22:	3720      	adds	r7, #32
    3d24:	46bd      	mov	sp, r7
    3d26:	bd80      	pop	{r7, pc}
    3d28:	000192c8 	.word	0x000192c8
    3d2c:	00019308 	.word	0x00019308
    3d30:	00019258 	.word	0x00019258

00003d34 <api_blocking_start>:
	k_sem_give(sem);
}

static int api_blocking_start(const struct device *dev,
			      clock_control_subsys_t subsys)
{
    3d34:	b590      	push	{r4, r7, lr}
    3d36:	b089      	sub	sp, #36	; 0x24
    3d38:	af00      	add	r7, sp, #0
    3d3a:	6078      	str	r0, [r7, #4]
    3d3c:	6039      	str	r1, [r7, #0]
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    3d3e:	f107 030c 	add.w	r3, r7, #12
    3d42:	60fb      	str	r3, [r7, #12]
    3d44:	f107 030c 	add.w	r3, r7, #12
    3d48:	613b      	str	r3, [r7, #16]
    3d4a:	2300      	movs	r3, #0
    3d4c:	617b      	str	r3, [r7, #20]
    3d4e:	2301      	movs	r3, #1
    3d50:	61bb      	str	r3, [r7, #24]

	if (!IS_ENABLED(CONFIG_MULTITHREADING)) {
		return -ENOTSUP;
	}

	err = api_start(dev, subsys, blocking_start_callback, &sem);
    3d52:	f107 030c 	add.w	r3, r7, #12
    3d56:	4a10      	ldr	r2, [pc, #64]	; (3d98 <api_blocking_start+0x64>)
    3d58:	6839      	ldr	r1, [r7, #0]
    3d5a:	6878      	ldr	r0, [r7, #4]
    3d5c:	f00e fe4f 	bl	129fe <api_start>
    3d60:	61f8      	str	r0, [r7, #28]
	if (err < 0) {
    3d62:	69fb      	ldr	r3, [r7, #28]
    3d64:	2b00      	cmp	r3, #0
    3d66:	da01      	bge.n	3d6c <api_blocking_start+0x38>
		return err;
    3d68:	69fb      	ldr	r3, [r7, #28]
    3d6a:	e011      	b.n	3d90 <api_blocking_start+0x5c>
	}

	return k_sem_take(&sem, K_MSEC(500));
    3d6c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    3d70:	f04f 0100 	mov.w	r1, #0
    3d74:	f00e fafb 	bl	1236e <k_ms_to_ticks_ceil64>
    3d78:	4602      	mov	r2, r0
    3d7a:	460b      	mov	r3, r1
    3d7c:	4610      	mov	r0, r2
    3d7e:	4619      	mov	r1, r3
    3d80:	f107 040c 	add.w	r4, r7, #12
    3d84:	4602      	mov	r2, r0
    3d86:	460b      	mov	r3, r1
    3d88:	4620      	mov	r0, r4
    3d8a:	f00e fc48 	bl	1261e <k_sem_take>
    3d8e:	4603      	mov	r3, r0
}
    3d90:	4618      	mov	r0, r3
    3d92:	3724      	adds	r7, #36	; 0x24
    3d94:	46bd      	mov	sp, r7
    3d96:	bd90      	pop	{r4, r7, pc}
    3d98:	00012a27 	.word	0x00012a27

00003d9c <get_subsys>:

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
    3d9c:	b480      	push	{r7}
    3d9e:	b085      	sub	sp, #20
    3da0:	af00      	add	r7, sp, #0
    3da2:	6078      	str	r0, [r7, #4]
	struct nrf_clock_control_data *data = DEVICE_GET(clock_nrf)->data;
    3da4:	4b06      	ldr	r3, [pc, #24]	; (3dc0 <get_subsys+0x24>)
    3da6:	60fb      	str	r3, [r7, #12]
	size_t offset = (size_t)(mgr - data->mgr);
    3da8:	68fb      	ldr	r3, [r7, #12]
    3daa:	687a      	ldr	r2, [r7, #4]
    3dac:	1ad3      	subs	r3, r2, r3
    3dae:	115b      	asrs	r3, r3, #5
    3db0:	60bb      	str	r3, [r7, #8]

	return (clock_control_subsys_t)offset;
    3db2:	68bb      	ldr	r3, [r7, #8]
}
    3db4:	4618      	mov	r0, r3
    3db6:	3714      	adds	r7, #20
    3db8:	46bd      	mov	sp, r7
    3dba:	bc80      	pop	{r7}
    3dbc:	4770      	bx	lr
    3dbe:	bf00      	nop
    3dc0:	200006b8 	.word	0x200006b8

00003dc4 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    3dc4:	b580      	push	{r7, lr}
    3dc6:	b084      	sub	sp, #16
    3dc8:	af00      	add	r7, sp, #0
    3dca:	6078      	str	r0, [r7, #4]
    3dcc:	6039      	str	r1, [r7, #0]
	int res;

	res = stop(DEVICE_GET(clock_nrf), get_subsys(mgr), CTX_ONOFF);
    3dce:	6878      	ldr	r0, [r7, #4]
    3dd0:	f7ff ffe4 	bl	3d9c <get_subsys>
    3dd4:	4603      	mov	r3, r0
    3dd6:	2240      	movs	r2, #64	; 0x40
    3dd8:	4619      	mov	r1, r3
    3dda:	4806      	ldr	r0, [pc, #24]	; (3df4 <onoff_stop+0x30>)
    3ddc:	f7ff ff6e 	bl	3cbc <stop>
    3de0:	60f8      	str	r0, [r7, #12]
	notify(mgr, res);
    3de2:	683b      	ldr	r3, [r7, #0]
    3de4:	68f9      	ldr	r1, [r7, #12]
    3de6:	6878      	ldr	r0, [r7, #4]
    3de8:	4798      	blx	r3
}
    3dea:	bf00      	nop
    3dec:	3710      	adds	r7, #16
    3dee:	46bd      	mov	sp, r7
    3df0:	bd80      	pop	{r7, pc}
    3df2:	bf00      	nop
    3df4:	200001e8 	.word	0x200001e8

00003df8 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    3df8:	b580      	push	{r7, lr}
    3dfa:	b086      	sub	sp, #24
    3dfc:	af02      	add	r7, sp, #8
    3dfe:	6078      	str	r0, [r7, #4]
    3e00:	6039      	str	r1, [r7, #0]
	int err;

	err = async_start(DEVICE_GET(clock_nrf), get_subsys(mgr),
    3e02:	6878      	ldr	r0, [r7, #4]
    3e04:	f7ff ffca 	bl	3d9c <get_subsys>
    3e08:	4601      	mov	r1, r0
    3e0a:	2340      	movs	r3, #64	; 0x40
    3e0c:	9300      	str	r3, [sp, #0]
    3e0e:	683b      	ldr	r3, [r7, #0]
    3e10:	4a07      	ldr	r2, [pc, #28]	; (3e30 <onoff_start+0x38>)
    3e12:	4808      	ldr	r0, [pc, #32]	; (3e34 <onoff_start+0x3c>)
    3e14:	f00e fdc5 	bl	129a2 <async_start>
    3e18:	60f8      	str	r0, [r7, #12]
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    3e1a:	68fb      	ldr	r3, [r7, #12]
    3e1c:	2b00      	cmp	r3, #0
    3e1e:	da03      	bge.n	3e28 <onoff_start+0x30>
		notify(mgr, err);
    3e20:	683b      	ldr	r3, [r7, #0]
    3e22:	68f9      	ldr	r1, [r7, #12]
    3e24:	6878      	ldr	r0, [r7, #4]
    3e26:	4798      	blx	r3
	}
}
    3e28:	bf00      	nop
    3e2a:	3710      	adds	r7, #16
    3e2c:	46bd      	mov	sp, r7
    3e2e:	bd80      	pop	{r7, pc}
    3e30:	00012a45 	.word	0x00012a45
    3e34:	200001e8 	.word	0x200001e8

00003e38 <lfclk_spinwait>:
 * This approach is implemented in nrfx_clock driver and utilized here.
 *
 * @param mode Start mode.
 */
static void lfclk_spinwait(enum nrf_lfclk_start_mode mode)
{
    3e38:	b580      	push	{r7, lr}
    3e3a:	b088      	sub	sp, #32
    3e3c:	af00      	add	r7, sp, #0
    3e3e:	4603      	mov	r3, r0
    3e40:	71fb      	strb	r3, [r7, #7]
		 IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_EXT_FULL_SWING))
		? NRF_CLOCK_LFCLK_Xtal
		: CLOCK_CONTROL_NRF_K32SRC;
	nrf_clock_lfclk_t type;

	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    3e42:	79fb      	ldrb	r3, [r7, #7]
    3e44:	2b01      	cmp	r3, #1
    3e46:	d10b      	bne.n	3e60 <lfclk_spinwait+0x28>
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    3e48:	4b4b      	ldr	r3, [pc, #300]	; (3f78 <lfclk_spinwait+0x140>)
    3e4a:	781b      	ldrb	r3, [r3, #0]
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    3e4c:	2b02      	cmp	r3, #2
    3e4e:	d107      	bne.n	3e60 <lfclk_spinwait+0x28>
	    (nrf_clock_lf_srccopy_get(NRF_CLOCK) == CLOCK_CONTROL_NRF_K32SRC)) {
    3e50:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3e54:	f00e fc6f 	bl	12736 <nrf_clock_lf_srccopy_get>
    3e58:	4603      	mov	r3, r0
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    3e5a:	2b02      	cmp	r3, #2
    3e5c:	f000 8088 	beq.w	3f70 <lfclk_spinwait+0x138>
		 * started.
		 */
		return;
	}

	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    3e60:	f014 f8c0 	bl	17fe4 <k_is_in_isr>
    3e64:	4603      	mov	r3, r0
    3e66:	2b00      	cmp	r3, #0
    3e68:	d104      	bne.n	3e74 <lfclk_spinwait+0x3c>
    3e6a:	f7ff fd85 	bl	3978 <k_is_pre_kernel>
    3e6e:	4603      	mov	r3, r0
    3e70:	2b00      	cmp	r3, #0
    3e72:	d001      	beq.n	3e78 <lfclk_spinwait+0x40>
    3e74:	2301      	movs	r3, #1
    3e76:	e000      	b.n	3e7a <lfclk_spinwait+0x42>
    3e78:	2300      	movs	r3, #0
    3e7a:	77fb      	strb	r3, [r7, #31]
    3e7c:	7ffb      	ldrb	r3, [r7, #31]
    3e7e:	f003 0301 	and.w	r3, r3, #1
    3e82:	77fb      	strb	r3, [r7, #31]
	int key = isr_mode ? irq_lock() : 0;
    3e84:	7ffb      	ldrb	r3, [r7, #31]
    3e86:	2b00      	cmp	r3, #0
    3e88:	d00b      	beq.n	3ea2 <lfclk_spinwait+0x6a>
	__asm__ volatile(
    3e8a:	f04f 0320 	mov.w	r3, #32
    3e8e:	f3ef 8211 	mrs	r2, BASEPRI
    3e92:	f383 8811 	msr	BASEPRI, r3
    3e96:	f3bf 8f6f 	isb	sy
    3e9a:	617a      	str	r2, [r7, #20]
    3e9c:	613b      	str	r3, [r7, #16]
	return key;
    3e9e:	697b      	ldr	r3, [r7, #20]
    3ea0:	e000      	b.n	3ea4 <lfclk_spinwait+0x6c>
    3ea2:	2300      	movs	r3, #0
    3ea4:	61bb      	str	r3, [r7, #24]

	if (!isr_mode) {
    3ea6:	7ffb      	ldrb	r3, [r7, #31]
    3ea8:	f083 0301 	eor.w	r3, r3, #1
    3eac:	b2db      	uxtb	r3, r3
    3eae:	2b00      	cmp	r3, #0
    3eb0:	d037      	beq.n	3f22 <lfclk_spinwait+0xea>
		nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
    3eb2:	2102      	movs	r1, #2
    3eb4:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3eb8:	f00e fbda 	bl	12670 <nrf_clock_int_disable>
	}

	while (!(nrfx_clock_is_running(d, (void *)&type)
    3ebc:	e031      	b.n	3f22 <lfclk_spinwait+0xea>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
		/* Synth source start is almost instant and LFCLKSTARTED may
		 * happen before calling idle. That would lead to deadlock.
		 */
		if (!IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_SYNTH)) {
			if (isr_mode) {
    3ebe:	7ffb      	ldrb	r3, [r7, #31]
    3ec0:	2b00      	cmp	r3, #0
    3ec2:	d004      	beq.n	3ece <lfclk_spinwait+0x96>
				k_cpu_atomic_idle(key);
    3ec4:	69bb      	ldr	r3, [r7, #24]
    3ec6:	4618      	mov	r0, r3
    3ec8:	f00e fb90 	bl	125ec <k_cpu_atomic_idle>
    3ecc:	e002      	b.n	3ed4 <lfclk_spinwait+0x9c>
			} else {
				k_msleep(1);
    3ece:	2001      	movs	r0, #1
    3ed0:	f00e fb72 	bl	125b8 <k_msleep>
			}
		}

		/* Clock interrupt is locked, LFCLKSTARTED is handled here. */
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    3ed4:	4b28      	ldr	r3, [pc, #160]	; (3f78 <lfclk_spinwait+0x140>)
    3ed6:	781b      	ldrb	r3, [r3, #0]
    3ed8:	2b02      	cmp	r3, #2
    3eda:	d122      	bne.n	3f22 <lfclk_spinwait+0xea>
		    && (nrf_clock_lf_src_get(NRF_CLOCK) == NRF_CLOCK_LFCLK_RC)
    3edc:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3ee0:	f00e fc1c 	bl	1271c <nrf_clock_lf_src_get>
    3ee4:	4603      	mov	r3, r0
    3ee6:	2b01      	cmp	r3, #1
    3ee8:	d11b      	bne.n	3f22 <lfclk_spinwait+0xea>
		    && nrf_clock_event_check(NRF_CLOCK,
    3eea:	f44f 7182 	mov.w	r1, #260	; 0x104
    3eee:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3ef2:	f00e fbf0 	bl	126d6 <nrf_clock_event_check>
    3ef6:	4603      	mov	r3, r0
    3ef8:	2b00      	cmp	r3, #0
    3efa:	d012      	beq.n	3f22 <lfclk_spinwait+0xea>
					     NRF_CLOCK_EVENT_LFCLKSTARTED)) {
			nrf_clock_event_clear(NRF_CLOCK,
    3efc:	f44f 7182 	mov.w	r1, #260	; 0x104
    3f00:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3f04:	f00e fbd2 	bl	126ac <nrf_clock_event_clear>
					      NRF_CLOCK_EVENT_LFCLKSTARTED);
			nrf_clock_lf_src_set(NRF_CLOCK,
    3f08:	2102      	movs	r1, #2
    3f0a:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3f0e:	f00e fbf6 	bl	126fe <nrf_clock_lf_src_set>
					     CLOCK_CONTROL_NRF_K32SRC);

			/* Clear pending interrupt, otherwise new clock event
			 * would not wake up from idle.
			 */
			NVIC_ClearPendingIRQ(DT_INST_IRQN(0));
    3f12:	2005      	movs	r0, #5
    3f14:	f7ff fd12 	bl	393c <__NVIC_ClearPendingIRQ>
			nrf_clock_task_trigger(NRF_CLOCK,
    3f18:	2108      	movs	r1, #8
    3f1a:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3f1e:	f00e fbb5 	bl	1268c <nrf_clock_task_trigger>
	while (!(nrfx_clock_is_running(d, (void *)&type)
    3f22:	4b16      	ldr	r3, [pc, #88]	; (3f7c <lfclk_spinwait+0x144>)
    3f24:	781b      	ldrb	r3, [r3, #0]
    3f26:	f107 020b 	add.w	r2, r7, #11
    3f2a:	4611      	mov	r1, r2
    3f2c:	4618      	mov	r0, r3
    3f2e:	f00e fc2e 	bl	1278e <nrfx_clock_is_running>
    3f32:	4603      	mov	r3, r0
    3f34:	f083 0301 	eor.w	r3, r3, #1
    3f38:	b2db      	uxtb	r3, r3
    3f3a:	2b00      	cmp	r3, #0
    3f3c:	d1bf      	bne.n	3ebe <lfclk_spinwait+0x86>
		 && ((type == target_type)
    3f3e:	7afa      	ldrb	r2, [r7, #11]
    3f40:	4b0d      	ldr	r3, [pc, #52]	; (3f78 <lfclk_spinwait+0x140>)
    3f42:	781b      	ldrb	r3, [r3, #0]
	while (!(nrfx_clock_is_running(d, (void *)&type)
    3f44:	429a      	cmp	r2, r3
    3f46:	d002      	beq.n	3f4e <lfclk_spinwait+0x116>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    3f48:	79fb      	ldrb	r3, [r7, #7]
    3f4a:	2b01      	cmp	r3, #1
    3f4c:	d1b7      	bne.n	3ebe <lfclk_spinwait+0x86>
					       NRF_CLOCK_TASK_LFCLKSTART);
		}
	}

	if (isr_mode) {
    3f4e:	7ffb      	ldrb	r3, [r7, #31]
    3f50:	2b00      	cmp	r3, #0
    3f52:	d007      	beq.n	3f64 <lfclk_spinwait+0x12c>
		irq_unlock(key);
    3f54:	69bb      	ldr	r3, [r7, #24]
    3f56:	60fb      	str	r3, [r7, #12]
	__asm__ volatile(
    3f58:	68fb      	ldr	r3, [r7, #12]
    3f5a:	f383 8811 	msr	BASEPRI, r3
    3f5e:	f3bf 8f6f 	isb	sy
}
    3f62:	e006      	b.n	3f72 <lfclk_spinwait+0x13a>
	} else {
		nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
    3f64:	2102      	movs	r1, #2
    3f66:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    3f6a:	f00e fb73 	bl	12654 <nrf_clock_int_enable>
    3f6e:	e000      	b.n	3f72 <lfclk_spinwait+0x13a>
		return;
    3f70:	bf00      	nop
	}
}
    3f72:	3720      	adds	r7, #32
    3f74:	46bd      	mov	sp, r7
    3f76:	bd80      	pop	{r7, pc}
    3f78:	0001cf30 	.word	0x0001cf30
    3f7c:	0001cf31 	.word	0x0001cf31

00003f80 <z_nrf_clock_control_lf_on>:

void z_nrf_clock_control_lf_on(enum nrf_lfclk_start_mode start_mode)
{
    3f80:	b580      	push	{r7, lr}
    3f82:	b084      	sub	sp, #16
    3f84:	af00      	add	r7, sp, #0
    3f86:	4603      	mov	r3, r0
    3f88:	71fb      	strb	r3, [r7, #7]
	static atomic_t on;
	static struct onoff_client cli;

	if (atomic_set(&on, 1) == 0) {
    3f8a:	2101      	movs	r1, #1
    3f8c:	481f      	ldr	r0, [pc, #124]	; (400c <z_nrf_clock_control_lf_on+0x8c>)
    3f8e:	f00e f9b3 	bl	122f8 <atomic_set>
    3f92:	4603      	mov	r3, r0
    3f94:	2b00      	cmp	r3, #0
    3f96:	d11b      	bne.n	3fd0 <z_nrf_clock_control_lf_on+0x50>
		int err;
		struct onoff_manager *mgr =
				get_onoff_manager(DEVICE_GET(clock_nrf),
    3f98:	2101      	movs	r1, #1
    3f9a:	481d      	ldr	r0, [pc, #116]	; (4010 <z_nrf_clock_control_lf_on+0x90>)
    3f9c:	f00e fc34 	bl	12808 <get_onoff_manager>
    3fa0:	60f8      	str	r0, [r7, #12]
						  CLOCK_CONTROL_NRF_TYPE_LFCLK);

		sys_notify_init_spinwait(&cli.notify);
    3fa2:	481c      	ldr	r0, [pc, #112]	; (4014 <z_nrf_clock_control_lf_on+0x94>)
    3fa4:	f7ff fcfe 	bl	39a4 <sys_notify_init_spinwait>
		err = onoff_request(mgr, &cli);
    3fa8:	491b      	ldr	r1, [pc, #108]	; (4018 <z_nrf_clock_control_lf_on+0x98>)
    3faa:	68f8      	ldr	r0, [r7, #12]
    3fac:	f7fc feda 	bl	d64 <onoff_request>
    3fb0:	60b8      	str	r0, [r7, #8]
		__ASSERT_NO_MSG(err >= 0);
    3fb2:	68bb      	ldr	r3, [r7, #8]
    3fb4:	2b00      	cmp	r3, #0
    3fb6:	da0b      	bge.n	3fd0 <z_nrf_clock_control_lf_on+0x50>
    3fb8:	f44f 7306 	mov.w	r3, #536	; 0x218
    3fbc:	4a17      	ldr	r2, [pc, #92]	; (401c <z_nrf_clock_control_lf_on+0x9c>)
    3fbe:	4918      	ldr	r1, [pc, #96]	; (4020 <z_nrf_clock_control_lf_on+0xa0>)
    3fc0:	4818      	ldr	r0, [pc, #96]	; (4024 <z_nrf_clock_control_lf_on+0xa4>)
    3fc2:	f00c f851 	bl	10068 <printk>
    3fc6:	f44f 7106 	mov.w	r1, #536	; 0x218
    3fca:	4814      	ldr	r0, [pc, #80]	; (401c <z_nrf_clock_control_lf_on+0x9c>)
    3fcc:	f00c fe94 	bl	10cf8 <assert_post_action>
	/* In case of simulated board leave immediately. */
	if (IS_ENABLED(CONFIG_SOC_SERIES_BSIM_NRFXX)) {
		return;
	}

	switch (start_mode) {
    3fd0:	79fb      	ldrb	r3, [r7, #7]
    3fd2:	2b00      	cmp	r3, #0
    3fd4:	d016      	beq.n	4004 <z_nrf_clock_control_lf_on+0x84>
    3fd6:	2b00      	cmp	r3, #0
    3fd8:	db07      	blt.n	3fea <z_nrf_clock_control_lf_on+0x6a>
    3fda:	3b01      	subs	r3, #1
    3fdc:	2b01      	cmp	r3, #1
    3fde:	d804      	bhi.n	3fea <z_nrf_clock_control_lf_on+0x6a>
	case CLOCK_CONTROL_NRF_LF_START_AVAILABLE:
	case CLOCK_CONTROL_NRF_LF_START_STABLE:
		lfclk_spinwait(start_mode);
    3fe0:	79fb      	ldrb	r3, [r7, #7]
    3fe2:	4618      	mov	r0, r3
    3fe4:	f7ff ff28 	bl	3e38 <lfclk_spinwait>
		break;
    3fe8:	e00d      	b.n	4006 <z_nrf_clock_control_lf_on+0x86>

	case CLOCK_CONTROL_NRF_LF_START_NOWAIT:
		break;

	default:
		__ASSERT_NO_MSG(false);
    3fea:	f240 232a 	movw	r3, #554	; 0x22a
    3fee:	4a0b      	ldr	r2, [pc, #44]	; (401c <z_nrf_clock_control_lf_on+0x9c>)
    3ff0:	490d      	ldr	r1, [pc, #52]	; (4028 <z_nrf_clock_control_lf_on+0xa8>)
    3ff2:	480c      	ldr	r0, [pc, #48]	; (4024 <z_nrf_clock_control_lf_on+0xa4>)
    3ff4:	f00c f838 	bl	10068 <printk>
    3ff8:	f240 212a 	movw	r1, #554	; 0x22a
    3ffc:	4807      	ldr	r0, [pc, #28]	; (401c <z_nrf_clock_control_lf_on+0x9c>)
    3ffe:	f00c fe7b 	bl	10cf8 <assert_post_action>
    4002:	e000      	b.n	4006 <z_nrf_clock_control_lf_on+0x86>
		break;
    4004:	bf00      	nop
	}
}
    4006:	3710      	adds	r7, #16
    4008:	46bd      	mov	sp, r7
    400a:	bd80      	pop	{r7, pc}
    400c:	20000710 	.word	0x20000710
    4010:	200001e8 	.word	0x200001e8
    4014:	20000718 	.word	0x20000718
    4018:	20000714 	.word	0x20000714
    401c:	000192c8 	.word	0x000192c8
    4020:	00019344 	.word	0x00019344
    4024:	00019258 	.word	0x00019258
    4028:	000192ac 	.word	0x000192ac

0000402c <clock_event_handler>:

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    402c:	b580      	push	{r7, lr}
    402e:	b084      	sub	sp, #16
    4030:	af00      	add	r7, sp, #0
    4032:	4603      	mov	r3, r0
    4034:	71fb      	strb	r3, [r7, #7]
	const struct device *dev = DEVICE_GET(clock_nrf);
    4036:	4b20      	ldr	r3, [pc, #128]	; (40b8 <clock_event_handler+0x8c>)
    4038:	60fb      	str	r3, [r7, #12]

	switch (event) {
    403a:	79fb      	ldrb	r3, [r7, #7]
    403c:	2b03      	cmp	r3, #3
    403e:	d01b      	beq.n	4078 <clock_event_handler+0x4c>
    4040:	2b03      	cmp	r3, #3
    4042:	dc26      	bgt.n	4092 <clock_event_handler+0x66>
    4044:	2b00      	cmp	r3, #0
    4046:	d002      	beq.n	404e <clock_event_handler+0x22>
    4048:	2b01      	cmp	r3, #1
    404a:	d010      	beq.n	406e <clock_event_handler+0x42>
    404c:	e021      	b.n	4092 <clock_event_handler+0x66>
	case NRFX_CLOCK_EVT_HFCLK_STARTED:
	{
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    404e:	2100      	movs	r1, #0
    4050:	68f8      	ldr	r0, [r7, #12]
    4052:	f00e fbae 	bl	127b2 <get_sub_data>
    4056:	60b8      	str	r0, [r7, #8]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    4058:	68bb      	ldr	r3, [r7, #8]
    405a:	689b      	ldr	r3, [r3, #8]
    405c:	f003 0307 	and.w	r3, r3, #7
    4060:	2b00      	cmp	r3, #0
    4062:	d123      	bne.n	40ac <clock_event_handler+0x80>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    4064:	2100      	movs	r1, #0
    4066:	68f8      	ldr	r0, [r7, #12]
    4068:	f7ff fd50 	bl	3b0c <clkstarted_handle>
		}

		break;
    406c:	e01e      	b.n	40ac <clock_event_handler+0x80>
	case NRFX_CLOCK_EVT_LFCLK_STARTED:
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    406e:	2101      	movs	r1, #1
    4070:	68f8      	ldr	r0, [r7, #12]
    4072:	f7ff fd4b 	bl	3b0c <clkstarted_handle>
		break;
    4076:	e01a      	b.n	40ae <clock_event_handler+0x82>
	case NRFX_CLOCK_EVT_CAL_DONE:
		if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_done_handler();
		} else {
			/* Should not happen when calibration is disabled. */
			__ASSERT_NO_MSG(false);
    4078:	f240 2352 	movw	r3, #594	; 0x252
    407c:	4a0f      	ldr	r2, [pc, #60]	; (40bc <clock_event_handler+0x90>)
    407e:	4910      	ldr	r1, [pc, #64]	; (40c0 <clock_event_handler+0x94>)
    4080:	4810      	ldr	r0, [pc, #64]	; (40c4 <clock_event_handler+0x98>)
    4082:	f00b fff1 	bl	10068 <printk>
    4086:	f240 2152 	movw	r1, #594	; 0x252
    408a:	480c      	ldr	r0, [pc, #48]	; (40bc <clock_event_handler+0x90>)
    408c:	f00c fe34 	bl	10cf8 <assert_post_action>
		}
		break;
    4090:	e00d      	b.n	40ae <clock_event_handler+0x82>
	default:
		__ASSERT_NO_MSG(0);
    4092:	f240 2356 	movw	r3, #598	; 0x256
    4096:	4a09      	ldr	r2, [pc, #36]	; (40bc <clock_event_handler+0x90>)
    4098:	4909      	ldr	r1, [pc, #36]	; (40c0 <clock_event_handler+0x94>)
    409a:	480a      	ldr	r0, [pc, #40]	; (40c4 <clock_event_handler+0x98>)
    409c:	f00b ffe4 	bl	10068 <printk>
    40a0:	f240 2156 	movw	r1, #598	; 0x256
    40a4:	4805      	ldr	r0, [pc, #20]	; (40bc <clock_event_handler+0x90>)
    40a6:	f00c fe27 	bl	10cf8 <assert_post_action>
		break;
    40aa:	e000      	b.n	40ae <clock_event_handler+0x82>
		break;
    40ac:	bf00      	nop
	}
}
    40ae:	bf00      	nop
    40b0:	3710      	adds	r7, #16
    40b2:	46bd      	mov	sp, r7
    40b4:	bd80      	pop	{r7, pc}
    40b6:	bf00      	nop
    40b8:	200001e8 	.word	0x200001e8
    40bc:	000192c8 	.word	0x000192c8
    40c0:	000192ac 	.word	0x000192ac
    40c4:	00019258 	.word	0x00019258

000040c8 <clk_init>:

static int clk_init(const struct device *dev)
{
    40c8:	b580      	push	{r7, lr}
    40ca:	b086      	sub	sp, #24
    40cc:	af00      	add	r7, sp, #0
    40ce:	6078      	str	r0, [r7, #4]
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    40d0:	2200      	movs	r2, #0
    40d2:	2101      	movs	r1, #1
    40d4:	2005      	movs	r0, #5
    40d6:	f000 fd15 	bl	4b04 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    40da:	2005      	movs	r0, #5
    40dc:	f00e fe4f 	bl	12d7e <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    40e0:	4819      	ldr	r0, [pc, #100]	; (4148 <clk_init+0x80>)
    40e2:	f005 fd7d 	bl	9be0 <nrfx_clock_init>
    40e6:	6138      	str	r0, [r7, #16]
	if (nrfx_err != NRFX_SUCCESS) {
    40e8:	693b      	ldr	r3, [r7, #16]
    40ea:	4a18      	ldr	r2, [pc, #96]	; (414c <clk_init+0x84>)
    40ec:	4293      	cmp	r3, r2
    40ee:	d002      	beq.n	40f6 <clk_init+0x2e>
		return -EIO;
    40f0:	f06f 0304 	mvn.w	r3, #4
    40f4:	e024      	b.n	4140 <clk_init+0x78>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    40f6:	f005 fde5 	bl	9cc4 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    40fa:	2300      	movs	r3, #0
    40fc:	75fb      	strb	r3, [r7, #23]
    40fe:	e01b      	b.n	4138 <clk_init+0x70>
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
    4100:	7dfb      	ldrb	r3, [r7, #23]
    4102:	4619      	mov	r1, r3
    4104:	6878      	ldr	r0, [r7, #4]
    4106:	f00e fb54 	bl	127b2 <get_sub_data>
    410a:	60f8      	str	r0, [r7, #12]

		err = onoff_manager_init(get_onoff_manager(dev, i),
    410c:	7dfb      	ldrb	r3, [r7, #23]
    410e:	4619      	mov	r1, r3
    4110:	6878      	ldr	r0, [r7, #4]
    4112:	f00e fb79 	bl	12808 <get_onoff_manager>
    4116:	4603      	mov	r3, r0
    4118:	490d      	ldr	r1, [pc, #52]	; (4150 <clk_init+0x88>)
    411a:	4618      	mov	r0, r3
    411c:	f00c f915 	bl	1034a <onoff_manager_init>
    4120:	60b8      	str	r0, [r7, #8]
					 &transitions);
		if (err < 0) {
    4122:	68bb      	ldr	r3, [r7, #8]
    4124:	2b00      	cmp	r3, #0
    4126:	da01      	bge.n	412c <clk_init+0x64>
			return err;
    4128:	68bb      	ldr	r3, [r7, #8]
    412a:	e009      	b.n	4140 <clk_init+0x78>
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    412c:	68fb      	ldr	r3, [r7, #12]
    412e:	2201      	movs	r2, #1
    4130:	609a      	str	r2, [r3, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    4132:	7dfb      	ldrb	r3, [r7, #23]
    4134:	3301      	adds	r3, #1
    4136:	75fb      	strb	r3, [r7, #23]
	for (enum clock_control_nrf_type i = 0;
    4138:	7dfb      	ldrb	r3, [r7, #23]
    413a:	2b01      	cmp	r3, #1
    413c:	d9e0      	bls.n	4100 <clk_init+0x38>
	}

	return 0;
    413e:	2300      	movs	r3, #0
}
    4140:	4618      	mov	r0, r3
    4142:	3718      	adds	r7, #24
    4144:	46bd      	mov	sp, r7
    4146:	bd80      	pop	{r7, pc}
    4148:	0000402d 	.word	0x0000402d
    414c:	0bad0000 	.word	0x0bad0000
    4150:	0001cb10 	.word	0x0001cb10

00004154 <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
    4154:	b580      	push	{r7, lr}
    4156:	b082      	sub	sp, #8
    4158:	af00      	add	r7, sp, #0
    415a:	6078      	str	r0, [r7, #4]
	__ASSERT_NO_MSG(false);
    415c:	2317      	movs	r3, #23
    415e:	4a06      	ldr	r2, [pc, #24]	; (4178 <z_clock_isr+0x24>)
    4160:	4906      	ldr	r1, [pc, #24]	; (417c <z_clock_isr+0x28>)
    4162:	4807      	ldr	r0, [pc, #28]	; (4180 <z_clock_isr+0x2c>)
    4164:	f00b ff80 	bl	10068 <printk>
    4168:	2117      	movs	r1, #23
    416a:	4803      	ldr	r0, [pc, #12]	; (4178 <z_clock_isr+0x24>)
    416c:	f00c fdc4 	bl	10cf8 <assert_post_action>
}
    4170:	bf00      	nop
    4172:	3708      	adds	r7, #8
    4174:	46bd      	mov	sp, r7
    4176:	bd80      	pop	{r7, pc}
    4178:	000193f8 	.word	0x000193f8
    417c:	0001942c 	.word	0x0001942c
    4180:	00019430 	.word	0x00019430

00004184 <__NVIC_ClearPendingIRQ>:
{
    4184:	b480      	push	{r7}
    4186:	b083      	sub	sp, #12
    4188:	af00      	add	r7, sp, #0
    418a:	4603      	mov	r3, r0
    418c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    418e:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4192:	2b00      	cmp	r3, #0
    4194:	db0c      	blt.n	41b0 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4196:	79fb      	ldrb	r3, [r7, #7]
    4198:	f003 021f 	and.w	r2, r3, #31
    419c:	4907      	ldr	r1, [pc, #28]	; (41bc <__NVIC_ClearPendingIRQ+0x38>)
    419e:	f997 3007 	ldrsb.w	r3, [r7, #7]
    41a2:	095b      	lsrs	r3, r3, #5
    41a4:	2001      	movs	r0, #1
    41a6:	fa00 f202 	lsl.w	r2, r0, r2
    41aa:	3360      	adds	r3, #96	; 0x60
    41ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    41b0:	bf00      	nop
    41b2:	370c      	adds	r7, #12
    41b4:	46bd      	mov	sp, r7
    41b6:	bc80      	pop	{r7}
    41b8:	4770      	bx	lr
    41ba:	bf00      	nop
    41bc:	e000e100 	.word	0xe000e100

000041c0 <nrf_rtc_prescaler_set>:
{
     return p_reg->COUNTER;
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    41c0:	b580      	push	{r7, lr}
    41c2:	b082      	sub	sp, #8
    41c4:	af00      	add	r7, sp, #0
    41c6:	6078      	str	r0, [r7, #4]
    41c8:	6039      	str	r1, [r7, #0]
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    41ca:	683b      	ldr	r3, [r7, #0]
    41cc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    41d0:	d30b      	bcc.n	41ea <nrf_rtc_prescaler_set+0x2a>
    41d2:	f44f 73bb 	mov.w	r3, #374	; 0x176
    41d6:	4a09      	ldr	r2, [pc, #36]	; (41fc <nrf_rtc_prescaler_set+0x3c>)
    41d8:	4909      	ldr	r1, [pc, #36]	; (4200 <nrf_rtc_prescaler_set+0x40>)
    41da:	480a      	ldr	r0, [pc, #40]	; (4204 <nrf_rtc_prescaler_set+0x44>)
    41dc:	f00b ff44 	bl	10068 <printk>
    41e0:	f44f 71bb 	mov.w	r1, #374	; 0x176
    41e4:	4805      	ldr	r0, [pc, #20]	; (41fc <nrf_rtc_prescaler_set+0x3c>)
    41e6:	f00c fd87 	bl	10cf8 <assert_post_action>
    p_reg->PRESCALER = val;
    41ea:	687b      	ldr	r3, [r7, #4]
    41ec:	683a      	ldr	r2, [r7, #0]
    41ee:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
    41f2:	bf00      	nop
    41f4:	3708      	adds	r7, #8
    41f6:	46bd      	mov	sp, r7
    41f8:	bd80      	pop	{r7, pc}
    41fa:	bf00      	nop
    41fc:	0001945c 	.word	0x0001945c
    4200:	00019490 	.word	0x00019490
    4204:	000194b8 	.word	0x000194b8

00004208 <set_comparator>:
{
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(uint32_t cyc)
{
    4208:	b580      	push	{r7, lr}
    420a:	b082      	sub	sp, #8
    420c:	af00      	add	r7, sp, #0
    420e:	6078      	str	r0, [r7, #4]
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    4210:	687b      	ldr	r3, [r7, #4]
    4212:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4216:	461a      	mov	r2, r3
    4218:	2100      	movs	r1, #0
    421a:	4803      	ldr	r0, [pc, #12]	; (4228 <set_comparator+0x20>)
    421c:	f00e fc54 	bl	12ac8 <nrf_rtc_cc_set>
}
    4220:	bf00      	nop
    4222:	3708      	adds	r7, #8
    4224:	46bd      	mov	sp, r7
    4226:	bd80      	pop	{r7, pc}
    4228:	50015000 	.word	0x50015000

0000422c <get_comparator>:

static uint32_t get_comparator(void)
{
    422c:	b580      	push	{r7, lr}
    422e:	af00      	add	r7, sp, #0
	return nrf_rtc_cc_get(RTC, 0);
    4230:	2100      	movs	r1, #0
    4232:	4803      	ldr	r0, [pc, #12]	; (4240 <get_comparator+0x14>)
    4234:	f00e fc5a 	bl	12aec <nrf_rtc_cc_get>
    4238:	4603      	mov	r3, r0
}
    423a:	4618      	mov	r0, r3
    423c:	bd80      	pop	{r7, pc}
    423e:	bf00      	nop
    4240:	50015000 	.word	0x50015000

00004244 <event_clear>:

static void event_clear(void)
{
    4244:	b580      	push	{r7, lr}
    4246:	af00      	add	r7, sp, #0
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
    4248:	f44f 71a0 	mov.w	r1, #320	; 0x140
    424c:	4802      	ldr	r0, [pc, #8]	; (4258 <event_clear+0x14>)
    424e:	f00e fc79 	bl	12b44 <nrf_rtc_event_clear>
}
    4252:	bf00      	nop
    4254:	bd80      	pop	{r7, pc}
    4256:	bf00      	nop
    4258:	50015000 	.word	0x50015000

0000425c <event_enable>:

static void event_enable(void)
{
    425c:	b580      	push	{r7, lr}
    425e:	af00      	add	r7, sp, #0
	nrf_rtc_event_enable(RTC, NRF_RTC_INT_COMPARE0_MASK);
    4260:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    4264:	4802      	ldr	r0, [pc, #8]	; (4270 <event_enable+0x14>)
    4266:	f00e fc9f 	bl	12ba8 <nrf_rtc_event_enable>
}
    426a:	bf00      	nop
    426c:	bd80      	pop	{r7, pc}
    426e:	bf00      	nop
    4270:	50015000 	.word	0x50015000

00004274 <int_disable>:

static void int_disable(void)
{
    4274:	b580      	push	{r7, lr}
    4276:	af00      	add	r7, sp, #0
	nrf_rtc_int_disable(RTC, NRF_RTC_INT_COMPARE0_MASK);
    4278:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    427c:	4802      	ldr	r0, [pc, #8]	; (4288 <int_disable+0x14>)
    427e:	f00e fc53 	bl	12b28 <nrf_rtc_int_disable>
}
    4282:	bf00      	nop
    4284:	bd80      	pop	{r7, pc}
    4286:	bf00      	nop
    4288:	50015000 	.word	0x50015000

0000428c <int_enable>:

static void int_enable(void)
{
    428c:	b580      	push	{r7, lr}
    428e:	af00      	add	r7, sp, #0
	nrf_rtc_int_enable(RTC, NRF_RTC_INT_COMPARE0_MASK);
    4290:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    4294:	4802      	ldr	r0, [pc, #8]	; (42a0 <int_enable+0x14>)
    4296:	f00e fc39 	bl	12b0c <nrf_rtc_int_enable>
}
    429a:	bf00      	nop
    429c:	bd80      	pop	{r7, pc}
    429e:	bf00      	nop
    42a0:	50015000 	.word	0x50015000

000042a4 <counter>:

static uint32_t counter(void)
{
    42a4:	b580      	push	{r7, lr}
    42a6:	af00      	add	r7, sp, #0
	return nrf_rtc_counter_get(RTC);
    42a8:	4802      	ldr	r0, [pc, #8]	; (42b4 <counter+0x10>)
    42aa:	f00e fc60 	bl	12b6e <nrf_rtc_counter_get>
    42ae:	4603      	mov	r3, r0
}
    42b0:	4618      	mov	r0, r3
    42b2:	bd80      	pop	{r7, pc}
    42b4:	50015000 	.word	0x50015000

000042b8 <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
    42b8:	b590      	push	{r4, r7, lr}
    42ba:	b085      	sub	sp, #20
    42bc:	af00      	add	r7, sp, #0
    42be:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(arg);
	event_clear();
    42c0:	f7ff ffc0 	bl	4244 <event_clear>

	uint32_t t = get_comparator();
    42c4:	f7ff ffb2 	bl	422c <get_comparator>
    42c8:	60f8      	str	r0, [r7, #12]
	uint32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    42ca:	4b16      	ldr	r3, [pc, #88]	; (4324 <rtc_nrf_isr+0x6c>)
    42cc:	681b      	ldr	r3, [r3, #0]
    42ce:	4619      	mov	r1, r3
    42d0:	68f8      	ldr	r0, [r7, #12]
    42d2:	f00e fc77 	bl	12bc4 <counter_sub>
    42d6:	4604      	mov	r4, r0
    42d8:	f00e fbe3 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    42dc:	4603      	mov	r3, r0
    42de:	2b00      	cmp	r3, #0
    42e0:	da02      	bge.n	42e8 <rtc_nrf_isr+0x30>
    42e2:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    42e6:	337f      	adds	r3, #127	; 0x7f
    42e8:	13db      	asrs	r3, r3, #15
    42ea:	fbb4 f3f3 	udiv	r3, r4, r3
    42ee:	60bb      	str	r3, [r7, #8]

	last_count += dticks * CYC_PER_TICK;
    42f0:	f00e fbd7 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    42f4:	4603      	mov	r3, r0
    42f6:	2b00      	cmp	r3, #0
    42f8:	da02      	bge.n	4300 <rtc_nrf_isr+0x48>
    42fa:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    42fe:	337f      	adds	r3, #127	; 0x7f
    4300:	13db      	asrs	r3, r3, #15
    4302:	461a      	mov	r2, r3
    4304:	68bb      	ldr	r3, [r7, #8]
    4306:	fb03 f202 	mul.w	r2, r3, r2
    430a:	4b06      	ldr	r3, [pc, #24]	; (4324 <rtc_nrf_isr+0x6c>)
    430c:	681b      	ldr	r3, [r3, #0]
    430e:	4413      	add	r3, r2
    4310:	4a04      	ldr	r2, [pc, #16]	; (4324 <rtc_nrf_isr+0x6c>)
    4312:	6013      	str	r3, [r2, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_alarm(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : (dticks > 0));
    4314:	68bb      	ldr	r3, [r7, #8]
    4316:	4618      	mov	r0, r3
    4318:	f00a ffd8 	bl	f2cc <z_clock_announce>
}
    431c:	bf00      	nop
    431e:	3714      	adds	r7, #20
    4320:	46bd      	mov	sp, r7
    4322:	bd90      	pop	{r4, r7, pc}
    4324:	20000728 	.word	0x20000728

00004328 <z_clock_driver_init>:

int z_clock_driver_init(const struct device *device)
{
    4328:	b580      	push	{r7, lr}
    432a:	b082      	sub	sp, #8
    432c:	af00      	add	r7, sp, #0
    432e:	6078      	str	r0, [r7, #4]
			(IS_ENABLED(CONFIG_SYSTEM_CLOCK_WAIT_FOR_AVAILABILITY) ?
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
    4330:	2100      	movs	r1, #0
    4332:	4812      	ldr	r0, [pc, #72]	; (437c <z_clock_driver_init+0x54>)
    4334:	f7ff ff44 	bl	41c0 <nrf_rtc_prescaler_set>
	event_clear();
    4338:	f7ff ff84 	bl	4244 <event_clear>
	NVIC_ClearPendingIRQ(RTC_IRQn);
    433c:	2015      	movs	r0, #21
    433e:	f7ff ff21 	bl	4184 <__NVIC_ClearPendingIRQ>
	int_enable();
    4342:	f7ff ffa3 	bl	428c <int_enable>

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    4346:	2200      	movs	r2, #0
    4348:	2101      	movs	r1, #1
    434a:	2015      	movs	r0, #21
    434c:	f000 fbda 	bl	4b04 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    4350:	2015      	movs	r0, #21
    4352:	f00e fd14 	bl	12d7e <arch_irq_enable>

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
    4356:	2108      	movs	r1, #8
    4358:	4808      	ldr	r0, [pc, #32]	; (437c <z_clock_driver_init+0x54>)
    435a:	f00e fc14 	bl	12b86 <nrf_rtc_task_trigger>
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);
    435e:	2100      	movs	r1, #0
    4360:	4806      	ldr	r0, [pc, #24]	; (437c <z_clock_driver_init+0x54>)
    4362:	f00e fc10 	bl	12b86 <nrf_rtc_task_trigger>

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	z_nrf_clock_control_lf_on(mode);
    4366:	4b06      	ldr	r3, [pc, #24]	; (4380 <z_clock_driver_init+0x58>)
    4368:	781b      	ldrb	r3, [r3, #0]
    436a:	4618      	mov	r0, r3
    436c:	f7ff fe08 	bl	3f80 <z_nrf_clock_control_lf_on>

	return 0;
    4370:	2300      	movs	r3, #0
}
    4372:	4618      	mov	r0, r3
    4374:	3708      	adds	r7, #8
    4376:	46bd      	mov	sp, r7
    4378:	bd80      	pop	{r7, pc}
    437a:	bf00      	nop
    437c:	50015000 	.word	0x50015000
    4380:	0001cf32 	.word	0x0001cf32

00004384 <z_clock_set_timeout>:

void z_clock_set_timeout(int32_t ticks, bool idle)
{
    4384:	b5b0      	push	{r4, r5, r7, lr}
    4386:	b084      	sub	sp, #16
    4388:	af00      	add	r7, sp, #0
    438a:	6078      	str	r0, [r7, #4]
    438c:	460b      	mov	r3, r1
    438e:	70fb      	strb	r3, [r7, #3]

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    4390:	687b      	ldr	r3, [r7, #4]
    4392:	f1b3 3fff 	cmp.w	r3, #4294967295
    4396:	d116      	bne.n	43c6 <z_clock_set_timeout+0x42>
    4398:	f00e fb83 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    439c:	4603      	mov	r3, r0
    439e:	2b00      	cmp	r3, #0
    43a0:	da02      	bge.n	43a8 <z_clock_set_timeout+0x24>
    43a2:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    43a6:	337f      	adds	r3, #127	; 0x7f
    43a8:	13db      	asrs	r3, r3, #15
    43aa:	f5c3 0400 	rsb	r4, r3, #8388608	; 0x800000
    43ae:	f00e fb78 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    43b2:	4603      	mov	r3, r0
    43b4:	2b00      	cmp	r3, #0
    43b6:	da02      	bge.n	43be <z_clock_set_timeout+0x3a>
    43b8:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    43bc:	337f      	adds	r3, #127	; 0x7f
    43be:	13db      	asrs	r3, r3, #15
    43c0:	fbb4 f3f3 	udiv	r3, r4, r3
    43c4:	e000      	b.n	43c8 <z_clock_set_timeout+0x44>
    43c6:	687b      	ldr	r3, [r7, #4]
    43c8:	607b      	str	r3, [r7, #4]
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    43ca:	687b      	ldr	r3, [r7, #4]
    43cc:	3b01      	subs	r3, #1
    43ce:	2b00      	cmp	r3, #0
    43d0:	dd33      	ble.n	443a <z_clock_set_timeout+0xb6>
    43d2:	687b      	ldr	r3, [r7, #4]
    43d4:	1e5c      	subs	r4, r3, #1
    43d6:	f00e fb64 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    43da:	4603      	mov	r3, r0
    43dc:	2b00      	cmp	r3, #0
    43de:	da02      	bge.n	43e6 <z_clock_set_timeout+0x62>
    43e0:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    43e4:	337f      	adds	r3, #127	; 0x7f
    43e6:	13db      	asrs	r3, r3, #15
    43e8:	f5c3 0500 	rsb	r5, r3, #8388608	; 0x800000
    43ec:	f00e fb59 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    43f0:	4603      	mov	r3, r0
    43f2:	2b00      	cmp	r3, #0
    43f4:	da02      	bge.n	43fc <z_clock_set_timeout+0x78>
    43f6:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    43fa:	337f      	adds	r3, #127	; 0x7f
    43fc:	13db      	asrs	r3, r3, #15
    43fe:	fbb5 f3f3 	udiv	r3, r5, r3
    4402:	429c      	cmp	r4, r3
    4404:	da02      	bge.n	440c <z_clock_set_timeout+0x88>
    4406:	687b      	ldr	r3, [r7, #4]
    4408:	3b01      	subs	r3, #1
    440a:	e017      	b.n	443c <z_clock_set_timeout+0xb8>
    440c:	f00e fb49 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4410:	4603      	mov	r3, r0
    4412:	2b00      	cmp	r3, #0
    4414:	da02      	bge.n	441c <z_clock_set_timeout+0x98>
    4416:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    441a:	337f      	adds	r3, #127	; 0x7f
    441c:	13db      	asrs	r3, r3, #15
    441e:	f5c3 0400 	rsb	r4, r3, #8388608	; 0x800000
    4422:	f00e fb3e 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4426:	4603      	mov	r3, r0
    4428:	2b00      	cmp	r3, #0
    442a:	da02      	bge.n	4432 <z_clock_set_timeout+0xae>
    442c:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    4430:	337f      	adds	r3, #127	; 0x7f
    4432:	13db      	asrs	r3, r3, #15
    4434:	fbb4 f3f3 	udiv	r3, r4, r3
    4438:	e000      	b.n	443c <z_clock_set_timeout+0xb8>
    443a:	2300      	movs	r3, #0
    443c:	607b      	str	r3, [r7, #4]

	uint32_t unannounced = counter_sub(counter(), last_count);
    443e:	f7ff ff31 	bl	42a4 <counter>
    4442:	4602      	mov	r2, r0
    4444:	4b4b      	ldr	r3, [pc, #300]	; (4574 <z_clock_set_timeout+0x1f0>)
    4446:	681b      	ldr	r3, [r3, #0]
    4448:	4619      	mov	r1, r3
    444a:	4610      	mov	r0, r2
    444c:	f00e fbba 	bl	12bc4 <counter_sub>
    4450:	60b8      	str	r0, [r7, #8]
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    4452:	68bb      	ldr	r3, [r7, #8]
    4454:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    4458:	d301      	bcc.n	445e <z_clock_set_timeout+0xda>
		ticks = 0;
    445a:	2300      	movs	r3, #0
    445c:	607b      	str	r3, [r7, #4]
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    445e:	f00e fb20 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4462:	4603      	mov	r3, r0
    4464:	2b00      	cmp	r3, #0
    4466:	da02      	bge.n	446e <z_clock_set_timeout+0xea>
    4468:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    446c:	337f      	adds	r3, #127	; 0x7f
    446e:	13db      	asrs	r3, r3, #15
    4470:	461a      	mov	r2, r3
    4472:	687b      	ldr	r3, [r7, #4]
    4474:	fb03 f302 	mul.w	r3, r3, r2
    4478:	461a      	mov	r2, r3
    447a:	68bb      	ldr	r3, [r7, #8]
    447c:	4413      	add	r3, r2
    447e:	3301      	adds	r3, #1
    4480:	60fb      	str	r3, [r7, #12]
	cyc += (CYC_PER_TICK - 1);
    4482:	f00e fb0e 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4486:	4603      	mov	r3, r0
    4488:	2b00      	cmp	r3, #0
    448a:	da02      	bge.n	4492 <z_clock_set_timeout+0x10e>
    448c:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    4490:	337f      	adds	r3, #127	; 0x7f
    4492:	13db      	asrs	r3, r3, #15
    4494:	3b01      	subs	r3, #1
    4496:	461a      	mov	r2, r3
    4498:	68fb      	ldr	r3, [r7, #12]
    449a:	4413      	add	r3, r2
    449c:	60fb      	str	r3, [r7, #12]
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
    449e:	f00e fb00 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    44a2:	4603      	mov	r3, r0
    44a4:	2b00      	cmp	r3, #0
    44a6:	da02      	bge.n	44ae <z_clock_set_timeout+0x12a>
    44a8:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    44ac:	337f      	adds	r3, #127	; 0x7f
    44ae:	13db      	asrs	r3, r3, #15
    44b0:	461a      	mov	r2, r3
    44b2:	68fb      	ldr	r3, [r7, #12]
    44b4:	fbb3 f4f2 	udiv	r4, r3, r2
    44b8:	f00e faf3 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    44bc:	4603      	mov	r3, r0
    44be:	2b00      	cmp	r3, #0
    44c0:	da02      	bge.n	44c8 <z_clock_set_timeout+0x144>
    44c2:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    44c6:	337f      	adds	r3, #127	; 0x7f
    44c8:	13db      	asrs	r3, r3, #15
    44ca:	fb03 f304 	mul.w	r3, r3, r4
    44ce:	60fb      	str	r3, [r7, #12]

	/* Due to elapsed time the calculation above might produce a
	 * duration that laps the counter.  Don't let it.
	 */
	if (cyc > MAX_CYCLES) {
    44d0:	f00e fae7 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    44d4:	4603      	mov	r3, r0
    44d6:	2b00      	cmp	r3, #0
    44d8:	da02      	bge.n	44e0 <z_clock_set_timeout+0x15c>
    44da:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    44de:	337f      	adds	r3, #127	; 0x7f
    44e0:	13db      	asrs	r3, r3, #15
    44e2:	f5c3 0400 	rsb	r4, r3, #8388608	; 0x800000
    44e6:	f00e fadc 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    44ea:	4603      	mov	r3, r0
    44ec:	2b00      	cmp	r3, #0
    44ee:	da02      	bge.n	44f6 <z_clock_set_timeout+0x172>
    44f0:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    44f4:	337f      	adds	r3, #127	; 0x7f
    44f6:	13db      	asrs	r3, r3, #15
    44f8:	fbb4 f4f3 	udiv	r4, r4, r3
    44fc:	f00e fad1 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4500:	4603      	mov	r3, r0
    4502:	2b00      	cmp	r3, #0
    4504:	da02      	bge.n	450c <z_clock_set_timeout+0x188>
    4506:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    450a:	337f      	adds	r3, #127	; 0x7f
    450c:	13db      	asrs	r3, r3, #15
    450e:	fb03 f304 	mul.w	r3, r3, r4
    4512:	68fa      	ldr	r2, [r7, #12]
    4514:	429a      	cmp	r2, r3
    4516:	d921      	bls.n	455c <z_clock_set_timeout+0x1d8>
		cyc = MAX_CYCLES;
    4518:	f00e fac3 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    451c:	4603      	mov	r3, r0
    451e:	2b00      	cmp	r3, #0
    4520:	da02      	bge.n	4528 <z_clock_set_timeout+0x1a4>
    4522:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    4526:	337f      	adds	r3, #127	; 0x7f
    4528:	13db      	asrs	r3, r3, #15
    452a:	f5c3 0400 	rsb	r4, r3, #8388608	; 0x800000
    452e:	f00e fab8 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4532:	4603      	mov	r3, r0
    4534:	2b00      	cmp	r3, #0
    4536:	da02      	bge.n	453e <z_clock_set_timeout+0x1ba>
    4538:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    453c:	337f      	adds	r3, #127	; 0x7f
    453e:	13db      	asrs	r3, r3, #15
    4540:	fbb4 f4f3 	udiv	r4, r4, r3
    4544:	f00e faad 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    4548:	4603      	mov	r3, r0
    454a:	2b00      	cmp	r3, #0
    454c:	da02      	bge.n	4554 <z_clock_set_timeout+0x1d0>
    454e:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    4552:	337f      	adds	r3, #127	; 0x7f
    4554:	13db      	asrs	r3, r3, #15
    4556:	fb03 f304 	mul.w	r3, r3, r4
    455a:	60fb      	str	r3, [r7, #12]
	}

	cyc += last_count;
    455c:	4b05      	ldr	r3, [pc, #20]	; (4574 <z_clock_set_timeout+0x1f0>)
    455e:	681b      	ldr	r3, [r3, #0]
    4560:	68fa      	ldr	r2, [r7, #12]
    4562:	4413      	add	r3, r2
    4564:	60fb      	str	r3, [r7, #12]
	set_protected_absolute_alarm(cyc);
    4566:	68f8      	ldr	r0, [r7, #12]
    4568:	f00e fbc5 	bl	12cf6 <set_protected_absolute_alarm>
}
    456c:	3710      	adds	r7, #16
    456e:	46bd      	mov	sp, r7
    4570:	bdb0      	pop	{r4, r5, r7, pc}
    4572:	bf00      	nop
    4574:	20000728 	.word	0x20000728

00004578 <z_clock_elapsed>:

uint32_t z_clock_elapsed(void)
{
    4578:	b590      	push	{r4, r7, lr}
    457a:	b08b      	sub	sp, #44	; 0x2c
    457c:	af00      	add	r7, sp, #0
    457e:	4b34      	ldr	r3, [pc, #208]	; (4650 <z_clock_elapsed+0xd8>)
    4580:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    4582:	f04f 0320 	mov.w	r3, #32
    4586:	f3ef 8211 	mrs	r2, BASEPRI
    458a:	f383 8811 	msr	BASEPRI, r3
    458e:	f3bf 8f6f 	isb	sy
    4592:	617a      	str	r2, [r7, #20]
    4594:	613b      	str	r3, [r7, #16]
	return key;
    4596:	697b      	ldr	r3, [r7, #20]
	k.key = arch_irq_lock();
    4598:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    459a:	69b8      	ldr	r0, [r7, #24]
    459c:	f00a fa5c 	bl	ea58 <z_spin_lock_valid>
    45a0:	4603      	mov	r3, r0
    45a2:	f083 0301 	eor.w	r3, r3, #1
    45a6:	b2db      	uxtb	r3, r3
    45a8:	2b00      	cmp	r3, #0
    45aa:	d00d      	beq.n	45c8 <z_clock_elapsed+0x50>
    45ac:	2378      	movs	r3, #120	; 0x78
    45ae:	4a29      	ldr	r2, [pc, #164]	; (4654 <z_clock_elapsed+0xdc>)
    45b0:	4929      	ldr	r1, [pc, #164]	; (4658 <z_clock_elapsed+0xe0>)
    45b2:	482a      	ldr	r0, [pc, #168]	; (465c <z_clock_elapsed+0xe4>)
    45b4:	f00b fd58 	bl	10068 <printk>
    45b8:	69b9      	ldr	r1, [r7, #24]
    45ba:	4829      	ldr	r0, [pc, #164]	; (4660 <z_clock_elapsed+0xe8>)
    45bc:	f00b fd54 	bl	10068 <printk>
    45c0:	2178      	movs	r1, #120	; 0x78
    45c2:	4824      	ldr	r0, [pc, #144]	; (4654 <z_clock_elapsed+0xdc>)
    45c4:	f00c fb98 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    45c8:	69b8      	ldr	r0, [r7, #24]
    45ca:	f00a fa7d 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    45ce:	68bb      	ldr	r3, [r7, #8]
    45d0:	60fb      	str	r3, [r7, #12]
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    45d2:	f7ff fe67 	bl	42a4 <counter>
    45d6:	4602      	mov	r2, r0
    45d8:	4b22      	ldr	r3, [pc, #136]	; (4664 <z_clock_elapsed+0xec>)
    45da:	681b      	ldr	r3, [r3, #0]
    45dc:	4619      	mov	r1, r3
    45de:	4610      	mov	r0, r2
    45e0:	f00e faf0 	bl	12bc4 <counter_sub>
    45e4:	4604      	mov	r4, r0
    45e6:	f00e fa5c 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
    45ea:	4603      	mov	r3, r0
    45ec:	2b00      	cmp	r3, #0
    45ee:	da02      	bge.n	45f6 <z_clock_elapsed+0x7e>
    45f0:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
    45f4:	337f      	adds	r3, #127	; 0x7f
    45f6:	13db      	asrs	r3, r3, #15
    45f8:	fbb4 f3f3 	udiv	r3, r4, r3
    45fc:	627b      	str	r3, [r7, #36]	; 0x24
    45fe:	4b14      	ldr	r3, [pc, #80]	; (4650 <z_clock_elapsed+0xd8>)
    4600:	623b      	str	r3, [r7, #32]
    4602:	68fb      	ldr	r3, [r7, #12]
    4604:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    4606:	6a38      	ldr	r0, [r7, #32]
    4608:	f00a fa42 	bl	ea90 <z_spin_unlock_valid>
    460c:	4603      	mov	r3, r0
    460e:	f083 0301 	eor.w	r3, r3, #1
    4612:	b2db      	uxtb	r3, r3
    4614:	2b00      	cmp	r3, #0
    4616:	d00d      	beq.n	4634 <z_clock_elapsed+0xbc>
    4618:	23a3      	movs	r3, #163	; 0xa3
    461a:	4a0e      	ldr	r2, [pc, #56]	; (4654 <z_clock_elapsed+0xdc>)
    461c:	4912      	ldr	r1, [pc, #72]	; (4668 <z_clock_elapsed+0xf0>)
    461e:	480f      	ldr	r0, [pc, #60]	; (465c <z_clock_elapsed+0xe4>)
    4620:	f00b fd22 	bl	10068 <printk>
    4624:	6a39      	ldr	r1, [r7, #32]
    4626:	4811      	ldr	r0, [pc, #68]	; (466c <z_clock_elapsed+0xf4>)
    4628:	f00b fd1e 	bl	10068 <printk>
    462c:	21a3      	movs	r1, #163	; 0xa3
    462e:	4809      	ldr	r0, [pc, #36]	; (4654 <z_clock_elapsed+0xdc>)
    4630:	f00c fb62 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    4634:	687b      	ldr	r3, [r7, #4]
    4636:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    4638:	69fb      	ldr	r3, [r7, #28]
    463a:	f383 8811 	msr	BASEPRI, r3
    463e:	f3bf 8f6f 	isb	sy
}
    4642:	bf00      	nop
}
    4644:	bf00      	nop

	k_spin_unlock(&lock, key);
	return ret;
    4646:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    4648:	4618      	mov	r0, r3
    464a:	372c      	adds	r7, #44	; 0x2c
    464c:	46bd      	mov	sp, r7
    464e:	bd90      	pop	{r4, r7, pc}
    4650:	20000724 	.word	0x20000724
    4654:	000194d8 	.word	0x000194d8
    4658:	00019500 	.word	0x00019500
    465c:	000194b8 	.word	0x000194b8
    4660:	00019518 	.word	0x00019518
    4664:	20000728 	.word	0x20000728
    4668:	00019530 	.word	0x00019530
    466c:	00019548 	.word	0x00019548

00004670 <z_timer_cycle_get_32>:

uint32_t z_timer_cycle_get_32(void)
{
    4670:	b580      	push	{r7, lr}
    4672:	b08a      	sub	sp, #40	; 0x28
    4674:	af00      	add	r7, sp, #0
    4676:	4b30      	ldr	r3, [pc, #192]	; (4738 <z_timer_cycle_get_32+0xc8>)
    4678:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    467a:	f04f 0320 	mov.w	r3, #32
    467e:	f3ef 8211 	mrs	r2, BASEPRI
    4682:	f383 8811 	msr	BASEPRI, r3
    4686:	f3bf 8f6f 	isb	sy
    468a:	617a      	str	r2, [r7, #20]
    468c:	613b      	str	r3, [r7, #16]
	return key;
    468e:	697b      	ldr	r3, [r7, #20]
	k.key = arch_irq_lock();
    4690:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    4692:	69b8      	ldr	r0, [r7, #24]
    4694:	f00a f9e0 	bl	ea58 <z_spin_lock_valid>
    4698:	4603      	mov	r3, r0
    469a:	f083 0301 	eor.w	r3, r3, #1
    469e:	b2db      	uxtb	r3, r3
    46a0:	2b00      	cmp	r3, #0
    46a2:	d00d      	beq.n	46c0 <z_timer_cycle_get_32+0x50>
    46a4:	2378      	movs	r3, #120	; 0x78
    46a6:	4a25      	ldr	r2, [pc, #148]	; (473c <z_timer_cycle_get_32+0xcc>)
    46a8:	4925      	ldr	r1, [pc, #148]	; (4740 <z_timer_cycle_get_32+0xd0>)
    46aa:	4826      	ldr	r0, [pc, #152]	; (4744 <z_timer_cycle_get_32+0xd4>)
    46ac:	f00b fcdc 	bl	10068 <printk>
    46b0:	69b9      	ldr	r1, [r7, #24]
    46b2:	4825      	ldr	r0, [pc, #148]	; (4748 <z_timer_cycle_get_32+0xd8>)
    46b4:	f00b fcd8 	bl	10068 <printk>
    46b8:	2178      	movs	r1, #120	; 0x78
    46ba:	4820      	ldr	r0, [pc, #128]	; (473c <z_timer_cycle_get_32+0xcc>)
    46bc:	f00c fb1c 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    46c0:	69b8      	ldr	r0, [r7, #24]
    46c2:	f00a fa01 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    46c6:	68bb      	ldr	r3, [r7, #8]
    46c8:	60fb      	str	r3, [r7, #12]
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = counter_sub(counter(), last_count) + last_count;
    46ca:	f7ff fdeb 	bl	42a4 <counter>
    46ce:	4602      	mov	r2, r0
    46d0:	4b1e      	ldr	r3, [pc, #120]	; (474c <z_timer_cycle_get_32+0xdc>)
    46d2:	681b      	ldr	r3, [r3, #0]
    46d4:	4619      	mov	r1, r3
    46d6:	4610      	mov	r0, r2
    46d8:	f00e fa74 	bl	12bc4 <counter_sub>
    46dc:	4602      	mov	r2, r0
    46de:	4b1b      	ldr	r3, [pc, #108]	; (474c <z_timer_cycle_get_32+0xdc>)
    46e0:	681b      	ldr	r3, [r3, #0]
    46e2:	4413      	add	r3, r2
    46e4:	627b      	str	r3, [r7, #36]	; 0x24
    46e6:	4b14      	ldr	r3, [pc, #80]	; (4738 <z_timer_cycle_get_32+0xc8>)
    46e8:	623b      	str	r3, [r7, #32]
    46ea:	68fb      	ldr	r3, [r7, #12]
    46ec:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    46ee:	6a38      	ldr	r0, [r7, #32]
    46f0:	f00a f9ce 	bl	ea90 <z_spin_unlock_valid>
    46f4:	4603      	mov	r3, r0
    46f6:	f083 0301 	eor.w	r3, r3, #1
    46fa:	b2db      	uxtb	r3, r3
    46fc:	2b00      	cmp	r3, #0
    46fe:	d00d      	beq.n	471c <z_timer_cycle_get_32+0xac>
    4700:	23a3      	movs	r3, #163	; 0xa3
    4702:	4a0e      	ldr	r2, [pc, #56]	; (473c <z_timer_cycle_get_32+0xcc>)
    4704:	4912      	ldr	r1, [pc, #72]	; (4750 <z_timer_cycle_get_32+0xe0>)
    4706:	480f      	ldr	r0, [pc, #60]	; (4744 <z_timer_cycle_get_32+0xd4>)
    4708:	f00b fcae 	bl	10068 <printk>
    470c:	6a39      	ldr	r1, [r7, #32]
    470e:	4811      	ldr	r0, [pc, #68]	; (4754 <z_timer_cycle_get_32+0xe4>)
    4710:	f00b fcaa 	bl	10068 <printk>
    4714:	21a3      	movs	r1, #163	; 0xa3
    4716:	4809      	ldr	r0, [pc, #36]	; (473c <z_timer_cycle_get_32+0xcc>)
    4718:	f00c faee 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    471c:	687b      	ldr	r3, [r7, #4]
    471e:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    4720:	69fb      	ldr	r3, [r7, #28]
    4722:	f383 8811 	msr	BASEPRI, r3
    4726:	f3bf 8f6f 	isb	sy
}
    472a:	bf00      	nop
}
    472c:	bf00      	nop

	k_spin_unlock(&lock, key);
	return ret;
    472e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    4730:	4618      	mov	r0, r3
    4732:	3728      	adds	r7, #40	; 0x28
    4734:	46bd      	mov	sp, r7
    4736:	bd80      	pop	{r7, pc}
    4738:	20000724 	.word	0x20000724
    473c:	000194d8 	.word	0x000194d8
    4740:	00019500 	.word	0x00019500
    4744:	000194b8 	.word	0x000194b8
    4748:	00019518 	.word	0x00019518
    474c:	20000728 	.word	0x20000728
    4750:	00019530 	.word	0x00019530
    4754:	00019548 	.word	0x00019548

00004758 <nrf_cc3xx_platform_abort_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
    4758:	b580      	push	{r7, lr}
    475a:	af00      	add	r7, sp, #0
	nrf_cc3xx_platform_set_abort(&apis);
    475c:	4802      	ldr	r0, [pc, #8]	; (4768 <nrf_cc3xx_platform_abort_init+0x10>)
    475e:	f00b f893 	bl	f888 <nrf_cc3xx_platform_set_abort>
}
    4762:	bf00      	nop
    4764:	bd80      	pop	{r7, pc}
    4766:	bf00      	nop
    4768:	0001cb1c 	.word	0x0001cb1c

0000476c <mutex_init_platform>:
};


/**@brief static function to initialize a mutex
 */
static void mutex_init_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    476c:	b580      	push	{r7, lr}
    476e:	b084      	sub	sp, #16
    4770:	af00      	add	r7, sp, #0
    4772:	6078      	str	r0, [r7, #4]
    int ret;
    struct k_mutex * p_mutex;

    /* Ensure that the mutex is valid (not NULL) */
    if (mutex == NULL) {
    4774:	687b      	ldr	r3, [r7, #4]
    4776:	2b00      	cmp	r3, #0
    4778:	d103      	bne.n	4782 <mutex_init_platform+0x16>
        platform_abort_apis.abort_fn(
    477a:	4b1e      	ldr	r3, [pc, #120]	; (47f4 <mutex_init_platform+0x88>)
    477c:	685b      	ldr	r3, [r3, #4]
    477e:	481e      	ldr	r0, [pc, #120]	; (47f8 <mutex_init_platform+0x8c>)
    4780:	4798      	blx	r3
            "mutex_init called with NULL parameter");
    }

    /* Allocate if this has not been initialized statically */
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    4782:	687b      	ldr	r3, [r7, #4]
    4784:	685b      	ldr	r3, [r3, #4]
    4786:	2b00      	cmp	r3, #0
    4788:	d124      	bne.n	47d4 <mutex_init_platform+0x68>
        mutex->mutex == NULL) {
    478a:	687b      	ldr	r3, [r7, #4]
    478c:	681b      	ldr	r3, [r3, #0]
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    478e:	2b00      	cmp	r3, #0
    4790:	d120      	bne.n	47d4 <mutex_init_platform+0x68>
        /* Allocate some memory for the mutex */
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    4792:	6879      	ldr	r1, [r7, #4]
    4794:	f04f 32ff 	mov.w	r2, #4294967295
    4798:	f04f 33ff 	mov.w	r3, #4294967295
    479c:	4817      	ldr	r0, [pc, #92]	; (47fc <mutex_init_platform+0x90>)
    479e:	f006 fe57 	bl	b450 <k_mem_slab_alloc>
    47a2:	60f8      	str	r0, [r7, #12]
        if(ret != 0 || mutex->mutex == NULL)
    47a4:	68fb      	ldr	r3, [r7, #12]
    47a6:	2b00      	cmp	r3, #0
    47a8:	d103      	bne.n	47b2 <mutex_init_platform+0x46>
    47aa:	687b      	ldr	r3, [r7, #4]
    47ac:	681b      	ldr	r3, [r3, #0]
    47ae:	2b00      	cmp	r3, #0
    47b0:	d103      	bne.n	47ba <mutex_init_platform+0x4e>
        {
            /* Allocation failed. Abort all operations */
            platform_abort_apis.abort_fn(
    47b2:	4b10      	ldr	r3, [pc, #64]	; (47f4 <mutex_init_platform+0x88>)
    47b4:	685b      	ldr	r3, [r3, #4]
    47b6:	4812      	ldr	r0, [pc, #72]	; (4800 <mutex_init_platform+0x94>)
    47b8:	4798      	blx	r3
                "Could not allocate mutex before initializing");
        }

        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    47ba:	687b      	ldr	r3, [r7, #4]
    47bc:	681b      	ldr	r3, [r3, #0]
    47be:	2214      	movs	r2, #20
    47c0:	2100      	movs	r1, #0
    47c2:	4618      	mov	r0, r3
    47c4:	f00e fd09 	bl	131da <memset>

        /** Set a flag to ensure that mutex is deallocated by the freeing
         * operation
         */
        mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    47c8:	687b      	ldr	r3, [r7, #4]
    47ca:	685b      	ldr	r3, [r3, #4]
    47cc:	f043 0202 	orr.w	r2, r3, #2
    47d0:	687b      	ldr	r3, [r7, #4]
    47d2:	605a      	str	r2, [r3, #4]
    }

    p_mutex = (struct k_mutex *)mutex->mutex;
    47d4:	687b      	ldr	r3, [r7, #4]
    47d6:	681b      	ldr	r3, [r3, #0]
    47d8:	60bb      	str	r3, [r7, #8]
    k_mutex_init(p_mutex);
    47da:	68b8      	ldr	r0, [r7, #8]
    47dc:	f00e faa7 	bl	12d2e <k_mutex_init>

    /* Set the mask to indicate that the mutex is valid */
    mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID;
    47e0:	687b      	ldr	r3, [r7, #4]
    47e2:	685b      	ldr	r3, [r3, #4]
    47e4:	f043 0201 	orr.w	r2, r3, #1
    47e8:	687b      	ldr	r3, [r7, #4]
    47ea:	605a      	str	r2, [r3, #4]
}
    47ec:	bf00      	nop
    47ee:	3710      	adds	r7, #16
    47f0:	46bd      	mov	sp, r7
    47f2:	bd80      	pop	{r7, pc}
    47f4:	20000188 	.word	0x20000188
    47f8:	00019560 	.word	0x00019560
    47fc:	2000072c 	.word	0x2000072c
    4800:	00019588 	.word	0x00019588

00004804 <mutex_free_platform>:


/** @brief Static function to free a mutex
 */
static void mutex_free_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    4804:	b580      	push	{r7, lr}
    4806:	b082      	sub	sp, #8
    4808:	af00      	add	r7, sp, #0
    480a:	6078      	str	r0, [r7, #4]
    /* Ensure that the mutex is valid (not NULL) */
    if (mutex == NULL) {
    480c:	687b      	ldr	r3, [r7, #4]
    480e:	2b00      	cmp	r3, #0
    4810:	d103      	bne.n	481a <mutex_free_platform+0x16>
        platform_abort_apis.abort_fn(
    4812:	4b13      	ldr	r3, [pc, #76]	; (4860 <mutex_free_platform+0x5c>)
    4814:	685b      	ldr	r3, [r3, #4]
    4816:	4813      	ldr	r0, [pc, #76]	; (4864 <mutex_free_platform+0x60>)
    4818:	4798      	blx	r3
            "mutex_init called with NULL parameter");
    }

    /* Check if we are freeing a mutex that isn't initialized */
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    481a:	687b      	ldr	r3, [r7, #4]
    481c:	685b      	ldr	r3, [r3, #4]
    481e:	2b00      	cmp	r3, #0
    4820:	d01a      	beq.n	4858 <mutex_free_platform+0x54>
        /*Nothing to free*/
        return;
    }

    /* Check if the mutex was allocated or being statically defined */
    if ((mutex->flags & NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED) != 0) {
    4822:	687b      	ldr	r3, [r7, #4]
    4824:	685b      	ldr	r3, [r3, #4]
    4826:	f003 0302 	and.w	r3, r3, #2
    482a:	2b00      	cmp	r3, #0
    482c:	d009      	beq.n	4842 <mutex_free_platform+0x3e>
        k_mem_slab_free(&mutex_slab, mutex->mutex);
    482e:	687b      	ldr	r3, [r7, #4]
    4830:	681b      	ldr	r3, [r3, #0]
    4832:	4619      	mov	r1, r3
    4834:	480c      	ldr	r0, [pc, #48]	; (4868 <mutex_free_platform+0x64>)
    4836:	f006 feb1 	bl	b59c <k_mem_slab_free>
        mutex->mutex = NULL;
    483a:	687b      	ldr	r3, [r7, #4]
    483c:	2200      	movs	r2, #0
    483e:	601a      	str	r2, [r3, #0]
    4840:	e006      	b.n	4850 <mutex_free_platform+0x4c>
    }
    else {
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    4842:	687b      	ldr	r3, [r7, #4]
    4844:	681b      	ldr	r3, [r3, #0]
    4846:	2214      	movs	r2, #20
    4848:	2100      	movs	r1, #0
    484a:	4618      	mov	r0, r3
    484c:	f00e fcc5 	bl	131da <memset>
    }

    /* Reset the mutex to invalid state */
    mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID;
    4850:	687b      	ldr	r3, [r7, #4]
    4852:	2200      	movs	r2, #0
    4854:	605a      	str	r2, [r3, #4]
    4856:	e000      	b.n	485a <mutex_free_platform+0x56>
        return;
    4858:	bf00      	nop
}
    485a:	3708      	adds	r7, #8
    485c:	46bd      	mov	sp, r7
    485e:	bd80      	pop	{r7, pc}
    4860:	20000188 	.word	0x20000188
    4864:	00019560 	.word	0x00019560
    4868:	2000072c 	.word	0x2000072c

0000486c <mutex_lock_platform>:


/** @brief Static function to lock a mutex
 */
static int32_t mutex_lock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    486c:	b580      	push	{r7, lr}
    486e:	b084      	sub	sp, #16
    4870:	af00      	add	r7, sp, #0
    4872:	6078      	str	r0, [r7, #4]
    int ret;
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    4874:	687b      	ldr	r3, [r7, #4]
    4876:	2b00      	cmp	r3, #0
    4878:	d102      	bne.n	4880 <mutex_lock_platform+0x14>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    487a:	f46f 43e0 	mvn.w	r3, #28672	; 0x7000
    487e:	e018      	b.n	48b2 <mutex_lock_platform+0x46>
    }

    /* Ensure that the mutex has been initialized */
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    4880:	687b      	ldr	r3, [r7, #4]
    4882:	685b      	ldr	r3, [r3, #4]
    4884:	2b00      	cmp	r3, #0
    4886:	d101      	bne.n	488c <mutex_lock_platform+0x20>
        return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    4888:	4b0c      	ldr	r3, [pc, #48]	; (48bc <mutex_lock_platform+0x50>)
    488a:	e012      	b.n	48b2 <mutex_lock_platform+0x46>
    }

    p_mutex = (struct k_mutex *)mutex->mutex;
    488c:	687b      	ldr	r3, [r7, #4]
    488e:	681b      	ldr	r3, [r3, #0]
    4890:	60fb      	str	r3, [r7, #12]

    ret = k_mutex_lock(p_mutex, K_FOREVER);
    4892:	f04f 30ff 	mov.w	r0, #4294967295
    4896:	f04f 31ff 	mov.w	r1, #4294967295
    489a:	4602      	mov	r2, r0
    489c:	460b      	mov	r3, r1
    489e:	68f8      	ldr	r0, [r7, #12]
    48a0:	f00e fa51 	bl	12d46 <k_mutex_lock>
    48a4:	60b8      	str	r0, [r7, #8]
    if (ret == 0) {
    48a6:	68bb      	ldr	r3, [r7, #8]
    48a8:	2b00      	cmp	r3, #0
    48aa:	d101      	bne.n	48b0 <mutex_lock_platform+0x44>
        return NRF_CC3XX_PLATFORM_SUCCESS;
    48ac:	2300      	movs	r3, #0
    48ae:	e000      	b.n	48b2 <mutex_lock_platform+0x46>
    }
    else {
        return NRF_CC3XX_PLATFORM_ERROR_MUTEX_FAILED;
    48b0:	4b03      	ldr	r3, [pc, #12]	; (48c0 <mutex_lock_platform+0x54>)
    }
}
    48b2:	4618      	mov	r0, r3
    48b4:	3710      	adds	r7, #16
    48b6:	46bd      	mov	sp, r7
    48b8:	bd80      	pop	{r7, pc}
    48ba:	bf00      	nop
    48bc:	ffff8fea 	.word	0xffff8fea
    48c0:	ffff8fe9 	.word	0xffff8fe9

000048c4 <mutex_unlock_platform>:


/** @brief Static function to unlock a mutex
 */
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    48c4:	b580      	push	{r7, lr}
    48c6:	b084      	sub	sp, #16
    48c8:	af00      	add	r7, sp, #0
    48ca:	6078      	str	r0, [r7, #4]
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    48cc:	687b      	ldr	r3, [r7, #4]
    48ce:	2b00      	cmp	r3, #0
    48d0:	d102      	bne.n	48d8 <mutex_unlock_platform+0x14>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    48d2:	f46f 43e0 	mvn.w	r3, #28672	; 0x7000
    48d6:	e00c      	b.n	48f2 <mutex_unlock_platform+0x2e>
    }

    /* Ensure that the mutex has been initialized */
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    48d8:	687b      	ldr	r3, [r7, #4]
    48da:	685b      	ldr	r3, [r3, #4]
    48dc:	2b00      	cmp	r3, #0
    48de:	d101      	bne.n	48e4 <mutex_unlock_platform+0x20>
        return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    48e0:	4b06      	ldr	r3, [pc, #24]	; (48fc <mutex_unlock_platform+0x38>)
    48e2:	e006      	b.n	48f2 <mutex_unlock_platform+0x2e>
    }

    p_mutex = (struct k_mutex *)mutex->mutex;
    48e4:	687b      	ldr	r3, [r7, #4]
    48e6:	681b      	ldr	r3, [r3, #0]
    48e8:	60fb      	str	r3, [r7, #12]

    k_mutex_unlock(p_mutex);
    48ea:	68f8      	ldr	r0, [r7, #12]
    48ec:	f00e fa3b 	bl	12d66 <k_mutex_unlock>
    return NRF_CC3XX_PLATFORM_SUCCESS;
    48f0:	2300      	movs	r3, #0
}
    48f2:	4618      	mov	r0, r3
    48f4:	3710      	adds	r7, #16
    48f6:	46bd      	mov	sp, r7
    48f8:	bd80      	pop	{r7, pc}
    48fa:	bf00      	nop
    48fc:	ffff8fea 	.word	0xffff8fea

00004900 <nrf_cc3xx_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
    4900:	b580      	push	{r7, lr}
    4902:	af00      	add	r7, sp, #0
    k_mem_slab_init(&mutex_slab,
    4904:	2340      	movs	r3, #64	; 0x40
    4906:	2214      	movs	r2, #20
    4908:	4904      	ldr	r1, [pc, #16]	; (491c <nrf_cc3xx_platform_mutex_init+0x1c>)
    490a:	4805      	ldr	r0, [pc, #20]	; (4920 <nrf_cc3xx_platform_mutex_init+0x20>)
    490c:	f012 fab0 	bl	16e70 <k_mem_slab_init>
            mutex_slab_buffer,
            sizeof(struct k_mutex),
            NUM_MUTEXES);

    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
    4910:	4904      	ldr	r1, [pc, #16]	; (4924 <nrf_cc3xx_platform_mutex_init+0x24>)
    4912:	4805      	ldr	r0, [pc, #20]	; (4928 <nrf_cc3xx_platform_mutex_init+0x28>)
    4914:	f00b f80a 	bl	f92c <nrf_cc3xx_platform_set_mutexes>
}
    4918:	bf00      	nop
    491a:	bd80      	pop	{r7, pc}
    491c:	20000748 	.word	0x20000748
    4920:	2000072c 	.word	0x2000072c
    4924:	0001cb34 	.word	0x0001cb34
    4928:	0001cb24 	.word	0x0001cb24

0000492c <arch_swap>:
 *
 * On ARMv6-M, the intlock key is represented by the PRIMASK register,
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
    492c:	b480      	push	{r7}
    492e:	b085      	sub	sp, #20
    4930:	af00      	add	r7, sp, #0
    4932:	6078      	str	r0, [r7, #4]
	/* store off key and return value */
	_current->arch.basepri = key;
    4934:	4b10      	ldr	r3, [pc, #64]	; (4978 <arch_swap+0x4c>)
    4936:	689b      	ldr	r3, [r3, #8]
    4938:	687a      	ldr	r2, [r7, #4]
    493a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	_current->arch.swap_return_value = _k_neg_eagain;
    493e:	4b0f      	ldr	r3, [pc, #60]	; (497c <arch_swap+0x50>)
    4940:	681a      	ldr	r2, [r3, #0]
    4942:	4b0d      	ldr	r3, [pc, #52]	; (4978 <arch_swap+0x4c>)
    4944:	689b      	ldr	r3, [r3, #8]
    4946:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    494a:	4b0d      	ldr	r3, [pc, #52]	; (4980 <arch_swap+0x54>)
    494c:	685b      	ldr	r3, [r3, #4]
    494e:	4a0c      	ldr	r2, [pc, #48]	; (4980 <arch_swap+0x54>)
    4950:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    4954:	6053      	str	r3, [r2, #4]
    4956:	2300      	movs	r3, #0
    4958:	60fb      	str	r3, [r7, #12]
	__asm__ volatile(
    495a:	68fb      	ldr	r3, [r7, #12]
    495c:	f383 8811 	msr	BASEPRI, r3
    4960:	f3bf 8f6f 	isb	sy
}
    4964:	bf00      	nop
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    4966:	4b04      	ldr	r3, [pc, #16]	; (4978 <arch_swap+0x4c>)
    4968:	689b      	ldr	r3, [r3, #8]
    496a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
}
    496e:	4618      	mov	r0, r3
    4970:	3714      	adds	r7, #20
    4972:	46bd      	mov	sp, r7
    4974:	bc80      	pop	{r7}
    4976:	4770      	bx	lr
    4978:	20000cd8 	.word	0x20000cd8
    497c:	0001cdfc 	.word	0x0001cdfc
    4980:	e000ed00 	.word	0xe000ed00

00004984 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    4984:	4914      	ldr	r1, [pc, #80]	; (49d8 <z_arm_pendsv+0x54>)
    ldr r2, [r1, #_kernel_offset_to_current]
    4986:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    4988:	f04f 0040 	mov.w	r0, #64	; 0x40
    add r0, r2
    498c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    498e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    4992:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    4996:	2020      	movs	r0, #32
    msr BASEPRI, r0
    4998:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    499c:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    49a0:	4f0e      	ldr	r7, [pc, #56]	; (49dc <z_arm_pendsv+0x58>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    49a2:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    49a6:	6a8a      	ldr	r2, [r1, #40]	; 0x28

    str r2, [r1, #_kernel_offset_to_current]
    49a8:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    49aa:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    49ac:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
    movs r3, #0
    49b0:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    49b2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    49b6:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    49ba:	f102 0040 	add.w	r0, r2, #64	; 0x40
    ldmia r0, {v1-v8, ip}
    49be:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    49c2:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
    49c6:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
    49ca:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
    49cc:	f00e f9fd 	bl	12dca <configure_builtin_stack_guard>
    pop {r2, lr}
    49d0:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    49d4:	4770      	bx	lr
    49d6:	0000      	.short	0x0000
    ldr r1, =_kernel
    49d8:	20000cd8 	.word	0x20000cd8
    ldr v4, =_SCS_ICSR
    49dc:	e000ed04 	.word	0xe000ed04

000049e0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    49e0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    49e4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    49e6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    49ea:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    49ee:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    49f0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    49f4:	2902      	cmp	r1, #2
    beq _oops
    49f6:	d0ff      	beq.n	49f8 <_oops>

000049f8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    49f8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    49fa:	f00e fa18 	bl	12e2e <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    49fe:	bd01      	pop	{r0, pc}

00004a00 <__NVIC_EnableIRQ>:
{
    4a00:	b480      	push	{r7}
    4a02:	b083      	sub	sp, #12
    4a04:	af00      	add	r7, sp, #0
    4a06:	4603      	mov	r3, r0
    4a08:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    4a0a:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a0e:	2b00      	cmp	r3, #0
    4a10:	db0b      	blt.n	4a2a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4a12:	79fb      	ldrb	r3, [r7, #7]
    4a14:	f003 021f 	and.w	r2, r3, #31
    4a18:	4906      	ldr	r1, [pc, #24]	; (4a34 <__NVIC_EnableIRQ+0x34>)
    4a1a:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a1e:	095b      	lsrs	r3, r3, #5
    4a20:	2001      	movs	r0, #1
    4a22:	fa00 f202 	lsl.w	r2, r0, r2
    4a26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4a2a:	bf00      	nop
    4a2c:	370c      	adds	r7, #12
    4a2e:	46bd      	mov	sp, r7
    4a30:	bc80      	pop	{r7}
    4a32:	4770      	bx	lr
    4a34:	e000e100 	.word	0xe000e100

00004a38 <__NVIC_DisableIRQ>:
{
    4a38:	b480      	push	{r7}
    4a3a:	b083      	sub	sp, #12
    4a3c:	af00      	add	r7, sp, #0
    4a3e:	4603      	mov	r3, r0
    4a40:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    4a42:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a46:	2b00      	cmp	r3, #0
    4a48:	db12      	blt.n	4a70 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4a4a:	79fb      	ldrb	r3, [r7, #7]
    4a4c:	f003 021f 	and.w	r2, r3, #31
    4a50:	490a      	ldr	r1, [pc, #40]	; (4a7c <__NVIC_DisableIRQ+0x44>)
    4a52:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a56:	095b      	lsrs	r3, r3, #5
    4a58:	2001      	movs	r0, #1
    4a5a:	fa00 f202 	lsl.w	r2, r0, r2
    4a5e:	3320      	adds	r3, #32
    4a60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4a64:	f3bf 8f4f 	dsb	sy
}
    4a68:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
    4a6a:	f3bf 8f6f 	isb	sy
}
    4a6e:	bf00      	nop
}
    4a70:	bf00      	nop
    4a72:	370c      	adds	r7, #12
    4a74:	46bd      	mov	sp, r7
    4a76:	bc80      	pop	{r7}
    4a78:	4770      	bx	lr
    4a7a:	bf00      	nop
    4a7c:	e000e100 	.word	0xe000e100

00004a80 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    4a80:	b480      	push	{r7}
    4a82:	b083      	sub	sp, #12
    4a84:	af00      	add	r7, sp, #0
    4a86:	4603      	mov	r3, r0
    4a88:	6039      	str	r1, [r7, #0]
    4a8a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    4a8c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a90:	2b00      	cmp	r3, #0
    4a92:	db0a      	blt.n	4aaa <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4a94:	683b      	ldr	r3, [r7, #0]
    4a96:	b2da      	uxtb	r2, r3
    4a98:	490c      	ldr	r1, [pc, #48]	; (4acc <__NVIC_SetPriority+0x4c>)
    4a9a:	f997 3007 	ldrsb.w	r3, [r7, #7]
    4a9e:	0152      	lsls	r2, r2, #5
    4aa0:	b2d2      	uxtb	r2, r2
    4aa2:	440b      	add	r3, r1
    4aa4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
    4aa8:	e00a      	b.n	4ac0 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4aaa:	683b      	ldr	r3, [r7, #0]
    4aac:	b2da      	uxtb	r2, r3
    4aae:	4908      	ldr	r1, [pc, #32]	; (4ad0 <__NVIC_SetPriority+0x50>)
    4ab0:	79fb      	ldrb	r3, [r7, #7]
    4ab2:	f003 030f 	and.w	r3, r3, #15
    4ab6:	3b04      	subs	r3, #4
    4ab8:	0152      	lsls	r2, r2, #5
    4aba:	b2d2      	uxtb	r2, r2
    4abc:	440b      	add	r3, r1
    4abe:	761a      	strb	r2, [r3, #24]
}
    4ac0:	bf00      	nop
    4ac2:	370c      	adds	r7, #12
    4ac4:	46bd      	mov	sp, r7
    4ac6:	bc80      	pop	{r7}
    4ac8:	4770      	bx	lr
    4aca:	bf00      	nop
    4acc:	e000e100 	.word	0xe000e100
    4ad0:	e000ed00 	.word	0xe000ed00

00004ad4 <arch_irq_is_enabled>:
{
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
    4ad4:	b480      	push	{r7}
    4ad6:	b083      	sub	sp, #12
    4ad8:	af00      	add	r7, sp, #0
    4ada:	6078      	str	r0, [r7, #4]
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    4adc:	4a08      	ldr	r2, [pc, #32]	; (4b00 <arch_irq_is_enabled+0x2c>)
    4ade:	687b      	ldr	r3, [r7, #4]
    4ae0:	095b      	lsrs	r3, r3, #5
    4ae2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4ae6:	687b      	ldr	r3, [r7, #4]
    4ae8:	f003 031f 	and.w	r3, r3, #31
    4aec:	2101      	movs	r1, #1
    4aee:	fa01 f303 	lsl.w	r3, r1, r3
    4af2:	4013      	ands	r3, r2
}
    4af4:	4618      	mov	r0, r3
    4af6:	370c      	adds	r7, #12
    4af8:	46bd      	mov	sp, r7
    4afa:	bc80      	pop	{r7}
    4afc:	4770      	bx	lr
    4afe:	bf00      	nop
    4b00:	e000e100 	.word	0xe000e100

00004b04 <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    4b04:	b580      	push	{r7, lr}
    4b06:	b084      	sub	sp, #16
    4b08:	af00      	add	r7, sp, #0
    4b0a:	60f8      	str	r0, [r7, #12]
    4b0c:	60b9      	str	r1, [r7, #8]
    4b0e:	607a      	str	r2, [r7, #4]
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
    4b10:	68bb      	ldr	r3, [r7, #8]
    4b12:	3301      	adds	r3, #1
    4b14:	60bb      	str	r3, [r7, #8]
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
    4b16:	68bb      	ldr	r3, [r7, #8]
    4b18:	2b07      	cmp	r3, #7
    4b1a:	d910      	bls.n	4b3e <z_arm_irq_priority_set+0x3a>
    4b1c:	235b      	movs	r3, #91	; 0x5b
    4b1e:	4a0d      	ldr	r2, [pc, #52]	; (4b54 <z_arm_irq_priority_set+0x50>)
    4b20:	490d      	ldr	r1, [pc, #52]	; (4b58 <z_arm_irq_priority_set+0x54>)
    4b22:	480e      	ldr	r0, [pc, #56]	; (4b5c <z_arm_irq_priority_set+0x58>)
    4b24:	f00b faa0 	bl	10068 <printk>
    4b28:	68bb      	ldr	r3, [r7, #8]
    4b2a:	3b01      	subs	r3, #1
    4b2c:	2207      	movs	r2, #7
    4b2e:	4619      	mov	r1, r3
    4b30:	480b      	ldr	r0, [pc, #44]	; (4b60 <z_arm_irq_priority_set+0x5c>)
    4b32:	f00b fa99 	bl	10068 <printk>
    4b36:	215b      	movs	r1, #91	; 0x5b
    4b38:	4806      	ldr	r0, [pc, #24]	; (4b54 <z_arm_irq_priority_set+0x50>)
    4b3a:	f00c f8dd 	bl	10cf8 <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    4b3e:	68fb      	ldr	r3, [r7, #12]
    4b40:	b25b      	sxtb	r3, r3
    4b42:	68b9      	ldr	r1, [r7, #8]
    4b44:	4618      	mov	r0, r3
    4b46:	f7ff ff9b 	bl	4a80 <__NVIC_SetPriority>
}
    4b4a:	bf00      	nop
    4b4c:	3710      	adds	r7, #16
    4b4e:	46bd      	mov	sp, r7
    4b50:	bd80      	pop	{r7, pc}
    4b52:	bf00      	nop
    4b54:	000195b8 	.word	0x000195b8
    4b58:	000195f0 	.word	0x000195f0
    4b5c:	0001960c 	.word	0x0001960c
    4b60:	0001962c 	.word	0x0001962c

00004b64 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    4b64:	b480      	push	{r7}
    4b66:	b087      	sub	sp, #28
    4b68:	af00      	add	r7, sp, #0
    4b6a:	60f8      	str	r0, [r7, #12]
    4b6c:	60b9      	str	r1, [r7, #8]
    4b6e:	607a      	str	r2, [r7, #4]
    4b70:	603b      	str	r3, [r7, #0]
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    4b72:	687b      	ldr	r3, [r7, #4]
    4b74:	3b20      	subs	r3, #32
    4b76:	617b      	str	r3, [r7, #20]
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
    4b78:	4a12      	ldr	r2, [pc, #72]	; (4bc4 <arch_new_thread+0x60>)
    4b7a:	697b      	ldr	r3, [r7, #20]
    4b7c:	619a      	str	r2, [r3, #24]
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    4b7e:	697b      	ldr	r3, [r7, #20]
    4b80:	699b      	ldr	r3, [r3, #24]
    4b82:	f023 0201 	bic.w	r2, r3, #1
    4b86:	697b      	ldr	r3, [r7, #20]
    4b88:	619a      	str	r2, [r3, #24]
#endif
	iframe->a1 = (uint32_t)entry;
    4b8a:	683a      	ldr	r2, [r7, #0]
    4b8c:	697b      	ldr	r3, [r7, #20]
    4b8e:	601a      	str	r2, [r3, #0]
	iframe->a2 = (uint32_t)p1;
    4b90:	6a3a      	ldr	r2, [r7, #32]
    4b92:	697b      	ldr	r3, [r7, #20]
    4b94:	605a      	str	r2, [r3, #4]
	iframe->a3 = (uint32_t)p2;
    4b96:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    4b98:	697b      	ldr	r3, [r7, #20]
    4b9a:	609a      	str	r2, [r3, #8]
	iframe->a4 = (uint32_t)p3;
    4b9c:	6aba      	ldr	r2, [r7, #40]	; 0x28
    4b9e:	697b      	ldr	r3, [r7, #20]
    4ba0:	60da      	str	r2, [r3, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    4ba2:	697b      	ldr	r3, [r7, #20]
    4ba4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    4ba8:	61da      	str	r2, [r3, #28]
#if defined(CONFIG_COMPILER_ISA_THUMB2)
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
    4baa:	697a      	ldr	r2, [r7, #20]
    4bac:	68fb      	ldr	r3, [r7, #12]
    4bae:	661a      	str	r2, [r3, #96]	; 0x60
	thread->arch.basepri = 0;
    4bb0:	68fb      	ldr	r3, [r7, #12]
    4bb2:	2200      	movs	r2, #0
    4bb4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    4bb8:	bf00      	nop
    4bba:	371c      	adds	r7, #28
    4bbc:	46bd      	mov	sp, r7
    4bbe:	bc80      	pop	{r7}
    4bc0:	4770      	bx	lr
    4bc2:	bf00      	nop
    4bc4:	00010545 	.word	0x00010545

00004bc8 <arch_switch_to_main_thread>:
#endif
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    4bc8:	b580      	push	{r7, lr}
    4bca:	b086      	sub	sp, #24
    4bcc:	af00      	add	r7, sp, #0
    4bce:	60f8      	str	r0, [r7, #12]
    4bd0:	60b9      	str	r1, [r7, #8]
    4bd2:	607a      	str	r2, [r7, #4]
	z_arm_prepare_switch_to_main();
    4bd4:	f00e f90b 	bl	12dee <z_arm_prepare_switch_to_main>

	_current = main_thread;
    4bd8:	4a0c      	ldr	r2, [pc, #48]	; (4c0c <arch_switch_to_main_thread+0x44>)
    4bda:	68fb      	ldr	r3, [r7, #12]
    4bdc:	6093      	str	r3, [r2, #8]
#endif

#if defined(CONFIG_BUILTIN_STACK_GUARD)
	/* Set PSPLIM register for built-in stack guarding of main thread. */
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
	__set_PSPLIM(main_thread->stack_info.start);
    4bde:	68fb      	ldr	r3, [r7, #12]
    4be0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    4be2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    4be4:	697b      	ldr	r3, [r7, #20]
    4be6:	f383 880b 	msr	PSPLIM, r3
}
    4bea:	bf00      	nop

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    4bec:	687b      	ldr	r3, [r7, #4]
    4bee:	68ba      	ldr	r2, [r7, #8]
    4bf0:	4618      	mov	r0, r3
    4bf2:	f382 8809 	msr	PSP, r2
    4bf6:	2100      	movs	r1, #0
    4bf8:	b663      	cpsie	if
    4bfa:	f381 8811 	msr	BASEPRI, r1
    4bfe:	f3bf 8f6f 	isb	sy
    4c02:	2200      	movs	r2, #0
    4c04:	2300      	movs	r3, #0
    4c06:	f00b fc9d 	bl	10544 <z_thread_entry>
    4c0a:	bf00      	nop
    4c0c:	20000cd8 	.word	0x20000cd8

00004c10 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    4c10:	4901      	ldr	r1, [pc, #4]	; (4c18 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    4c12:	2210      	movs	r2, #16
	str	r2, [r1]
    4c14:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    4c16:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    4c18:	e000ed10 	.word	0xe000ed10

00004c1c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    4c1c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    4c1e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    4c20:	f380 8811 	msr	BASEPRI, r0
	isb
    4c24:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    4c28:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    4c2c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    4c2e:	b662      	cpsie	i
	isb
    4c30:	f3bf 8f6f 	isb	sy

	bx	lr
    4c34:	4770      	bx	lr
    4c36:	bf00      	nop

00004c38 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    4c38:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    4c3a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    4c3c:	f381 8811 	msr	BASEPRI, r1

	wfe
    4c40:	bf20      	wfe

	msr	BASEPRI, r0
    4c42:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    4c46:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    4c48:	4770      	bx	lr
    4c4a:	bf00      	nop

00004c4c <log_const_source_id>:
{
    4c4c:	b480      	push	{r7}
    4c4e:	b083      	sub	sp, #12
    4c50:	af00      	add	r7, sp, #0
    4c52:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    4c54:	687b      	ldr	r3, [r7, #4]
    4c56:	4a04      	ldr	r2, [pc, #16]	; (4c68 <log_const_source_id+0x1c>)
    4c58:	1a9b      	subs	r3, r3, r2
    4c5a:	08db      	lsrs	r3, r3, #3
}
    4c5c:	4618      	mov	r0, r3
    4c5e:	370c      	adds	r7, #12
    4c60:	46bd      	mov	sp, r7
    4c62:	bc80      	pop	{r7}
    4c64:	4770      	bx	lr
    4c66:	bf00      	nop
    4c68:	00018788 	.word	0x00018788

00004c6c <esf_dump>:
#include <kernel.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os);

static void esf_dump(const z_arch_esf_t *esf)
{
    4c6c:	b580      	push	{r7, lr}
    4c6e:	b092      	sub	sp, #72	; 0x48
    4c70:	af02      	add	r7, sp, #8
    4c72:	6078      	str	r0, [r7, #4]
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    4c74:	2303      	movs	r3, #3
    4c76:	2b00      	cmp	r3, #0
    4c78:	d041      	beq.n	4cfe <esf_dump+0x92>
    4c7a:	f00e f8be 	bl	12dfa <_is_user_context>
    4c7e:	4603      	mov	r3, r0
    4c80:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
    4c84:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
    4c88:	2201      	movs	r2, #1
    4c8a:	f362 0302 	bfi	r3, r2, #0, #3
    4c8e:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
    4c92:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
    4c96:	f36f 03c5 	bfc	r3, #3, #3
    4c9a:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
    4c9e:	2303      	movs	r3, #3
    4ca0:	2b00      	cmp	r3, #0
    4ca2:	d009      	beq.n	4cb8 <esf_dump+0x4c>
    4ca4:	4b70      	ldr	r3, [pc, #448]	; (4e68 <esf_dump+0x1fc>)
    4ca6:	681b      	ldr	r3, [r3, #0]
    4ca8:	4618      	mov	r0, r3
    4caa:	f7ff ffcf 	bl	4c4c <log_const_source_id>
    4cae:	4603      	mov	r3, r0
    4cb0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4cb4:	b29a      	uxth	r2, r3
    4cb6:	e000      	b.n	4cba <esf_dump+0x4e>
    4cb8:	2200      	movs	r2, #0
    4cba:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
    4cbc:	f362 138f 	bfi	r3, r2, #6, #10
    4cc0:	873b      	strh	r3, [r7, #56]	; 0x38
    4cc2:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
    4cc6:	2b00      	cmp	r3, #0
    4cc8:	d00c      	beq.n	4ce4 <esf_dump+0x78>
    4cca:	687b      	ldr	r3, [r7, #4]
    4ccc:	681a      	ldr	r2, [r3, #0]
    4cce:	687b      	ldr	r3, [r7, #4]
    4cd0:	6859      	ldr	r1, [r3, #4]
    4cd2:	687b      	ldr	r3, [r7, #4]
    4cd4:	689b      	ldr	r3, [r3, #8]
    4cd6:	9300      	str	r3, [sp, #0]
    4cd8:	460b      	mov	r3, r1
    4cda:	4964      	ldr	r1, [pc, #400]	; (4e6c <esf_dump+0x200>)
    4cdc:	8f38      	ldrh	r0, [r7, #56]	; 0x38
    4cde:	f7fd fe07 	bl	28f0 <log_from_user>
    4ce2:	e00c      	b.n	4cfe <esf_dump+0x92>
    4ce4:	687b      	ldr	r3, [r7, #4]
    4ce6:	6819      	ldr	r1, [r3, #0]
    4ce8:	687b      	ldr	r3, [r7, #4]
    4cea:	685a      	ldr	r2, [r3, #4]
    4cec:	687b      	ldr	r3, [r7, #4]
    4cee:	6898      	ldr	r0, [r3, #8]
    4cf0:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
    4cf2:	f8ad 3000 	strh.w	r3, [sp]
    4cf6:	4603      	mov	r3, r0
    4cf8:	485c      	ldr	r0, [pc, #368]	; (4e6c <esf_dump+0x200>)
    4cfa:	f00c fcd7 	bl	116ac <log_3>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    4cfe:	2303      	movs	r3, #3
    4d00:	2b00      	cmp	r3, #0
    4d02:	d041      	beq.n	4d88 <esf_dump+0x11c>
    4d04:	f00e f879 	bl	12dfa <_is_user_context>
    4d08:	4603      	mov	r3, r0
    4d0a:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    4d0e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    4d12:	2201      	movs	r2, #1
    4d14:	f362 0302 	bfi	r3, r2, #0, #3
    4d18:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    4d1c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    4d20:	f36f 03c5 	bfc	r3, #3, #3
    4d24:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    4d28:	2303      	movs	r3, #3
    4d2a:	2b00      	cmp	r3, #0
    4d2c:	d009      	beq.n	4d42 <esf_dump+0xd6>
    4d2e:	4b4e      	ldr	r3, [pc, #312]	; (4e68 <esf_dump+0x1fc>)
    4d30:	681b      	ldr	r3, [r3, #0]
    4d32:	4618      	mov	r0, r3
    4d34:	f7ff ff8a 	bl	4c4c <log_const_source_id>
    4d38:	4603      	mov	r3, r0
    4d3a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4d3e:	b29a      	uxth	r2, r3
    4d40:	e000      	b.n	4d44 <esf_dump+0xd8>
    4d42:	2200      	movs	r2, #0
    4d44:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    4d46:	f362 138f 	bfi	r3, r2, #6, #10
    4d4a:	84bb      	strh	r3, [r7, #36]	; 0x24
    4d4c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
    4d50:	2b00      	cmp	r3, #0
    4d52:	d00c      	beq.n	4d6e <esf_dump+0x102>
    4d54:	687b      	ldr	r3, [r7, #4]
    4d56:	68da      	ldr	r2, [r3, #12]
    4d58:	687b      	ldr	r3, [r7, #4]
    4d5a:	6919      	ldr	r1, [r3, #16]
    4d5c:	687b      	ldr	r3, [r7, #4]
    4d5e:	695b      	ldr	r3, [r3, #20]
    4d60:	9300      	str	r3, [sp, #0]
    4d62:	460b      	mov	r3, r1
    4d64:	4942      	ldr	r1, [pc, #264]	; (4e70 <esf_dump+0x204>)
    4d66:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
    4d68:	f7fd fdc2 	bl	28f0 <log_from_user>
    4d6c:	e00c      	b.n	4d88 <esf_dump+0x11c>
    4d6e:	687b      	ldr	r3, [r7, #4]
    4d70:	68d9      	ldr	r1, [r3, #12]
    4d72:	687b      	ldr	r3, [r7, #4]
    4d74:	691a      	ldr	r2, [r3, #16]
    4d76:	687b      	ldr	r3, [r7, #4]
    4d78:	6958      	ldr	r0, [r3, #20]
    4d7a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    4d7c:	f8ad 3000 	strh.w	r3, [sp]
    4d80:	4603      	mov	r3, r0
    4d82:	483b      	ldr	r0, [pc, #236]	; (4e70 <esf_dump+0x204>)
    4d84:	f00c fc92 	bl	116ac <log_3>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    4d88:	2303      	movs	r3, #3
    4d8a:	2b00      	cmp	r3, #0
    4d8c:	d032      	beq.n	4df4 <esf_dump+0x188>
    4d8e:	f00e f834 	bl	12dfa <_is_user_context>
    4d92:	4603      	mov	r3, r0
    4d94:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
    4d98:	7c3b      	ldrb	r3, [r7, #16]
    4d9a:	2201      	movs	r2, #1
    4d9c:	f362 0302 	bfi	r3, r2, #0, #3
    4da0:	743b      	strb	r3, [r7, #16]
    4da2:	7c3b      	ldrb	r3, [r7, #16]
    4da4:	f36f 03c5 	bfc	r3, #3, #3
    4da8:	743b      	strb	r3, [r7, #16]
    4daa:	2303      	movs	r3, #3
    4dac:	2b00      	cmp	r3, #0
    4dae:	d009      	beq.n	4dc4 <esf_dump+0x158>
    4db0:	4b2d      	ldr	r3, [pc, #180]	; (4e68 <esf_dump+0x1fc>)
    4db2:	681b      	ldr	r3, [r3, #0]
    4db4:	4618      	mov	r0, r3
    4db6:	f7ff ff49 	bl	4c4c <log_const_source_id>
    4dba:	4603      	mov	r3, r0
    4dbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4dc0:	b29a      	uxth	r2, r3
    4dc2:	e000      	b.n	4dc6 <esf_dump+0x15a>
    4dc4:	2200      	movs	r2, #0
    4dc6:	8a3b      	ldrh	r3, [r7, #16]
    4dc8:	f362 138f 	bfi	r3, r2, #6, #10
    4dcc:	823b      	strh	r3, [r7, #16]
    4dce:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
    4dd2:	2b00      	cmp	r3, #0
    4dd4:	d007      	beq.n	4de6 <esf_dump+0x17a>
    4dd6:	687b      	ldr	r3, [r7, #4]
    4dd8:	69db      	ldr	r3, [r3, #28]
    4dda:	461a      	mov	r2, r3
    4ddc:	4925      	ldr	r1, [pc, #148]	; (4e74 <esf_dump+0x208>)
    4dde:	8a38      	ldrh	r0, [r7, #16]
    4de0:	f7fd fd86 	bl	28f0 <log_from_user>
    4de4:	e006      	b.n	4df4 <esf_dump+0x188>
    4de6:	687b      	ldr	r3, [r7, #4]
    4de8:	69db      	ldr	r3, [r3, #28]
    4dea:	8a3a      	ldrh	r2, [r7, #16]
    4dec:	4619      	mov	r1, r3
    4dee:	4821      	ldr	r0, [pc, #132]	; (4e74 <esf_dump+0x208>)
    4df0:	f00c fc2c 	bl	1164c <log_1>
			callee->v4, callee->v5, callee->v6);
		LOG_ERR("r10/v7: 0x%08x  r11/v8: 0x%08x    psp:  0x%08x",
			callee->v7, callee->v8, callee->psp);
	}
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    4df4:	2303      	movs	r3, #3
    4df6:	2b00      	cmp	r3, #0
    4df8:	d032      	beq.n	4e60 <esf_dump+0x1f4>
    4dfa:	f00d fffe 	bl	12dfa <_is_user_context>
    4dfe:	4603      	mov	r3, r0
    4e00:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    4e04:	7b3b      	ldrb	r3, [r7, #12]
    4e06:	2201      	movs	r2, #1
    4e08:	f362 0302 	bfi	r3, r2, #0, #3
    4e0c:	733b      	strb	r3, [r7, #12]
    4e0e:	7b3b      	ldrb	r3, [r7, #12]
    4e10:	f36f 03c5 	bfc	r3, #3, #3
    4e14:	733b      	strb	r3, [r7, #12]
    4e16:	2303      	movs	r3, #3
    4e18:	2b00      	cmp	r3, #0
    4e1a:	d009      	beq.n	4e30 <esf_dump+0x1c4>
    4e1c:	4b12      	ldr	r3, [pc, #72]	; (4e68 <esf_dump+0x1fc>)
    4e1e:	681b      	ldr	r3, [r3, #0]
    4e20:	4618      	mov	r0, r3
    4e22:	f7ff ff13 	bl	4c4c <log_const_source_id>
    4e26:	4603      	mov	r3, r0
    4e28:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4e2c:	b29a      	uxth	r2, r3
    4e2e:	e000      	b.n	4e32 <esf_dump+0x1c6>
    4e30:	2200      	movs	r2, #0
    4e32:	89bb      	ldrh	r3, [r7, #12]
    4e34:	f362 138f 	bfi	r3, r2, #6, #10
    4e38:	81bb      	strh	r3, [r7, #12]
    4e3a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
    4e3e:	2b00      	cmp	r3, #0
    4e40:	d007      	beq.n	4e52 <esf_dump+0x1e6>
    4e42:	687b      	ldr	r3, [r7, #4]
    4e44:	699b      	ldr	r3, [r3, #24]
    4e46:	461a      	mov	r2, r3
    4e48:	490b      	ldr	r1, [pc, #44]	; (4e78 <esf_dump+0x20c>)
    4e4a:	89b8      	ldrh	r0, [r7, #12]
    4e4c:	f7fd fd50 	bl	28f0 <log_from_user>
		esf->basic.pc);
}
    4e50:	e006      	b.n	4e60 <esf_dump+0x1f4>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    4e52:	687b      	ldr	r3, [r7, #4]
    4e54:	699b      	ldr	r3, [r3, #24]
    4e56:	89ba      	ldrh	r2, [r7, #12]
    4e58:	4619      	mov	r1, r3
    4e5a:	4807      	ldr	r0, [pc, #28]	; (4e78 <esf_dump+0x20c>)
    4e5c:	f00c fbf6 	bl	1164c <log_1>
}
    4e60:	bf00      	nop
    4e62:	3740      	adds	r7, #64	; 0x40
    4e64:	46bd      	mov	sp, r7
    4e66:	bd80      	pop	{r7, pc}
    4e68:	200000f0 	.word	0x200000f0
    4e6c:	00019664 	.word	0x00019664
    4e70:	00019694 	.word	0x00019694
    4e74:	000196c4 	.word	0x000196c4
    4e78:	000196d4 	.word	0x000196d4

00004e7c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    4e7c:	bf30      	wfi
    b z_SysNmiOnReset
    4e7e:	f7ff bffd 	b.w	4e7c <z_SysNmiOnReset>
    4e82:	bf00      	nop

00004e84 <relocate_vector_table>:
#define VECTOR_ADDRESS ((uintptr_t)_vector_start)
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
    4e84:	b480      	push	{r7}
    4e86:	af00      	add	r7, sp, #0
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4e88:	4b07      	ldr	r3, [pc, #28]	; (4ea8 <relocate_vector_table+0x24>)
    4e8a:	4a08      	ldr	r2, [pc, #32]	; (4eac <relocate_vector_table+0x28>)
    4e8c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    4e90:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    4e92:	f3bf 8f4f 	dsb	sy
}
    4e96:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
    4e98:	f3bf 8f6f 	isb	sy
}
    4e9c:	bf00      	nop
	__DSB();
	__ISB();
}
    4e9e:	bf00      	nop
    4ea0:	46bd      	mov	sp, r7
    4ea2:	bc80      	pop	{r7}
    4ea4:	4770      	bx	lr
    4ea6:	bf00      	nop
    4ea8:	00000000 	.word	0x00000000
    4eac:	e000ed00 	.word	0xe000ed00

00004eb0 <z_arm_floating_point_init>:

#endif /* CONFIG_CPU_CORTEX_M_HAS_VTOR */

#if defined(CONFIG_CPU_HAS_FPU)
static inline void z_arm_floating_point_init(void)
{
    4eb0:	b480      	push	{r7}
    4eb2:	b083      	sub	sp, #12
    4eb4:	af00      	add	r7, sp, #0
	/*
	 * Upon reset, the Co-Processor Access Control Register is, normally,
	 * 0x00000000. However, it might be left un-cleared by firmware running
	 * before Zephyr boot.
	 */
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    4eb6:	4b0c      	ldr	r3, [pc, #48]	; (4ee8 <z_arm_floating_point_init+0x38>)
    4eb8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    4ebc:	4a0a      	ldr	r2, [pc, #40]	; (4ee8 <z_arm_floating_point_init+0x38>)
    4ebe:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    4ec2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    4ec6:	f3ef 8314 	mrs	r3, CONTROL
    4eca:	603b      	str	r3, [r7, #0]
  return(result);
    4ecc:	683b      	ldr	r3, [r7, #0]
	 * Note:
	 * In Sharing FP Registers mode CONTROL.FPCA is cleared before switching
	 * to main, so it may be skipped here (saving few boot cycles).
	 */
#if !defined(CONFIG_FPU) || !defined(CONFIG_FPU_SHARING)
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    4ece:	f023 0304 	bic.w	r3, r3, #4
    4ed2:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    4ed4:	687b      	ldr	r3, [r7, #4]
    4ed6:	f383 8814 	msr	CONTROL, r3
}
    4eda:	bf00      	nop
#endif
}
    4edc:	bf00      	nop
    4ede:	370c      	adds	r7, #12
    4ee0:	46bd      	mov	sp, r7
    4ee2:	bc80      	pop	{r7}
    4ee4:	4770      	bx	lr
    4ee6:	bf00      	nop
    4ee8:	e000ed00 	.word	0xe000ed00

00004eec <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    4eec:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    4eee:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    4ef0:	4a0b      	ldr	r2, [pc, #44]	; (4f20 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    4ef2:	6a50      	ldr	r0, [r2, #36]	; 0x24
	cmp r0, #0
    4ef4:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    4ef6:	bf1e      	ittt	ne
	movne	r1, #0
    4ef8:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    4efa:	6251      	strne	r1, [r2, #36]	; 0x24
		blne	z_sys_power_save_idle_exit
    4efc:	f011 ff1d 	blne	16d3a <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    4f00:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    4f02:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    4f06:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    4f0a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    4f0e:	4905      	ldr	r1, [pc, #20]	; (4f24 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    4f10:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    4f12:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    4f14:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    4f16:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    4f1a:	4903      	ldr	r1, [pc, #12]	; (4f28 <_isr_wrapper+0x3c>)
	bx r1
    4f1c:	4708      	bx	r1
    4f1e:	0000      	.short	0x0000
	ldr r2, =_kernel
    4f20:	20000cd8 	.word	0x20000cd8
	ldr r1, =_sw_isr_table
    4f24:	00018580 	.word	0x00018580
	ldr r1, =z_arm_int_exit
    4f28:	00006071 	.word	0x00006071

00004f2c <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    4f2c:	f00b ff05 	bl	10d3a <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    4f30:	2020      	movs	r0, #32
    msr BASEPRI, r0
    4f32:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    4f36:	4808      	ldr	r0, [pc, #32]	; (4f58 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    4f38:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    4f3c:	1840      	adds	r0, r0, r1
    msr PSP, r0
    4f3e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    4f42:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    4f46:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    4f48:	4308      	orrs	r0, r1
    msr CONTROL, r0
    4f4a:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    4f4e:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    4f52:	f00d ff83 	bl	12e5c <z_arm_prep_c>
    4f56:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    4f58:	20001148 	.word	0x20001148

00004f5c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    4f5c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    4f60:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    4f64:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    4f66:	4672      	mov	r2, lr
	bl z_arm_fault
    4f68:	f001 f800 	bl	5f6c <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    4f6c:	bd01      	pop	{r0, pc}
    4f6e:	bf00      	nop

00004f70 <log_const_source_id>:
{
    4f70:	b480      	push	{r7}
    4f72:	b083      	sub	sp, #12
    4f74:	af00      	add	r7, sp, #0
    4f76:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    4f78:	687b      	ldr	r3, [r7, #4]
    4f7a:	4a04      	ldr	r2, [pc, #16]	; (4f8c <log_const_source_id+0x1c>)
    4f7c:	1a9b      	subs	r3, r3, r2
    4f7e:	08db      	lsrs	r3, r3, #3
}
    4f80:	4618      	mov	r0, r3
    4f82:	370c      	adds	r7, #12
    4f84:	46bd      	mov	sp, r7
    4f86:	bc80      	pop	{r7}
    4f88:	4770      	bx	lr
    4f8a:	bf00      	nop
    4f8c:	00018788 	.word	0x00018788

00004f90 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    4f90:	b580      	push	{r7, lr}
    4f92:	b090      	sub	sp, #64	; 0x40
    4f94:	af00      	add	r7, sp, #0
    4f96:	60f8      	str	r0, [r7, #12]
    4f98:	60b9      	str	r1, [r7, #8]
    4f9a:	607a      	str	r2, [r7, #4]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    4f9c:	2300      	movs	r3, #0
    4f9e:	63fb      	str	r3, [r7, #60]	; 0x3c
	uint32_t mmfar = -EINVAL;
    4fa0:	f06f 0315 	mvn.w	r3, #21
    4fa4:	63bb      	str	r3, [r7, #56]	; 0x38

	PR_FAULT_INFO("***** MPU FAULT *****");
    4fa6:	2303      	movs	r3, #3
    4fa8:	2b00      	cmp	r3, #0
    4faa:	d030      	beq.n	500e <mem_manage_fault+0x7e>
    4fac:	f00d ff64 	bl	12e78 <_is_user_context>
    4fb0:	4603      	mov	r3, r0
    4fb2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    4fb6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    4fba:	2201      	movs	r2, #1
    4fbc:	f362 0302 	bfi	r3, r2, #0, #3
    4fc0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    4fc4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    4fc8:	f36f 03c5 	bfc	r3, #3, #3
    4fcc:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    4fd0:	2303      	movs	r3, #3
    4fd2:	2b00      	cmp	r3, #0
    4fd4:	d009      	beq.n	4fea <mem_manage_fault+0x5a>
    4fd6:	4bbb      	ldr	r3, [pc, #748]	; (52c4 <mem_manage_fault+0x334>)
    4fd8:	681b      	ldr	r3, [r3, #0]
    4fda:	4618      	mov	r0, r3
    4fdc:	f7ff ffc8 	bl	4f70 <log_const_source_id>
    4fe0:	4603      	mov	r3, r0
    4fe2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    4fe6:	b29a      	uxth	r2, r3
    4fe8:	e000      	b.n	4fec <mem_manage_fault+0x5c>
    4fea:	2200      	movs	r2, #0
    4fec:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    4fee:	f362 138f 	bfi	r3, r2, #6, #10
    4ff2:	85bb      	strh	r3, [r7, #44]	; 0x2c
    4ff4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    4ff8:	2b00      	cmp	r3, #0
    4ffa:	d004      	beq.n	5006 <mem_manage_fault+0x76>
    4ffc:	49b2      	ldr	r1, [pc, #712]	; (52c8 <mem_manage_fault+0x338>)
    4ffe:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
    5000:	f7fd fc76 	bl	28f0 <log_from_user>
    5004:	e003      	b.n	500e <mem_manage_fault+0x7e>
    5006:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
    5008:	48af      	ldr	r0, [pc, #700]	; (52c8 <mem_manage_fault+0x338>)
    500a:	f00c fb0a 	bl	11622 <log_0>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    500e:	4baf      	ldr	r3, [pc, #700]	; (52cc <mem_manage_fault+0x33c>)
    5010:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5012:	f003 0310 	and.w	r3, r3, #16
    5016:	2b00      	cmp	r3, #0
    5018:	d033      	beq.n	5082 <mem_manage_fault+0xf2>
		PR_FAULT_INFO("  Stacking error (context area might be"
    501a:	2303      	movs	r3, #3
    501c:	2b00      	cmp	r3, #0
    501e:	d030      	beq.n	5082 <mem_manage_fault+0xf2>
    5020:	f00d ff2a 	bl	12e78 <_is_user_context>
    5024:	4603      	mov	r3, r0
    5026:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    502a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    502e:	2201      	movs	r2, #1
    5030:	f362 0302 	bfi	r3, r2, #0, #3
    5034:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    5038:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    503c:	f36f 03c5 	bfc	r3, #3, #3
    5040:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    5044:	2303      	movs	r3, #3
    5046:	2b00      	cmp	r3, #0
    5048:	d009      	beq.n	505e <mem_manage_fault+0xce>
    504a:	4b9e      	ldr	r3, [pc, #632]	; (52c4 <mem_manage_fault+0x334>)
    504c:	681b      	ldr	r3, [r3, #0]
    504e:	4618      	mov	r0, r3
    5050:	f7ff ff8e 	bl	4f70 <log_const_source_id>
    5054:	4603      	mov	r3, r0
    5056:	f3c3 0309 	ubfx	r3, r3, #0, #10
    505a:	b29a      	uxth	r2, r3
    505c:	e000      	b.n	5060 <mem_manage_fault+0xd0>
    505e:	2200      	movs	r2, #0
    5060:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    5062:	f362 138f 	bfi	r3, r2, #6, #10
    5066:	853b      	strh	r3, [r7, #40]	; 0x28
    5068:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    506c:	2b00      	cmp	r3, #0
    506e:	d004      	beq.n	507a <mem_manage_fault+0xea>
    5070:	4997      	ldr	r1, [pc, #604]	; (52d0 <mem_manage_fault+0x340>)
    5072:	8d38      	ldrh	r0, [r7, #40]	; 0x28
    5074:	f7fd fc3c 	bl	28f0 <log_from_user>
    5078:	e003      	b.n	5082 <mem_manage_fault+0xf2>
    507a:	8d39      	ldrh	r1, [r7, #40]	; 0x28
    507c:	4894      	ldr	r0, [pc, #592]	; (52d0 <mem_manage_fault+0x340>)
    507e:	f00c fad0 	bl	11622 <log_0>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    5082:	4b92      	ldr	r3, [pc, #584]	; (52cc <mem_manage_fault+0x33c>)
    5084:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5086:	f003 0308 	and.w	r3, r3, #8
    508a:	2b00      	cmp	r3, #0
    508c:	d033      	beq.n	50f6 <mem_manage_fault+0x166>
		PR_FAULT_INFO("  Unstacking error");
    508e:	2303      	movs	r3, #3
    5090:	2b00      	cmp	r3, #0
    5092:	d030      	beq.n	50f6 <mem_manage_fault+0x166>
    5094:	f00d fef0 	bl	12e78 <_is_user_context>
    5098:	4603      	mov	r3, r0
    509a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    509e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    50a2:	2201      	movs	r2, #1
    50a4:	f362 0302 	bfi	r3, r2, #0, #3
    50a8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    50ac:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    50b0:	f36f 03c5 	bfc	r3, #3, #3
    50b4:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    50b8:	2303      	movs	r3, #3
    50ba:	2b00      	cmp	r3, #0
    50bc:	d009      	beq.n	50d2 <mem_manage_fault+0x142>
    50be:	4b81      	ldr	r3, [pc, #516]	; (52c4 <mem_manage_fault+0x334>)
    50c0:	681b      	ldr	r3, [r3, #0]
    50c2:	4618      	mov	r0, r3
    50c4:	f7ff ff54 	bl	4f70 <log_const_source_id>
    50c8:	4603      	mov	r3, r0
    50ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    50ce:	b29a      	uxth	r2, r3
    50d0:	e000      	b.n	50d4 <mem_manage_fault+0x144>
    50d2:	2200      	movs	r2, #0
    50d4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    50d6:	f362 138f 	bfi	r3, r2, #6, #10
    50da:	84bb      	strh	r3, [r7, #36]	; 0x24
    50dc:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    50e0:	2b00      	cmp	r3, #0
    50e2:	d004      	beq.n	50ee <mem_manage_fault+0x15e>
    50e4:	497b      	ldr	r1, [pc, #492]	; (52d4 <mem_manage_fault+0x344>)
    50e6:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
    50e8:	f7fd fc02 	bl	28f0 <log_from_user>
    50ec:	e003      	b.n	50f6 <mem_manage_fault+0x166>
    50ee:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
    50f0:	4878      	ldr	r0, [pc, #480]	; (52d4 <mem_manage_fault+0x344>)
    50f2:	f00c fa96 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    50f6:	4b75      	ldr	r3, [pc, #468]	; (52cc <mem_manage_fault+0x33c>)
    50f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    50fa:	f003 0302 	and.w	r3, r3, #2
    50fe:	2b00      	cmp	r3, #0
    5100:	d077      	beq.n	51f2 <mem_manage_fault+0x262>
		PR_FAULT_INFO("  Data Access Violation");
    5102:	2303      	movs	r3, #3
    5104:	2b00      	cmp	r3, #0
    5106:	d030      	beq.n	516a <mem_manage_fault+0x1da>
    5108:	f00d feb6 	bl	12e78 <_is_user_context>
    510c:	4603      	mov	r3, r0
    510e:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    5112:	f897 3020 	ldrb.w	r3, [r7, #32]
    5116:	2201      	movs	r2, #1
    5118:	f362 0302 	bfi	r3, r2, #0, #3
    511c:	f887 3020 	strb.w	r3, [r7, #32]
    5120:	f897 3020 	ldrb.w	r3, [r7, #32]
    5124:	f36f 03c5 	bfc	r3, #3, #3
    5128:	f887 3020 	strb.w	r3, [r7, #32]
    512c:	2303      	movs	r3, #3
    512e:	2b00      	cmp	r3, #0
    5130:	d009      	beq.n	5146 <mem_manage_fault+0x1b6>
    5132:	4b64      	ldr	r3, [pc, #400]	; (52c4 <mem_manage_fault+0x334>)
    5134:	681b      	ldr	r3, [r3, #0]
    5136:	4618      	mov	r0, r3
    5138:	f7ff ff1a 	bl	4f70 <log_const_source_id>
    513c:	4603      	mov	r3, r0
    513e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5142:	b29a      	uxth	r2, r3
    5144:	e000      	b.n	5148 <mem_manage_fault+0x1b8>
    5146:	2200      	movs	r2, #0
    5148:	8c3b      	ldrh	r3, [r7, #32]
    514a:	f362 138f 	bfi	r3, r2, #6, #10
    514e:	843b      	strh	r3, [r7, #32]
    5150:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    5154:	2b00      	cmp	r3, #0
    5156:	d004      	beq.n	5162 <mem_manage_fault+0x1d2>
    5158:	495f      	ldr	r1, [pc, #380]	; (52d8 <mem_manage_fault+0x348>)
    515a:	8c38      	ldrh	r0, [r7, #32]
    515c:	f7fd fbc8 	bl	28f0 <log_from_user>
    5160:	e003      	b.n	516a <mem_manage_fault+0x1da>
    5162:	8c39      	ldrh	r1, [r7, #32]
    5164:	485c      	ldr	r0, [pc, #368]	; (52d8 <mem_manage_fault+0x348>)
    5166:	f00c fa5c 	bl	11622 <log_0>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    516a:	4b58      	ldr	r3, [pc, #352]	; (52cc <mem_manage_fault+0x33c>)
    516c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    516e:	63bb      	str	r3, [r7, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    5170:	4b56      	ldr	r3, [pc, #344]	; (52cc <mem_manage_fault+0x33c>)
    5172:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5174:	f003 0380 	and.w	r3, r3, #128	; 0x80
    5178:	2b00      	cmp	r3, #0
    517a:	d03a      	beq.n	51f2 <mem_manage_fault+0x262>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    517c:	2303      	movs	r3, #3
    517e:	2b00      	cmp	r3, #0
    5180:	d02e      	beq.n	51e0 <mem_manage_fault+0x250>
    5182:	f00d fe79 	bl	12e78 <_is_user_context>
    5186:	4603      	mov	r3, r0
    5188:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    518c:	7f3b      	ldrb	r3, [r7, #28]
    518e:	2201      	movs	r2, #1
    5190:	f362 0302 	bfi	r3, r2, #0, #3
    5194:	773b      	strb	r3, [r7, #28]
    5196:	7f3b      	ldrb	r3, [r7, #28]
    5198:	f36f 03c5 	bfc	r3, #3, #3
    519c:	773b      	strb	r3, [r7, #28]
    519e:	2303      	movs	r3, #3
    51a0:	2b00      	cmp	r3, #0
    51a2:	d009      	beq.n	51b8 <mem_manage_fault+0x228>
    51a4:	4b47      	ldr	r3, [pc, #284]	; (52c4 <mem_manage_fault+0x334>)
    51a6:	681b      	ldr	r3, [r3, #0]
    51a8:	4618      	mov	r0, r3
    51aa:	f7ff fee1 	bl	4f70 <log_const_source_id>
    51ae:	4603      	mov	r3, r0
    51b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    51b4:	b29a      	uxth	r2, r3
    51b6:	e000      	b.n	51ba <mem_manage_fault+0x22a>
    51b8:	2200      	movs	r2, #0
    51ba:	8bbb      	ldrh	r3, [r7, #28]
    51bc:	f362 138f 	bfi	r3, r2, #6, #10
    51c0:	83bb      	strh	r3, [r7, #28]
    51c2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    51c6:	2b00      	cmp	r3, #0
    51c8:	d005      	beq.n	51d6 <mem_manage_fault+0x246>
    51ca:	6bba      	ldr	r2, [r7, #56]	; 0x38
    51cc:	4943      	ldr	r1, [pc, #268]	; (52dc <mem_manage_fault+0x34c>)
    51ce:	8bb8      	ldrh	r0, [r7, #28]
    51d0:	f7fd fb8e 	bl	28f0 <log_from_user>
    51d4:	e004      	b.n	51e0 <mem_manage_fault+0x250>
    51d6:	8bba      	ldrh	r2, [r7, #28]
    51d8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    51da:	4840      	ldr	r0, [pc, #256]	; (52dc <mem_manage_fault+0x34c>)
    51dc:	f00c fa36 	bl	1164c <log_1>
			if (from_hard_fault) {
    51e0:	68bb      	ldr	r3, [r7, #8]
    51e2:	2b00      	cmp	r3, #0
    51e4:	d005      	beq.n	51f2 <mem_manage_fault+0x262>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    51e6:	4b39      	ldr	r3, [pc, #228]	; (52cc <mem_manage_fault+0x33c>)
    51e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    51ea:	4a38      	ldr	r2, [pc, #224]	; (52cc <mem_manage_fault+0x33c>)
    51ec:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    51f0:	6293      	str	r3, [r2, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    51f2:	4b36      	ldr	r3, [pc, #216]	; (52cc <mem_manage_fault+0x33c>)
    51f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    51f6:	f003 0301 	and.w	r3, r3, #1
    51fa:	2b00      	cmp	r3, #0
    51fc:	d02f      	beq.n	525e <mem_manage_fault+0x2ce>
		PR_FAULT_INFO("  Instruction Access Violation");
    51fe:	2303      	movs	r3, #3
    5200:	2b00      	cmp	r3, #0
    5202:	d02c      	beq.n	525e <mem_manage_fault+0x2ce>
    5204:	f00d fe38 	bl	12e78 <_is_user_context>
    5208:	4603      	mov	r3, r0
    520a:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    520e:	7e3b      	ldrb	r3, [r7, #24]
    5210:	2201      	movs	r2, #1
    5212:	f362 0302 	bfi	r3, r2, #0, #3
    5216:	763b      	strb	r3, [r7, #24]
    5218:	7e3b      	ldrb	r3, [r7, #24]
    521a:	f36f 03c5 	bfc	r3, #3, #3
    521e:	763b      	strb	r3, [r7, #24]
    5220:	2303      	movs	r3, #3
    5222:	2b00      	cmp	r3, #0
    5224:	d009      	beq.n	523a <mem_manage_fault+0x2aa>
    5226:	4b27      	ldr	r3, [pc, #156]	; (52c4 <mem_manage_fault+0x334>)
    5228:	681b      	ldr	r3, [r3, #0]
    522a:	4618      	mov	r0, r3
    522c:	f7ff fea0 	bl	4f70 <log_const_source_id>
    5230:	4603      	mov	r3, r0
    5232:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5236:	b29a      	uxth	r2, r3
    5238:	e000      	b.n	523c <mem_manage_fault+0x2ac>
    523a:	2200      	movs	r2, #0
    523c:	8b3b      	ldrh	r3, [r7, #24]
    523e:	f362 138f 	bfi	r3, r2, #6, #10
    5242:	833b      	strh	r3, [r7, #24]
    5244:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    5248:	2b00      	cmp	r3, #0
    524a:	d004      	beq.n	5256 <mem_manage_fault+0x2c6>
    524c:	4924      	ldr	r1, [pc, #144]	; (52e0 <mem_manage_fault+0x350>)
    524e:	8b38      	ldrh	r0, [r7, #24]
    5250:	f7fd fb4e 	bl	28f0 <log_from_user>
    5254:	e003      	b.n	525e <mem_manage_fault+0x2ce>
    5256:	8b39      	ldrh	r1, [r7, #24]
    5258:	4821      	ldr	r0, [pc, #132]	; (52e0 <mem_manage_fault+0x350>)
    525a:	f00c f9e2 	bl	11622 <log_0>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    525e:	4b1b      	ldr	r3, [pc, #108]	; (52cc <mem_manage_fault+0x33c>)
    5260:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5262:	f003 0320 	and.w	r3, r3, #32
    5266:	2b00      	cmp	r3, #0
    5268:	d042      	beq.n	52f0 <mem_manage_fault+0x360>
		PR_FAULT_INFO(
    526a:	2303      	movs	r3, #3
    526c:	2b00      	cmp	r3, #0
    526e:	d03f      	beq.n	52f0 <mem_manage_fault+0x360>
    5270:	f00d fe02 	bl	12e78 <_is_user_context>
    5274:	4603      	mov	r3, r0
    5276:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    527a:	7d3b      	ldrb	r3, [r7, #20]
    527c:	2201      	movs	r2, #1
    527e:	f362 0302 	bfi	r3, r2, #0, #3
    5282:	753b      	strb	r3, [r7, #20]
    5284:	7d3b      	ldrb	r3, [r7, #20]
    5286:	f36f 03c5 	bfc	r3, #3, #3
    528a:	753b      	strb	r3, [r7, #20]
    528c:	2303      	movs	r3, #3
    528e:	2b00      	cmp	r3, #0
    5290:	d009      	beq.n	52a6 <mem_manage_fault+0x316>
    5292:	4b0c      	ldr	r3, [pc, #48]	; (52c4 <mem_manage_fault+0x334>)
    5294:	681b      	ldr	r3, [r3, #0]
    5296:	4618      	mov	r0, r3
    5298:	f7ff fe6a 	bl	4f70 <log_const_source_id>
    529c:	4603      	mov	r3, r0
    529e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    52a2:	b29a      	uxth	r2, r3
    52a4:	e000      	b.n	52a8 <mem_manage_fault+0x318>
    52a6:	2200      	movs	r2, #0
    52a8:	8abb      	ldrh	r3, [r7, #20]
    52aa:	f362 138f 	bfi	r3, r2, #6, #10
    52ae:	82bb      	strh	r3, [r7, #20]
    52b0:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    52b4:	2b00      	cmp	r3, #0
    52b6:	d017      	beq.n	52e8 <mem_manage_fault+0x358>
    52b8:	490a      	ldr	r1, [pc, #40]	; (52e4 <mem_manage_fault+0x354>)
    52ba:	8ab8      	ldrh	r0, [r7, #20]
    52bc:	f7fd fb18 	bl	28f0 <log_from_user>
    52c0:	e016      	b.n	52f0 <mem_manage_fault+0x360>
    52c2:	bf00      	nop
    52c4:	200000f4 	.word	0x200000f4
    52c8:	00019704 	.word	0x00019704
    52cc:	e000ed00 	.word	0xe000ed00
    52d0:	0001971c 	.word	0x0001971c
    52d4:	00019750 	.word	0x00019750
    52d8:	00019764 	.word	0x00019764
    52dc:	0001977c 	.word	0x0001977c
    52e0:	00019794 	.word	0x00019794
    52e4:	000197b4 	.word	0x000197b4
    52e8:	8ab9      	ldrh	r1, [r7, #20]
    52ea:	4815      	ldr	r0, [pc, #84]	; (5340 <mem_manage_fault+0x3b0>)
    52ec:	f00c f999 	bl	11622 <log_0>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    52f0:	4b14      	ldr	r3, [pc, #80]	; (5344 <mem_manage_fault+0x3b4>)
    52f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    52f4:	f003 0310 	and.w	r3, r3, #16
    52f8:	2b00      	cmp	r3, #0
    52fa:	d00e      	beq.n	531a <mem_manage_fault+0x38a>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(0,
    52fc:	f44f 739f 	mov.w	r3, #318	; 0x13e
    5300:	4a11      	ldr	r2, [pc, #68]	; (5348 <mem_manage_fault+0x3b8>)
    5302:	4912      	ldr	r1, [pc, #72]	; (534c <mem_manage_fault+0x3bc>)
    5304:	4812      	ldr	r0, [pc, #72]	; (5350 <mem_manage_fault+0x3c0>)
    5306:	f00a feaf 	bl	10068 <printk>
    530a:	4812      	ldr	r0, [pc, #72]	; (5354 <mem_manage_fault+0x3c4>)
    530c:	f00a feac 	bl	10068 <printk>
    5310:	f44f 719f 	mov.w	r1, #318	; 0x13e
    5314:	480c      	ldr	r0, [pc, #48]	; (5348 <mem_manage_fault+0x3b8>)
    5316:	f00b fcef 	bl	10cf8 <assert_post_action>
		"Stacking error without stack guard / User-mode support\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    531a:	4b0a      	ldr	r3, [pc, #40]	; (5344 <mem_manage_fault+0x3b4>)
    531c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    531e:	4a09      	ldr	r2, [pc, #36]	; (5344 <mem_manage_fault+0x3b4>)
    5320:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    5324:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    5326:	68f8      	ldr	r0, [r7, #12]
    5328:	f00d fdb7 	bl	12e9a <memory_fault_recoverable>
    532c:	4603      	mov	r3, r0
    532e:	461a      	mov	r2, r3
    5330:	687b      	ldr	r3, [r7, #4]
    5332:	701a      	strb	r2, [r3, #0]

	return reason;
    5334:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    5336:	4618      	mov	r0, r3
    5338:	3740      	adds	r7, #64	; 0x40
    533a:	46bd      	mov	sp, r7
    533c:	bd80      	pop	{r7, pc}
    533e:	bf00      	nop
    5340:	000197b4 	.word	0x000197b4
    5344:	e000ed00 	.word	0xe000ed00
    5348:	000197e4 	.word	0x000197e4
    534c:	00019820 	.word	0x00019820
    5350:	00019824 	.word	0x00019824
    5354:	00019844 	.word	0x00019844

00005358 <bus_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
{
    5358:	b580      	push	{r7, lr}
    535a:	b090      	sub	sp, #64	; 0x40
    535c:	af00      	add	r7, sp, #0
    535e:	60f8      	str	r0, [r7, #12]
    5360:	60b9      	str	r1, [r7, #8]
    5362:	607a      	str	r2, [r7, #4]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    5364:	2300      	movs	r3, #0
    5366:	63fb      	str	r3, [r7, #60]	; 0x3c

	PR_FAULT_INFO("***** BUS FAULT *****");
    5368:	2303      	movs	r3, #3
    536a:	2b00      	cmp	r3, #0
    536c:	d030      	beq.n	53d0 <bus_fault+0x78>
    536e:	f00d fd83 	bl	12e78 <_is_user_context>
    5372:	4603      	mov	r3, r0
    5374:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
    5378:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    537c:	2201      	movs	r2, #1
    537e:	f362 0302 	bfi	r3, r2, #0, #3
    5382:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    5386:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    538a:	f36f 03c5 	bfc	r3, #3, #3
    538e:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    5392:	2303      	movs	r3, #3
    5394:	2b00      	cmp	r3, #0
    5396:	d009      	beq.n	53ac <bus_fault+0x54>
    5398:	4bbd      	ldr	r3, [pc, #756]	; (5690 <bus_fault+0x338>)
    539a:	681b      	ldr	r3, [r3, #0]
    539c:	4618      	mov	r0, r3
    539e:	f7ff fde7 	bl	4f70 <log_const_source_id>
    53a2:	4603      	mov	r3, r0
    53a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    53a8:	b29a      	uxth	r2, r3
    53aa:	e000      	b.n	53ae <bus_fault+0x56>
    53ac:	2200      	movs	r2, #0
    53ae:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    53b0:	f362 138f 	bfi	r3, r2, #6, #10
    53b4:	85bb      	strh	r3, [r7, #44]	; 0x2c
    53b6:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
    53ba:	2b00      	cmp	r3, #0
    53bc:	d004      	beq.n	53c8 <bus_fault+0x70>
    53be:	49b5      	ldr	r1, [pc, #724]	; (5694 <bus_fault+0x33c>)
    53c0:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
    53c2:	f7fd fa95 	bl	28f0 <log_from_user>
    53c6:	e003      	b.n	53d0 <bus_fault+0x78>
    53c8:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
    53ca:	48b2      	ldr	r0, [pc, #712]	; (5694 <bus_fault+0x33c>)
    53cc:	f00c f929 	bl	11622 <log_0>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    53d0:	4bb1      	ldr	r3, [pc, #708]	; (5698 <bus_fault+0x340>)
    53d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    53d4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    53d8:	2b00      	cmp	r3, #0
    53da:	d033      	beq.n	5444 <bus_fault+0xec>
		PR_FAULT_INFO("  Stacking error");
    53dc:	2303      	movs	r3, #3
    53de:	2b00      	cmp	r3, #0
    53e0:	d030      	beq.n	5444 <bus_fault+0xec>
    53e2:	f00d fd49 	bl	12e78 <_is_user_context>
    53e6:	4603      	mov	r3, r0
    53e8:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
    53ec:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    53f0:	2201      	movs	r2, #1
    53f2:	f362 0302 	bfi	r3, r2, #0, #3
    53f6:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    53fa:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    53fe:	f36f 03c5 	bfc	r3, #3, #3
    5402:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    5406:	2303      	movs	r3, #3
    5408:	2b00      	cmp	r3, #0
    540a:	d009      	beq.n	5420 <bus_fault+0xc8>
    540c:	4ba0      	ldr	r3, [pc, #640]	; (5690 <bus_fault+0x338>)
    540e:	681b      	ldr	r3, [r3, #0]
    5410:	4618      	mov	r0, r3
    5412:	f7ff fdad 	bl	4f70 <log_const_source_id>
    5416:	4603      	mov	r3, r0
    5418:	f3c3 0309 	ubfx	r3, r3, #0, #10
    541c:	b29a      	uxth	r2, r3
    541e:	e000      	b.n	5422 <bus_fault+0xca>
    5420:	2200      	movs	r2, #0
    5422:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    5424:	f362 138f 	bfi	r3, r2, #6, #10
    5428:	853b      	strh	r3, [r7, #40]	; 0x28
    542a:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
    542e:	2b00      	cmp	r3, #0
    5430:	d004      	beq.n	543c <bus_fault+0xe4>
    5432:	499a      	ldr	r1, [pc, #616]	; (569c <bus_fault+0x344>)
    5434:	8d38      	ldrh	r0, [r7, #40]	; 0x28
    5436:	f7fd fa5b 	bl	28f0 <log_from_user>
    543a:	e003      	b.n	5444 <bus_fault+0xec>
    543c:	8d39      	ldrh	r1, [r7, #40]	; 0x28
    543e:	4897      	ldr	r0, [pc, #604]	; (569c <bus_fault+0x344>)
    5440:	f00c f8ef 	bl	11622 <log_0>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    5444:	4b94      	ldr	r3, [pc, #592]	; (5698 <bus_fault+0x340>)
    5446:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5448:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    544c:	2b00      	cmp	r3, #0
    544e:	d033      	beq.n	54b8 <bus_fault+0x160>
		PR_FAULT_INFO("  Unstacking error");
    5450:	2303      	movs	r3, #3
    5452:	2b00      	cmp	r3, #0
    5454:	d030      	beq.n	54b8 <bus_fault+0x160>
    5456:	f00d fd0f 	bl	12e78 <_is_user_context>
    545a:	4603      	mov	r3, r0
    545c:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
    5460:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    5464:	2201      	movs	r2, #1
    5466:	f362 0302 	bfi	r3, r2, #0, #3
    546a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    546e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    5472:	f36f 03c5 	bfc	r3, #3, #3
    5476:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    547a:	2303      	movs	r3, #3
    547c:	2b00      	cmp	r3, #0
    547e:	d009      	beq.n	5494 <bus_fault+0x13c>
    5480:	4b83      	ldr	r3, [pc, #524]	; (5690 <bus_fault+0x338>)
    5482:	681b      	ldr	r3, [r3, #0]
    5484:	4618      	mov	r0, r3
    5486:	f7ff fd73 	bl	4f70 <log_const_source_id>
    548a:	4603      	mov	r3, r0
    548c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5490:	b29a      	uxth	r2, r3
    5492:	e000      	b.n	5496 <bus_fault+0x13e>
    5494:	2200      	movs	r2, #0
    5496:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    5498:	f362 138f 	bfi	r3, r2, #6, #10
    549c:	84bb      	strh	r3, [r7, #36]	; 0x24
    549e:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
    54a2:	2b00      	cmp	r3, #0
    54a4:	d004      	beq.n	54b0 <bus_fault+0x158>
    54a6:	497e      	ldr	r1, [pc, #504]	; (56a0 <bus_fault+0x348>)
    54a8:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
    54aa:	f7fd fa21 	bl	28f0 <log_from_user>
    54ae:	e003      	b.n	54b8 <bus_fault+0x160>
    54b0:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
    54b2:	487b      	ldr	r0, [pc, #492]	; (56a0 <bus_fault+0x348>)
    54b4:	f00c f8b5 	bl	11622 <log_0>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    54b8:	4b77      	ldr	r3, [pc, #476]	; (5698 <bus_fault+0x340>)
    54ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    54bc:	f403 7300 	and.w	r3, r3, #512	; 0x200
    54c0:	2b00      	cmp	r3, #0
    54c2:	d077      	beq.n	55b4 <bus_fault+0x25c>
		PR_FAULT_INFO("  Precise data bus error");
    54c4:	2303      	movs	r3, #3
    54c6:	2b00      	cmp	r3, #0
    54c8:	d030      	beq.n	552c <bus_fault+0x1d4>
    54ca:	f00d fcd5 	bl	12e78 <_is_user_context>
    54ce:	4603      	mov	r3, r0
    54d0:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
    54d4:	f897 3020 	ldrb.w	r3, [r7, #32]
    54d8:	2201      	movs	r2, #1
    54da:	f362 0302 	bfi	r3, r2, #0, #3
    54de:	f887 3020 	strb.w	r3, [r7, #32]
    54e2:	f897 3020 	ldrb.w	r3, [r7, #32]
    54e6:	f36f 03c5 	bfc	r3, #3, #3
    54ea:	f887 3020 	strb.w	r3, [r7, #32]
    54ee:	2303      	movs	r3, #3
    54f0:	2b00      	cmp	r3, #0
    54f2:	d009      	beq.n	5508 <bus_fault+0x1b0>
    54f4:	4b66      	ldr	r3, [pc, #408]	; (5690 <bus_fault+0x338>)
    54f6:	681b      	ldr	r3, [r3, #0]
    54f8:	4618      	mov	r0, r3
    54fa:	f7ff fd39 	bl	4f70 <log_const_source_id>
    54fe:	4603      	mov	r3, r0
    5500:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5504:	b29a      	uxth	r2, r3
    5506:	e000      	b.n	550a <bus_fault+0x1b2>
    5508:	2200      	movs	r2, #0
    550a:	8c3b      	ldrh	r3, [r7, #32]
    550c:	f362 138f 	bfi	r3, r2, #6, #10
    5510:	843b      	strh	r3, [r7, #32]
    5512:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
    5516:	2b00      	cmp	r3, #0
    5518:	d004      	beq.n	5524 <bus_fault+0x1cc>
    551a:	4962      	ldr	r1, [pc, #392]	; (56a4 <bus_fault+0x34c>)
    551c:	8c38      	ldrh	r0, [r7, #32]
    551e:	f7fd f9e7 	bl	28f0 <log_from_user>
    5522:	e003      	b.n	552c <bus_fault+0x1d4>
    5524:	8c39      	ldrh	r1, [r7, #32]
    5526:	485f      	ldr	r0, [pc, #380]	; (56a4 <bus_fault+0x34c>)
    5528:	f00c f87b 	bl	11622 <log_0>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    552c:	4b5a      	ldr	r3, [pc, #360]	; (5698 <bus_fault+0x340>)
    552e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    5530:	637b      	str	r3, [r7, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    5532:	4b59      	ldr	r3, [pc, #356]	; (5698 <bus_fault+0x340>)
    5534:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5536:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    553a:	2b00      	cmp	r3, #0
    553c:	d03a      	beq.n	55b4 <bus_fault+0x25c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    553e:	2303      	movs	r3, #3
    5540:	2b00      	cmp	r3, #0
    5542:	d02e      	beq.n	55a2 <bus_fault+0x24a>
    5544:	f00d fc98 	bl	12e78 <_is_user_context>
    5548:	4603      	mov	r3, r0
    554a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    554e:	7f3b      	ldrb	r3, [r7, #28]
    5550:	2201      	movs	r2, #1
    5552:	f362 0302 	bfi	r3, r2, #0, #3
    5556:	773b      	strb	r3, [r7, #28]
    5558:	7f3b      	ldrb	r3, [r7, #28]
    555a:	f36f 03c5 	bfc	r3, #3, #3
    555e:	773b      	strb	r3, [r7, #28]
    5560:	2303      	movs	r3, #3
    5562:	2b00      	cmp	r3, #0
    5564:	d009      	beq.n	557a <bus_fault+0x222>
    5566:	4b4a      	ldr	r3, [pc, #296]	; (5690 <bus_fault+0x338>)
    5568:	681b      	ldr	r3, [r3, #0]
    556a:	4618      	mov	r0, r3
    556c:	f7ff fd00 	bl	4f70 <log_const_source_id>
    5570:	4603      	mov	r3, r0
    5572:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5576:	b29a      	uxth	r2, r3
    5578:	e000      	b.n	557c <bus_fault+0x224>
    557a:	2200      	movs	r2, #0
    557c:	8bbb      	ldrh	r3, [r7, #28]
    557e:	f362 138f 	bfi	r3, r2, #6, #10
    5582:	83bb      	strh	r3, [r7, #28]
    5584:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    5588:	2b00      	cmp	r3, #0
    558a:	d005      	beq.n	5598 <bus_fault+0x240>
    558c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    558e:	4946      	ldr	r1, [pc, #280]	; (56a8 <bus_fault+0x350>)
    5590:	8bb8      	ldrh	r0, [r7, #28]
    5592:	f7fd f9ad 	bl	28f0 <log_from_user>
    5596:	e004      	b.n	55a2 <bus_fault+0x24a>
    5598:	8bba      	ldrh	r2, [r7, #28]
    559a:	6b79      	ldr	r1, [r7, #52]	; 0x34
    559c:	4842      	ldr	r0, [pc, #264]	; (56a8 <bus_fault+0x350>)
    559e:	f00c f855 	bl	1164c <log_1>
			if (from_hard_fault) {
    55a2:	68bb      	ldr	r3, [r7, #8]
    55a4:	2b00      	cmp	r3, #0
    55a6:	d005      	beq.n	55b4 <bus_fault+0x25c>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    55a8:	4b3b      	ldr	r3, [pc, #236]	; (5698 <bus_fault+0x340>)
    55aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    55ac:	4a3a      	ldr	r2, [pc, #232]	; (5698 <bus_fault+0x340>)
    55ae:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    55b2:	6293      	str	r3, [r2, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    55b4:	4b38      	ldr	r3, [pc, #224]	; (5698 <bus_fault+0x340>)
    55b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    55b8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    55bc:	2b00      	cmp	r3, #0
    55be:	d02f      	beq.n	5620 <bus_fault+0x2c8>
		PR_FAULT_INFO("  Imprecise data bus error");
    55c0:	2303      	movs	r3, #3
    55c2:	2b00      	cmp	r3, #0
    55c4:	d02c      	beq.n	5620 <bus_fault+0x2c8>
    55c6:	f00d fc57 	bl	12e78 <_is_user_context>
    55ca:	4603      	mov	r3, r0
    55cc:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    55d0:	7e3b      	ldrb	r3, [r7, #24]
    55d2:	2201      	movs	r2, #1
    55d4:	f362 0302 	bfi	r3, r2, #0, #3
    55d8:	763b      	strb	r3, [r7, #24]
    55da:	7e3b      	ldrb	r3, [r7, #24]
    55dc:	f36f 03c5 	bfc	r3, #3, #3
    55e0:	763b      	strb	r3, [r7, #24]
    55e2:	2303      	movs	r3, #3
    55e4:	2b00      	cmp	r3, #0
    55e6:	d009      	beq.n	55fc <bus_fault+0x2a4>
    55e8:	4b29      	ldr	r3, [pc, #164]	; (5690 <bus_fault+0x338>)
    55ea:	681b      	ldr	r3, [r3, #0]
    55ec:	4618      	mov	r0, r3
    55ee:	f7ff fcbf 	bl	4f70 <log_const_source_id>
    55f2:	4603      	mov	r3, r0
    55f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    55f8:	b29a      	uxth	r2, r3
    55fa:	e000      	b.n	55fe <bus_fault+0x2a6>
    55fc:	2200      	movs	r2, #0
    55fe:	8b3b      	ldrh	r3, [r7, #24]
    5600:	f362 138f 	bfi	r3, r2, #6, #10
    5604:	833b      	strh	r3, [r7, #24]
    5606:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    560a:	2b00      	cmp	r3, #0
    560c:	d004      	beq.n	5618 <bus_fault+0x2c0>
    560e:	4927      	ldr	r1, [pc, #156]	; (56ac <bus_fault+0x354>)
    5610:	8b38      	ldrh	r0, [r7, #24]
    5612:	f7fd f96d 	bl	28f0 <log_from_user>
    5616:	e003      	b.n	5620 <bus_fault+0x2c8>
    5618:	8b39      	ldrh	r1, [r7, #24]
    561a:	4824      	ldr	r0, [pc, #144]	; (56ac <bus_fault+0x354>)
    561c:	f00c f801 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    5620:	4b1d      	ldr	r3, [pc, #116]	; (5698 <bus_fault+0x340>)
    5622:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5624:	f403 7380 	and.w	r3, r3, #256	; 0x100
    5628:	2b00      	cmp	r3, #0
    562a:	d043      	beq.n	56b4 <bus_fault+0x35c>
		PR_FAULT_INFO("  Instruction bus error");
    562c:	2303      	movs	r3, #3
    562e:	2b00      	cmp	r3, #0
    5630:	d076      	beq.n	5720 <bus_fault+0x3c8>
    5632:	f00d fc21 	bl	12e78 <_is_user_context>
    5636:	4603      	mov	r3, r0
    5638:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    563c:	7d3b      	ldrb	r3, [r7, #20]
    563e:	2201      	movs	r2, #1
    5640:	f362 0302 	bfi	r3, r2, #0, #3
    5644:	753b      	strb	r3, [r7, #20]
    5646:	7d3b      	ldrb	r3, [r7, #20]
    5648:	f36f 03c5 	bfc	r3, #3, #3
    564c:	753b      	strb	r3, [r7, #20]
    564e:	2303      	movs	r3, #3
    5650:	2b00      	cmp	r3, #0
    5652:	d009      	beq.n	5668 <bus_fault+0x310>
    5654:	4b0e      	ldr	r3, [pc, #56]	; (5690 <bus_fault+0x338>)
    5656:	681b      	ldr	r3, [r3, #0]
    5658:	4618      	mov	r0, r3
    565a:	f7ff fc89 	bl	4f70 <log_const_source_id>
    565e:	4603      	mov	r3, r0
    5660:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5664:	b29a      	uxth	r2, r3
    5666:	e000      	b.n	566a <bus_fault+0x312>
    5668:	2200      	movs	r2, #0
    566a:	8abb      	ldrh	r3, [r7, #20]
    566c:	f362 138f 	bfi	r3, r2, #6, #10
    5670:	82bb      	strh	r3, [r7, #20]
    5672:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    5676:	2b00      	cmp	r3, #0
    5678:	d004      	beq.n	5684 <bus_fault+0x32c>
    567a:	490d      	ldr	r1, [pc, #52]	; (56b0 <bus_fault+0x358>)
    567c:	8ab8      	ldrh	r0, [r7, #20]
    567e:	f7fd f937 	bl	28f0 <log_from_user>
    5682:	e04d      	b.n	5720 <bus_fault+0x3c8>
    5684:	8ab9      	ldrh	r1, [r7, #20]
    5686:	480a      	ldr	r0, [pc, #40]	; (56b0 <bus_fault+0x358>)
    5688:	f00b ffcb 	bl	11622 <log_0>
    568c:	e048      	b.n	5720 <bus_fault+0x3c8>
    568e:	bf00      	nop
    5690:	200000f4 	.word	0x200000f4
    5694:	00019880 	.word	0x00019880
    5698:	e000ed00 	.word	0xe000ed00
    569c:	00019898 	.word	0x00019898
    56a0:	00019750 	.word	0x00019750
    56a4:	000198ac 	.word	0x000198ac
    56a8:	000198c8 	.word	0x000198c8
    56ac:	000198e0 	.word	0x000198e0
    56b0:	000198fc 	.word	0x000198fc
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    56b4:	4b23      	ldr	r3, [pc, #140]	; (5744 <bus_fault+0x3ec>)
    56b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    56b8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    56bc:	2b00      	cmp	r3, #0
    56be:	d02f      	beq.n	5720 <bus_fault+0x3c8>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    56c0:	2303      	movs	r3, #3
    56c2:	2b00      	cmp	r3, #0
    56c4:	d02c      	beq.n	5720 <bus_fault+0x3c8>
    56c6:	f00d fbd7 	bl	12e78 <_is_user_context>
    56ca:	4603      	mov	r3, r0
    56cc:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    56d0:	7c3b      	ldrb	r3, [r7, #16]
    56d2:	2201      	movs	r2, #1
    56d4:	f362 0302 	bfi	r3, r2, #0, #3
    56d8:	743b      	strb	r3, [r7, #16]
    56da:	7c3b      	ldrb	r3, [r7, #16]
    56dc:	f36f 03c5 	bfc	r3, #3, #3
    56e0:	743b      	strb	r3, [r7, #16]
    56e2:	2303      	movs	r3, #3
    56e4:	2b00      	cmp	r3, #0
    56e6:	d009      	beq.n	56fc <bus_fault+0x3a4>
    56e8:	4b17      	ldr	r3, [pc, #92]	; (5748 <bus_fault+0x3f0>)
    56ea:	681b      	ldr	r3, [r3, #0]
    56ec:	4618      	mov	r0, r3
    56ee:	f7ff fc3f 	bl	4f70 <log_const_source_id>
    56f2:	4603      	mov	r3, r0
    56f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    56f8:	b29a      	uxth	r2, r3
    56fa:	e000      	b.n	56fe <bus_fault+0x3a6>
    56fc:	2200      	movs	r2, #0
    56fe:	8a3b      	ldrh	r3, [r7, #16]
    5700:	f362 138f 	bfi	r3, r2, #6, #10
    5704:	823b      	strh	r3, [r7, #16]
    5706:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    570a:	2b00      	cmp	r3, #0
    570c:	d004      	beq.n	5718 <bus_fault+0x3c0>
    570e:	490f      	ldr	r1, [pc, #60]	; (574c <bus_fault+0x3f4>)
    5710:	8a38      	ldrh	r0, [r7, #16]
    5712:	f7fd f8ed 	bl	28f0 <log_from_user>
    5716:	e003      	b.n	5720 <bus_fault+0x3c8>
    5718:	8a39      	ldrh	r1, [r7, #16]
    571a:	480c      	ldr	r0, [pc, #48]	; (574c <bus_fault+0x3f4>)
    571c:	f00b ff81 	bl	11622 <log_0>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    5720:	4b08      	ldr	r3, [pc, #32]	; (5744 <bus_fault+0x3ec>)
    5722:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5724:	4a07      	ldr	r2, [pc, #28]	; (5744 <bus_fault+0x3ec>)
    5726:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    572a:	6293      	str	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf);
    572c:	68f8      	ldr	r0, [r7, #12]
    572e:	f00d fbb4 	bl	12e9a <memory_fault_recoverable>
    5732:	4603      	mov	r3, r0
    5734:	461a      	mov	r2, r3
    5736:	687b      	ldr	r3, [r7, #4]
    5738:	701a      	strb	r2, [r3, #0]

	return reason;
    573a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    573c:	4618      	mov	r0, r3
    573e:	3740      	adds	r7, #64	; 0x40
    5740:	46bd      	mov	sp, r7
    5742:	bd80      	pop	{r7, pc}
    5744:	e000ed00 	.word	0xe000ed00
    5748:	200000f4 	.word	0x200000f4
    574c:	000197b4 	.word	0x000197b4

00005750 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
{
    5750:	b580      	push	{r7, lr}
    5752:	b08e      	sub	sp, #56	; 0x38
    5754:	af00      	add	r7, sp, #0
    5756:	6078      	str	r0, [r7, #4]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    5758:	2300      	movs	r3, #0
    575a:	637b      	str	r3, [r7, #52]	; 0x34

	PR_FAULT_INFO("***** USAGE FAULT *****");
    575c:	2303      	movs	r3, #3
    575e:	2b00      	cmp	r3, #0
    5760:	d030      	beq.n	57c4 <usage_fault+0x74>
    5762:	f00d fb89 	bl	12e78 <_is_user_context>
    5766:	4603      	mov	r3, r0
    5768:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    576c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    5770:	2201      	movs	r2, #1
    5772:	f362 0302 	bfi	r3, r2, #0, #3
    5776:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    577a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    577e:	f36f 03c5 	bfc	r3, #3, #3
    5782:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    5786:	2303      	movs	r3, #3
    5788:	2b00      	cmp	r3, #0
    578a:	d009      	beq.n	57a0 <usage_fault+0x50>
    578c:	4bb2      	ldr	r3, [pc, #712]	; (5a58 <usage_fault+0x308>)
    578e:	681b      	ldr	r3, [r3, #0]
    5790:	4618      	mov	r0, r3
    5792:	f7ff fbed 	bl	4f70 <log_const_source_id>
    5796:	4603      	mov	r3, r0
    5798:	f3c3 0309 	ubfx	r3, r3, #0, #10
    579c:	b29a      	uxth	r2, r3
    579e:	e000      	b.n	57a2 <usage_fault+0x52>
    57a0:	2200      	movs	r2, #0
    57a2:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    57a4:	f362 138f 	bfi	r3, r2, #6, #10
    57a8:	853b      	strh	r3, [r7, #40]	; 0x28
    57aa:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    57ae:	2b00      	cmp	r3, #0
    57b0:	d004      	beq.n	57bc <usage_fault+0x6c>
    57b2:	49aa      	ldr	r1, [pc, #680]	; (5a5c <usage_fault+0x30c>)
    57b4:	8d38      	ldrh	r0, [r7, #40]	; 0x28
    57b6:	f7fd f89b 	bl	28f0 <log_from_user>
    57ba:	e003      	b.n	57c4 <usage_fault+0x74>
    57bc:	8d39      	ldrh	r1, [r7, #40]	; 0x28
    57be:	48a7      	ldr	r0, [pc, #668]	; (5a5c <usage_fault+0x30c>)
    57c0:	f00b ff2f 	bl	11622 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    57c4:	4ba6      	ldr	r3, [pc, #664]	; (5a60 <usage_fault+0x310>)
    57c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    57c8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    57cc:	2b00      	cmp	r3, #0
    57ce:	d033      	beq.n	5838 <usage_fault+0xe8>
		PR_FAULT_INFO("  Division by zero");
    57d0:	2303      	movs	r3, #3
    57d2:	2b00      	cmp	r3, #0
    57d4:	d030      	beq.n	5838 <usage_fault+0xe8>
    57d6:	f00d fb4f 	bl	12e78 <_is_user_context>
    57da:	4603      	mov	r3, r0
    57dc:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    57e0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    57e4:	2201      	movs	r2, #1
    57e6:	f362 0302 	bfi	r3, r2, #0, #3
    57ea:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    57ee:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    57f2:	f36f 03c5 	bfc	r3, #3, #3
    57f6:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    57fa:	2303      	movs	r3, #3
    57fc:	2b00      	cmp	r3, #0
    57fe:	d009      	beq.n	5814 <usage_fault+0xc4>
    5800:	4b95      	ldr	r3, [pc, #596]	; (5a58 <usage_fault+0x308>)
    5802:	681b      	ldr	r3, [r3, #0]
    5804:	4618      	mov	r0, r3
    5806:	f7ff fbb3 	bl	4f70 <log_const_source_id>
    580a:	4603      	mov	r3, r0
    580c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5810:	b29a      	uxth	r2, r3
    5812:	e000      	b.n	5816 <usage_fault+0xc6>
    5814:	2200      	movs	r2, #0
    5816:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    5818:	f362 138f 	bfi	r3, r2, #6, #10
    581c:	84bb      	strh	r3, [r7, #36]	; 0x24
    581e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    5822:	2b00      	cmp	r3, #0
    5824:	d004      	beq.n	5830 <usage_fault+0xe0>
    5826:	498f      	ldr	r1, [pc, #572]	; (5a64 <usage_fault+0x314>)
    5828:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
    582a:	f7fd f861 	bl	28f0 <log_from_user>
    582e:	e003      	b.n	5838 <usage_fault+0xe8>
    5830:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
    5832:	488c      	ldr	r0, [pc, #560]	; (5a64 <usage_fault+0x314>)
    5834:	f00b fef5 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    5838:	4b89      	ldr	r3, [pc, #548]	; (5a60 <usage_fault+0x310>)
    583a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    583c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    5840:	2b00      	cmp	r3, #0
    5842:	d033      	beq.n	58ac <usage_fault+0x15c>
		PR_FAULT_INFO("  Unaligned memory access");
    5844:	2303      	movs	r3, #3
    5846:	2b00      	cmp	r3, #0
    5848:	d030      	beq.n	58ac <usage_fault+0x15c>
    584a:	f00d fb15 	bl	12e78 <_is_user_context>
    584e:	4603      	mov	r3, r0
    5850:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    5854:	f897 3020 	ldrb.w	r3, [r7, #32]
    5858:	2201      	movs	r2, #1
    585a:	f362 0302 	bfi	r3, r2, #0, #3
    585e:	f887 3020 	strb.w	r3, [r7, #32]
    5862:	f897 3020 	ldrb.w	r3, [r7, #32]
    5866:	f36f 03c5 	bfc	r3, #3, #3
    586a:	f887 3020 	strb.w	r3, [r7, #32]
    586e:	2303      	movs	r3, #3
    5870:	2b00      	cmp	r3, #0
    5872:	d009      	beq.n	5888 <usage_fault+0x138>
    5874:	4b78      	ldr	r3, [pc, #480]	; (5a58 <usage_fault+0x308>)
    5876:	681b      	ldr	r3, [r3, #0]
    5878:	4618      	mov	r0, r3
    587a:	f7ff fb79 	bl	4f70 <log_const_source_id>
    587e:	4603      	mov	r3, r0
    5880:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5884:	b29a      	uxth	r2, r3
    5886:	e000      	b.n	588a <usage_fault+0x13a>
    5888:	2200      	movs	r2, #0
    588a:	8c3b      	ldrh	r3, [r7, #32]
    588c:	f362 138f 	bfi	r3, r2, #6, #10
    5890:	843b      	strh	r3, [r7, #32]
    5892:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    5896:	2b00      	cmp	r3, #0
    5898:	d004      	beq.n	58a4 <usage_fault+0x154>
    589a:	4973      	ldr	r1, [pc, #460]	; (5a68 <usage_fault+0x318>)
    589c:	8c38      	ldrh	r0, [r7, #32]
    589e:	f7fd f827 	bl	28f0 <log_from_user>
    58a2:	e003      	b.n	58ac <usage_fault+0x15c>
    58a4:	8c39      	ldrh	r1, [r7, #32]
    58a6:	4870      	ldr	r0, [pc, #448]	; (5a68 <usage_fault+0x318>)
    58a8:	f00b febb 	bl	11622 <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    58ac:	4b6c      	ldr	r3, [pc, #432]	; (5a60 <usage_fault+0x310>)
    58ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    58b0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    58b4:	2b00      	cmp	r3, #0
    58b6:	d031      	beq.n	591c <usage_fault+0x1cc>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
    58b8:	2303      	movs	r3, #3
    58ba:	2b00      	cmp	r3, #0
    58bc:	d02c      	beq.n	5918 <usage_fault+0x1c8>
    58be:	f00d fadb 	bl	12e78 <_is_user_context>
    58c2:	4603      	mov	r3, r0
    58c4:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    58c8:	7f3b      	ldrb	r3, [r7, #28]
    58ca:	2201      	movs	r2, #1
    58cc:	f362 0302 	bfi	r3, r2, #0, #3
    58d0:	773b      	strb	r3, [r7, #28]
    58d2:	7f3b      	ldrb	r3, [r7, #28]
    58d4:	f36f 03c5 	bfc	r3, #3, #3
    58d8:	773b      	strb	r3, [r7, #28]
    58da:	2303      	movs	r3, #3
    58dc:	2b00      	cmp	r3, #0
    58de:	d009      	beq.n	58f4 <usage_fault+0x1a4>
    58e0:	4b5d      	ldr	r3, [pc, #372]	; (5a58 <usage_fault+0x308>)
    58e2:	681b      	ldr	r3, [r3, #0]
    58e4:	4618      	mov	r0, r3
    58e6:	f7ff fb43 	bl	4f70 <log_const_source_id>
    58ea:	4603      	mov	r3, r0
    58ec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    58f0:	b29a      	uxth	r2, r3
    58f2:	e000      	b.n	58f6 <usage_fault+0x1a6>
    58f4:	2200      	movs	r2, #0
    58f6:	8bbb      	ldrh	r3, [r7, #28]
    58f8:	f362 138f 	bfi	r3, r2, #6, #10
    58fc:	83bb      	strh	r3, [r7, #28]
    58fe:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    5902:	2b00      	cmp	r3, #0
    5904:	d004      	beq.n	5910 <usage_fault+0x1c0>
    5906:	4959      	ldr	r1, [pc, #356]	; (5a6c <usage_fault+0x31c>)
    5908:	8bb8      	ldrh	r0, [r7, #28]
    590a:	f7fc fff1 	bl	28f0 <log_from_user>
    590e:	e003      	b.n	5918 <usage_fault+0x1c8>
    5910:	8bb9      	ldrh	r1, [r7, #28]
    5912:	4856      	ldr	r0, [pc, #344]	; (5a6c <usage_fault+0x31c>)
    5914:	f00b fe85 	bl	11622 <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
    5918:	2302      	movs	r3, #2
    591a:	637b      	str	r3, [r7, #52]	; 0x34
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    591c:	4b50      	ldr	r3, [pc, #320]	; (5a60 <usage_fault+0x310>)
    591e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5920:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
    5924:	2b00      	cmp	r3, #0
    5926:	d02f      	beq.n	5988 <usage_fault+0x238>
		PR_FAULT_INFO("  No coprocessor instructions");
    5928:	2303      	movs	r3, #3
    592a:	2b00      	cmp	r3, #0
    592c:	d02c      	beq.n	5988 <usage_fault+0x238>
    592e:	f00d faa3 	bl	12e78 <_is_user_context>
    5932:	4603      	mov	r3, r0
    5934:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    5938:	7e3b      	ldrb	r3, [r7, #24]
    593a:	2201      	movs	r2, #1
    593c:	f362 0302 	bfi	r3, r2, #0, #3
    5940:	763b      	strb	r3, [r7, #24]
    5942:	7e3b      	ldrb	r3, [r7, #24]
    5944:	f36f 03c5 	bfc	r3, #3, #3
    5948:	763b      	strb	r3, [r7, #24]
    594a:	2303      	movs	r3, #3
    594c:	2b00      	cmp	r3, #0
    594e:	d009      	beq.n	5964 <usage_fault+0x214>
    5950:	4b41      	ldr	r3, [pc, #260]	; (5a58 <usage_fault+0x308>)
    5952:	681b      	ldr	r3, [r3, #0]
    5954:	4618      	mov	r0, r3
    5956:	f7ff fb0b 	bl	4f70 <log_const_source_id>
    595a:	4603      	mov	r3, r0
    595c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5960:	b29a      	uxth	r2, r3
    5962:	e000      	b.n	5966 <usage_fault+0x216>
    5964:	2200      	movs	r2, #0
    5966:	8b3b      	ldrh	r3, [r7, #24]
    5968:	f362 138f 	bfi	r3, r2, #6, #10
    596c:	833b      	strh	r3, [r7, #24]
    596e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    5972:	2b00      	cmp	r3, #0
    5974:	d004      	beq.n	5980 <usage_fault+0x230>
    5976:	493e      	ldr	r1, [pc, #248]	; (5a70 <usage_fault+0x320>)
    5978:	8b38      	ldrh	r0, [r7, #24]
    597a:	f7fc ffb9 	bl	28f0 <log_from_user>
    597e:	e003      	b.n	5988 <usage_fault+0x238>
    5980:	8b39      	ldrh	r1, [r7, #24]
    5982:	483b      	ldr	r0, [pc, #236]	; (5a70 <usage_fault+0x320>)
    5984:	f00b fe4d 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    5988:	4b35      	ldr	r3, [pc, #212]	; (5a60 <usage_fault+0x310>)
    598a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    598c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    5990:	2b00      	cmp	r3, #0
    5992:	d02f      	beq.n	59f4 <usage_fault+0x2a4>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    5994:	2303      	movs	r3, #3
    5996:	2b00      	cmp	r3, #0
    5998:	d02c      	beq.n	59f4 <usage_fault+0x2a4>
    599a:	f00d fa6d 	bl	12e78 <_is_user_context>
    599e:	4603      	mov	r3, r0
    59a0:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    59a4:	7d3b      	ldrb	r3, [r7, #20]
    59a6:	2201      	movs	r2, #1
    59a8:	f362 0302 	bfi	r3, r2, #0, #3
    59ac:	753b      	strb	r3, [r7, #20]
    59ae:	7d3b      	ldrb	r3, [r7, #20]
    59b0:	f36f 03c5 	bfc	r3, #3, #3
    59b4:	753b      	strb	r3, [r7, #20]
    59b6:	2303      	movs	r3, #3
    59b8:	2b00      	cmp	r3, #0
    59ba:	d009      	beq.n	59d0 <usage_fault+0x280>
    59bc:	4b26      	ldr	r3, [pc, #152]	; (5a58 <usage_fault+0x308>)
    59be:	681b      	ldr	r3, [r3, #0]
    59c0:	4618      	mov	r0, r3
    59c2:	f7ff fad5 	bl	4f70 <log_const_source_id>
    59c6:	4603      	mov	r3, r0
    59c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    59cc:	b29a      	uxth	r2, r3
    59ce:	e000      	b.n	59d2 <usage_fault+0x282>
    59d0:	2200      	movs	r2, #0
    59d2:	8abb      	ldrh	r3, [r7, #20]
    59d4:	f362 138f 	bfi	r3, r2, #6, #10
    59d8:	82bb      	strh	r3, [r7, #20]
    59da:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    59de:	2b00      	cmp	r3, #0
    59e0:	d004      	beq.n	59ec <usage_fault+0x29c>
    59e2:	4924      	ldr	r1, [pc, #144]	; (5a74 <usage_fault+0x324>)
    59e4:	8ab8      	ldrh	r0, [r7, #20]
    59e6:	f7fc ff83 	bl	28f0 <log_from_user>
    59ea:	e003      	b.n	59f4 <usage_fault+0x2a4>
    59ec:	8ab9      	ldrh	r1, [r7, #20]
    59ee:	4821      	ldr	r0, [pc, #132]	; (5a74 <usage_fault+0x324>)
    59f0:	f00b fe17 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    59f4:	4b1a      	ldr	r3, [pc, #104]	; (5a60 <usage_fault+0x310>)
    59f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    59f8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    59fc:	2b00      	cmp	r3, #0
    59fe:	d041      	beq.n	5a84 <usage_fault+0x334>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    5a00:	2303      	movs	r3, #3
    5a02:	2b00      	cmp	r3, #0
    5a04:	d03e      	beq.n	5a84 <usage_fault+0x334>
    5a06:	f00d fa37 	bl	12e78 <_is_user_context>
    5a0a:	4603      	mov	r3, r0
    5a0c:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    5a10:	7c3b      	ldrb	r3, [r7, #16]
    5a12:	2201      	movs	r2, #1
    5a14:	f362 0302 	bfi	r3, r2, #0, #3
    5a18:	743b      	strb	r3, [r7, #16]
    5a1a:	7c3b      	ldrb	r3, [r7, #16]
    5a1c:	f36f 03c5 	bfc	r3, #3, #3
    5a20:	743b      	strb	r3, [r7, #16]
    5a22:	2303      	movs	r3, #3
    5a24:	2b00      	cmp	r3, #0
    5a26:	d009      	beq.n	5a3c <usage_fault+0x2ec>
    5a28:	4b0b      	ldr	r3, [pc, #44]	; (5a58 <usage_fault+0x308>)
    5a2a:	681b      	ldr	r3, [r3, #0]
    5a2c:	4618      	mov	r0, r3
    5a2e:	f7ff fa9f 	bl	4f70 <log_const_source_id>
    5a32:	4603      	mov	r3, r0
    5a34:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5a38:	b29a      	uxth	r2, r3
    5a3a:	e000      	b.n	5a3e <usage_fault+0x2ee>
    5a3c:	2200      	movs	r2, #0
    5a3e:	8a3b      	ldrh	r3, [r7, #16]
    5a40:	f362 138f 	bfi	r3, r2, #6, #10
    5a44:	823b      	strh	r3, [r7, #16]
    5a46:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    5a4a:	2b00      	cmp	r3, #0
    5a4c:	d016      	beq.n	5a7c <usage_fault+0x32c>
    5a4e:	490a      	ldr	r1, [pc, #40]	; (5a78 <usage_fault+0x328>)
    5a50:	8a38      	ldrh	r0, [r7, #16]
    5a52:	f7fc ff4d 	bl	28f0 <log_from_user>
    5a56:	e015      	b.n	5a84 <usage_fault+0x334>
    5a58:	200000f4 	.word	0x200000f4
    5a5c:	00019914 	.word	0x00019914
    5a60:	e000ed00 	.word	0xe000ed00
    5a64:	0001992c 	.word	0x0001992c
    5a68:	00019940 	.word	0x00019940
    5a6c:	0001995c 	.word	0x0001995c
    5a70:	00019988 	.word	0x00019988
    5a74:	000199a8 	.word	0x000199a8
    5a78:	000199d0 	.word	0x000199d0
    5a7c:	8a39      	ldrh	r1, [r7, #16]
    5a7e:	4823      	ldr	r0, [pc, #140]	; (5b0c <usage_fault+0x3bc>)
    5a80:	f00b fdcf 	bl	11622 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    5a84:	4b22      	ldr	r3, [pc, #136]	; (5b10 <usage_fault+0x3c0>)
    5a86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5a88:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    5a8c:	2b00      	cmp	r3, #0
    5a8e:	d02f      	beq.n	5af0 <usage_fault+0x3a0>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    5a90:	2303      	movs	r3, #3
    5a92:	2b00      	cmp	r3, #0
    5a94:	d02c      	beq.n	5af0 <usage_fault+0x3a0>
    5a96:	f00d f9ef 	bl	12e78 <_is_user_context>
    5a9a:	4603      	mov	r3, r0
    5a9c:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    5aa0:	7b3b      	ldrb	r3, [r7, #12]
    5aa2:	2201      	movs	r2, #1
    5aa4:	f362 0302 	bfi	r3, r2, #0, #3
    5aa8:	733b      	strb	r3, [r7, #12]
    5aaa:	7b3b      	ldrb	r3, [r7, #12]
    5aac:	f36f 03c5 	bfc	r3, #3, #3
    5ab0:	733b      	strb	r3, [r7, #12]
    5ab2:	2303      	movs	r3, #3
    5ab4:	2b00      	cmp	r3, #0
    5ab6:	d009      	beq.n	5acc <usage_fault+0x37c>
    5ab8:	4b16      	ldr	r3, [pc, #88]	; (5b14 <usage_fault+0x3c4>)
    5aba:	681b      	ldr	r3, [r3, #0]
    5abc:	4618      	mov	r0, r3
    5abe:	f7ff fa57 	bl	4f70 <log_const_source_id>
    5ac2:	4603      	mov	r3, r0
    5ac4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5ac8:	b29a      	uxth	r2, r3
    5aca:	e000      	b.n	5ace <usage_fault+0x37e>
    5acc:	2200      	movs	r2, #0
    5ace:	89bb      	ldrh	r3, [r7, #12]
    5ad0:	f362 138f 	bfi	r3, r2, #6, #10
    5ad4:	81bb      	strh	r3, [r7, #12]
    5ad6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    5ada:	2b00      	cmp	r3, #0
    5adc:	d004      	beq.n	5ae8 <usage_fault+0x398>
    5ade:	490e      	ldr	r1, [pc, #56]	; (5b18 <usage_fault+0x3c8>)
    5ae0:	89b8      	ldrh	r0, [r7, #12]
    5ae2:	f7fc ff05 	bl	28f0 <log_from_user>
    5ae6:	e003      	b.n	5af0 <usage_fault+0x3a0>
    5ae8:	89b9      	ldrh	r1, [r7, #12]
    5aea:	480b      	ldr	r0, [pc, #44]	; (5b18 <usage_fault+0x3c8>)
    5aec:	f00b fd99 	bl	11622 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    5af0:	4b07      	ldr	r3, [pc, #28]	; (5b10 <usage_fault+0x3c0>)
    5af2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5af4:	4a06      	ldr	r2, [pc, #24]	; (5b10 <usage_fault+0x3c0>)
    5af6:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    5afa:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    5afe:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
    5b00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
    5b02:	4618      	mov	r0, r3
    5b04:	3738      	adds	r7, #56	; 0x38
    5b06:	46bd      	mov	sp, r7
    5b08:	bd80      	pop	{r7, pc}
    5b0a:	bf00      	nop
    5b0c:	000199d0 	.word	0x000199d0
    5b10:	e000ed00 	.word	0xe000ed00
    5b14:	200000f4 	.word	0x200000f4
    5b18:	000199ec 	.word	0x000199ec

00005b1c <debug_monitor>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void debug_monitor(const z_arch_esf_t *esf)
{
    5b1c:	b580      	push	{r7, lr}
    5b1e:	b084      	sub	sp, #16
    5b20:	af00      	add	r7, sp, #0
    5b22:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(esf);

	PR_FAULT_INFO(
    5b24:	2303      	movs	r3, #3
    5b26:	2b00      	cmp	r3, #0
    5b28:	d02a      	beq.n	5b80 <debug_monitor+0x64>
    5b2a:	f00d f9a5 	bl	12e78 <_is_user_context>
    5b2e:	4603      	mov	r3, r0
    5b30:	73fb      	strb	r3, [r7, #15]
    5b32:	7b3b      	ldrb	r3, [r7, #12]
    5b34:	2201      	movs	r2, #1
    5b36:	f362 0302 	bfi	r3, r2, #0, #3
    5b3a:	733b      	strb	r3, [r7, #12]
    5b3c:	7b3b      	ldrb	r3, [r7, #12]
    5b3e:	f36f 03c5 	bfc	r3, #3, #3
    5b42:	733b      	strb	r3, [r7, #12]
    5b44:	2303      	movs	r3, #3
    5b46:	2b00      	cmp	r3, #0
    5b48:	d009      	beq.n	5b5e <debug_monitor+0x42>
    5b4a:	4b0f      	ldr	r3, [pc, #60]	; (5b88 <debug_monitor+0x6c>)
    5b4c:	681b      	ldr	r3, [r3, #0]
    5b4e:	4618      	mov	r0, r3
    5b50:	f7ff fa0e 	bl	4f70 <log_const_source_id>
    5b54:	4603      	mov	r3, r0
    5b56:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5b5a:	b29a      	uxth	r2, r3
    5b5c:	e000      	b.n	5b60 <debug_monitor+0x44>
    5b5e:	2200      	movs	r2, #0
    5b60:	89bb      	ldrh	r3, [r7, #12]
    5b62:	f362 138f 	bfi	r3, r2, #6, #10
    5b66:	81bb      	strh	r3, [r7, #12]
    5b68:	7bfb      	ldrb	r3, [r7, #15]
    5b6a:	2b00      	cmp	r3, #0
    5b6c:	d004      	beq.n	5b78 <debug_monitor+0x5c>
    5b6e:	4907      	ldr	r1, [pc, #28]	; (5b8c <debug_monitor+0x70>)
    5b70:	89b8      	ldrh	r0, [r7, #12]
    5b72:	f7fc febd 	bl	28f0 <log_from_user>
		"***** Debug monitor exception (not implemented) *****");
}
    5b76:	e003      	b.n	5b80 <debug_monitor+0x64>
	PR_FAULT_INFO(
    5b78:	89b9      	ldrh	r1, [r7, #12]
    5b7a:	4804      	ldr	r0, [pc, #16]	; (5b8c <debug_monitor+0x70>)
    5b7c:	f00b fd51 	bl	11622 <log_0>
}
    5b80:	bf00      	nop
    5b82:	3710      	adds	r7, #16
    5b84:	46bd      	mov	sp, r7
    5b86:	bd80      	pop	{r7, pc}
    5b88:	200000f4 	.word	0x200000f4
    5b8c:	00019a18 	.word	0x00019a18

00005b90 <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    5b90:	b580      	push	{r7, lr}
    5b92:	b088      	sub	sp, #32
    5b94:	af00      	add	r7, sp, #0
    5b96:	6078      	str	r0, [r7, #4]
    5b98:	6039      	str	r1, [r7, #0]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    5b9a:	2300      	movs	r3, #0
    5b9c:	61fb      	str	r3, [r7, #28]

	PR_FAULT_INFO("***** HARD FAULT *****");
    5b9e:	2303      	movs	r3, #3
    5ba0:	2b00      	cmp	r3, #0
    5ba2:	d02a      	beq.n	5bfa <hard_fault+0x6a>
    5ba4:	f00d f968 	bl	12e78 <_is_user_context>
    5ba8:	4603      	mov	r3, r0
    5baa:	76fb      	strb	r3, [r7, #27]
    5bac:	7d3b      	ldrb	r3, [r7, #20]
    5bae:	2201      	movs	r2, #1
    5bb0:	f362 0302 	bfi	r3, r2, #0, #3
    5bb4:	753b      	strb	r3, [r7, #20]
    5bb6:	7d3b      	ldrb	r3, [r7, #20]
    5bb8:	f36f 03c5 	bfc	r3, #3, #3
    5bbc:	753b      	strb	r3, [r7, #20]
    5bbe:	2303      	movs	r3, #3
    5bc0:	2b00      	cmp	r3, #0
    5bc2:	d009      	beq.n	5bd8 <hard_fault+0x48>
    5bc4:	4b57      	ldr	r3, [pc, #348]	; (5d24 <hard_fault+0x194>)
    5bc6:	681b      	ldr	r3, [r3, #0]
    5bc8:	4618      	mov	r0, r3
    5bca:	f7ff f9d1 	bl	4f70 <log_const_source_id>
    5bce:	4603      	mov	r3, r0
    5bd0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5bd4:	b29a      	uxth	r2, r3
    5bd6:	e000      	b.n	5bda <hard_fault+0x4a>
    5bd8:	2200      	movs	r2, #0
    5bda:	8abb      	ldrh	r3, [r7, #20]
    5bdc:	f362 138f 	bfi	r3, r2, #6, #10
    5be0:	82bb      	strh	r3, [r7, #20]
    5be2:	7efb      	ldrb	r3, [r7, #27]
    5be4:	2b00      	cmp	r3, #0
    5be6:	d004      	beq.n	5bf2 <hard_fault+0x62>
    5be8:	494f      	ldr	r1, [pc, #316]	; (5d28 <hard_fault+0x198>)
    5bea:	8ab8      	ldrh	r0, [r7, #20]
    5bec:	f7fc fe80 	bl	28f0 <log_from_user>
    5bf0:	e003      	b.n	5bfa <hard_fault+0x6a>
    5bf2:	8ab9      	ldrh	r1, [r7, #20]
    5bf4:	484c      	ldr	r0, [pc, #304]	; (5d28 <hard_fault+0x198>)
    5bf6:	f00b fd14 	bl	11622 <log_0>
	}
#undef _SVC_OPCODE

	*recoverable = memory_fault_recoverable(esf);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	*recoverable = false;
    5bfa:	683b      	ldr	r3, [r7, #0]
    5bfc:	2200      	movs	r2, #0
    5bfe:	701a      	strb	r2, [r3, #0]

	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    5c00:	4b4a      	ldr	r3, [pc, #296]	; (5d2c <hard_fault+0x19c>)
    5c02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5c04:	f003 0302 	and.w	r3, r3, #2
    5c08:	2b00      	cmp	r3, #0
    5c0a:	d02f      	beq.n	5c6c <hard_fault+0xdc>
		PR_EXC("  Bus fault on vector table read");
    5c0c:	2303      	movs	r3, #3
    5c0e:	2b00      	cmp	r3, #0
    5c10:	f000 8082 	beq.w	5d18 <hard_fault+0x188>
    5c14:	f00d f930 	bl	12e78 <_is_user_context>
    5c18:	4603      	mov	r3, r0
    5c1a:	767b      	strb	r3, [r7, #25]
    5c1c:	7c3b      	ldrb	r3, [r7, #16]
    5c1e:	2201      	movs	r2, #1
    5c20:	f362 0302 	bfi	r3, r2, #0, #3
    5c24:	743b      	strb	r3, [r7, #16]
    5c26:	7c3b      	ldrb	r3, [r7, #16]
    5c28:	f36f 03c5 	bfc	r3, #3, #3
    5c2c:	743b      	strb	r3, [r7, #16]
    5c2e:	2303      	movs	r3, #3
    5c30:	2b00      	cmp	r3, #0
    5c32:	d009      	beq.n	5c48 <hard_fault+0xb8>
    5c34:	4b3b      	ldr	r3, [pc, #236]	; (5d24 <hard_fault+0x194>)
    5c36:	681b      	ldr	r3, [r3, #0]
    5c38:	4618      	mov	r0, r3
    5c3a:	f7ff f999 	bl	4f70 <log_const_source_id>
    5c3e:	4603      	mov	r3, r0
    5c40:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5c44:	b29a      	uxth	r2, r3
    5c46:	e000      	b.n	5c4a <hard_fault+0xba>
    5c48:	2200      	movs	r2, #0
    5c4a:	8a3b      	ldrh	r3, [r7, #16]
    5c4c:	f362 138f 	bfi	r3, r2, #6, #10
    5c50:	823b      	strh	r3, [r7, #16]
    5c52:	7e7b      	ldrb	r3, [r7, #25]
    5c54:	2b00      	cmp	r3, #0
    5c56:	d004      	beq.n	5c62 <hard_fault+0xd2>
    5c58:	4935      	ldr	r1, [pc, #212]	; (5d30 <hard_fault+0x1a0>)
    5c5a:	8a38      	ldrh	r0, [r7, #16]
    5c5c:	f7fc fe48 	bl	28f0 <log_from_user>
    5c60:	e05a      	b.n	5d18 <hard_fault+0x188>
    5c62:	8a39      	ldrh	r1, [r7, #16]
    5c64:	4832      	ldr	r0, [pc, #200]	; (5d30 <hard_fault+0x1a0>)
    5c66:	f00b fcdc 	bl	11622 <log_0>
    5c6a:	e055      	b.n	5d18 <hard_fault+0x188>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    5c6c:	4b2f      	ldr	r3, [pc, #188]	; (5d2c <hard_fault+0x19c>)
    5c6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5c70:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
    5c74:	2b00      	cmp	r3, #0
    5c76:	d04f      	beq.n	5d18 <hard_fault+0x188>
		PR_EXC("  Fault escalation (see below)");
    5c78:	2303      	movs	r3, #3
    5c7a:	2b00      	cmp	r3, #0
    5c7c:	d02a      	beq.n	5cd4 <hard_fault+0x144>
    5c7e:	f00d f8fb 	bl	12e78 <_is_user_context>
    5c82:	4603      	mov	r3, r0
    5c84:	76bb      	strb	r3, [r7, #26]
    5c86:	7b3b      	ldrb	r3, [r7, #12]
    5c88:	2201      	movs	r2, #1
    5c8a:	f362 0302 	bfi	r3, r2, #0, #3
    5c8e:	733b      	strb	r3, [r7, #12]
    5c90:	7b3b      	ldrb	r3, [r7, #12]
    5c92:	f36f 03c5 	bfc	r3, #3, #3
    5c96:	733b      	strb	r3, [r7, #12]
    5c98:	2303      	movs	r3, #3
    5c9a:	2b00      	cmp	r3, #0
    5c9c:	d009      	beq.n	5cb2 <hard_fault+0x122>
    5c9e:	4b21      	ldr	r3, [pc, #132]	; (5d24 <hard_fault+0x194>)
    5ca0:	681b      	ldr	r3, [r3, #0]
    5ca2:	4618      	mov	r0, r3
    5ca4:	f7ff f964 	bl	4f70 <log_const_source_id>
    5ca8:	4603      	mov	r3, r0
    5caa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5cae:	b29a      	uxth	r2, r3
    5cb0:	e000      	b.n	5cb4 <hard_fault+0x124>
    5cb2:	2200      	movs	r2, #0
    5cb4:	89bb      	ldrh	r3, [r7, #12]
    5cb6:	f362 138f 	bfi	r3, r2, #6, #10
    5cba:	81bb      	strh	r3, [r7, #12]
    5cbc:	7ebb      	ldrb	r3, [r7, #26]
    5cbe:	2b00      	cmp	r3, #0
    5cc0:	d004      	beq.n	5ccc <hard_fault+0x13c>
    5cc2:	491c      	ldr	r1, [pc, #112]	; (5d34 <hard_fault+0x1a4>)
    5cc4:	89b8      	ldrh	r0, [r7, #12]
    5cc6:	f7fc fe13 	bl	28f0 <log_from_user>
    5cca:	e003      	b.n	5cd4 <hard_fault+0x144>
    5ccc:	89b9      	ldrh	r1, [r7, #12]
    5cce:	4819      	ldr	r0, [pc, #100]	; (5d34 <hard_fault+0x1a4>)
    5cd0:	f00b fca7 	bl	11622 <log_0>
		if (SCB_MMFSR != 0) {
    5cd4:	4b18      	ldr	r3, [pc, #96]	; (5d38 <hard_fault+0x1a8>)
    5cd6:	781b      	ldrb	r3, [r3, #0]
    5cd8:	b2db      	uxtb	r3, r3
    5cda:	2b00      	cmp	r3, #0
    5cdc:	d006      	beq.n	5cec <hard_fault+0x15c>
			reason = mem_manage_fault(esf, 1, recoverable);
    5cde:	683a      	ldr	r2, [r7, #0]
    5ce0:	2101      	movs	r1, #1
    5ce2:	6878      	ldr	r0, [r7, #4]
    5ce4:	f7ff f954 	bl	4f90 <mem_manage_fault>
    5ce8:	61f8      	str	r0, [r7, #28]
    5cea:	e015      	b.n	5d18 <hard_fault+0x188>
		} else if (SCB_BFSR != 0) {
    5cec:	4b13      	ldr	r3, [pc, #76]	; (5d3c <hard_fault+0x1ac>)
    5cee:	781b      	ldrb	r3, [r3, #0]
    5cf0:	b2db      	uxtb	r3, r3
    5cf2:	2b00      	cmp	r3, #0
    5cf4:	d007      	beq.n	5d06 <hard_fault+0x176>
			reason = bus_fault(esf, 1, recoverable);
    5cf6:	683a      	ldr	r2, [r7, #0]
    5cf8:	2101      	movs	r1, #1
    5cfa:	6878      	ldr	r0, [r7, #4]
    5cfc:	f7ff fb2c 	bl	5358 <bus_fault>
    5d00:	4603      	mov	r3, r0
    5d02:	61fb      	str	r3, [r7, #28]
    5d04:	e008      	b.n	5d18 <hard_fault+0x188>
		} else if (SCB_UFSR != 0) {
    5d06:	4b0e      	ldr	r3, [pc, #56]	; (5d40 <hard_fault+0x1b0>)
    5d08:	881b      	ldrh	r3, [r3, #0]
    5d0a:	b29b      	uxth	r3, r3
    5d0c:	2b00      	cmp	r3, #0
    5d0e:	d003      	beq.n	5d18 <hard_fault+0x188>
			reason = usage_fault(esf);
    5d10:	6878      	ldr	r0, [r7, #4]
    5d12:	f7ff fd1d 	bl	5750 <usage_fault>
    5d16:	61f8      	str	r0, [r7, #28]
	}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
    5d18:	69fb      	ldr	r3, [r7, #28]
}
    5d1a:	4618      	mov	r0, r3
    5d1c:	3720      	adds	r7, #32
    5d1e:	46bd      	mov	sp, r7
    5d20:	bd80      	pop	{r7, pc}
    5d22:	bf00      	nop
    5d24:	200000f4 	.word	0x200000f4
    5d28:	00019a50 	.word	0x00019a50
    5d2c:	e000ed00 	.word	0xe000ed00
    5d30:	00019a68 	.word	0x00019a68
    5d34:	00019a8c 	.word	0x00019a8c
    5d38:	e000ed28 	.word	0xe000ed28
    5d3c:	e000ed29 	.word	0xe000ed29
    5d40:	e000ed2a 	.word	0xe000ed2a

00005d44 <reserved_exception>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
    5d44:	b580      	push	{r7, lr}
    5d46:	b084      	sub	sp, #16
    5d48:	af00      	add	r7, sp, #0
    5d4a:	6078      	str	r0, [r7, #4]
    5d4c:	6039      	str	r1, [r7, #0]
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
    5d4e:	2303      	movs	r3, #3
    5d50:	2b00      	cmp	r3, #0
    5d52:	d03b      	beq.n	5dcc <reserved_exception+0x88>
    5d54:	f00d f890 	bl	12e78 <_is_user_context>
    5d58:	4603      	mov	r3, r0
    5d5a:	73fb      	strb	r3, [r7, #15]
    5d5c:	7b3b      	ldrb	r3, [r7, #12]
    5d5e:	2201      	movs	r2, #1
    5d60:	f362 0302 	bfi	r3, r2, #0, #3
    5d64:	733b      	strb	r3, [r7, #12]
    5d66:	7b3b      	ldrb	r3, [r7, #12]
    5d68:	f36f 03c5 	bfc	r3, #3, #3
    5d6c:	733b      	strb	r3, [r7, #12]
    5d6e:	2303      	movs	r3, #3
    5d70:	2b00      	cmp	r3, #0
    5d72:	d009      	beq.n	5d88 <reserved_exception+0x44>
    5d74:	4b17      	ldr	r3, [pc, #92]	; (5dd4 <reserved_exception+0x90>)
    5d76:	681b      	ldr	r3, [r3, #0]
    5d78:	4618      	mov	r0, r3
    5d7a:	f7ff f8f9 	bl	4f70 <log_const_source_id>
    5d7e:	4603      	mov	r3, r0
    5d80:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5d84:	b29a      	uxth	r2, r3
    5d86:	e000      	b.n	5d8a <reserved_exception+0x46>
    5d88:	2200      	movs	r2, #0
    5d8a:	89bb      	ldrh	r3, [r7, #12]
    5d8c:	f362 138f 	bfi	r3, r2, #6, #10
    5d90:	81bb      	strh	r3, [r7, #12]
    5d92:	7bfb      	ldrb	r3, [r7, #15]
    5d94:	2b00      	cmp	r3, #0
    5d96:	d00c      	beq.n	5db2 <reserved_exception+0x6e>
    5d98:	683b      	ldr	r3, [r7, #0]
    5d9a:	2b0f      	cmp	r3, #15
    5d9c:	dc01      	bgt.n	5da2 <reserved_exception+0x5e>
    5d9e:	4a0e      	ldr	r2, [pc, #56]	; (5dd8 <reserved_exception+0x94>)
    5da0:	e000      	b.n	5da4 <reserved_exception+0x60>
    5da2:	4a0e      	ldr	r2, [pc, #56]	; (5ddc <reserved_exception+0x98>)
    5da4:	683b      	ldr	r3, [r7, #0]
    5da6:	3b10      	subs	r3, #16
    5da8:	490d      	ldr	r1, [pc, #52]	; (5de0 <reserved_exception+0x9c>)
    5daa:	89b8      	ldrh	r0, [r7, #12]
    5dac:	f7fc fda0 	bl	28f0 <log_from_user>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
    5db0:	e00c      	b.n	5dcc <reserved_exception+0x88>
	PR_FAULT_INFO("***** %s %d) *****",
    5db2:	683b      	ldr	r3, [r7, #0]
    5db4:	2b0f      	cmp	r3, #15
    5db6:	dc01      	bgt.n	5dbc <reserved_exception+0x78>
    5db8:	4907      	ldr	r1, [pc, #28]	; (5dd8 <reserved_exception+0x94>)
    5dba:	e000      	b.n	5dbe <reserved_exception+0x7a>
    5dbc:	4907      	ldr	r1, [pc, #28]	; (5ddc <reserved_exception+0x98>)
    5dbe:	683b      	ldr	r3, [r7, #0]
    5dc0:	3b10      	subs	r3, #16
    5dc2:	461a      	mov	r2, r3
    5dc4:	89bb      	ldrh	r3, [r7, #12]
    5dc6:	4806      	ldr	r0, [pc, #24]	; (5de0 <reserved_exception+0x9c>)
    5dc8:	f00b fc57 	bl	1167a <log_2>
}
    5dcc:	bf00      	nop
    5dce:	3710      	adds	r7, #16
    5dd0:	46bd      	mov	sp, r7
    5dd2:	bd80      	pop	{r7, pc}
    5dd4:	200000f4 	.word	0x200000f4
    5dd8:	00019aac 	.word	0x00019aac
    5ddc:	00019ac4 	.word	0x00019ac4
    5de0:	00019ae0 	.word	0x00019ae0

00005de4 <fault_handle>:

/* Handler function for ARM fault conditions. */
static uint32_t fault_handle(z_arch_esf_t *esf, int fault, bool *recoverable)
{
    5de4:	b580      	push	{r7, lr}
    5de6:	b086      	sub	sp, #24
    5de8:	af00      	add	r7, sp, #0
    5dea:	60f8      	str	r0, [r7, #12]
    5dec:	60b9      	str	r1, [r7, #8]
    5dee:	607a      	str	r2, [r7, #4]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    5df0:	2300      	movs	r3, #0
    5df2:	617b      	str	r3, [r7, #20]

	*recoverable = false;
    5df4:	687b      	ldr	r3, [r7, #4]
    5df6:	2200      	movs	r2, #0
    5df8:	701a      	strb	r2, [r3, #0]
    5dfa:	68bb      	ldr	r3, [r7, #8]
    5dfc:	3b03      	subs	r3, #3
    5dfe:	2b09      	cmp	r3, #9
    5e00:	d834      	bhi.n	5e6c <fault_handle+0x88>
    5e02:	a201      	add	r2, pc, #4	; (adr r2, 5e08 <fault_handle+0x24>)
    5e04:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5e08:	00005e31 	.word	0x00005e31
    5e0c:	00005e3d 	.word	0x00005e3d
    5e10:	00005e4b 	.word	0x00005e4b
    5e14:	00005e5b 	.word	0x00005e5b
    5e18:	00005e6d 	.word	0x00005e6d
    5e1c:	00005e6d 	.word	0x00005e6d
    5e20:	00005e6d 	.word	0x00005e6d
    5e24:	00005e6d 	.word	0x00005e6d
    5e28:	00005e6d 	.word	0x00005e6d
    5e2c:	00005e65 	.word	0x00005e65

	switch (fault) {
	case 3:
		reason = hard_fault(esf, recoverable);
    5e30:	6879      	ldr	r1, [r7, #4]
    5e32:	68f8      	ldr	r0, [r7, #12]
    5e34:	f7ff feac 	bl	5b90 <hard_fault>
    5e38:	6178      	str	r0, [r7, #20]
		break;
    5e3a:	e01c      	b.n	5e76 <fault_handle+0x92>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	/* HardFault is raised for all fault conditions on ARMv6-M. */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	case 4:
		reason = mem_manage_fault(esf, 0, recoverable);
    5e3c:	687a      	ldr	r2, [r7, #4]
    5e3e:	2100      	movs	r1, #0
    5e40:	68f8      	ldr	r0, [r7, #12]
    5e42:	f7ff f8a5 	bl	4f90 <mem_manage_fault>
    5e46:	6178      	str	r0, [r7, #20]
		break;
    5e48:	e015      	b.n	5e76 <fault_handle+0x92>
	case 5:
		reason = bus_fault(esf, 0, recoverable);
    5e4a:	687a      	ldr	r2, [r7, #4]
    5e4c:	2100      	movs	r1, #0
    5e4e:	68f8      	ldr	r0, [r7, #12]
    5e50:	f7ff fa82 	bl	5358 <bus_fault>
    5e54:	4603      	mov	r3, r0
    5e56:	617b      	str	r3, [r7, #20]
		break;
    5e58:	e00d      	b.n	5e76 <fault_handle+0x92>
	case 6:
		reason = usage_fault(esf);
    5e5a:	68f8      	ldr	r0, [r7, #12]
    5e5c:	f7ff fc78 	bl	5750 <usage_fault>
    5e60:	6178      	str	r0, [r7, #20]
		break;
    5e62:	e008      	b.n	5e76 <fault_handle+0x92>
	case 7:
		secure_fault(esf);
		break;
#endif /* CONFIG_ARM_SECURE_FIRMWARE */
	case 12:
		debug_monitor(esf);
    5e64:	68f8      	ldr	r0, [r7, #12]
    5e66:	f7ff fe59 	bl	5b1c <debug_monitor>
		break;
    5e6a:	e004      	b.n	5e76 <fault_handle+0x92>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	default:
		reserved_exception(esf, fault);
    5e6c:	68b9      	ldr	r1, [r7, #8]
    5e6e:	68f8      	ldr	r0, [r7, #12]
    5e70:	f7ff ff68 	bl	5d44 <reserved_exception>
		break;
    5e74:	bf00      	nop
	}

	if ((*recoverable) == false) {
    5e76:	687b      	ldr	r3, [r7, #4]
    5e78:	781b      	ldrb	r3, [r3, #0]
    5e7a:	f083 0301 	eor.w	r3, r3, #1
    5e7e:	b2db      	uxtb	r3, r3
    5e80:	2b00      	cmp	r3, #0
    5e82:	d003      	beq.n	5e8c <fault_handle+0xa8>
		/* Dump generic information about the fault. */
		fault_show(esf, fault);
    5e84:	68b9      	ldr	r1, [r7, #8]
    5e86:	68f8      	ldr	r0, [r7, #12]
    5e88:	f00c fffd 	bl	12e86 <fault_show>
	}

	return reason;
    5e8c:	697b      	ldr	r3, [r7, #20]
}
    5e8e:	4618      	mov	r0, r3
    5e90:	3718      	adds	r7, #24
    5e92:	46bd      	mov	sp, r7
    5e94:	bd80      	pop	{r7, pc}
    5e96:	bf00      	nop

00005e98 <get_esf>:
 *
 * @return ESF pointer on success, otherwise return NULL
 */
static inline z_arch_esf_t *get_esf(uint32_t msp, uint32_t psp, uint32_t exc_return,
	bool *nested_exc)
{
    5e98:	b580      	push	{r7, lr}
    5e9a:	b086      	sub	sp, #24
    5e9c:	af00      	add	r7, sp, #0
    5e9e:	60f8      	str	r0, [r7, #12]
    5ea0:	60b9      	str	r1, [r7, #8]
    5ea2:	607a      	str	r2, [r7, #4]
    5ea4:	603b      	str	r3, [r7, #0]
	bool alternative_state_exc = false;
    5ea6:	2300      	movs	r3, #0
    5ea8:	74fb      	strb	r3, [r7, #19]
	z_arch_esf_t *ptr_esf;

	*nested_exc = false;
    5eaa:	683b      	ldr	r3, [r7, #0]
    5eac:	2200      	movs	r2, #0
    5eae:	701a      	strb	r2, [r3, #0]

	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    5eb0:	687b      	ldr	r3, [r7, #4]
    5eb2:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    5eb6:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    5eba:	d001      	beq.n	5ec0 <get_esf+0x28>
			EXC_RETURN_INDICATOR_PREFIX) {
		/* Invalid EXC_RETURN value. This is a fatal error. */
		return NULL;
    5ebc:	2300      	movs	r3, #0
    5ebe:	e04d      	b.n	5f5c <get_esf+0xc4>
	}
#else
	/* The processor has a single execution state.
	 * We verify that the Thread mode is using PSP.
	 */
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    5ec0:	687b      	ldr	r3, [r7, #4]
    5ec2:	f003 0308 	and.w	r3, r3, #8
    5ec6:	2b00      	cmp	r3, #0
    5ec8:	d034      	beq.n	5f34 <get_esf+0x9c>
		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
    5eca:	687b      	ldr	r3, [r7, #4]
    5ecc:	f003 0304 	and.w	r3, r3, #4
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    5ed0:	2b00      	cmp	r3, #0
    5ed2:	d12f      	bne.n	5f34 <get_esf+0x9c>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    5ed4:	2303      	movs	r3, #3
    5ed6:	2b00      	cmp	r3, #0
    5ed8:	d02a      	beq.n	5f30 <get_esf+0x98>
    5eda:	f00c ffcd 	bl	12e78 <_is_user_context>
    5ede:	4603      	mov	r3, r0
    5ee0:	74bb      	strb	r3, [r7, #18]
    5ee2:	7c3b      	ldrb	r3, [r7, #16]
    5ee4:	2201      	movs	r2, #1
    5ee6:	f362 0302 	bfi	r3, r2, #0, #3
    5eea:	743b      	strb	r3, [r7, #16]
    5eec:	7c3b      	ldrb	r3, [r7, #16]
    5eee:	f36f 03c5 	bfc	r3, #3, #3
    5ef2:	743b      	strb	r3, [r7, #16]
    5ef4:	2303      	movs	r3, #3
    5ef6:	2b00      	cmp	r3, #0
    5ef8:	d009      	beq.n	5f0e <get_esf+0x76>
    5efa:	4b1a      	ldr	r3, [pc, #104]	; (5f64 <get_esf+0xcc>)
    5efc:	681b      	ldr	r3, [r3, #0]
    5efe:	4618      	mov	r0, r3
    5f00:	f7ff f836 	bl	4f70 <log_const_source_id>
    5f04:	4603      	mov	r3, r0
    5f06:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5f0a:	b29a      	uxth	r2, r3
    5f0c:	e000      	b.n	5f10 <get_esf+0x78>
    5f0e:	2200      	movs	r2, #0
    5f10:	8a3b      	ldrh	r3, [r7, #16]
    5f12:	f362 138f 	bfi	r3, r2, #6, #10
    5f16:	823b      	strh	r3, [r7, #16]
    5f18:	7cbb      	ldrb	r3, [r7, #18]
    5f1a:	2b00      	cmp	r3, #0
    5f1c:	d004      	beq.n	5f28 <get_esf+0x90>
    5f1e:	4912      	ldr	r1, [pc, #72]	; (5f68 <get_esf+0xd0>)
    5f20:	8a38      	ldrh	r0, [r7, #16]
    5f22:	f7fc fce5 	bl	28f0 <log_from_user>
    5f26:	e003      	b.n	5f30 <get_esf+0x98>
    5f28:	8a39      	ldrh	r1, [r7, #16]
    5f2a:	480f      	ldr	r0, [pc, #60]	; (5f68 <get_esf+0xd0>)
    5f2c:	f00b fb79 	bl	11622 <log_0>
		return NULL;
    5f30:	2300      	movs	r3, #0
    5f32:	e013      	b.n	5f5c <get_esf+0xc4>
	}
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	if (!alternative_state_exc) {
    5f34:	7cfb      	ldrb	r3, [r7, #19]
    5f36:	f083 0301 	eor.w	r3, r3, #1
    5f3a:	b2db      	uxtb	r3, r3
    5f3c:	2b00      	cmp	r3, #0
    5f3e:	d00c      	beq.n	5f5a <get_esf+0xc2>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    5f40:	687b      	ldr	r3, [r7, #4]
    5f42:	f003 0308 	and.w	r3, r3, #8
    5f46:	2b00      	cmp	r3, #0
    5f48:	d002      	beq.n	5f50 <get_esf+0xb8>
			/* Returning to thread mode */
			ptr_esf =  (z_arch_esf_t *)psp;
    5f4a:	68bb      	ldr	r3, [r7, #8]
    5f4c:	617b      	str	r3, [r7, #20]
    5f4e:	e004      	b.n	5f5a <get_esf+0xc2>

		} else {
			/* Returning to handler mode */
			ptr_esf = (z_arch_esf_t *)msp;
    5f50:	68fb      	ldr	r3, [r7, #12]
    5f52:	617b      	str	r3, [r7, #20]
			*nested_exc = true;
    5f54:	683b      	ldr	r3, [r7, #0]
    5f56:	2201      	movs	r2, #1
    5f58:	701a      	strb	r2, [r3, #0]
		}
	}

	return ptr_esf;
    5f5a:	697b      	ldr	r3, [r7, #20]
}
    5f5c:	4618      	mov	r0, r3
    5f5e:	3718      	adds	r7, #24
    5f60:	46bd      	mov	sp, r7
    5f62:	bd80      	pop	{r7, pc}
    5f64:	200000f4 	.word	0x200000f4
    5f68:	00019af4 	.word	0x00019af4

00005f6c <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    5f6c:	b580      	push	{r7, lr}
    5f6e:	b092      	sub	sp, #72	; 0x48
    5f70:	af00      	add	r7, sp, #0
    5f72:	60f8      	str	r0, [r7, #12]
    5f74:	60b9      	str	r1, [r7, #8]
    5f76:	607a      	str	r2, [r7, #4]
    5f78:	603b      	str	r3, [r7, #0]
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    5f7a:	2300      	movs	r3, #0
    5f7c:	647b      	str	r3, [r7, #68]	; 0x44
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    5f7e:	4b2d      	ldr	r3, [pc, #180]	; (6034 <z_arm_fault+0xc8>)
    5f80:	685b      	ldr	r3, [r3, #4]
    5f82:	f3c3 0308 	ubfx	r3, r3, #0, #9
    5f86:	643b      	str	r3, [r7, #64]	; 0x40
    5f88:	2300      	movs	r3, #0
    5f8a:	63bb      	str	r3, [r7, #56]	; 0x38
	__asm__ volatile(
    5f8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    5f8e:	f383 8811 	msr	BASEPRI, r3
    5f92:	f3bf 8f6f 	isb	sy
}
    5f96:	bf00      	nop
	arch_irq_unlock(0);

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
    5f98:	f107 0336 	add.w	r3, r7, #54	; 0x36
    5f9c:	687a      	ldr	r2, [r7, #4]
    5f9e:	68b9      	ldr	r1, [r7, #8]
    5fa0:	68f8      	ldr	r0, [r7, #12]
    5fa2:	f7ff ff79 	bl	5e98 <get_esf>
    5fa6:	63f8      	str	r0, [r7, #60]	; 0x3c
	__ASSERT(esf != NULL,
    5fa8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    5faa:	2b00      	cmp	r3, #0
    5fac:	d10e      	bne.n	5fcc <z_arm_fault+0x60>
    5fae:	f240 33bb 	movw	r3, #955	; 0x3bb
    5fb2:	4a21      	ldr	r2, [pc, #132]	; (6038 <z_arm_fault+0xcc>)
    5fb4:	4921      	ldr	r1, [pc, #132]	; (603c <z_arm_fault+0xd0>)
    5fb6:	4822      	ldr	r0, [pc, #136]	; (6040 <z_arm_fault+0xd4>)
    5fb8:	f00a f856 	bl	10068 <printk>
    5fbc:	4821      	ldr	r0, [pc, #132]	; (6044 <z_arm_fault+0xd8>)
    5fbe:	f00a f853 	bl	10068 <printk>
    5fc2:	f240 31bb 	movw	r1, #955	; 0x3bb
    5fc6:	481c      	ldr	r0, [pc, #112]	; (6038 <z_arm_fault+0xcc>)
    5fc8:	f00a fe96 	bl	10cf8 <assert_post_action>

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    5fcc:	f107 0337 	add.w	r3, r7, #55	; 0x37
    5fd0:	461a      	mov	r2, r3
    5fd2:	6c39      	ldr	r1, [r7, #64]	; 0x40
    5fd4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    5fd6:	f7ff ff05 	bl	5de4 <fault_handle>
    5fda:	6478      	str	r0, [r7, #68]	; 0x44
	if (recoverable) {
    5fdc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    5fe0:	2b00      	cmp	r3, #0
    5fe2:	d123      	bne.n	602c <z_arm_fault+0xc0>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    5fe4:	f107 0314 	add.w	r3, r7, #20
    5fe8:	2220      	movs	r2, #32
    5fea:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    5fec:	4618      	mov	r0, r3
    5fee:	f00d f89f 	bl	13130 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    5ff2:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    5ff6:	2b00      	cmp	r3, #0
    5ff8:	d00b      	beq.n	6012 <z_arm_fault+0xa6>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    5ffa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    5ffc:	f3c3 0308 	ubfx	r3, r3, #0, #9
    6000:	2b00      	cmp	r3, #0
    6002:	d10c      	bne.n	601e <z_arm_fault+0xb2>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    6004:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    6006:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    600a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    600e:	633b      	str	r3, [r7, #48]	; 0x30
    6010:	e005      	b.n	601e <z_arm_fault+0xb2>
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    6012:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    6014:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    6018:	f023 0301 	bic.w	r3, r3, #1
    601c:	633b      	str	r3, [r7, #48]	; 0x30
	}

	z_arm_fatal_error(reason, &esf_copy);
    601e:	f107 0314 	add.w	r3, r7, #20
    6022:	4619      	mov	r1, r3
    6024:	6c78      	ldr	r0, [r7, #68]	; 0x44
    6026:	f00c feef 	bl	12e08 <z_arm_fatal_error>
    602a:	e000      	b.n	602e <z_arm_fault+0xc2>
		return;
    602c:	bf00      	nop
}
    602e:	3748      	adds	r7, #72	; 0x48
    6030:	46bd      	mov	sp, r7
    6032:	bd80      	pop	{r7, pc}
    6034:	e000ed00 	.word	0xe000ed00
    6038:	000197e4 	.word	0x000197e4
    603c:	00019b20 	.word	0x00019b20
    6040:	00019824 	.word	0x00019824
    6044:	00019b34 	.word	0x00019b34

00006048 <z_arm_fault_init>:
 * Turns on the desired hardware faults.
 *
 * @return N/A
 */
void z_arm_fault_init(void)
{
    6048:	b480      	push	{r7}
    604a:	af00      	add	r7, sp, #0
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    604c:	4b07      	ldr	r3, [pc, #28]	; (606c <z_arm_fault_init+0x24>)
    604e:	695b      	ldr	r3, [r3, #20]
    6050:	4a06      	ldr	r2, [pc, #24]	; (606c <z_arm_fault_init+0x24>)
    6052:	f043 0310 	orr.w	r3, r3, #16
    6056:	6153      	str	r3, [r2, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
    6058:	4b04      	ldr	r3, [pc, #16]	; (606c <z_arm_fault_init+0x24>)
    605a:	695b      	ldr	r3, [r3, #20]
    605c:	4a03      	ldr	r2, [pc, #12]	; (606c <z_arm_fault_init+0x24>)
    605e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    6062:	6153      	str	r3, [r2, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    6064:	bf00      	nop
    6066:	46bd      	mov	sp, r7
    6068:	bc80      	pop	{r7}
    606a:	4770      	bx	lr
    606c:	e000ed00 	.word	0xe000ed00

00006070 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    6070:	4b04      	ldr	r3, [pc, #16]	; (6084 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    6072:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    6074:	6a98      	ldr	r0, [r3, #40]	; 0x28
	cmp r0, r1
    6076:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    6078:	d003      	beq.n	6082 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    607a:	4903      	ldr	r1, [pc, #12]	; (6088 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    607c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    6080:	600a      	str	r2, [r1, #0]

00006082 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    6082:	4770      	bx	lr
	ldr r3, =_kernel
    6084:	20000cd8 	.word	0x20000cd8
	ldr r1, =_SCS_ICSR
    6088:	e000ed04 	.word	0xe000ed04

0000608c <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
    608c:	b480      	push	{r7}
    608e:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
    6090:	f3bf 8f4f 	dsb	sy
}
    6094:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    6096:	4b06      	ldr	r3, [pc, #24]	; (60b0 <__NVIC_SystemReset+0x24>)
    6098:	68db      	ldr	r3, [r3, #12]
    609a:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    609e:	4904      	ldr	r1, [pc, #16]	; (60b0 <__NVIC_SystemReset+0x24>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    60a0:	4b04      	ldr	r3, [pc, #16]	; (60b4 <__NVIC_SystemReset+0x28>)
    60a2:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    60a4:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
    60a6:	f3bf 8f4f 	dsb	sy
}
    60aa:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    60ac:	bf00      	nop
    60ae:	e7fd      	b.n	60ac <__NVIC_SystemReset+0x20>
    60b0:	e000ed00 	.word	0xe000ed00
    60b4:	05fa0004 	.word	0x05fa0004

000060b8 <__NVIC_SetPriority>:
{
    60b8:	b480      	push	{r7}
    60ba:	b083      	sub	sp, #12
    60bc:	af00      	add	r7, sp, #0
    60be:	4603      	mov	r3, r0
    60c0:	6039      	str	r1, [r7, #0]
    60c2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    60c4:	f997 3007 	ldrsb.w	r3, [r7, #7]
    60c8:	2b00      	cmp	r3, #0
    60ca:	db0a      	blt.n	60e2 <__NVIC_SetPriority+0x2a>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    60cc:	683b      	ldr	r3, [r7, #0]
    60ce:	b2da      	uxtb	r2, r3
    60d0:	490c      	ldr	r1, [pc, #48]	; (6104 <__NVIC_SetPriority+0x4c>)
    60d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
    60d6:	0152      	lsls	r2, r2, #5
    60d8:	b2d2      	uxtb	r2, r2
    60da:	440b      	add	r3, r1
    60dc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    60e0:	e00a      	b.n	60f8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    60e2:	683b      	ldr	r3, [r7, #0]
    60e4:	b2da      	uxtb	r2, r3
    60e6:	4908      	ldr	r1, [pc, #32]	; (6108 <__NVIC_SetPriority+0x50>)
    60e8:	79fb      	ldrb	r3, [r7, #7]
    60ea:	f003 030f 	and.w	r3, r3, #15
    60ee:	3b04      	subs	r3, #4
    60f0:	0152      	lsls	r2, r2, #5
    60f2:	b2d2      	uxtb	r2, r2
    60f4:	440b      	add	r3, r1
    60f6:	761a      	strb	r2, [r3, #24]
}
    60f8:	bf00      	nop
    60fa:	370c      	adds	r7, #12
    60fc:	46bd      	mov	sp, r7
    60fe:	bc80      	pop	{r7}
    6100:	4770      	bx	lr
    6102:	bf00      	nop
    6104:	e000e100 	.word	0xe000e100
    6108:	e000ed00 	.word	0xe000ed00

0000610c <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    610c:	b580      	push	{r7, lr}
    610e:	b084      	sub	sp, #16
    6110:	af00      	add	r7, sp, #0
    6112:	6078      	str	r0, [r7, #4]
	if (_current == thread) {
    6114:	4b10      	ldr	r3, [pc, #64]	; (6158 <z_impl_k_thread_abort+0x4c>)
    6116:	689b      	ldr	r3, [r3, #8]
    6118:	687a      	ldr	r2, [r7, #4]
    611a:	429a      	cmp	r2, r3
    611c:	d113      	bne.n	6146 <z_impl_k_thread_abort+0x3a>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    611e:	f3ef 8305 	mrs	r3, IPSR
    6122:	60fb      	str	r3, [r7, #12]
  return(result);
    6124:	68fb      	ldr	r3, [r7, #12]
 * The current executing vector is found in the IPSR register. All
 * IRQs and system exceptions are considered as interrupt context.
 */
static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return (__get_IPSR()) ? (true) : (false);
    6126:	2b00      	cmp	r3, #0
    6128:	bf14      	ite	ne
    612a:	2301      	movne	r3, #1
    612c:	2300      	moveq	r3, #0
    612e:	b2db      	uxtb	r3, r3
		if (arch_is_in_isr()) {
    6130:	2b00      	cmp	r3, #0
    6132:	d006      	beq.n	6142 <z_impl_k_thread_abort+0x36>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    6134:	4b09      	ldr	r3, [pc, #36]	; (615c <z_impl_k_thread_abort+0x50>)
    6136:	685b      	ldr	r3, [r3, #4]
    6138:	4a08      	ldr	r2, [pc, #32]	; (615c <z_impl_k_thread_abort+0x50>)
    613a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    613e:	6053      	str	r3, [r2, #4]
    6140:	e001      	b.n	6146 <z_impl_k_thread_abort+0x3a>
		} else {
			z_self_abort(); /* Never returns */
    6142:	f008 fce5 	bl	eb10 <z_self_abort>
		}
	}

	z_thread_single_abort(thread);
    6146:	6878      	ldr	r0, [r7, #4]
    6148:	f006 fe98 	bl	ce7c <z_thread_single_abort>

	/* The abort handler might have altered the ready queue. */
	z_reschedule_unlocked();
    614c:	f00c fecc 	bl	12ee8 <z_reschedule_unlocked>
}
    6150:	bf00      	nop
    6152:	3710      	adds	r7, #16
    6154:	46bd      	mov	sp, r7
    6156:	bd80      	pop	{r7, pc}
    6158:	20000cd8 	.word	0x20000cd8
    615c:	e000ed00 	.word	0xe000ed00

00006160 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    6160:	b580      	push	{r7, lr}
    6162:	b088      	sub	sp, #32
    6164:	af00      	add	r7, sp, #0
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
		{
		.start = (uint32_t)&_ramfunc_ram_start,
    6166:	4b13      	ldr	r3, [pc, #76]	; (61b4 <z_arm_configure_static_mpu_regions+0x54>)
		const struct k_mem_partition ramfunc_region =
    6168:	617b      	str	r3, [r7, #20]
		.size = (uint32_t)&_ramfunc_ram_size,
    616a:	4b13      	ldr	r3, [pc, #76]	; (61b8 <z_arm_configure_static_mpu_regions+0x58>)
		const struct k_mem_partition ramfunc_region =
    616c:	61bb      	str	r3, [r7, #24]
    616e:	2306      	movs	r3, #6
    6170:	83bb      	strh	r3, [r7, #28]
    6172:	2301      	movs	r3, #1
    6174:	83fb      	strh	r3, [r7, #30]
#endif /* !CONFIG_MULTITHREADING && CONFIG_MPU_STACK_GUARD */
	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    6176:	f107 0314 	add.w	r3, r7, #20
    617a:	60fb      	str	r3, [r7, #12]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    617c:	4a0f      	ldr	r2, [pc, #60]	; (61bc <z_arm_configure_static_mpu_regions+0x5c>)
    617e:	4b10      	ldr	r3, [pc, #64]	; (61c0 <z_arm_configure_static_mpu_regions+0x60>)
    6180:	f107 000c 	add.w	r0, r7, #12
    6184:	2101      	movs	r1, #1
    6186:	f000 fcbb 	bl	6b00 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
    618a:	463b      	mov	r3, r7
    618c:	2200      	movs	r2, #0
    618e:	601a      	str	r2, [r3, #0]
    6190:	605a      	str	r2, [r3, #4]
    6192:	609a      	str	r2, [r3, #8]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    6194:	4b0b      	ldr	r3, [pc, #44]	; (61c4 <z_arm_configure_static_mpu_regions+0x64>)
	const struct k_mem_partition dyn_region_areas[] = {
    6196:	603b      	str	r3, [r7, #0]
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    6198:	4a09      	ldr	r2, [pc, #36]	; (61c0 <z_arm_configure_static_mpu_regions+0x60>)
    619a:	4b0a      	ldr	r3, [pc, #40]	; (61c4 <z_arm_configure_static_mpu_regions+0x64>)
    619c:	1ad3      	subs	r3, r2, r3
	const struct k_mem_partition dyn_region_areas[] = {
    619e:	607b      	str	r3, [r7, #4]
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    61a0:	463b      	mov	r3, r7
    61a2:	2101      	movs	r1, #1
    61a4:	4618      	mov	r0, r3
    61a6:	f000 fcdb 	bl	6b60 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    61aa:	bf00      	nop
    61ac:	3720      	adds	r7, #32
    61ae:	46bd      	mov	sp, r7
    61b0:	bd80      	pop	{r7, pc}
    61b2:	bf00      	nop
    61b4:	20000000 	.word	0x20000000
    61b8:	00000000 	.word	0x00000000
    61bc:	20000000 	.word	0x20000000
    61c0:	20010000 	.word	0x20010000
    61c4:	200002c0 	.word	0x200002c0

000061c8 <ARM_MPU_SetRegion>:
* \param rnr Region number to be configured.
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
    61c8:	b580      	push	{r7, lr}
    61ca:	b084      	sub	sp, #16
    61cc:	af00      	add	r7, sp, #0
    61ce:	60f8      	str	r0, [r7, #12]
    61d0:	60b9      	str	r1, [r7, #8]
    61d2:	607a      	str	r2, [r7, #4]
  ARM_MPU_SetRegionEx(MPU, rnr, rbar, rlar);
    61d4:	687b      	ldr	r3, [r7, #4]
    61d6:	68ba      	ldr	r2, [r7, #8]
    61d8:	68f9      	ldr	r1, [r7, #12]
    61da:	4803      	ldr	r0, [pc, #12]	; (61e8 <ARM_MPU_SetRegion+0x20>)
    61dc:	f00c fea0 	bl	12f20 <ARM_MPU_SetRegionEx>
}
    61e0:	bf00      	nop
    61e2:	3710      	adds	r7, #16
    61e4:	46bd      	mov	sp, r7
    61e6:	bd80      	pop	{r7, pc}
    61e8:	e000ed90 	.word	0xe000ed90

000061ec <log_const_source_id>:
{
    61ec:	b480      	push	{r7}
    61ee:	b083      	sub	sp, #12
    61f0:	af00      	add	r7, sp, #0
    61f2:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    61f4:	687b      	ldr	r3, [r7, #4]
    61f6:	4a04      	ldr	r2, [pc, #16]	; (6208 <log_const_source_id+0x1c>)
    61f8:	1a9b      	subs	r3, r3, r2
    61fa:	08db      	lsrs	r3, r3, #3
}
    61fc:	4618      	mov	r0, r3
    61fe:	370c      	adds	r7, #12
    6200:	46bd      	mov	sp, r7
    6202:	bc80      	pop	{r7}
    6204:	4770      	bx	lr
    6206:	bf00      	nop
    6208:	00018788 	.word	0x00018788

0000620c <mpu_init>:
static struct dynamic_region_info dyn_reg_info[MPU_DYNAMIC_REGION_AREAS_NUM];


/* Global MPU configuration at system initialization. */
static void mpu_init(void)
{
    620c:	b480      	push	{r7}
    620e:	af00      	add	r7, sp, #0

	/* Flash region(s): Attribute-0
	 * SRAM region(s): Attribute-1
	 * SRAM no cache-able regions(s): Attribute-2
	 */
	MPU->MAIR0 =
    6210:	4b03      	ldr	r3, [pc, #12]	; (6220 <mpu_init+0x14>)
    6212:	4a04      	ldr	r2, [pc, #16]	; (6224 <mpu_init+0x18>)
    6214:	631a      	str	r2, [r3, #48]	; 0x30
		((MPU_MAIR_ATTR_SRAM << MPU_MAIR0_Attr1_Pos) &
			MPU_MAIR0_Attr1_Msk)
		|
		((MPU_MAIR_ATTR_SRAM_NOCACHE << MPU_MAIR0_Attr2_Pos) &
			MPU_MAIR0_Attr2_Msk);
}
    6216:	bf00      	nop
    6218:	46bd      	mov	sp, r7
    621a:	bc80      	pop	{r7}
    621c:	4770      	bx	lr
    621e:	bf00      	nop
    6220:	e000ed90 	.word	0xe000ed90
    6224:	0044ffaa 	.word	0x0044ffaa

00006228 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
    6228:	b580      	push	{r7, lr}
    622a:	b092      	sub	sp, #72	; 0x48
    622c:	af04      	add	r7, sp, #16
    622e:	6078      	str	r0, [r7, #4]
    6230:	6039      	str	r1, [r7, #0]
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    6232:	683b      	ldr	r3, [r7, #0]
    6234:	681b      	ldr	r3, [r3, #0]
    6236:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
    623a:	683a      	ldr	r2, [r7, #0]
    623c:	7a12      	ldrb	r2, [r2, #8]
    623e:	f3c2 0204 	ubfx	r2, r2, #0, #5
    6242:	b2d2      	uxtb	r2, r2
    6244:	ea43 0102 	orr.w	r1, r3, r2
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    6248:	683b      	ldr	r3, [r7, #0]
    624a:	68db      	ldr	r3, [r3, #12]
    624c:	f023 021f 	bic.w	r2, r3, #31
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    6250:	683b      	ldr	r3, [r7, #0]
    6252:	7a1b      	ldrb	r3, [r3, #8]
    6254:	f3c3 1342 	ubfx	r3, r3, #5, #3
    6258:	b2db      	uxtb	r3, r3
    625a:	005b      	lsls	r3, r3, #1
			& MPU_RLAR_AttrIndx_Msk)
    625c:	f003 030e 	and.w	r3, r3, #14
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    6260:	4313      	orrs	r3, r2
		| MPU_RLAR_EN_Msk
    6262:	f043 0301 	orr.w	r3, r3, #1
	ARM_MPU_SetRegion(
    6266:	461a      	mov	r2, r3
    6268:	6878      	ldr	r0, [r7, #4]
    626a:	f7ff ffad 	bl	61c8 <ARM_MPU_SetRegion>
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
    626e:	2303      	movs	r3, #3
    6270:	2b03      	cmp	r3, #3
    6272:	d95f      	bls.n	6334 <region_init+0x10c>
    6274:	f00c fe4d 	bl	12f12 <_is_user_context>
    6278:	4603      	mov	r3, r0
    627a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    627e:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    6282:	2204      	movs	r2, #4
    6284:	f362 0302 	bfi	r3, r2, #0, #3
    6288:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    628c:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    6290:	f36f 03c5 	bfc	r3, #3, #3
    6294:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    6298:	2303      	movs	r3, #3
    629a:	2b00      	cmp	r3, #0
    629c:	d009      	beq.n	62b2 <region_init+0x8a>
    629e:	4b27      	ldr	r3, [pc, #156]	; (633c <region_init+0x114>)
    62a0:	681b      	ldr	r3, [r3, #0]
    62a2:	4618      	mov	r0, r3
    62a4:	f7ff ffa2 	bl	61ec <log_const_source_id>
    62a8:	4603      	mov	r3, r0
    62aa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    62ae:	b29a      	uxth	r2, r3
    62b0:	e000      	b.n	62b4 <region_init+0x8c>
    62b2:	2200      	movs	r2, #0
    62b4:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    62b6:	f362 138f 	bfi	r3, r2, #6, #10
    62ba:	86bb      	strh	r3, [r7, #52]	; 0x34
    62bc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    62c0:	2b00      	cmp	r3, #0
    62c2:	d01a      	beq.n	62fa <region_init+0xd2>
    62c4:	683b      	ldr	r3, [r7, #0]
    62c6:	681b      	ldr	r3, [r3, #0]
    62c8:	683a      	ldr	r2, [r7, #0]
    62ca:	7a12      	ldrb	r2, [r2, #8]
    62cc:	f3c2 0204 	ubfx	r2, r2, #0, #5
    62d0:	b2d2      	uxtb	r2, r2
    62d2:	4611      	mov	r1, r2
    62d4:	683a      	ldr	r2, [r7, #0]
    62d6:	7a12      	ldrb	r2, [r2, #8]
    62d8:	f3c2 1242 	ubfx	r2, r2, #5, #3
    62dc:	b2d2      	uxtb	r2, r2
    62de:	4610      	mov	r0, r2
    62e0:	683a      	ldr	r2, [r7, #0]
    62e2:	68d2      	ldr	r2, [r2, #12]
    62e4:	9203      	str	r2, [sp, #12]
    62e6:	9002      	str	r0, [sp, #8]
    62e8:	9101      	str	r1, [sp, #4]
    62ea:	9300      	str	r3, [sp, #0]
    62ec:	687b      	ldr	r3, [r7, #4]
    62ee:	4a14      	ldr	r2, [pc, #80]	; (6340 <region_init+0x118>)
    62f0:	4914      	ldr	r1, [pc, #80]	; (6344 <region_init+0x11c>)
    62f2:	8eb8      	ldrh	r0, [r7, #52]	; 0x34
    62f4:	f7fc fafc 	bl	28f0 <log_from_user>
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    62f8:	e01c      	b.n	6334 <region_init+0x10c>
	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
    62fa:	4b11      	ldr	r3, [pc, #68]	; (6340 <region_init+0x118>)
    62fc:	61fb      	str	r3, [r7, #28]
    62fe:	687b      	ldr	r3, [r7, #4]
    6300:	623b      	str	r3, [r7, #32]
    6302:	683b      	ldr	r3, [r7, #0]
    6304:	681b      	ldr	r3, [r3, #0]
    6306:	627b      	str	r3, [r7, #36]	; 0x24
    6308:	683b      	ldr	r3, [r7, #0]
    630a:	7a1b      	ldrb	r3, [r3, #8]
    630c:	f3c3 0304 	ubfx	r3, r3, #0, #5
    6310:	b2db      	uxtb	r3, r3
    6312:	62bb      	str	r3, [r7, #40]	; 0x28
    6314:	683b      	ldr	r3, [r7, #0]
    6316:	7a1b      	ldrb	r3, [r3, #8]
    6318:	f3c3 1342 	ubfx	r3, r3, #5, #3
    631c:	b2db      	uxtb	r3, r3
    631e:	62fb      	str	r3, [r7, #44]	; 0x2c
    6320:	683b      	ldr	r3, [r7, #0]
    6322:	68db      	ldr	r3, [r3, #12]
    6324:	633b      	str	r3, [r7, #48]	; 0x30
    6326:	f107 011c 	add.w	r1, r7, #28
    632a:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    632c:	2206      	movs	r2, #6
    632e:	4805      	ldr	r0, [pc, #20]	; (6344 <region_init+0x11c>)
    6330:	f00b f9d6 	bl	116e0 <log_n>
}
    6334:	bf00      	nop
    6336:	3738      	adds	r7, #56	; 0x38
    6338:	46bd      	mov	sp, r7
    633a:	bd80      	pop	{r7, pc}
    633c:	200000f8 	.word	0x200000f8
    6340:	0001cb48 	.word	0x0001cb48
    6344:	00019b78 	.word	0x00019b78

00006348 <mpu_region_get_base>:
	}
	return -EINVAL;
}

static inline uint32_t mpu_region_get_base(const uint32_t index)
{
    6348:	b480      	push	{r7}
    634a:	b083      	sub	sp, #12
    634c:	af00      	add	r7, sp, #0
    634e:	6078      	str	r0, [r7, #4]
	MPU->RNR = index;
    6350:	4a05      	ldr	r2, [pc, #20]	; (6368 <mpu_region_get_base+0x20>)
    6352:	687b      	ldr	r3, [r7, #4]
    6354:	6093      	str	r3, [r2, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    6356:	4b04      	ldr	r3, [pc, #16]	; (6368 <mpu_region_get_base+0x20>)
    6358:	68db      	ldr	r3, [r3, #12]
    635a:	f023 031f 	bic.w	r3, r3, #31
}
    635e:	4618      	mov	r0, r3
    6360:	370c      	adds	r7, #12
    6362:	46bd      	mov	sp, r7
    6364:	bc80      	pop	{r7}
    6366:	4770      	bx	lr
    6368:	e000ed90 	.word	0xe000ed90

0000636c <mpu_region_set_base>:

static inline void mpu_region_set_base(const uint32_t index, const uint32_t base)
{
    636c:	b480      	push	{r7}
    636e:	b083      	sub	sp, #12
    6370:	af00      	add	r7, sp, #0
    6372:	6078      	str	r0, [r7, #4]
    6374:	6039      	str	r1, [r7, #0]
	MPU->RNR = index;
    6376:	4a09      	ldr	r2, [pc, #36]	; (639c <mpu_region_set_base+0x30>)
    6378:	687b      	ldr	r3, [r7, #4]
    637a:	6093      	str	r3, [r2, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    637c:	4b07      	ldr	r3, [pc, #28]	; (639c <mpu_region_set_base+0x30>)
    637e:	68db      	ldr	r3, [r3, #12]
    6380:	f003 021f 	and.w	r2, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    6384:	683b      	ldr	r3, [r7, #0]
    6386:	f023 031f 	bic.w	r3, r3, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    638a:	4904      	ldr	r1, [pc, #16]	; (639c <mpu_region_set_base+0x30>)
		| (base & MPU_RBAR_BASE_Msk);
    638c:	4313      	orrs	r3, r2
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    638e:	60cb      	str	r3, [r1, #12]
}
    6390:	bf00      	nop
    6392:	370c      	adds	r7, #12
    6394:	46bd      	mov	sp, r7
    6396:	bc80      	pop	{r7}
    6398:	4770      	bx	lr
    639a:	bf00      	nop
    639c:	e000ed90 	.word	0xe000ed90

000063a0 <mpu_region_get_last_addr>:

static inline uint32_t mpu_region_get_last_addr(const uint32_t index)
{
    63a0:	b480      	push	{r7}
    63a2:	b083      	sub	sp, #12
    63a4:	af00      	add	r7, sp, #0
    63a6:	6078      	str	r0, [r7, #4]
	MPU->RNR = index;
    63a8:	4a05      	ldr	r2, [pc, #20]	; (63c0 <mpu_region_get_last_addr+0x20>)
    63aa:	687b      	ldr	r3, [r7, #4]
    63ac:	6093      	str	r3, [r2, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    63ae:	4b04      	ldr	r3, [pc, #16]	; (63c0 <mpu_region_get_last_addr+0x20>)
    63b0:	691b      	ldr	r3, [r3, #16]
    63b2:	f043 031f 	orr.w	r3, r3, #31
}
    63b6:	4618      	mov	r0, r3
    63b8:	370c      	adds	r7, #12
    63ba:	46bd      	mov	sp, r7
    63bc:	bc80      	pop	{r7}
    63be:	4770      	bx	lr
    63c0:	e000ed90 	.word	0xe000ed90

000063c4 <mpu_region_set_limit>:

static inline void mpu_region_set_limit(const uint32_t index, const uint32_t limit)
{
    63c4:	b480      	push	{r7}
    63c6:	b083      	sub	sp, #12
    63c8:	af00      	add	r7, sp, #0
    63ca:	6078      	str	r0, [r7, #4]
    63cc:	6039      	str	r1, [r7, #0]
	MPU->RNR = index;
    63ce:	4a09      	ldr	r2, [pc, #36]	; (63f4 <mpu_region_set_limit+0x30>)
    63d0:	687b      	ldr	r3, [r7, #4]
    63d2:	6093      	str	r3, [r2, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    63d4:	4b07      	ldr	r3, [pc, #28]	; (63f4 <mpu_region_set_limit+0x30>)
    63d6:	691b      	ldr	r3, [r3, #16]
    63d8:	f003 021f 	and.w	r2, r3, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    63dc:	683b      	ldr	r3, [r7, #0]
    63de:	f023 031f 	bic.w	r3, r3, #31
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    63e2:	4904      	ldr	r1, [pc, #16]	; (63f4 <mpu_region_set_limit+0x30>)
		| (limit & MPU_RLAR_LIMIT_Msk);
    63e4:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    63e6:	610b      	str	r3, [r1, #16]
}
    63e8:	bf00      	nop
    63ea:	370c      	adds	r7, #12
    63ec:	46bd      	mov	sp, r7
    63ee:	bc80      	pop	{r7}
    63f0:	4770      	bx	lr
    63f2:	bf00      	nop
    63f4:	e000ed90 	.word	0xe000ed90

000063f8 <mpu_region_get_access_attr>:

static inline void mpu_region_get_access_attr(const uint32_t index,
	arm_mpu_region_attr_t *attr)
{
    63f8:	b480      	push	{r7}
    63fa:	b083      	sub	sp, #12
    63fc:	af00      	add	r7, sp, #0
    63fe:	6078      	str	r0, [r7, #4]
    6400:	6039      	str	r1, [r7, #0]
	MPU->RNR = index;
    6402:	4a0e      	ldr	r2, [pc, #56]	; (643c <mpu_region_get_access_attr+0x44>)
    6404:	687b      	ldr	r3, [r7, #4]
    6406:	6093      	str	r3, [r2, #8]

	attr->rbar = MPU->RBAR &
    6408:	4b0c      	ldr	r3, [pc, #48]	; (643c <mpu_region_get_access_attr+0x44>)
    640a:	68db      	ldr	r3, [r3, #12]
    640c:	f003 031f 	and.w	r3, r3, #31
    6410:	b2d9      	uxtb	r1, r3
    6412:	683a      	ldr	r2, [r7, #0]
    6414:	7813      	ldrb	r3, [r2, #0]
    6416:	f361 0304 	bfi	r3, r1, #0, #5
    641a:	7013      	strb	r3, [r2, #0]
		(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk);
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    641c:	4b07      	ldr	r3, [pc, #28]	; (643c <mpu_region_get_access_attr+0x44>)
    641e:	691b      	ldr	r3, [r3, #16]
    6420:	085b      	lsrs	r3, r3, #1
    6422:	f003 0307 	and.w	r3, r3, #7
    6426:	b2d9      	uxtb	r1, r3
    6428:	683a      	ldr	r2, [r7, #0]
    642a:	7813      	ldrb	r3, [r2, #0]
    642c:	f361 1347 	bfi	r3, r1, #5, #3
    6430:	7013      	strb	r3, [r2, #0]
		MPU_RLAR_AttrIndx_Pos;
}
    6432:	bf00      	nop
    6434:	370c      	adds	r7, #12
    6436:	46bd      	mov	sp, r7
    6438:	bc80      	pop	{r7}
    643a:	4770      	bx	lr
    643c:	e000ed90 	.word	0xe000ed90

00006440 <mpu_region_get_conf>:

static inline void mpu_region_get_conf(const uint32_t index,
	struct arm_mpu_region *region_conf)
{
    6440:	b580      	push	{r7, lr}
    6442:	b082      	sub	sp, #8
    6444:	af00      	add	r7, sp, #0
    6446:	6078      	str	r0, [r7, #4]
    6448:	6039      	str	r1, [r7, #0]
	MPU->RNR = index;
    644a:	4a0c      	ldr	r2, [pc, #48]	; (647c <mpu_region_get_conf+0x3c>)
    644c:	687b      	ldr	r3, [r7, #4]
    644e:	6093      	str	r3, [r2, #8]
	/* Region attribution:
	 * - Cache-ability
	 * - Share-ability
	 * - Access Permissions
	 */
	mpu_region_get_access_attr(index, &region_conf->attr);
    6450:	683b      	ldr	r3, [r7, #0]
    6452:	3308      	adds	r3, #8
    6454:	4619      	mov	r1, r3
    6456:	6878      	ldr	r0, [r7, #4]
    6458:	f7ff ffce 	bl	63f8 <mpu_region_get_access_attr>

	/* Region base address */
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    645c:	4b07      	ldr	r3, [pc, #28]	; (647c <mpu_region_get_conf+0x3c>)
    645e:	68db      	ldr	r3, [r3, #12]
    6460:	f023 021f 	bic.w	r2, r3, #31
    6464:	683b      	ldr	r3, [r7, #0]
    6466:	601a      	str	r2, [r3, #0]

	/* Region limit address */
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    6468:	4b04      	ldr	r3, [pc, #16]	; (647c <mpu_region_get_conf+0x3c>)
    646a:	691b      	ldr	r3, [r3, #16]
    646c:	f023 021f 	bic.w	r2, r3, #31
    6470:	683b      	ldr	r3, [r7, #0]
    6472:	60da      	str	r2, [r3, #12]
}
    6474:	bf00      	nop
    6476:	3708      	adds	r7, #8
    6478:	46bd      	mov	sp, r7
    647a:	bd80      	pop	{r7, pc}
    647c:	e000ed90 	.word	0xe000ed90

00006480 <mpu_configure_regions_and_partition>:
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
	*regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    6480:	b580      	push	{r7, lr}
    6482:	b090      	sub	sp, #64	; 0x40
    6484:	af00      	add	r7, sp, #0
    6486:	6078      	str	r0, [r7, #4]
    6488:	4608      	mov	r0, r1
    648a:	4611      	mov	r1, r2
    648c:	461a      	mov	r2, r3
    648e:	4603      	mov	r3, r0
    6490:	70fb      	strb	r3, [r7, #3]
    6492:	460b      	mov	r3, r1
    6494:	70bb      	strb	r3, [r7, #2]
    6496:	4613      	mov	r3, r2
    6498:	707b      	strb	r3, [r7, #1]
	int i;
	int reg_index = start_reg_index;
    649a:	78bb      	ldrb	r3, [r7, #2]
    649c:	63fb      	str	r3, [r7, #60]	; 0x3c

	for (i = 0; i < regions_num; i++) {
    649e:	2300      	movs	r3, #0
    64a0:	63bb      	str	r3, [r7, #56]	; 0x38
    64a2:	e18d      	b.n	67c0 <mpu_configure_regions_and_partition+0x340>
		if (regions[i]->size == 0U) {
    64a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    64a6:	009b      	lsls	r3, r3, #2
    64a8:	687a      	ldr	r2, [r7, #4]
    64aa:	4413      	add	r3, r2
    64ac:	681b      	ldr	r3, [r3, #0]
    64ae:	685b      	ldr	r3, [r3, #4]
    64b0:	2b00      	cmp	r3, #0
    64b2:	f000 8181 	beq.w	67b8 <mpu_configure_regions_and_partition+0x338>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    64b6:	787b      	ldrb	r3, [r7, #1]
    64b8:	2b00      	cmp	r3, #0
    64ba:	d044      	beq.n	6546 <mpu_configure_regions_and_partition+0xc6>
			(!mpu_partition_is_valid(regions[i]))) {
    64bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    64be:	009b      	lsls	r3, r3, #2
    64c0:	687a      	ldr	r2, [r7, #4]
    64c2:	4413      	add	r3, r2
    64c4:	681b      	ldr	r3, [r3, #0]
    64c6:	4618      	mov	r0, r3
    64c8:	f00c fd46 	bl	12f58 <mpu_partition_is_valid>
    64cc:	4603      	mov	r3, r0
		if (do_sanity_check &&
    64ce:	2b00      	cmp	r3, #0
    64d0:	d139      	bne.n	6546 <mpu_configure_regions_and_partition+0xc6>
			LOG_ERR("Partition %u: sanity check failed.", i);
    64d2:	2303      	movs	r3, #3
    64d4:	2b00      	cmp	r3, #0
    64d6:	d033      	beq.n	6540 <mpu_configure_regions_and_partition+0xc0>
    64d8:	f00c fd1b 	bl	12f12 <_is_user_context>
    64dc:	4603      	mov	r3, r0
    64de:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    64e2:	f897 3020 	ldrb.w	r3, [r7, #32]
    64e6:	2201      	movs	r2, #1
    64e8:	f362 0302 	bfi	r3, r2, #0, #3
    64ec:	f887 3020 	strb.w	r3, [r7, #32]
    64f0:	f897 3020 	ldrb.w	r3, [r7, #32]
    64f4:	f36f 03c5 	bfc	r3, #3, #3
    64f8:	f887 3020 	strb.w	r3, [r7, #32]
    64fc:	2303      	movs	r3, #3
    64fe:	2b00      	cmp	r3, #0
    6500:	d009      	beq.n	6516 <mpu_configure_regions_and_partition+0x96>
    6502:	4ba8      	ldr	r3, [pc, #672]	; (67a4 <mpu_configure_regions_and_partition+0x324>)
    6504:	681b      	ldr	r3, [r3, #0]
    6506:	4618      	mov	r0, r3
    6508:	f7ff fe70 	bl	61ec <log_const_source_id>
    650c:	4603      	mov	r3, r0
    650e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    6512:	b29a      	uxth	r2, r3
    6514:	e000      	b.n	6518 <mpu_configure_regions_and_partition+0x98>
    6516:	2200      	movs	r2, #0
    6518:	8c3b      	ldrh	r3, [r7, #32]
    651a:	f362 138f 	bfi	r3, r2, #6, #10
    651e:	843b      	strh	r3, [r7, #32]
    6520:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    6524:	2b00      	cmp	r3, #0
    6526:	d005      	beq.n	6534 <mpu_configure_regions_and_partition+0xb4>
    6528:	6bba      	ldr	r2, [r7, #56]	; 0x38
    652a:	499f      	ldr	r1, [pc, #636]	; (67a8 <mpu_configure_regions_and_partition+0x328>)
    652c:	8c38      	ldrh	r0, [r7, #32]
    652e:	f7fc f9df 	bl	28f0 <log_from_user>
    6532:	e005      	b.n	6540 <mpu_configure_regions_and_partition+0xc0>
    6534:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6536:	8c3a      	ldrh	r2, [r7, #32]
    6538:	4619      	mov	r1, r3
    653a:	489b      	ldr	r0, [pc, #620]	; (67a8 <mpu_configure_regions_and_partition+0x328>)
    653c:	f00b f886 	bl	1164c <log_1>
			return -EINVAL;
    6540:	f06f 0315 	mvn.w	r3, #21
    6544:	e142      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>

		/* Derive the index of the underlying MPU region,
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);
    6546:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6548:	009b      	lsls	r3, r3, #2
    654a:	687a      	ldr	r2, [r7, #4]
    654c:	4413      	add	r3, r2
    654e:	681b      	ldr	r3, [r3, #0]
    6550:	6818      	ldr	r0, [r3, #0]
    6552:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6554:	009b      	lsls	r3, r3, #2
    6556:	687a      	ldr	r2, [r7, #4]
    6558:	4413      	add	r3, r2
    655a:	681b      	ldr	r3, [r3, #0]
    655c:	685b      	ldr	r3, [r3, #4]
    655e:	4619      	mov	r1, r3
    6560:	f00c fd1a 	bl	12f98 <get_region_index>
    6564:	6338      	str	r0, [r7, #48]	; 0x30

		if ((u_reg_index == -EINVAL) ||
    6566:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    6568:	f113 0f16 	cmn.w	r3, #22
    656c:	d004      	beq.n	6578 <mpu_configure_regions_and_partition+0xf8>
			(u_reg_index > (reg_index - 1))) {
    656e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6570:	3b01      	subs	r3, #1
		if ((u_reg_index == -EINVAL) ||
    6572:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    6574:	429a      	cmp	r2, r3
    6576:	dd35      	ble.n	65e4 <mpu_configure_regions_and_partition+0x164>
			LOG_ERR("Invalid underlying region index %u",
    6578:	2303      	movs	r3, #3
    657a:	2b00      	cmp	r3, #0
    657c:	d02f      	beq.n	65de <mpu_configure_regions_and_partition+0x15e>
    657e:	f00c fcc8 	bl	12f12 <_is_user_context>
    6582:	4603      	mov	r3, r0
    6584:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    6588:	7f3b      	ldrb	r3, [r7, #28]
    658a:	2201      	movs	r2, #1
    658c:	f362 0302 	bfi	r3, r2, #0, #3
    6590:	773b      	strb	r3, [r7, #28]
    6592:	7f3b      	ldrb	r3, [r7, #28]
    6594:	f36f 03c5 	bfc	r3, #3, #3
    6598:	773b      	strb	r3, [r7, #28]
    659a:	2303      	movs	r3, #3
    659c:	2b00      	cmp	r3, #0
    659e:	d009      	beq.n	65b4 <mpu_configure_regions_and_partition+0x134>
    65a0:	4b80      	ldr	r3, [pc, #512]	; (67a4 <mpu_configure_regions_and_partition+0x324>)
    65a2:	681b      	ldr	r3, [r3, #0]
    65a4:	4618      	mov	r0, r3
    65a6:	f7ff fe21 	bl	61ec <log_const_source_id>
    65aa:	4603      	mov	r3, r0
    65ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    65b0:	b29a      	uxth	r2, r3
    65b2:	e000      	b.n	65b6 <mpu_configure_regions_and_partition+0x136>
    65b4:	2200      	movs	r2, #0
    65b6:	8bbb      	ldrh	r3, [r7, #28]
    65b8:	f362 138f 	bfi	r3, r2, #6, #10
    65bc:	83bb      	strh	r3, [r7, #28]
    65be:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    65c2:	2b00      	cmp	r3, #0
    65c4:	d005      	beq.n	65d2 <mpu_configure_regions_and_partition+0x152>
    65c6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    65c8:	4978      	ldr	r1, [pc, #480]	; (67ac <mpu_configure_regions_and_partition+0x32c>)
    65ca:	8bb8      	ldrh	r0, [r7, #28]
    65cc:	f7fc f990 	bl	28f0 <log_from_user>
    65d0:	e005      	b.n	65de <mpu_configure_regions_and_partition+0x15e>
    65d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    65d4:	8bba      	ldrh	r2, [r7, #28]
    65d6:	4619      	mov	r1, r3
    65d8:	4874      	ldr	r0, [pc, #464]	; (67ac <mpu_configure_regions_and_partition+0x32c>)
    65da:	f00b f837 	bl	1164c <log_1>
				u_reg_index);
			return -EINVAL;
    65de:	f06f 0315 	mvn.w	r3, #21
    65e2:	e0f3      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>

		/*
		 * The new memory region is to be placed inside the underlying
		 * region, possibly splitting the underlying region into two.
		 */
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
    65e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    65e6:	4618      	mov	r0, r3
    65e8:	f7ff feae 	bl	6348 <mpu_region_get_base>
    65ec:	62f8      	str	r0, [r7, #44]	; 0x2c
		uint32_t u_reg_last = mpu_region_get_last_addr(u_reg_index);
    65ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    65f0:	4618      	mov	r0, r3
    65f2:	f7ff fed5 	bl	63a0 <mpu_region_get_last_addr>
    65f6:	62b8      	str	r0, [r7, #40]	; 0x28
		uint32_t reg_last = regions[i]->start + regions[i]->size - 1;
    65f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    65fa:	009b      	lsls	r3, r3, #2
    65fc:	687a      	ldr	r2, [r7, #4]
    65fe:	4413      	add	r3, r2
    6600:	681b      	ldr	r3, [r3, #0]
    6602:	681a      	ldr	r2, [r3, #0]
    6604:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6606:	009b      	lsls	r3, r3, #2
    6608:	6879      	ldr	r1, [r7, #4]
    660a:	440b      	add	r3, r1
    660c:	681b      	ldr	r3, [r3, #0]
    660e:	685b      	ldr	r3, [r3, #4]
    6610:	4413      	add	r3, r2
    6612:	3b01      	subs	r3, #1
    6614:	627b      	str	r3, [r7, #36]	; 0x24

		if ((regions[i]->start == u_reg_base) &&
    6616:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6618:	009b      	lsls	r3, r3, #2
    661a:	687a      	ldr	r2, [r7, #4]
    661c:	4413      	add	r3, r2
    661e:	681b      	ldr	r3, [r3, #0]
    6620:	681b      	ldr	r3, [r3, #0]
    6622:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    6624:	429a      	cmp	r2, r3
    6626:	d10e      	bne.n	6646 <mpu_configure_regions_and_partition+0x1c6>
    6628:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    662a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    662c:	429a      	cmp	r2, r3
    662e:	d10a      	bne.n	6646 <mpu_configure_regions_and_partition+0x1c6>
			 * underlying region. In this case we simply
			 * update the partition attributes of the
			 * underlying region with those of the new
			 * region.
			 */
			mpu_configure_region(u_reg_index, regions[i]);
    6630:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    6632:	b2d8      	uxtb	r0, r3
    6634:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6636:	009b      	lsls	r3, r3, #2
    6638:	687a      	ldr	r2, [r7, #4]
    663a:	4413      	add	r3, r2
    663c:	681b      	ldr	r3, [r3, #0]
    663e:	4619      	mov	r1, r3
    6640:	f000 f9e2 	bl	6a08 <mpu_configure_region>
    6644:	e0b9      	b.n	67ba <mpu_configure_regions_and_partition+0x33a>
		} else if (regions[i]->start == u_reg_base) {
    6646:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6648:	009b      	lsls	r3, r3, #2
    664a:	687a      	ldr	r2, [r7, #4]
    664c:	4413      	add	r3, r2
    664e:	681b      	ldr	r3, [r3, #0]
    6650:	681b      	ldr	r3, [r3, #0]
    6652:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    6654:	429a      	cmp	r2, r3
    6656:	d125      	bne.n	66a4 <mpu_configure_regions_and_partition+0x224>
			/* The new region starts exactly at the start of the
			 * underlying region; the start of the underlying
			 * region needs to be set to the end of the new region.
			 */
			mpu_region_set_base(u_reg_index,
    6658:	6b38      	ldr	r0, [r7, #48]	; 0x30
				regions[i]->start + regions[i]->size);
    665a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    665c:	009b      	lsls	r3, r3, #2
    665e:	687a      	ldr	r2, [r7, #4]
    6660:	4413      	add	r3, r2
    6662:	681b      	ldr	r3, [r3, #0]
    6664:	681a      	ldr	r2, [r3, #0]
    6666:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6668:	009b      	lsls	r3, r3, #2
    666a:	6879      	ldr	r1, [r7, #4]
    666c:	440b      	add	r3, r1
    666e:	681b      	ldr	r3, [r3, #0]
    6670:	685b      	ldr	r3, [r3, #4]
    6672:	4413      	add	r3, r2
			mpu_region_set_base(u_reg_index,
    6674:	4619      	mov	r1, r3
    6676:	f7ff fe79 	bl	636c <mpu_region_set_base>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);
    667a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    667c:	b2d8      	uxtb	r0, r3
    667e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6680:	009b      	lsls	r3, r3, #2
    6682:	687a      	ldr	r2, [r7, #4]
    6684:	4413      	add	r3, r2
    6686:	681b      	ldr	r3, [r3, #0]
    6688:	4619      	mov	r1, r3
    668a:	f000 f9bd 	bl	6a08 <mpu_configure_region>
    668e:	63f8      	str	r0, [r7, #60]	; 0x3c

			if (reg_index == -EINVAL) {
    6690:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6692:	f113 0f16 	cmn.w	r3, #22
    6696:	d101      	bne.n	669c <mpu_configure_regions_and_partition+0x21c>
				return reg_index;
    6698:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    669a:	e097      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>
			}

			reg_index++;
    669c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    669e:	3301      	adds	r3, #1
    66a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    66a2:	e08a      	b.n	67ba <mpu_configure_regions_and_partition+0x33a>
		} else if (reg_last == u_reg_last) {
    66a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    66a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    66a8:	429a      	cmp	r2, r3
    66aa:	d11f      	bne.n	66ec <mpu_configure_regions_and_partition+0x26c>
			/* The new region ends exactly at the end of the
			 * underlying region; the end of the underlying
			 * region needs to be set to the start of the
			 * new region.
			 */
			mpu_region_set_limit(u_reg_index,
    66ac:	6b38      	ldr	r0, [r7, #48]	; 0x30
				regions[i]->start - 1);
    66ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    66b0:	009b      	lsls	r3, r3, #2
    66b2:	687a      	ldr	r2, [r7, #4]
    66b4:	4413      	add	r3, r2
    66b6:	681b      	ldr	r3, [r3, #0]
    66b8:	681b      	ldr	r3, [r3, #0]
    66ba:	3b01      	subs	r3, #1
			mpu_region_set_limit(u_reg_index,
    66bc:	4619      	mov	r1, r3
    66be:	f7ff fe81 	bl	63c4 <mpu_region_set_limit>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);
    66c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    66c4:	b2d8      	uxtb	r0, r3
    66c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    66c8:	009b      	lsls	r3, r3, #2
    66ca:	687a      	ldr	r2, [r7, #4]
    66cc:	4413      	add	r3, r2
    66ce:	681b      	ldr	r3, [r3, #0]
    66d0:	4619      	mov	r1, r3
    66d2:	f000 f999 	bl	6a08 <mpu_configure_region>
    66d6:	63f8      	str	r0, [r7, #60]	; 0x3c

			if (reg_index == -EINVAL) {
    66d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    66da:	f113 0f16 	cmn.w	r3, #22
    66de:	d101      	bne.n	66e4 <mpu_configure_regions_and_partition+0x264>
				return reg_index;
    66e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    66e2:	e073      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>
			}

			reg_index++;
    66e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    66e6:	3301      	adds	r3, #1
    66e8:	63fb      	str	r3, [r7, #60]	; 0x3c
    66ea:	e066      	b.n	67ba <mpu_configure_regions_and_partition+0x33a>
		} else {
			/* The new regions lies strictly inside the
			 * underlying region, which needs to split
			 * into two regions.
			 */
			mpu_region_set_limit(u_reg_index,
    66ec:	6b38      	ldr	r0, [r7, #48]	; 0x30
				regions[i]->start - 1);
    66ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    66f0:	009b      	lsls	r3, r3, #2
    66f2:	687a      	ldr	r2, [r7, #4]
    66f4:	4413      	add	r3, r2
    66f6:	681b      	ldr	r3, [r3, #0]
    66f8:	681b      	ldr	r3, [r3, #0]
    66fa:	3b01      	subs	r3, #1
			mpu_region_set_limit(u_reg_index,
    66fc:	4619      	mov	r1, r3
    66fe:	f7ff fe61 	bl	63c4 <mpu_region_set_limit>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);
    6702:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6704:	b2d8      	uxtb	r0, r3
    6706:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6708:	009b      	lsls	r3, r3, #2
    670a:	687a      	ldr	r2, [r7, #4]
    670c:	4413      	add	r3, r2
    670e:	681b      	ldr	r3, [r3, #0]
    6710:	4619      	mov	r1, r3
    6712:	f000 f979 	bl	6a08 <mpu_configure_region>
    6716:	63f8      	str	r0, [r7, #60]	; 0x3c

			if (reg_index == -EINVAL) {
    6718:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    671a:	f113 0f16 	cmn.w	r3, #22
    671e:	d101      	bne.n	6724 <mpu_configure_regions_and_partition+0x2a4>
				return reg_index;
    6720:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6722:	e053      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>
			}
			reg_index++;
    6724:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6726:	3301      	adds	r3, #1
    6728:	63fb      	str	r3, [r7, #60]	; 0x3c
			 * access attributes as the initial underlying
			 * region.
			 */
			struct arm_mpu_region fill_region;

			mpu_region_get_access_attr(u_reg_index,
    672a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    672c:	f107 030c 	add.w	r3, r7, #12
    6730:	3308      	adds	r3, #8
    6732:	4619      	mov	r1, r3
    6734:	4610      	mov	r0, r2
    6736:	f7ff fe5f 	bl	63f8 <mpu_region_get_access_attr>
				&fill_region.attr);
			fill_region.base = regions[i]->start +
    673a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    673c:	009b      	lsls	r3, r3, #2
    673e:	687a      	ldr	r2, [r7, #4]
    6740:	4413      	add	r3, r2
    6742:	681b      	ldr	r3, [r3, #0]
    6744:	681a      	ldr	r2, [r3, #0]
				regions[i]->size;
    6746:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6748:	009b      	lsls	r3, r3, #2
    674a:	6879      	ldr	r1, [r7, #4]
    674c:	440b      	add	r3, r1
    674e:	681b      	ldr	r3, [r3, #0]
    6750:	685b      	ldr	r3, [r3, #4]
			fill_region.base = regions[i]->start +
    6752:	4413      	add	r3, r2
    6754:	60fb      	str	r3, [r7, #12]
			fill_region.attr.r_limit =
			REGION_LIMIT_ADDR((regions[i]->start +
    6756:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6758:	009b      	lsls	r3, r3, #2
    675a:	687a      	ldr	r2, [r7, #4]
    675c:	4413      	add	r3, r2
    675e:	681b      	ldr	r3, [r3, #0]
    6760:	681a      	ldr	r2, [r3, #0]
    6762:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6764:	009b      	lsls	r3, r3, #2
    6766:	6879      	ldr	r1, [r7, #4]
    6768:	440b      	add	r3, r1
    676a:	681b      	ldr	r3, [r3, #0]
    676c:	685b      	ldr	r3, [r3, #4]
    676e:	4413      	add	r3, r2
    6770:	f023 021f 	bic.w	r2, r3, #31
    6774:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    6776:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6778:	1acb      	subs	r3, r1, r3
    677a:	4413      	add	r3, r2
    677c:	3b01      	subs	r3, #1
    677e:	f023 031f 	bic.w	r3, r3, #31
			fill_region.attr.r_limit =
    6782:	61bb      	str	r3, [r7, #24]
				regions[i]->size), (u_reg_last - reg_last));

			reg_index =
				region_allocate_and_init(reg_index,
    6784:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6786:	b2db      	uxtb	r3, r3
    6788:	f107 020c 	add.w	r2, r7, #12
    678c:	4611      	mov	r1, r2
    678e:	4618      	mov	r0, r3
    6790:	f000 f8b4 	bl	68fc <region_allocate_and_init>
    6794:	63f8      	str	r0, [r7, #60]	; 0x3c
					(const struct arm_mpu_region *)
						&fill_region);

			if (reg_index == -EINVAL) {
    6796:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    6798:	f113 0f16 	cmn.w	r3, #22
    679c:	d108      	bne.n	67b0 <mpu_configure_regions_and_partition+0x330>
				return reg_index;
    679e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    67a0:	e014      	b.n	67cc <mpu_configure_regions_and_partition+0x34c>
    67a2:	bf00      	nop
    67a4:	200000f8 	.word	0x200000f8
    67a8:	00019ba0 	.word	0x00019ba0
    67ac:	00019bc4 	.word	0x00019bc4
			}

			reg_index++;
    67b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    67b2:	3301      	adds	r3, #1
    67b4:	63fb      	str	r3, [r7, #60]	; 0x3c
    67b6:	e000      	b.n	67ba <mpu_configure_regions_and_partition+0x33a>
			continue;
    67b8:	bf00      	nop
	for (i = 0; i < regions_num; i++) {
    67ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    67bc:	3301      	adds	r3, #1
    67be:	63bb      	str	r3, [r7, #56]	; 0x38
    67c0:	78fb      	ldrb	r3, [r7, #3]
    67c2:	6bba      	ldr	r2, [r7, #56]	; 0x38
    67c4:	429a      	cmp	r2, r3
    67c6:	f6ff ae6d 	blt.w	64a4 <mpu_configure_regions_and_partition+0x24>
		}
	}

	return reg_index;
    67ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    67cc:	4618      	mov	r0, r3
    67ce:	3740      	adds	r7, #64	; 0x40
    67d0:	46bd      	mov	sp, r7
    67d2:	bd80      	pop	{r7, pc}

000067d4 <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
    67d4:	b580      	push	{r7, lr}
    67d6:	b086      	sub	sp, #24
    67d8:	af00      	add	r7, sp, #0
    67da:	60f8      	str	r0, [r7, #12]
    67dc:	607a      	str	r2, [r7, #4]
    67de:	603b      	str	r3, [r7, #0]
    67e0:	460b      	mov	r3, r1
    67e2:	72fb      	strb	r3, [r7, #11]
	int mpu_reg_index = static_regions_num;
    67e4:	4b09      	ldr	r3, [pc, #36]	; (680c <mpu_configure_static_mpu_regions+0x38>)
    67e6:	781b      	ldrb	r3, [r3, #0]
    67e8:	617b      	str	r3, [r7, #20]
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    67ea:	697b      	ldr	r3, [r7, #20]
    67ec:	b2da      	uxtb	r2, r3
    67ee:	7af9      	ldrb	r1, [r7, #11]
    67f0:	2301      	movs	r3, #1
    67f2:	68f8      	ldr	r0, [r7, #12]
    67f4:	f7ff fe44 	bl	6480 <mpu_configure_regions_and_partition>
    67f8:	6178      	str	r0, [r7, #20]
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    67fa:	697b      	ldr	r3, [r7, #20]
    67fc:	b2da      	uxtb	r2, r3
    67fe:	4b03      	ldr	r3, [pc, #12]	; (680c <mpu_configure_static_mpu_regions+0x38>)
    6800:	701a      	strb	r2, [r3, #0]

	return mpu_reg_index;
    6802:	697b      	ldr	r3, [r7, #20]
}
    6804:	4618      	mov	r0, r3
    6806:	3718      	adds	r7, #24
    6808:	46bd      	mov	sp, r7
    680a:	bd80      	pop	{r7, pc}
    680c:	20000d43 	.word	0x20000d43

00006810 <mpu_mark_areas_for_dynamic_regions>:
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
		const struct k_mem_partition dyn_region_areas[],
		const uint8_t dyn_region_areas_num)
{
    6810:	b580      	push	{r7, lr}
    6812:	b084      	sub	sp, #16
    6814:	af00      	add	r7, sp, #0
    6816:	6078      	str	r0, [r7, #4]
    6818:	460b      	mov	r3, r1
    681a:	70fb      	strb	r3, [r7, #3]
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    681c:	2300      	movs	r3, #0
    681e:	60fb      	str	r3, [r7, #12]
    6820:	e05e      	b.n	68e0 <mpu_mark_areas_for_dynamic_regions+0xd0>
		if (dyn_region_areas[i].size == 0U) {
    6822:	68fa      	ldr	r2, [r7, #12]
    6824:	4613      	mov	r3, r2
    6826:	005b      	lsls	r3, r3, #1
    6828:	4413      	add	r3, r2
    682a:	009b      	lsls	r3, r3, #2
    682c:	461a      	mov	r2, r3
    682e:	687b      	ldr	r3, [r7, #4]
    6830:	4413      	add	r3, r2
    6832:	685b      	ldr	r3, [r3, #4]
    6834:	2b00      	cmp	r3, #0
    6836:	d04f      	beq.n	68d8 <mpu_mark_areas_for_dynamic_regions+0xc8>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    6838:	68fa      	ldr	r2, [r7, #12]
    683a:	4613      	mov	r3, r2
    683c:	005b      	lsls	r3, r3, #1
    683e:	4413      	add	r3, r2
    6840:	009b      	lsls	r3, r3, #2
    6842:	461a      	mov	r2, r3
    6844:	687b      	ldr	r3, [r7, #4]
    6846:	4413      	add	r3, r2
    6848:	6818      	ldr	r0, [r3, #0]
					dyn_region_areas[i].size);
    684a:	68fa      	ldr	r2, [r7, #12]
    684c:	4613      	mov	r3, r2
    684e:	005b      	lsls	r3, r3, #1
    6850:	4413      	add	r3, r2
    6852:	009b      	lsls	r3, r3, #2
    6854:	461a      	mov	r2, r3
    6856:	687b      	ldr	r3, [r7, #4]
    6858:	4413      	add	r3, r2
			get_region_index(dyn_region_areas[i].start,
    685a:	685b      	ldr	r3, [r3, #4]
    685c:	4619      	mov	r1, r3
    685e:	f00c fb9b 	bl	12f98 <get_region_index>
    6862:	4601      	mov	r1, r0
		dyn_reg_info[i].index =
    6864:	4823      	ldr	r0, [pc, #140]	; (68f4 <mpu_mark_areas_for_dynamic_regions+0xe4>)
    6866:	68fa      	ldr	r2, [r7, #12]
    6868:	4613      	mov	r3, r2
    686a:	009b      	lsls	r3, r3, #2
    686c:	4413      	add	r3, r2
    686e:	009b      	lsls	r3, r3, #2
    6870:	4403      	add	r3, r0
    6872:	6019      	str	r1, [r3, #0]

		if (dyn_reg_info[i].index == -EINVAL) {
    6874:	491f      	ldr	r1, [pc, #124]	; (68f4 <mpu_mark_areas_for_dynamic_regions+0xe4>)
    6876:	68fa      	ldr	r2, [r7, #12]
    6878:	4613      	mov	r3, r2
    687a:	009b      	lsls	r3, r3, #2
    687c:	4413      	add	r3, r2
    687e:	009b      	lsls	r3, r3, #2
    6880:	440b      	add	r3, r1
    6882:	681b      	ldr	r3, [r3, #0]
    6884:	f113 0f16 	cmn.w	r3, #22
    6888:	d102      	bne.n	6890 <mpu_mark_areas_for_dynamic_regions+0x80>

			return -EINVAL;
    688a:	f06f 0315 	mvn.w	r3, #21
    688e:	e02c      	b.n	68ea <mpu_mark_areas_for_dynamic_regions+0xda>
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    6890:	4918      	ldr	r1, [pc, #96]	; (68f4 <mpu_mark_areas_for_dynamic_regions+0xe4>)
    6892:	68fa      	ldr	r2, [r7, #12]
    6894:	4613      	mov	r3, r2
    6896:	009b      	lsls	r3, r3, #2
    6898:	4413      	add	r3, r2
    689a:	009b      	lsls	r3, r3, #2
    689c:	440b      	add	r3, r1
    689e:	681b      	ldr	r3, [r3, #0]
    68a0:	4a15      	ldr	r2, [pc, #84]	; (68f8 <mpu_mark_areas_for_dynamic_regions+0xe8>)
    68a2:	7812      	ldrb	r2, [r2, #0]
    68a4:	4293      	cmp	r3, r2
    68a6:	db02      	blt.n	68ae <mpu_mark_areas_for_dynamic_regions+0x9e>

			return -EINVAL;
    68a8:	f06f 0315 	mvn.w	r3, #21
    68ac:	e01d      	b.n	68ea <mpu_mark_areas_for_dynamic_regions+0xda>
		}

		/* Store default configuration */
		mpu_region_get_conf(dyn_reg_info[i].index,
    68ae:	4911      	ldr	r1, [pc, #68]	; (68f4 <mpu_mark_areas_for_dynamic_regions+0xe4>)
    68b0:	68fa      	ldr	r2, [r7, #12]
    68b2:	4613      	mov	r3, r2
    68b4:	009b      	lsls	r3, r3, #2
    68b6:	4413      	add	r3, r2
    68b8:	009b      	lsls	r3, r3, #2
    68ba:	440b      	add	r3, r1
    68bc:	681b      	ldr	r3, [r3, #0]
    68be:	4618      	mov	r0, r3
    68c0:	68fa      	ldr	r2, [r7, #12]
    68c2:	4613      	mov	r3, r2
    68c4:	009b      	lsls	r3, r3, #2
    68c6:	4413      	add	r3, r2
    68c8:	009b      	lsls	r3, r3, #2
    68ca:	4a0a      	ldr	r2, [pc, #40]	; (68f4 <mpu_mark_areas_for_dynamic_regions+0xe4>)
    68cc:	4413      	add	r3, r2
    68ce:	3304      	adds	r3, #4
    68d0:	4619      	mov	r1, r3
    68d2:	f7ff fdb5 	bl	6440 <mpu_region_get_conf>
    68d6:	e000      	b.n	68da <mpu_mark_areas_for_dynamic_regions+0xca>
			continue;
    68d8:	bf00      	nop
	for (int i = 0; i < dyn_region_areas_num; i++) {
    68da:	68fb      	ldr	r3, [r7, #12]
    68dc:	3301      	adds	r3, #1
    68de:	60fb      	str	r3, [r7, #12]
    68e0:	78fb      	ldrb	r3, [r7, #3]
    68e2:	68fa      	ldr	r2, [r7, #12]
    68e4:	429a      	cmp	r2, r3
    68e6:	db9c      	blt.n	6822 <mpu_mark_areas_for_dynamic_regions+0x12>
			&dyn_reg_info[i].region_conf);
	}

	return 0;
    68e8:	2300      	movs	r3, #0
}
    68ea:	4618      	mov	r0, r3
    68ec:	3710      	adds	r7, #16
    68ee:	46bd      	mov	sp, r7
    68f0:	bd80      	pop	{r7, pc}
    68f2:	bf00      	nop
    68f4:	20000c48 	.word	0x20000c48
    68f8:	20000d43 	.word	0x20000d43

000068fc <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
    68fc:	b590      	push	{r4, r7, lr}
    68fe:	b085      	sub	sp, #20
    6900:	af00      	add	r7, sp, #0
    6902:	4603      	mov	r3, r0
    6904:	6039      	str	r1, [r7, #0]
    6906:	71fb      	strb	r3, [r7, #7]
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    6908:	79fc      	ldrb	r4, [r7, #7]
    690a:	f00c fb1e 	bl	12f4a <get_num_regions>
    690e:	4603      	mov	r3, r0
    6910:	3b01      	subs	r3, #1
    6912:	429c      	cmp	r4, r3
    6914:	d934      	bls.n	6980 <region_allocate_and_init+0x84>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    6916:	2303      	movs	r3, #3
    6918:	2b00      	cmp	r3, #0
    691a:	d02e      	beq.n	697a <region_allocate_and_init+0x7e>
    691c:	f00c faf9 	bl	12f12 <_is_user_context>
    6920:	4603      	mov	r3, r0
    6922:	73bb      	strb	r3, [r7, #14]
    6924:	7b3b      	ldrb	r3, [r7, #12]
    6926:	2201      	movs	r2, #1
    6928:	f362 0302 	bfi	r3, r2, #0, #3
    692c:	733b      	strb	r3, [r7, #12]
    692e:	7b3b      	ldrb	r3, [r7, #12]
    6930:	f36f 03c5 	bfc	r3, #3, #3
    6934:	733b      	strb	r3, [r7, #12]
    6936:	2303      	movs	r3, #3
    6938:	2b00      	cmp	r3, #0
    693a:	d009      	beq.n	6950 <region_allocate_and_init+0x54>
    693c:	4b2e      	ldr	r3, [pc, #184]	; (69f8 <region_allocate_and_init+0xfc>)
    693e:	681b      	ldr	r3, [r3, #0]
    6940:	4618      	mov	r0, r3
    6942:	f7ff fc53 	bl	61ec <log_const_source_id>
    6946:	4603      	mov	r3, r0
    6948:	f3c3 0309 	ubfx	r3, r3, #0, #10
    694c:	b29a      	uxth	r2, r3
    694e:	e000      	b.n	6952 <region_allocate_and_init+0x56>
    6950:	2200      	movs	r2, #0
    6952:	89bb      	ldrh	r3, [r7, #12]
    6954:	f362 138f 	bfi	r3, r2, #6, #10
    6958:	81bb      	strh	r3, [r7, #12]
    695a:	7bbb      	ldrb	r3, [r7, #14]
    695c:	2b00      	cmp	r3, #0
    695e:	d006      	beq.n	696e <region_allocate_and_init+0x72>
    6960:	79fb      	ldrb	r3, [r7, #7]
    6962:	461a      	mov	r2, r3
    6964:	4925      	ldr	r1, [pc, #148]	; (69fc <region_allocate_and_init+0x100>)
    6966:	89b8      	ldrh	r0, [r7, #12]
    6968:	f7fb ffc2 	bl	28f0 <log_from_user>
    696c:	e005      	b.n	697a <region_allocate_and_init+0x7e>
    696e:	79fb      	ldrb	r3, [r7, #7]
    6970:	89ba      	ldrh	r2, [r7, #12]
    6972:	4619      	mov	r1, r3
    6974:	4821      	ldr	r0, [pc, #132]	; (69fc <region_allocate_and_init+0x100>)
    6976:	f00a fe69 	bl	1164c <log_1>
		return -EINVAL;
    697a:	f06f 0315 	mvn.w	r3, #21
    697e:	e037      	b.n	69f0 <region_allocate_and_init+0xf4>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);
    6980:	2303      	movs	r3, #3
    6982:	2b03      	cmp	r3, #3
    6984:	d92e      	bls.n	69e4 <region_allocate_and_init+0xe8>
    6986:	f00c fac4 	bl	12f12 <_is_user_context>
    698a:	4603      	mov	r3, r0
    698c:	73fb      	strb	r3, [r7, #15]
    698e:	7a3b      	ldrb	r3, [r7, #8]
    6990:	2204      	movs	r2, #4
    6992:	f362 0302 	bfi	r3, r2, #0, #3
    6996:	723b      	strb	r3, [r7, #8]
    6998:	7a3b      	ldrb	r3, [r7, #8]
    699a:	f36f 03c5 	bfc	r3, #3, #3
    699e:	723b      	strb	r3, [r7, #8]
    69a0:	2303      	movs	r3, #3
    69a2:	2b00      	cmp	r3, #0
    69a4:	d009      	beq.n	69ba <region_allocate_and_init+0xbe>
    69a6:	4b14      	ldr	r3, [pc, #80]	; (69f8 <region_allocate_and_init+0xfc>)
    69a8:	681b      	ldr	r3, [r3, #0]
    69aa:	4618      	mov	r0, r3
    69ac:	f7ff fc1e 	bl	61ec <log_const_source_id>
    69b0:	4603      	mov	r3, r0
    69b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    69b6:	b29a      	uxth	r2, r3
    69b8:	e000      	b.n	69bc <region_allocate_and_init+0xc0>
    69ba:	2200      	movs	r2, #0
    69bc:	893b      	ldrh	r3, [r7, #8]
    69be:	f362 138f 	bfi	r3, r2, #6, #10
    69c2:	813b      	strh	r3, [r7, #8]
    69c4:	7bfb      	ldrb	r3, [r7, #15]
    69c6:	2b00      	cmp	r3, #0
    69c8:	d006      	beq.n	69d8 <region_allocate_and_init+0xdc>
    69ca:	79fb      	ldrb	r3, [r7, #7]
    69cc:	4a0c      	ldr	r2, [pc, #48]	; (6a00 <region_allocate_and_init+0x104>)
    69ce:	490d      	ldr	r1, [pc, #52]	; (6a04 <region_allocate_and_init+0x108>)
    69d0:	8938      	ldrh	r0, [r7, #8]
    69d2:	f7fb ff8d 	bl	28f0 <log_from_user>
    69d6:	e005      	b.n	69e4 <region_allocate_and_init+0xe8>
    69d8:	4909      	ldr	r1, [pc, #36]	; (6a00 <region_allocate_and_init+0x104>)
    69da:	79fa      	ldrb	r2, [r7, #7]
    69dc:	893b      	ldrh	r3, [r7, #8]
    69de:	4809      	ldr	r0, [pc, #36]	; (6a04 <region_allocate_and_init+0x108>)
    69e0:	f00a fe4b 	bl	1167a <log_2>

	/* Program region */
	region_init(index, region_conf);
    69e4:	79fb      	ldrb	r3, [r7, #7]
    69e6:	6839      	ldr	r1, [r7, #0]
    69e8:	4618      	mov	r0, r3
    69ea:	f7ff fc1d 	bl	6228 <region_init>

	return index;
    69ee:	79fb      	ldrb	r3, [r7, #7]
}
    69f0:	4618      	mov	r0, r3
    69f2:	3714      	adds	r7, #20
    69f4:	46bd      	mov	sp, r7
    69f6:	bd90      	pop	{r4, r7, pc}
    69f8:	200000f8 	.word	0x200000f8
    69fc:	00019be8 	.word	0x00019be8
    6a00:	0001cb54 	.word	0x0001cb54
    6a04:	00019c10 	.word	0x00019c10

00006a08 <mpu_configure_region>:
/* This internal function programs an MPU region
 * of a given configuration at a given MPU index.
 */
static int mpu_configure_region(const uint8_t index,
	const struct k_mem_partition *new_region)
{
    6a08:	b590      	push	{r4, r7, lr}
    6a0a:	b089      	sub	sp, #36	; 0x24
    6a0c:	af00      	add	r7, sp, #0
    6a0e:	4603      	mov	r3, r0
    6a10:	6039      	str	r1, [r7, #0]
    6a12:	71fb      	strb	r3, [r7, #7]
	struct arm_mpu_region region_conf;

	LOG_DBG("Configure MPU region at index 0x%x", index);
    6a14:	2303      	movs	r3, #3
    6a16:	2b03      	cmp	r3, #3
    6a18:	d92e      	bls.n	6a78 <mpu_configure_region+0x70>
    6a1a:	f00c fa7a 	bl	12f12 <_is_user_context>
    6a1e:	4603      	mov	r3, r0
    6a20:	77fb      	strb	r3, [r7, #31]
    6a22:	7a3b      	ldrb	r3, [r7, #8]
    6a24:	2204      	movs	r2, #4
    6a26:	f362 0302 	bfi	r3, r2, #0, #3
    6a2a:	723b      	strb	r3, [r7, #8]
    6a2c:	7a3b      	ldrb	r3, [r7, #8]
    6a2e:	f36f 03c5 	bfc	r3, #3, #3
    6a32:	723b      	strb	r3, [r7, #8]
    6a34:	2303      	movs	r3, #3
    6a36:	2b00      	cmp	r3, #0
    6a38:	d009      	beq.n	6a4e <mpu_configure_region+0x46>
    6a3a:	4b1e      	ldr	r3, [pc, #120]	; (6ab4 <mpu_configure_region+0xac>)
    6a3c:	681b      	ldr	r3, [r3, #0]
    6a3e:	4618      	mov	r0, r3
    6a40:	f7ff fbd4 	bl	61ec <log_const_source_id>
    6a44:	4603      	mov	r3, r0
    6a46:	f3c3 0309 	ubfx	r3, r3, #0, #10
    6a4a:	b29a      	uxth	r2, r3
    6a4c:	e000      	b.n	6a50 <mpu_configure_region+0x48>
    6a4e:	2200      	movs	r2, #0
    6a50:	893b      	ldrh	r3, [r7, #8]
    6a52:	f362 138f 	bfi	r3, r2, #6, #10
    6a56:	813b      	strh	r3, [r7, #8]
    6a58:	7ffb      	ldrb	r3, [r7, #31]
    6a5a:	2b00      	cmp	r3, #0
    6a5c:	d006      	beq.n	6a6c <mpu_configure_region+0x64>
    6a5e:	79fb      	ldrb	r3, [r7, #7]
    6a60:	4a15      	ldr	r2, [pc, #84]	; (6ab8 <mpu_configure_region+0xb0>)
    6a62:	4916      	ldr	r1, [pc, #88]	; (6abc <mpu_configure_region+0xb4>)
    6a64:	8938      	ldrh	r0, [r7, #8]
    6a66:	f7fb ff43 	bl	28f0 <log_from_user>
    6a6a:	e005      	b.n	6a78 <mpu_configure_region+0x70>
    6a6c:	4912      	ldr	r1, [pc, #72]	; (6ab8 <mpu_configure_region+0xb0>)
    6a6e:	79fa      	ldrb	r2, [r7, #7]
    6a70:	893b      	ldrh	r3, [r7, #8]
    6a72:	4812      	ldr	r0, [pc, #72]	; (6abc <mpu_configure_region+0xb4>)
    6a74:	f00a fe01 	bl	1167a <log_2>

	/* Populate internal ARM MPU region configuration structure. */
	region_conf.base = new_region->start;
    6a78:	683b      	ldr	r3, [r7, #0]
    6a7a:	681b      	ldr	r3, [r3, #0]
    6a7c:	60fb      	str	r3, [r7, #12]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    6a7e:	683b      	ldr	r3, [r7, #0]
    6a80:	f103 0108 	add.w	r1, r3, #8
		&new_region->attr, new_region->start, new_region->size);
    6a84:	683b      	ldr	r3, [r7, #0]
    6a86:	681a      	ldr	r2, [r3, #0]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    6a88:	683b      	ldr	r3, [r7, #0]
    6a8a:	685c      	ldr	r4, [r3, #4]
    6a8c:	f107 030c 	add.w	r3, r7, #12
    6a90:	f103 0008 	add.w	r0, r3, #8
    6a94:	4623      	mov	r3, r4
    6a96:	f00c fa9e 	bl	12fd6 <get_region_attr_from_k_mem_partition_info>

	/* Allocate and program region */
	return region_allocate_and_init(index,
    6a9a:	f107 020c 	add.w	r2, r7, #12
    6a9e:	79fb      	ldrb	r3, [r7, #7]
    6aa0:	4611      	mov	r1, r2
    6aa2:	4618      	mov	r0, r3
    6aa4:	f7ff ff2a 	bl	68fc <region_allocate_and_init>
    6aa8:	4603      	mov	r3, r0
		(const struct arm_mpu_region *)&region_conf);
}
    6aaa:	4618      	mov	r0, r3
    6aac:	3724      	adds	r7, #36	; 0x24
    6aae:	46bd      	mov	sp, r7
    6ab0:	bd90      	pop	{r4, r7, pc}
    6ab2:	bf00      	nop
    6ab4:	200000f8 	.word	0x200000f8
    6ab8:	0001cb70 	.word	0x0001cb70
    6abc:	00019c38 	.word	0x00019c38

00006ac0 <arm_core_mpu_enable>:

/**
 * @brief enable the MPU
 */
void arm_core_mpu_enable(void)
{
    6ac0:	b480      	push	{r7}
    6ac2:	af00      	add	r7, sp, #0
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    6ac4:	4b06      	ldr	r3, [pc, #24]	; (6ae0 <arm_core_mpu_enable+0x20>)
    6ac6:	2205      	movs	r2, #5
    6ac8:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    6aca:	f3bf 8f4f 	dsb	sy
}
    6ace:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
    6ad0:	f3bf 8f6f 	isb	sy
}
    6ad4:	bf00      	nop

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    6ad6:	bf00      	nop
    6ad8:	46bd      	mov	sp, r7
    6ada:	bc80      	pop	{r7}
    6adc:	4770      	bx	lr
    6ade:	bf00      	nop
    6ae0:	e000ed90 	.word	0xe000ed90

00006ae4 <arm_core_mpu_disable>:

/**
 * @brief disable the MPU
 */
void arm_core_mpu_disable(void)
{
    6ae4:	b480      	push	{r7}
    6ae6:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    6ae8:	f3bf 8f5f 	dmb	sy
}
    6aec:	bf00      	nop
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    6aee:	4b03      	ldr	r3, [pc, #12]	; (6afc <arm_core_mpu_disable+0x18>)
    6af0:	2200      	movs	r2, #0
    6af2:	605a      	str	r2, [r3, #4]
}
    6af4:	bf00      	nop
    6af6:	46bd      	mov	sp, r7
    6af8:	bc80      	pop	{r7}
    6afa:	4770      	bx	lr
    6afc:	e000ed90 	.word	0xe000ed90

00006b00 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    6b00:	b580      	push	{r7, lr}
    6b02:	b084      	sub	sp, #16
    6b04:	af00      	add	r7, sp, #0
    6b06:	60f8      	str	r0, [r7, #12]
    6b08:	607a      	str	r2, [r7, #4]
    6b0a:	603b      	str	r3, [r7, #0]
    6b0c:	460b      	mov	r3, r1
    6b0e:	72fb      	strb	r3, [r7, #11]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    6b10:	7af9      	ldrb	r1, [r7, #11]
    6b12:	683b      	ldr	r3, [r7, #0]
    6b14:	687a      	ldr	r2, [r7, #4]
    6b16:	68f8      	ldr	r0, [r7, #12]
    6b18:	f7ff fe5c 	bl	67d4 <mpu_configure_static_mpu_regions>
    6b1c:	4603      	mov	r3, r0
    6b1e:	f113 0f16 	cmn.w	r3, #22
    6b22:	d110      	bne.n	6b46 <arm_core_mpu_configure_static_mpu_regions+0x46>
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
    6b24:	f240 1303 	movw	r3, #259	; 0x103
    6b28:	4a09      	ldr	r2, [pc, #36]	; (6b50 <arm_core_mpu_configure_static_mpu_regions+0x50>)
    6b2a:	490a      	ldr	r1, [pc, #40]	; (6b54 <arm_core_mpu_configure_static_mpu_regions+0x54>)
    6b2c:	480a      	ldr	r0, [pc, #40]	; (6b58 <arm_core_mpu_configure_static_mpu_regions+0x58>)
    6b2e:	f009 fa9b 	bl	10068 <printk>
    6b32:	7afb      	ldrb	r3, [r7, #11]
    6b34:	4619      	mov	r1, r3
    6b36:	4809      	ldr	r0, [pc, #36]	; (6b5c <arm_core_mpu_configure_static_mpu_regions+0x5c>)
    6b38:	f009 fa96 	bl	10068 <printk>
    6b3c:	f240 1103 	movw	r1, #259	; 0x103
    6b40:	4803      	ldr	r0, [pc, #12]	; (6b50 <arm_core_mpu_configure_static_mpu_regions+0x50>)
    6b42:	f00a f8d9 	bl	10cf8 <assert_post_action>
			regions_num);
	}
}
    6b46:	bf00      	nop
    6b48:	3710      	adds	r7, #16
    6b4a:	46bd      	mov	sp, r7
    6b4c:	bd80      	pop	{r7, pc}
    6b4e:	bf00      	nop
    6b50:	00019c60 	.word	0x00019c60
    6b54:	00019ca0 	.word	0x00019ca0
    6b58:	00019ca4 	.word	0x00019ca4
    6b5c:	00019cc4 	.word	0x00019cc4

00006b60 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct k_mem_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
    6b60:	b580      	push	{r7, lr}
    6b62:	b082      	sub	sp, #8
    6b64:	af00      	add	r7, sp, #0
    6b66:	6078      	str	r0, [r7, #4]
    6b68:	460b      	mov	r3, r1
    6b6a:	70fb      	strb	r3, [r7, #3]
	if (mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    6b6c:	78fb      	ldrb	r3, [r7, #3]
    6b6e:	4619      	mov	r1, r3
    6b70:	6878      	ldr	r0, [r7, #4]
    6b72:	f7ff fe4d 	bl	6810 <mpu_mark_areas_for_dynamic_regions>
    6b76:	4603      	mov	r3, r0
    6b78:	f113 0f16 	cmn.w	r3, #22
    6b7c:	d110      	bne.n	6ba0 <arm_core_mpu_mark_areas_for_dynamic_regions+0x40>
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
    6b7e:	f240 1313 	movw	r3, #275	; 0x113
    6b82:	4a09      	ldr	r2, [pc, #36]	; (6ba8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x48>)
    6b84:	4909      	ldr	r1, [pc, #36]	; (6bac <arm_core_mpu_mark_areas_for_dynamic_regions+0x4c>)
    6b86:	480a      	ldr	r0, [pc, #40]	; (6bb0 <arm_core_mpu_mark_areas_for_dynamic_regions+0x50>)
    6b88:	f009 fa6e 	bl	10068 <printk>
    6b8c:	78fb      	ldrb	r3, [r7, #3]
    6b8e:	4619      	mov	r1, r3
    6b90:	4808      	ldr	r0, [pc, #32]	; (6bb4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>)
    6b92:	f009 fa69 	bl	10068 <printk>
    6b96:	f240 1113 	movw	r1, #275	; 0x113
    6b9a:	4803      	ldr	r0, [pc, #12]	; (6ba8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x48>)
    6b9c:	f00a f8ac 	bl	10cf8 <assert_post_action>
			dyn_region_areas_num);
	}
}
    6ba0:	bf00      	nop
    6ba2:	3708      	adds	r7, #8
    6ba4:	46bd      	mov	sp, r7
    6ba6:	bd80      	pop	{r7, pc}
    6ba8:	00019c60 	.word	0x00019c60
    6bac:	00019ca0 	.word	0x00019ca0
    6bb0:	00019ca4 	.word	0x00019ca4
    6bb4:	00019cf0 	.word	0x00019cf0

00006bb8 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(const struct device *arg)
{
    6bb8:	b590      	push	{r4, r7, lr}
    6bba:	b087      	sub	sp, #28
    6bbc:	af00      	add	r7, sp, #0
    6bbe:	6078      	str	r0, [r7, #4]
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    6bc0:	4b48      	ldr	r3, [pc, #288]	; (6ce4 <arm_mpu_init+0x12c>)
    6bc2:	681c      	ldr	r4, [r3, #0]
    6bc4:	f00c f9c1 	bl	12f4a <get_num_regions>
    6bc8:	4603      	mov	r3, r0
    6bca:	429c      	cmp	r4, r3
    6bcc:	d918      	bls.n	6c00 <arm_mpu_init+0x48>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
    6bce:	f44f 739d 	mov.w	r3, #314	; 0x13a
    6bd2:	4a45      	ldr	r2, [pc, #276]	; (6ce8 <arm_mpu_init+0x130>)
    6bd4:	4945      	ldr	r1, [pc, #276]	; (6cec <arm_mpu_init+0x134>)
    6bd6:	4846      	ldr	r0, [pc, #280]	; (6cf0 <arm_mpu_init+0x138>)
    6bd8:	f009 fa46 	bl	10068 <printk>
    6bdc:	4b41      	ldr	r3, [pc, #260]	; (6ce4 <arm_mpu_init+0x12c>)
    6bde:	681c      	ldr	r4, [r3, #0]
    6be0:	f00c f9b3 	bl	12f4a <get_num_regions>
    6be4:	4603      	mov	r3, r0
    6be6:	461a      	mov	r2, r3
    6be8:	4621      	mov	r1, r4
    6bea:	4842      	ldr	r0, [pc, #264]	; (6cf4 <arm_mpu_init+0x13c>)
    6bec:	f009 fa3c 	bl	10068 <printk>
    6bf0:	f44f 719d 	mov.w	r1, #314	; 0x13a
    6bf4:	483c      	ldr	r0, [pc, #240]	; (6ce8 <arm_mpu_init+0x130>)
    6bf6:	f00a f87f 	bl	10cf8 <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
    6bfa:	f04f 33ff 	mov.w	r3, #4294967295
    6bfe:	e06c      	b.n	6cda <arm_mpu_init+0x122>
	}

	LOG_DBG("total region count: %d", get_num_regions());
    6c00:	2303      	movs	r3, #3
    6c02:	2b03      	cmp	r3, #3
    6c04:	d934      	bls.n	6c70 <arm_mpu_init+0xb8>
    6c06:	f00c f984 	bl	12f12 <_is_user_context>
    6c0a:	4603      	mov	r3, r0
    6c0c:	75fb      	strb	r3, [r7, #23]
    6c0e:	7b3b      	ldrb	r3, [r7, #12]
    6c10:	2204      	movs	r2, #4
    6c12:	f362 0302 	bfi	r3, r2, #0, #3
    6c16:	733b      	strb	r3, [r7, #12]
    6c18:	7b3b      	ldrb	r3, [r7, #12]
    6c1a:	f36f 03c5 	bfc	r3, #3, #3
    6c1e:	733b      	strb	r3, [r7, #12]
    6c20:	2303      	movs	r3, #3
    6c22:	2b00      	cmp	r3, #0
    6c24:	d009      	beq.n	6c3a <arm_mpu_init+0x82>
    6c26:	4b34      	ldr	r3, [pc, #208]	; (6cf8 <arm_mpu_init+0x140>)
    6c28:	681b      	ldr	r3, [r3, #0]
    6c2a:	4618      	mov	r0, r3
    6c2c:	f7ff fade 	bl	61ec <log_const_source_id>
    6c30:	4603      	mov	r3, r0
    6c32:	f3c3 0309 	ubfx	r3, r3, #0, #10
    6c36:	b29a      	uxth	r2, r3
    6c38:	e000      	b.n	6c3c <arm_mpu_init+0x84>
    6c3a:	2200      	movs	r2, #0
    6c3c:	89bb      	ldrh	r3, [r7, #12]
    6c3e:	f362 138f 	bfi	r3, r2, #6, #10
    6c42:	81bb      	strh	r3, [r7, #12]
    6c44:	7dfb      	ldrb	r3, [r7, #23]
    6c46:	2b00      	cmp	r3, #0
    6c48:	d008      	beq.n	6c5c <arm_mpu_init+0xa4>
    6c4a:	f00c f97e 	bl	12f4a <get_num_regions>
    6c4e:	4603      	mov	r3, r0
    6c50:	4a2a      	ldr	r2, [pc, #168]	; (6cfc <arm_mpu_init+0x144>)
    6c52:	492b      	ldr	r1, [pc, #172]	; (6d00 <arm_mpu_init+0x148>)
    6c54:	89b8      	ldrh	r0, [r7, #12]
    6c56:	f7fb fe4b 	bl	28f0 <log_from_user>
    6c5a:	e009      	b.n	6c70 <arm_mpu_init+0xb8>
    6c5c:	4c27      	ldr	r4, [pc, #156]	; (6cfc <arm_mpu_init+0x144>)
    6c5e:	f00c f974 	bl	12f4a <get_num_regions>
    6c62:	4603      	mov	r3, r0
    6c64:	461a      	mov	r2, r3
    6c66:	89bb      	ldrh	r3, [r7, #12]
    6c68:	4621      	mov	r1, r4
    6c6a:	4825      	ldr	r0, [pc, #148]	; (6d00 <arm_mpu_init+0x148>)
    6c6c:	f00a fd05 	bl	1167a <log_2>

	arm_core_mpu_disable();
    6c70:	f7ff ff38 	bl	6ae4 <arm_core_mpu_disable>
	SCB_CleanInvalidateDCache();
#endif
#endif /* CONFIG_NOCACHE_MEMORY */

	/* Architecture-specific configuration */
	mpu_init();
    6c74:	f7ff faca 	bl	620c <mpu_init>

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    6c78:	2300      	movs	r3, #0
    6c7a:	613b      	str	r3, [r7, #16]
    6c7c:	e00b      	b.n	6c96 <arm_mpu_init+0xde>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    6c7e:	4b19      	ldr	r3, [pc, #100]	; (6ce4 <arm_mpu_init+0x12c>)
    6c80:	685a      	ldr	r2, [r3, #4]
    6c82:	693b      	ldr	r3, [r7, #16]
    6c84:	011b      	lsls	r3, r3, #4
    6c86:	4413      	add	r3, r2
    6c88:	4619      	mov	r1, r3
    6c8a:	6938      	ldr	r0, [r7, #16]
    6c8c:	f7ff facc 	bl	6228 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    6c90:	693b      	ldr	r3, [r7, #16]
    6c92:	3301      	adds	r3, #1
    6c94:	613b      	str	r3, [r7, #16]
    6c96:	4b13      	ldr	r3, [pc, #76]	; (6ce4 <arm_mpu_init+0x12c>)
    6c98:	681b      	ldr	r3, [r3, #0]
    6c9a:	693a      	ldr	r2, [r7, #16]
    6c9c:	429a      	cmp	r2, r3
    6c9e:	d3ee      	bcc.n	6c7e <arm_mpu_init+0xc6>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    6ca0:	4b10      	ldr	r3, [pc, #64]	; (6ce4 <arm_mpu_init+0x12c>)
    6ca2:	681b      	ldr	r3, [r3, #0]
    6ca4:	b2da      	uxtb	r2, r3
    6ca6:	4b17      	ldr	r3, [pc, #92]	; (6d04 <arm_mpu_init+0x14c>)
    6ca8:	701a      	strb	r2, [r3, #0]


	arm_core_mpu_enable();
    6caa:	f7ff ff09 	bl	6ac0 <arm_core_mpu_enable>
	defined(CONFIG_CPU_CORTEX_M4)
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
		"Invalid number of MPU regions\n");
#elif defined(NUM_MPU_REGIONS)
	__ASSERT(
    6cae:	4b16      	ldr	r3, [pc, #88]	; (6d08 <arm_mpu_init+0x150>)
    6cb0:	681b      	ldr	r3, [r3, #0]
    6cb2:	0a1b      	lsrs	r3, r3, #8
    6cb4:	b2db      	uxtb	r3, r3
    6cb6:	2b10      	cmp	r3, #16
    6cb8:	d00e      	beq.n	6cd8 <arm_mpu_init+0x120>
    6cba:	f240 1365 	movw	r3, #357	; 0x165
    6cbe:	4a0a      	ldr	r2, [pc, #40]	; (6ce8 <arm_mpu_init+0x130>)
    6cc0:	4912      	ldr	r1, [pc, #72]	; (6d0c <arm_mpu_init+0x154>)
    6cc2:	480b      	ldr	r0, [pc, #44]	; (6cf0 <arm_mpu_init+0x138>)
    6cc4:	f009 f9d0 	bl	10068 <printk>
    6cc8:	4811      	ldr	r0, [pc, #68]	; (6d10 <arm_mpu_init+0x158>)
    6cca:	f009 f9cd 	bl	10068 <printk>
    6cce:	f240 1165 	movw	r1, #357	; 0x165
    6cd2:	4805      	ldr	r0, [pc, #20]	; (6ce8 <arm_mpu_init+0x130>)
    6cd4:	f00a f810 	bl	10cf8 <assert_post_action>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    6cd8:	2300      	movs	r3, #0
}
    6cda:	4618      	mov	r0, r3
    6cdc:	371c      	adds	r7, #28
    6cde:	46bd      	mov	sp, r7
    6ce0:	bd90      	pop	{r4, r7, pc}
    6ce2:	bf00      	nop
    6ce4:	0001cbb8 	.word	0x0001cbb8
    6ce8:	00019c60 	.word	0x00019c60
    6cec:	00019ca0 	.word	0x00019ca0
    6cf0:	00019ca4 	.word	0x00019ca4
    6cf4:	00019d50 	.word	0x00019d50
    6cf8:	200000f8 	.word	0x200000f8
    6cfc:	0001cb88 	.word	0x0001cb88
    6d00:	00019d84 	.word	0x00019d84
    6d04:	20000d43 	.word	0x20000d43
    6d08:	e000ed90 	.word	0xe000ed90
    6d0c:	00019da0 	.word	0x00019da0
    6d10:	00019df4 	.word	0x00019df4

00006d14 <__stdout_hook_install>:
}

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
    6d14:	b480      	push	{r7}
    6d16:	b083      	sub	sp, #12
    6d18:	af00      	add	r7, sp, #0
    6d1a:	6078      	str	r0, [r7, #4]
	_stdout_hook = hook;
    6d1c:	4a03      	ldr	r2, [pc, #12]	; (6d2c <__stdout_hook_install+0x18>)
    6d1e:	687b      	ldr	r3, [r7, #4]
    6d20:	6013      	str	r3, [r2, #0]
}
    6d22:	bf00      	nop
    6d24:	370c      	adds	r7, #12
    6d26:	46bd      	mov	sp, r7
    6d28:	bc80      	pop	{r7}
    6d2a:	4770      	bx	lr
    6d2c:	200000fc 	.word	0x200000fc

00006d30 <nrf_gpio_pin_port_decode>:
 *                      that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
    6d30:	b580      	push	{r7, lr}
    6d32:	b082      	sub	sp, #8
    6d34:	af00      	add	r7, sp, #0
    6d36:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    6d38:	687b      	ldr	r3, [r7, #4]
    6d3a:	681b      	ldr	r3, [r3, #0]
    6d3c:	4618      	mov	r0, r3
    6d3e:	f00c fc70 	bl	13622 <nrf_gpio_pin_present_check>
    6d42:	4603      	mov	r3, r0
    6d44:	f083 0301 	eor.w	r3, r3, #1
    6d48:	b2db      	uxtb	r3, r3
    6d4a:	2b00      	cmp	r3, #0
    6d4c:	d00b      	beq.n	6d66 <nrf_gpio_pin_port_decode+0x36>
    6d4e:	f240 231a 	movw	r3, #538	; 0x21a
    6d52:	4a10      	ldr	r2, [pc, #64]	; (6d94 <nrf_gpio_pin_port_decode+0x64>)
    6d54:	4910      	ldr	r1, [pc, #64]	; (6d98 <nrf_gpio_pin_port_decode+0x68>)
    6d56:	4811      	ldr	r0, [pc, #68]	; (6d9c <nrf_gpio_pin_port_decode+0x6c>)
    6d58:	f009 f986 	bl	10068 <printk>
    6d5c:	f240 211a 	movw	r1, #538	; 0x21a
    6d60:	480c      	ldr	r0, [pc, #48]	; (6d94 <nrf_gpio_pin_port_decode+0x64>)
    6d62:	f009 ffc9 	bl	10cf8 <assert_post_action>

    switch (nrf_gpio_pin_port_number_extract(p_pin))
    6d66:	6878      	ldr	r0, [r7, #4]
    6d68:	f00c fc7f 	bl	1366a <nrf_gpio_pin_port_number_extract>
    6d6c:	4603      	mov	r3, r0
    6d6e:	2b00      	cmp	r3, #0
    6d70:	d00b      	beq.n	6d8a <nrf_gpio_pin_port_decode+0x5a>
    {
        default:
            NRFX_ASSERT(0);
    6d72:	f240 231f 	movw	r3, #543	; 0x21f
    6d76:	4a07      	ldr	r2, [pc, #28]	; (6d94 <nrf_gpio_pin_port_decode+0x64>)
    6d78:	4909      	ldr	r1, [pc, #36]	; (6da0 <nrf_gpio_pin_port_decode+0x70>)
    6d7a:	4808      	ldr	r0, [pc, #32]	; (6d9c <nrf_gpio_pin_port_decode+0x6c>)
    6d7c:	f009 f974 	bl	10068 <printk>
    6d80:	f240 211f 	movw	r1, #543	; 0x21f
    6d84:	4803      	ldr	r0, [pc, #12]	; (6d94 <nrf_gpio_pin_port_decode+0x64>)
    6d86:	f009 ffb7 	bl	10cf8 <assert_post_action>
#if defined(P0_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 0: return NRF_P0;
    6d8a:	4b06      	ldr	r3, [pc, #24]	; (6da4 <nrf_gpio_pin_port_decode+0x74>)
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
#endif
    }
}
    6d8c:	4618      	mov	r0, r3
    6d8e:	3708      	adds	r7, #8
    6d90:	46bd      	mov	sp, r7
    6d92:	bd80      	pop	{r7, pc}
    6d94:	00019e28 	.word	0x00019e28
    6d98:	00019e5c 	.word	0x00019e5c
    6d9c:	00019e80 	.word	0x00019e80
    6da0:	00019ea0 	.word	0x00019ea0
    6da4:	50842500 	.word	0x50842500

00006da8 <gpio_manage_callback>:
 * @return 0 on success, negative errno otherwise.
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
    6da8:	b580      	push	{r7, lr}
    6daa:	b084      	sub	sp, #16
    6dac:	af00      	add	r7, sp, #0
    6dae:	60f8      	str	r0, [r7, #12]
    6db0:	60b9      	str	r1, [r7, #8]
    6db2:	4613      	mov	r3, r2
    6db4:	71fb      	strb	r3, [r7, #7]
	__ASSERT(callback, "No callback!");
    6db6:	68bb      	ldr	r3, [r7, #8]
    6db8:	2b00      	cmp	r3, #0
    6dba:	d10c      	bne.n	6dd6 <gpio_manage_callback+0x2e>
    6dbc:	2324      	movs	r3, #36	; 0x24
    6dbe:	4a23      	ldr	r2, [pc, #140]	; (6e4c <gpio_manage_callback+0xa4>)
    6dc0:	4923      	ldr	r1, [pc, #140]	; (6e50 <gpio_manage_callback+0xa8>)
    6dc2:	4824      	ldr	r0, [pc, #144]	; (6e54 <gpio_manage_callback+0xac>)
    6dc4:	f009 f950 	bl	10068 <printk>
    6dc8:	4823      	ldr	r0, [pc, #140]	; (6e58 <gpio_manage_callback+0xb0>)
    6dca:	f009 f94d 	bl	10068 <printk>
    6dce:	2124      	movs	r1, #36	; 0x24
    6dd0:	481e      	ldr	r0, [pc, #120]	; (6e4c <gpio_manage_callback+0xa4>)
    6dd2:	f009 ff91 	bl	10cf8 <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
    6dd6:	68bb      	ldr	r3, [r7, #8]
    6dd8:	685b      	ldr	r3, [r3, #4]
    6dda:	2b00      	cmp	r3, #0
    6ddc:	d10c      	bne.n	6df8 <gpio_manage_callback+0x50>
    6dde:	2325      	movs	r3, #37	; 0x25
    6de0:	4a1a      	ldr	r2, [pc, #104]	; (6e4c <gpio_manage_callback+0xa4>)
    6de2:	491e      	ldr	r1, [pc, #120]	; (6e5c <gpio_manage_callback+0xb4>)
    6de4:	481b      	ldr	r0, [pc, #108]	; (6e54 <gpio_manage_callback+0xac>)
    6de6:	f009 f93f 	bl	10068 <printk>
    6dea:	481d      	ldr	r0, [pc, #116]	; (6e60 <gpio_manage_callback+0xb8>)
    6dec:	f009 f93c 	bl	10068 <printk>
    6df0:	2125      	movs	r1, #37	; 0x25
    6df2:	4816      	ldr	r0, [pc, #88]	; (6e4c <gpio_manage_callback+0xa4>)
    6df4:	f009 ff80 	bl	10cf8 <assert_post_action>

	if (!sys_slist_is_empty(callbacks)) {
    6df8:	68f8      	ldr	r0, [r7, #12]
    6dfa:	f00c fa8c 	bl	13316 <sys_slist_is_empty>
    6dfe:	4603      	mov	r3, r0
    6e00:	f083 0301 	eor.w	r3, r3, #1
    6e04:	b2db      	uxtb	r3, r3
    6e06:	2b00      	cmp	r3, #0
    6e08:	d013      	beq.n	6e32 <gpio_manage_callback+0x8a>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    6e0a:	68bb      	ldr	r3, [r7, #8]
    6e0c:	4619      	mov	r1, r3
    6e0e:	68f8      	ldr	r0, [r7, #12]
    6e10:	f00c fb0e 	bl	13430 <sys_slist_find_and_remove>
    6e14:	4603      	mov	r3, r0
    6e16:	f083 0301 	eor.w	r3, r3, #1
    6e1a:	b2db      	uxtb	r3, r3
    6e1c:	2b00      	cmp	r3, #0
    6e1e:	d008      	beq.n	6e32 <gpio_manage_callback+0x8a>
			if (!set) {
    6e20:	79fb      	ldrb	r3, [r7, #7]
    6e22:	f083 0301 	eor.w	r3, r3, #1
    6e26:	b2db      	uxtb	r3, r3
    6e28:	2b00      	cmp	r3, #0
    6e2a:	d002      	beq.n	6e32 <gpio_manage_callback+0x8a>
				return -EINVAL;
    6e2c:	f06f 0315 	mvn.w	r3, #21
    6e30:	e008      	b.n	6e44 <gpio_manage_callback+0x9c>
			}
		}
	}

	if (set) {
    6e32:	79fb      	ldrb	r3, [r7, #7]
    6e34:	2b00      	cmp	r3, #0
    6e36:	d004      	beq.n	6e42 <gpio_manage_callback+0x9a>
		sys_slist_prepend(callbacks, &callback->node);
    6e38:	68bb      	ldr	r3, [r7, #8]
    6e3a:	4619      	mov	r1, r3
    6e3c:	68f8      	ldr	r0, [r7, #12]
    6e3e:	f00c fa98 	bl	13372 <sys_slist_prepend>
	}

	return 0;
    6e42:	2300      	movs	r3, #0
}
    6e44:	4618      	mov	r0, r3
    6e46:	3710      	adds	r7, #16
    6e48:	46bd      	mov	sp, r7
    6e4a:	bd80      	pop	{r7, pc}
    6e4c:	00019ea4 	.word	0x00019ea4
    6e50:	00019ed4 	.word	0x00019ed4
    6e54:	00019e80 	.word	0x00019e80
    6e58:	00019ee0 	.word	0x00019ee0
    6e5c:	00019ef0 	.word	0x00019ef0
    6e60:	00019f04 	.word	0x00019f04

00006e64 <gpio_fire_callbacks>:
 * @param pins The actual pin mask that triggered the interrupt
 */
static inline void gpio_fire_callbacks(sys_slist_t *list,
					const struct device *port,
					uint32_t pins)
{
    6e64:	b580      	push	{r7, lr}
    6e66:	b086      	sub	sp, #24
    6e68:	af00      	add	r7, sp, #0
    6e6a:	60f8      	str	r0, [r7, #12]
    6e6c:	60b9      	str	r1, [r7, #8]
    6e6e:	607a      	str	r2, [r7, #4]
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    6e70:	68f8      	ldr	r0, [r7, #12]
    6e72:	f00c fa3a 	bl	132ea <sys_slist_peek_head>
    6e76:	4603      	mov	r3, r0
    6e78:	2b00      	cmp	r3, #0
    6e7a:	d004      	beq.n	6e86 <gpio_fire_callbacks+0x22>
    6e7c:	68f8      	ldr	r0, [r7, #12]
    6e7e:	f00c fa34 	bl	132ea <sys_slist_peek_head>
    6e82:	4603      	mov	r3, r0
    6e84:	e000      	b.n	6e88 <gpio_fire_callbacks+0x24>
    6e86:	2300      	movs	r3, #0
    6e88:	617b      	str	r3, [r7, #20]
    6e8a:	697b      	ldr	r3, [r7, #20]
    6e8c:	2b00      	cmp	r3, #0
    6e8e:	d00e      	beq.n	6eae <gpio_fire_callbacks+0x4a>
    6e90:	697b      	ldr	r3, [r7, #20]
    6e92:	4618      	mov	r0, r3
    6e94:	f00c fa5c 	bl	13350 <sys_slist_peek_next>
    6e98:	4603      	mov	r3, r0
    6e9a:	2b00      	cmp	r3, #0
    6e9c:	d005      	beq.n	6eaa <gpio_fire_callbacks+0x46>
    6e9e:	697b      	ldr	r3, [r7, #20]
    6ea0:	4618      	mov	r0, r3
    6ea2:	f00c fa55 	bl	13350 <sys_slist_peek_next>
    6ea6:	4603      	mov	r3, r0
    6ea8:	e002      	b.n	6eb0 <gpio_fire_callbacks+0x4c>
    6eaa:	2300      	movs	r3, #0
    6eac:	e000      	b.n	6eb0 <gpio_fire_callbacks+0x4c>
    6eae:	2300      	movs	r3, #0
    6eb0:	613b      	str	r3, [r7, #16]
    6eb2:	e035      	b.n	6f20 <gpio_fire_callbacks+0xbc>
		if (cb->pin_mask & pins) {
    6eb4:	697b      	ldr	r3, [r7, #20]
    6eb6:	689a      	ldr	r2, [r3, #8]
    6eb8:	687b      	ldr	r3, [r7, #4]
    6eba:	4013      	ands	r3, r2
    6ebc:	2b00      	cmp	r3, #0
    6ebe:	d019      	beq.n	6ef4 <gpio_fire_callbacks+0x90>
			__ASSERT(cb->handler, "No callback handler!");
    6ec0:	697b      	ldr	r3, [r7, #20]
    6ec2:	685b      	ldr	r3, [r3, #4]
    6ec4:	2b00      	cmp	r3, #0
    6ec6:	d10c      	bne.n	6ee2 <gpio_fire_callbacks+0x7e>
    6ec8:	2345      	movs	r3, #69	; 0x45
    6eca:	4a19      	ldr	r2, [pc, #100]	; (6f30 <gpio_fire_callbacks+0xcc>)
    6ecc:	4919      	ldr	r1, [pc, #100]	; (6f34 <gpio_fire_callbacks+0xd0>)
    6ece:	481a      	ldr	r0, [pc, #104]	; (6f38 <gpio_fire_callbacks+0xd4>)
    6ed0:	f009 f8ca 	bl	10068 <printk>
    6ed4:	4819      	ldr	r0, [pc, #100]	; (6f3c <gpio_fire_callbacks+0xd8>)
    6ed6:	f009 f8c7 	bl	10068 <printk>
    6eda:	2145      	movs	r1, #69	; 0x45
    6edc:	4814      	ldr	r0, [pc, #80]	; (6f30 <gpio_fire_callbacks+0xcc>)
    6ede:	f009 ff0b 	bl	10cf8 <assert_post_action>
			cb->handler(port, cb, cb->pin_mask & pins);
    6ee2:	697b      	ldr	r3, [r7, #20]
    6ee4:	685b      	ldr	r3, [r3, #4]
    6ee6:	697a      	ldr	r2, [r7, #20]
    6ee8:	6891      	ldr	r1, [r2, #8]
    6eea:	687a      	ldr	r2, [r7, #4]
    6eec:	400a      	ands	r2, r1
    6eee:	6979      	ldr	r1, [r7, #20]
    6ef0:	68b8      	ldr	r0, [r7, #8]
    6ef2:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    6ef4:	693b      	ldr	r3, [r7, #16]
    6ef6:	617b      	str	r3, [r7, #20]
    6ef8:	697b      	ldr	r3, [r7, #20]
    6efa:	2b00      	cmp	r3, #0
    6efc:	d00e      	beq.n	6f1c <gpio_fire_callbacks+0xb8>
    6efe:	697b      	ldr	r3, [r7, #20]
    6f00:	4618      	mov	r0, r3
    6f02:	f00c fa25 	bl	13350 <sys_slist_peek_next>
    6f06:	4603      	mov	r3, r0
    6f08:	2b00      	cmp	r3, #0
    6f0a:	d005      	beq.n	6f18 <gpio_fire_callbacks+0xb4>
    6f0c:	697b      	ldr	r3, [r7, #20]
    6f0e:	4618      	mov	r0, r3
    6f10:	f00c fa1e 	bl	13350 <sys_slist_peek_next>
    6f14:	4603      	mov	r3, r0
    6f16:	e002      	b.n	6f1e <gpio_fire_callbacks+0xba>
    6f18:	2300      	movs	r3, #0
    6f1a:	e000      	b.n	6f1e <gpio_fire_callbacks+0xba>
    6f1c:	2300      	movs	r3, #0
    6f1e:	613b      	str	r3, [r7, #16]
    6f20:	697b      	ldr	r3, [r7, #20]
    6f22:	2b00      	cmp	r3, #0
    6f24:	d1c6      	bne.n	6eb4 <gpio_fire_callbacks+0x50>
		}
	}
}
    6f26:	bf00      	nop
    6f28:	bf00      	nop
    6f2a:	3718      	adds	r7, #24
    6f2c:	46bd      	mov	sp, r7
    6f2e:	bd80      	pop	{r7, pc}
    6f30:	00019ea4 	.word	0x00019ea4
    6f34:	00019f1c 	.word	0x00019f1c
    6f38:	00019e80 	.word	0x00019e80
    6f3c:	00019f04 	.word	0x00019f04

00006f40 <gpiote_channel_alloc>:
	return port->config;
}

static int gpiote_channel_alloc(atomic_t *mask, uint32_t abs_pin,
				nrf_gpiote_polarity_t polarity)
{
    6f40:	b580      	push	{r7, lr}
    6f42:	b088      	sub	sp, #32
    6f44:	af00      	add	r7, sp, #0
    6f46:	60f8      	str	r0, [r7, #12]
    6f48:	60b9      	str	r1, [r7, #8]
    6f4a:	4613      	mov	r3, r2
    6f4c:	71fb      	strb	r3, [r7, #7]
	for (uint8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    6f4e:	2300      	movs	r3, #0
    6f50:	77fb      	strb	r3, [r7, #31]
    6f52:	e032      	b.n	6fba <gpiote_channel_alloc+0x7a>
		atomic_val_t prev = atomic_or(mask, BIT(channel));
    6f54:	7ffb      	ldrb	r3, [r7, #31]
    6f56:	2201      	movs	r2, #1
    6f58:	fa02 f303 	lsl.w	r3, r2, r3
    6f5c:	4619      	mov	r1, r3
    6f5e:	68f8      	ldr	r0, [r7, #12]
    6f60:	f00c fa8b 	bl	1347a <atomic_or>
    6f64:	61b8      	str	r0, [r7, #24]

		if ((prev & BIT(channel)) == 0) {
    6f66:	69ba      	ldr	r2, [r7, #24]
    6f68:	7ffb      	ldrb	r3, [r7, #31]
    6f6a:	fa22 f303 	lsr.w	r3, r2, r3
    6f6e:	f003 0301 	and.w	r3, r3, #1
    6f72:	2b00      	cmp	r3, #0
    6f74:	d11e      	bne.n	6fb4 <gpiote_channel_alloc+0x74>
			nrf_gpiote_event_t evt =
    6f76:	7ffb      	ldrb	r3, [r7, #31]
    6f78:	3340      	adds	r3, #64	; 0x40
    6f7a:	b29b      	uxth	r3, r3
    6f7c:	009b      	lsls	r3, r3, #2
    6f7e:	82fb      	strh	r3, [r7, #22]
				offsetof(NRF_GPIOTE_Type, EVENTS_IN[channel]);

			nrf_gpiote_event_configure(NRF_GPIOTE, channel, abs_pin,
    6f80:	7ff9      	ldrb	r1, [r7, #31]
    6f82:	79fb      	ldrb	r3, [r7, #7]
    6f84:	68ba      	ldr	r2, [r7, #8]
    6f86:	4811      	ldr	r0, [pc, #68]	; (6fcc <gpiote_channel_alloc+0x8c>)
    6f88:	f00c fc1b 	bl	137c2 <nrf_gpiote_event_configure>
						   polarity);
			nrf_gpiote_event_clear(NRF_GPIOTE, evt);
    6f8c:	8afb      	ldrh	r3, [r7, #22]
    6f8e:	4619      	mov	r1, r3
    6f90:	480e      	ldr	r0, [pc, #56]	; (6fcc <gpiote_channel_alloc+0x8c>)
    6f92:	f00c fb91 	bl	136b8 <nrf_gpiote_event_clear>
			nrf_gpiote_event_enable(NRF_GPIOTE, channel);
    6f96:	7ffb      	ldrb	r3, [r7, #31]
    6f98:	4619      	mov	r1, r3
    6f9a:	480c      	ldr	r0, [pc, #48]	; (6fcc <gpiote_channel_alloc+0x8c>)
    6f9c:	f00c fbe1 	bl	13762 <nrf_gpiote_event_enable>
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    6fa0:	7ffb      	ldrb	r3, [r7, #31]
    6fa2:	2201      	movs	r2, #1
    6fa4:	fa02 f303 	lsl.w	r3, r2, r3
    6fa8:	4619      	mov	r1, r3
    6faa:	4808      	ldr	r0, [pc, #32]	; (6fcc <gpiote_channel_alloc+0x8c>)
    6fac:	f00c fbae 	bl	1370c <nrf_gpiote_int_enable>
			return 0;
    6fb0:	2300      	movs	r3, #0
    6fb2:	e007      	b.n	6fc4 <gpiote_channel_alloc+0x84>
	for (uint8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    6fb4:	7ffb      	ldrb	r3, [r7, #31]
    6fb6:	3301      	adds	r3, #1
    6fb8:	77fb      	strb	r3, [r7, #31]
    6fba:	7ffb      	ldrb	r3, [r7, #31]
    6fbc:	2b07      	cmp	r3, #7
    6fbe:	d9c9      	bls.n	6f54 <gpiote_channel_alloc+0x14>
		}
	}

	return -ENODEV;
    6fc0:	f06f 0312 	mvn.w	r3, #18
}
    6fc4:	4618      	mov	r0, r3
    6fc6:	3720      	adds	r7, #32
    6fc8:	46bd      	mov	sp, r7
    6fca:	bd80      	pop	{r7, pc}
    6fcc:	5000d000 	.word	0x5000d000

00006fd0 <gpiote_pin_cleanup>:

/* Function checks if given pin does not have already enabled GPIOTE event and
 * disables it.
 */
static void gpiote_pin_cleanup(atomic_t *mask, uint32_t abs_pin)
{
    6fd0:	b580      	push	{r7, lr}
    6fd2:	b084      	sub	sp, #16
    6fd4:	af00      	add	r7, sp, #0
    6fd6:	6078      	str	r0, [r7, #4]
    6fd8:	6039      	str	r1, [r7, #0]
	uint32_t intenset = nrf_gpiote_int_enable_check(NRF_GPIOTE,
    6fda:	21ff      	movs	r1, #255	; 0xff
    6fdc:	481a      	ldr	r0, [pc, #104]	; (7048 <gpiote_pin_cleanup+0x78>)
    6fde:	f00c fbb1 	bl	13744 <nrf_gpiote_int_enable_check>
    6fe2:	60b8      	str	r0, [r7, #8]
						     NRF_GPIOTE_INT_IN_MASK);

	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    6fe4:	2300      	movs	r3, #0
    6fe6:	60fb      	str	r3, [r7, #12]
    6fe8:	e028      	b.n	703c <gpiote_pin_cleanup+0x6c>
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    6fea:	68f9      	ldr	r1, [r7, #12]
    6fec:	4816      	ldr	r0, [pc, #88]	; (7048 <gpiote_pin_cleanup+0x78>)
    6fee:	f00c fc1b 	bl	13828 <nrf_gpiote_event_pin_get>
    6ff2:	4602      	mov	r2, r0
    6ff4:	683b      	ldr	r3, [r7, #0]
    6ff6:	4293      	cmp	r3, r2
    6ff8:	d11d      	bne.n	7036 <gpiote_pin_cleanup+0x66>
		    && (intenset & BIT(i))) {
    6ffa:	68ba      	ldr	r2, [r7, #8]
    6ffc:	68fb      	ldr	r3, [r7, #12]
    6ffe:	fa22 f303 	lsr.w	r3, r2, r3
    7002:	f003 0301 	and.w	r3, r3, #1
    7006:	2b00      	cmp	r3, #0
    7008:	d015      	beq.n	7036 <gpiote_pin_cleanup+0x66>
			(void)atomic_and(mask, ~BIT(i));
    700a:	2201      	movs	r2, #1
    700c:	68fb      	ldr	r3, [r7, #12]
    700e:	fa02 f303 	lsl.w	r3, r2, r3
    7012:	43db      	mvns	r3, r3
    7014:	4619      	mov	r1, r3
    7016:	6878      	ldr	r0, [r7, #4]
    7018:	f00c fa45 	bl	134a6 <atomic_and>
			nrf_gpiote_event_disable(NRF_GPIOTE, i);
    701c:	68f9      	ldr	r1, [r7, #12]
    701e:	480a      	ldr	r0, [pc, #40]	; (7048 <gpiote_pin_cleanup+0x78>)
    7020:	f00c fbb7 	bl	13792 <nrf_gpiote_event_disable>
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    7024:	2201      	movs	r2, #1
    7026:	68fb      	ldr	r3, [r7, #12]
    7028:	fa02 f303 	lsl.w	r3, r2, r3
    702c:	4619      	mov	r1, r3
    702e:	4806      	ldr	r0, [pc, #24]	; (7048 <gpiote_pin_cleanup+0x78>)
    7030:	f00c fb7a 	bl	13728 <nrf_gpiote_int_disable>
			return;
    7034:	e005      	b.n	7042 <gpiote_pin_cleanup+0x72>
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    7036:	68fb      	ldr	r3, [r7, #12]
    7038:	3301      	adds	r3, #1
    703a:	60fb      	str	r3, [r7, #12]
    703c:	68fb      	ldr	r3, [r7, #12]
    703e:	2b07      	cmp	r3, #7
    7040:	d9d3      	bls.n	6fea <gpiote_pin_cleanup+0x1a>
		}
	}
}
    7042:	3710      	adds	r7, #16
    7044:	46bd      	mov	sp, r7
    7046:	bd80      	pop	{r7, pc}
    7048:	5000d000 	.word	0x5000d000

0000704c <gpiote_pin_int_cfg>:
	}
	return NRF_GPIO_PIN_SENSE_LOW;
}

static int gpiote_pin_int_cfg(const struct device *port, uint32_t pin)
{
    704c:	b580      	push	{r7, lr}
    704e:	b088      	sub	sp, #32
    7050:	af00      	add	r7, sp, #0
    7052:	6078      	str	r0, [r7, #4]
    7054:	6039      	str	r1, [r7, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
    7056:	6878      	ldr	r0, [r7, #4]
    7058:	f00c fbf9 	bl	1384e <get_port_data>
    705c:	6178      	str	r0, [r7, #20]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
    705e:	6878      	ldr	r0, [r7, #4]
    7060:	f00c fc00 	bl	13864 <get_port_cfg>
    7064:	6138      	str	r0, [r7, #16]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    7066:	693b      	ldr	r3, [r7, #16]
    7068:	7a1b      	ldrb	r3, [r3, #8]
    706a:	015b      	lsls	r3, r3, #5
    706c:	461a      	mov	r2, r3
    706e:	683b      	ldr	r3, [r7, #0]
    7070:	f003 031f 	and.w	r3, r3, #31
    7074:	4313      	orrs	r3, r2
    7076:	60fb      	str	r3, [r7, #12]
	int res = 0;
    7078:	2300      	movs	r3, #0
    707a:	61fb      	str	r3, [r7, #28]

	gpiote_pin_cleanup(&gpiote_alloc_mask, abs_pin);
    707c:	68f9      	ldr	r1, [r7, #12]
    707e:	4825      	ldr	r0, [pc, #148]	; (7114 <gpiote_pin_int_cfg+0xc8>)
    7080:	f7ff ffa6 	bl	6fd0 <gpiote_pin_cleanup>
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
    7084:	2100      	movs	r1, #0
    7086:	68f8      	ldr	r0, [r7, #12]
    7088:	f00c fa57 	bl	1353a <nrf_gpio_cfg_sense_set>

	/* Pins trigger interrupts only if pin has been configured to do so */
	if (data->pin_int_en & BIT(pin)) {
    708c:	697b      	ldr	r3, [r7, #20]
    708e:	68da      	ldr	r2, [r3, #12]
    7090:	683b      	ldr	r3, [r7, #0]
    7092:	fa22 f303 	lsr.w	r3, r2, r3
    7096:	f003 0301 	and.w	r3, r3, #1
    709a:	2b00      	cmp	r3, #0
    709c:	d035      	beq.n	710a <gpiote_pin_int_cfg+0xbe>
		if (data->trig_edge & BIT(pin)) {
    709e:	697b      	ldr	r3, [r7, #20]
    70a0:	695a      	ldr	r2, [r3, #20]
    70a2:	683b      	ldr	r3, [r7, #0]
    70a4:	fa22 f303 	lsr.w	r3, r2, r3
    70a8:	f003 0301 	and.w	r3, r3, #1
    70ac:	2b00      	cmp	r3, #0
    70ae:	d021      	beq.n	70f4 <gpiote_pin_int_cfg+0xa8>
		/* For edge triggering we use GPIOTE channels. */
			nrf_gpiote_polarity_t pol;

			if (data->double_edge & BIT(pin)) {
    70b0:	697b      	ldr	r3, [r7, #20]
    70b2:	699a      	ldr	r2, [r3, #24]
    70b4:	683b      	ldr	r3, [r7, #0]
    70b6:	fa22 f303 	lsr.w	r3, r2, r3
    70ba:	f003 0301 	and.w	r3, r3, #1
    70be:	2b00      	cmp	r3, #0
    70c0:	d002      	beq.n	70c8 <gpiote_pin_int_cfg+0x7c>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    70c2:	2303      	movs	r3, #3
    70c4:	76fb      	strb	r3, [r7, #27]
    70c6:	e00d      	b.n	70e4 <gpiote_pin_int_cfg+0x98>
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    70c8:	697b      	ldr	r3, [r7, #20]
    70ca:	691a      	ldr	r2, [r3, #16]
    70cc:	683b      	ldr	r3, [r7, #0]
    70ce:	fa22 f303 	lsr.w	r3, r2, r3
    70d2:	f003 0301 	and.w	r3, r3, #1
    70d6:	2b00      	cmp	r3, #0
    70d8:	d002      	beq.n	70e0 <gpiote_pin_int_cfg+0x94>
				pol = NRF_GPIOTE_POLARITY_LOTOHI;
    70da:	2301      	movs	r3, #1
    70dc:	76fb      	strb	r3, [r7, #27]
    70de:	e001      	b.n	70e4 <gpiote_pin_int_cfg+0x98>
			} else {
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    70e0:	2302      	movs	r3, #2
    70e2:	76fb      	strb	r3, [r7, #27]
			}

			res = gpiote_channel_alloc(&gpiote_alloc_mask,
    70e4:	7efb      	ldrb	r3, [r7, #27]
    70e6:	461a      	mov	r2, r3
    70e8:	68f9      	ldr	r1, [r7, #12]
    70ea:	480a      	ldr	r0, [pc, #40]	; (7114 <gpiote_pin_int_cfg+0xc8>)
    70ec:	f7ff ff28 	bl	6f40 <gpiote_channel_alloc>
    70f0:	61f8      	str	r0, [r7, #28]
    70f2:	e00a      	b.n	710a <gpiote_pin_int_cfg+0xbe>
						   abs_pin, pol);
		} else {
		/* For level triggering we use sense mechanism. */
			uint32_t sense = sense_for_pin(data, pin);
    70f4:	6839      	ldr	r1, [r7, #0]
    70f6:	6978      	ldr	r0, [r7, #20]
    70f8:	f00c fbbf 	bl	1387a <sense_for_pin>
    70fc:	60b8      	str	r0, [r7, #8]

			nrf_gpio_cfg_sense_set(abs_pin, sense);
    70fe:	68bb      	ldr	r3, [r7, #8]
    7100:	b2db      	uxtb	r3, r3
    7102:	4619      	mov	r1, r3
    7104:	68f8      	ldr	r0, [r7, #12]
    7106:	f00c fa18 	bl	1353a <nrf_gpio_cfg_sense_set>
		}
	}
	return res;
    710a:	69fb      	ldr	r3, [r7, #28]
}
    710c:	4618      	mov	r0, r3
    710e:	3720      	adds	r7, #32
    7110:	46bd      	mov	sp, r7
    7112:	bd80      	pop	{r7, pc}
    7114:	20000c5c 	.word	0x20000c5c

00007118 <gpio_nrfx_config>:

static int gpio_nrfx_config(const struct device *port,
			    gpio_pin_t pin, gpio_flags_t flags)
{
    7118:	b590      	push	{r4, r7, lr}
    711a:	b08b      	sub	sp, #44	; 0x2c
    711c:	af02      	add	r7, sp, #8
    711e:	60f8      	str	r0, [r7, #12]
    7120:	460b      	mov	r3, r1
    7122:	607a      	str	r2, [r7, #4]
    7124:	72fb      	strb	r3, [r7, #11]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    7126:	68f8      	ldr	r0, [r7, #12]
    7128:	f00c fb9c 	bl	13864 <get_port_cfg>
    712c:	4603      	mov	r3, r0
    712e:	685b      	ldr	r3, [r3, #4]
    7130:	61bb      	str	r3, [r7, #24]
	nrf_gpio_pin_pull_t pull;
	nrf_gpio_pin_drive_t drive;
	nrf_gpio_pin_dir_t dir;
	nrf_gpio_pin_input_t input;

	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    7132:	687a      	ldr	r2, [r7, #4]
    7134:	4b4f      	ldr	r3, [pc, #316]	; (7274 <gpio_nrfx_config+0x15c>)
    7136:	4013      	ands	r3, r2
    7138:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    713c:	d02f      	beq.n	719e <gpio_nrfx_config+0x86>
    713e:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    7142:	d838      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    7144:	4a4c      	ldr	r2, [pc, #304]	; (7278 <gpio_nrfx_config+0x160>)
    7146:	4293      	cmp	r3, r2
    7148:	d032      	beq.n	71b0 <gpio_nrfx_config+0x98>
    714a:	4a4b      	ldr	r2, [pc, #300]	; (7278 <gpio_nrfx_config+0x160>)
    714c:	4293      	cmp	r3, r2
    714e:	d832      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    7150:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    7154:	d01a      	beq.n	718c <gpio_nrfx_config+0x74>
    7156:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    715a:	d82c      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    715c:	4a47      	ldr	r2, [pc, #284]	; (727c <gpio_nrfx_config+0x164>)
    715e:	4293      	cmp	r3, r2
    7160:	d020      	beq.n	71a4 <gpio_nrfx_config+0x8c>
    7162:	4a46      	ldr	r2, [pc, #280]	; (727c <gpio_nrfx_config+0x164>)
    7164:	4293      	cmp	r3, r2
    7166:	d826      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    7168:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    716c:	d014      	beq.n	7198 <gpio_nrfx_config+0x80>
    716e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    7172:	d820      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    7174:	2b06      	cmp	r3, #6
    7176:	d00c      	beq.n	7192 <gpio_nrfx_config+0x7a>
    7178:	2b06      	cmp	r3, #6
    717a:	d81c      	bhi.n	71b6 <gpio_nrfx_config+0x9e>
    717c:	2b00      	cmp	r3, #0
    717e:	d002      	beq.n	7186 <gpio_nrfx_config+0x6e>
    7180:	2b02      	cmp	r3, #2
    7182:	d012      	beq.n	71aa <gpio_nrfx_config+0x92>
    7184:	e017      	b.n	71b6 <gpio_nrfx_config+0x9e>
			 GPIO_OPEN_DRAIN)) {
	case GPIO_DS_DFLT_LOW | GPIO_DS_DFLT_HIGH:
		drive = NRF_GPIO_PIN_S0S1;
    7186:	2300      	movs	r3, #0
    7188:	77bb      	strb	r3, [r7, #30]
		break;
    718a:	e017      	b.n	71bc <gpio_nrfx_config+0xa4>
	case GPIO_DS_DFLT_LOW | GPIO_DS_ALT_HIGH:
		drive = NRF_GPIO_PIN_S0H1;
    718c:	2302      	movs	r3, #2
    718e:	77bb      	strb	r3, [r7, #30]
		break;
    7190:	e014      	b.n	71bc <gpio_nrfx_config+0xa4>
	case GPIO_DS_DFLT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_S0D1;
    7192:	2306      	movs	r3, #6
    7194:	77bb      	strb	r3, [r7, #30]
		break;
    7196:	e011      	b.n	71bc <gpio_nrfx_config+0xa4>

	case GPIO_DS_ALT_LOW | GPIO_DS_DFLT_HIGH:
		drive = NRF_GPIO_PIN_H0S1;
    7198:	2301      	movs	r3, #1
    719a:	77bb      	strb	r3, [r7, #30]
		break;
    719c:	e00e      	b.n	71bc <gpio_nrfx_config+0xa4>
	case GPIO_DS_ALT_LOW | GPIO_DS_ALT_HIGH:
		drive = NRF_GPIO_PIN_H0H1;
    719e:	2303      	movs	r3, #3
    71a0:	77bb      	strb	r3, [r7, #30]
		break;
    71a2:	e00b      	b.n	71bc <gpio_nrfx_config+0xa4>
	case GPIO_DS_ALT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_H0D1;
    71a4:	2307      	movs	r3, #7
    71a6:	77bb      	strb	r3, [r7, #30]
		break;
    71a8:	e008      	b.n	71bc <gpio_nrfx_config+0xa4>

	case GPIO_DS_DFLT_HIGH | GPIO_OPEN_SOURCE:
		drive = NRF_GPIO_PIN_D0S1;
    71aa:	2304      	movs	r3, #4
    71ac:	77bb      	strb	r3, [r7, #30]
		break;
    71ae:	e005      	b.n	71bc <gpio_nrfx_config+0xa4>
	case GPIO_DS_ALT_HIGH | GPIO_OPEN_SOURCE:
		drive = NRF_GPIO_PIN_D0H1;
    71b0:	2305      	movs	r3, #5
    71b2:	77bb      	strb	r3, [r7, #30]
		break;
    71b4:	e002      	b.n	71bc <gpio_nrfx_config+0xa4>

	default:
		return -EINVAL;
    71b6:	f06f 0315 	mvn.w	r3, #21
    71ba:	e057      	b.n	726c <gpio_nrfx_config+0x154>
	}

	if ((flags & GPIO_PULL_UP) != 0) {
    71bc:	687b      	ldr	r3, [r7, #4]
    71be:	f003 0310 	and.w	r3, r3, #16
    71c2:	2b00      	cmp	r3, #0
    71c4:	d002      	beq.n	71cc <gpio_nrfx_config+0xb4>
		pull = NRF_GPIO_PIN_PULLUP;
    71c6:	2303      	movs	r3, #3
    71c8:	77fb      	strb	r3, [r7, #31]
    71ca:	e009      	b.n	71e0 <gpio_nrfx_config+0xc8>
	} else if ((flags & GPIO_PULL_DOWN) != 0) {
    71cc:	687b      	ldr	r3, [r7, #4]
    71ce:	f003 0320 	and.w	r3, r3, #32
    71d2:	2b00      	cmp	r3, #0
    71d4:	d002      	beq.n	71dc <gpio_nrfx_config+0xc4>
		pull = NRF_GPIO_PIN_PULLDOWN;
    71d6:	2301      	movs	r3, #1
    71d8:	77fb      	strb	r3, [r7, #31]
    71da:	e001      	b.n	71e0 <gpio_nrfx_config+0xc8>
	} else {
		pull = NRF_GPIO_PIN_NOPULL;
    71dc:	2300      	movs	r3, #0
    71de:	77fb      	strb	r3, [r7, #31]
	}

	dir = ((flags & GPIO_OUTPUT) != 0)
	      ? NRF_GPIO_PIN_DIR_OUTPUT
	      : NRF_GPIO_PIN_DIR_INPUT;
    71e0:	687b      	ldr	r3, [r7, #4]
    71e2:	0a5b      	lsrs	r3, r3, #9
    71e4:	b2db      	uxtb	r3, r3
	dir = ((flags & GPIO_OUTPUT) != 0)
    71e6:	f003 0301 	and.w	r3, r3, #1
    71ea:	75fb      	strb	r3, [r7, #23]

	input = ((flags & GPIO_INPUT) != 0)
    71ec:	687b      	ldr	r3, [r7, #4]
    71ee:	f403 7380 	and.w	r3, r3, #256	; 0x100
		? NRF_GPIO_PIN_INPUT_CONNECT
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    71f2:	2b00      	cmp	r3, #0
    71f4:	bf0c      	ite	eq
    71f6:	2301      	moveq	r3, #1
    71f8:	2300      	movne	r3, #0
    71fa:	b2db      	uxtb	r3, r3
	input = ((flags & GPIO_INPUT) != 0)
    71fc:	75bb      	strb	r3, [r7, #22]

	if ((flags & GPIO_OUTPUT) != 0) {
    71fe:	687b      	ldr	r3, [r7, #4]
    7200:	f403 7300 	and.w	r3, r3, #512	; 0x200
    7204:	2b00      	cmp	r3, #0
    7206:	d01a      	beq.n	723e <gpio_nrfx_config+0x126>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    7208:	687b      	ldr	r3, [r7, #4]
    720a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    720e:	2b00      	cmp	r3, #0
    7210:	d008      	beq.n	7224 <gpio_nrfx_config+0x10c>
			nrf_gpio_port_out_set(reg, BIT(pin));
    7212:	7afb      	ldrb	r3, [r7, #11]
    7214:	2201      	movs	r2, #1
    7216:	fa02 f303 	lsl.w	r3, r2, r3
    721a:	4619      	mov	r1, r3
    721c:	69b8      	ldr	r0, [r7, #24]
    721e:	f00c f9e6 	bl	135ee <nrf_gpio_port_out_set>
    7222:	e00c      	b.n	723e <gpio_nrfx_config+0x126>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    7224:	687b      	ldr	r3, [r7, #4]
    7226:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    722a:	2b00      	cmp	r3, #0
    722c:	d007      	beq.n	723e <gpio_nrfx_config+0x126>
			nrf_gpio_port_out_clear(reg, BIT(pin));
    722e:	7afb      	ldrb	r3, [r7, #11]
    7230:	2201      	movs	r2, #1
    7232:	fa02 f303 	lsl.w	r3, r2, r3
    7236:	4619      	mov	r1, r3
    7238:	69b8      	ldr	r0, [r7, #24]
    723a:	f00c f9e5 	bl	13608 <nrf_gpio_port_out_clear>
		}
	}

	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
    723e:	68f8      	ldr	r0, [r7, #12]
    7240:	f00c fb10 	bl	13864 <get_port_cfg>
    7244:	4603      	mov	r3, r0
    7246:	7a1b      	ldrb	r3, [r3, #8]
    7248:	015a      	lsls	r2, r3, #5
    724a:	7afb      	ldrb	r3, [r7, #11]
    724c:	f003 031f 	and.w	r3, r3, #31
    7250:	4313      	orrs	r3, r2
    7252:	461c      	mov	r4, r3
    7254:	7ff8      	ldrb	r0, [r7, #31]
    7256:	7dba      	ldrb	r2, [r7, #22]
    7258:	7df9      	ldrb	r1, [r7, #23]
    725a:	2300      	movs	r3, #0
    725c:	9301      	str	r3, [sp, #4]
    725e:	7fbb      	ldrb	r3, [r7, #30]
    7260:	9300      	str	r3, [sp, #0]
    7262:	4603      	mov	r3, r0
    7264:	4620      	mov	r0, r4
    7266:	f00c f93f 	bl	134e8 <nrf_gpio_cfg>
		     dir, input, pull, drive, NRF_GPIO_PIN_NOSENSE);

	return 0;
    726a:	2300      	movs	r3, #0
}
    726c:	4618      	mov	r0, r3
    726e:	3724      	adds	r7, #36	; 0x24
    7270:	46bd      	mov	sp, r7
    7272:	bd90      	pop	{r4, r7, pc}
    7274:	00f00006 	.word	0x00f00006
    7278:	00400002 	.word	0x00400002
    727c:	00100006 	.word	0x00100006

00007280 <gpiote_event_handler>:
#ifdef CONFIG_GPIO_NRF_P1
DEVICE_DECLARE(gpio_nrfx_p1);
#endif

static void gpiote_event_handler(void)
{
    7280:	b580      	push	{r7, lr}
    7282:	b084      	sub	sp, #16
    7284:	af00      	add	r7, sp, #0
	uint32_t fired_triggers[GPIO_COUNT] = {0};
    7286:	2300      	movs	r3, #0
    7288:	603b      	str	r3, [r7, #0]
	bool port_event = nrf_gpiote_event_check(NRF_GPIOTE,
    728a:	f44f 71be 	mov.w	r1, #380	; 0x17c
    728e:	4832      	ldr	r0, [pc, #200]	; (7358 <gpiote_event_handler+0xd8>)
    7290:	f00c f9fe 	bl	13690 <nrf_gpiote_event_check>
    7294:	4603      	mov	r3, r0
    7296:	72fb      	strb	r3, [r7, #11]
						 NRF_GPIOTE_EVENT_PORT);

	if (port_event) {
    7298:	7afb      	ldrb	r3, [r7, #11]
    729a:	2b00      	cmp	r3, #0
    729c:	d009      	beq.n	72b2 <gpiote_event_handler+0x32>
#ifdef CONFIG_GPIO_NRF_P0
		fired_triggers[0] =
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
    729e:	482f      	ldr	r0, [pc, #188]	; (735c <gpiote_event_handler+0xdc>)
    72a0:	f00c fc75 	bl	13b8e <check_level_trigger_pins>
    72a4:	4603      	mov	r3, r0
		fired_triggers[0] =
    72a6:	603b      	str	r3, [r7, #0]
#endif

		/* Sense detect was disabled while checking pins so
		 * DETECT should be deasserted.
		 */
		nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
    72a8:	f44f 71be 	mov.w	r1, #380	; 0x17c
    72ac:	482a      	ldr	r0, [pc, #168]	; (7358 <gpiote_event_handler+0xd8>)
    72ae:	f00c fa03 	bl	136b8 <nrf_gpiote_event_clear>
	}

	/* Handle interrupt from GPIOTE channels. */
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    72b2:	2300      	movs	r3, #0
    72b4:	60fb      	str	r3, [r7, #12]
    72b6:	e039      	b.n	732c <gpiote_event_handler+0xac>
		nrf_gpiote_event_t evt =
    72b8:	68fb      	ldr	r3, [r7, #12]
    72ba:	3340      	adds	r3, #64	; 0x40
    72bc:	b29b      	uxth	r3, r3
    72be:	009b      	lsls	r3, r3, #2
    72c0:	813b      	strh	r3, [r7, #8]
			offsetof(NRF_GPIOTE_Type, EVENTS_IN[i]);

		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    72c2:	2201      	movs	r2, #1
    72c4:	68fb      	ldr	r3, [r7, #12]
    72c6:	fa02 f303 	lsl.w	r3, r2, r3
    72ca:	4619      	mov	r1, r3
    72cc:	4822      	ldr	r0, [pc, #136]	; (7358 <gpiote_event_handler+0xd8>)
    72ce:	f00c fa39 	bl	13744 <nrf_gpiote_int_enable_check>
    72d2:	4603      	mov	r3, r0
    72d4:	2b00      	cmp	r3, #0
    72d6:	d026      	beq.n	7326 <gpiote_event_handler+0xa6>
		    nrf_gpiote_event_check(NRF_GPIOTE, evt)) {
    72d8:	893b      	ldrh	r3, [r7, #8]
    72da:	4619      	mov	r1, r3
    72dc:	481e      	ldr	r0, [pc, #120]	; (7358 <gpiote_event_handler+0xd8>)
    72de:	f00c f9d7 	bl	13690 <nrf_gpiote_event_check>
    72e2:	4603      	mov	r3, r0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    72e4:	2b00      	cmp	r3, #0
    72e6:	d01e      	beq.n	7326 <gpiote_event_handler+0xa6>
			uint32_t abs_pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
    72e8:	68f9      	ldr	r1, [r7, #12]
    72ea:	481b      	ldr	r0, [pc, #108]	; (7358 <gpiote_event_handler+0xd8>)
    72ec:	f00c fa9c 	bl	13828 <nrf_gpiote_event_pin_get>
    72f0:	6078      	str	r0, [r7, #4]
			/* Divide absolute pin number to port and pin parts. */
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    72f2:	687b      	ldr	r3, [r7, #4]
    72f4:	095a      	lsrs	r2, r3, #5
    72f6:	0093      	lsls	r3, r2, #2
    72f8:	f107 0110 	add.w	r1, r7, #16
    72fc:	440b      	add	r3, r1
    72fe:	f853 1c10 	ldr.w	r1, [r3, #-16]
    7302:	687b      	ldr	r3, [r7, #4]
    7304:	f003 031f 	and.w	r3, r3, #31
    7308:	2001      	movs	r0, #1
    730a:	fa00 f303 	lsl.w	r3, r0, r3
    730e:	4319      	orrs	r1, r3
    7310:	0093      	lsls	r3, r2, #2
    7312:	f107 0210 	add.w	r2, r7, #16
    7316:	4413      	add	r3, r2
    7318:	f843 1c10 	str.w	r1, [r3, #-16]
			nrf_gpiote_event_clear(NRF_GPIOTE, evt);
    731c:	893b      	ldrh	r3, [r7, #8]
    731e:	4619      	mov	r1, r3
    7320:	480d      	ldr	r0, [pc, #52]	; (7358 <gpiote_event_handler+0xd8>)
    7322:	f00c f9c9 	bl	136b8 <nrf_gpiote_event_clear>
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    7326:	68fb      	ldr	r3, [r7, #12]
    7328:	3301      	adds	r3, #1
    732a:	60fb      	str	r3, [r7, #12]
    732c:	68fb      	ldr	r3, [r7, #12]
    732e:	2b07      	cmp	r3, #7
    7330:	d9c2      	bls.n	72b8 <gpiote_event_handler+0x38>
		}
	}

#ifdef CONFIG_GPIO_NRF_P0
	if (fired_triggers[0]) {
    7332:	683b      	ldr	r3, [r7, #0]
    7334:	2b00      	cmp	r3, #0
    7336:	d004      	beq.n	7342 <gpiote_event_handler+0xc2>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
    7338:	683b      	ldr	r3, [r7, #0]
    733a:	4619      	mov	r1, r3
    733c:	4807      	ldr	r0, [pc, #28]	; (735c <gpiote_event_handler+0xdc>)
    733e:	f00c fc73 	bl	13c28 <fire_callbacks>
	if (fired_triggers[1]) {
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
	}
#endif

	if (port_event) {
    7342:	7afb      	ldrb	r3, [r7, #11]
    7344:	2b00      	cmp	r3, #0
    7346:	d002      	beq.n	734e <gpiote_event_handler+0xce>
		/* Reprogram sense to match current configuration.
		 * This may cause DETECT to be re-asserted.
		 */
#ifdef CONFIG_GPIO_NRF_P0
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
    7348:	4804      	ldr	r0, [pc, #16]	; (735c <gpiote_event_handler+0xdc>)
    734a:	f00c fbdc 	bl	13b06 <cfg_level_pins>
#endif
#ifdef CONFIG_GPIO_NRF_P1
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
#endif
	}
}
    734e:	bf00      	nop
    7350:	3710      	adds	r7, #16
    7352:	46bd      	mov	sp, r7
    7354:	bd80      	pop	{r7, pc}
    7356:	bf00      	nop
    7358:	5000d000 	.word	0x5000d000
    735c:	20000228 	.word	0x20000228

00007360 <gpio_nrfx_init>:

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    7360:	b580      	push	{r7, lr}
    7362:	b082      	sub	sp, #8
    7364:	af00      	add	r7, sp, #0
    7366:	6078      	str	r0, [r7, #4]
	static bool gpio_initialized;

	if (!gpio_initialized) {
    7368:	4b0d      	ldr	r3, [pc, #52]	; (73a0 <gpio_nrfx_init+0x40>)
    736a:	781b      	ldrb	r3, [r3, #0]
    736c:	f083 0301 	eor.w	r3, r3, #1
    7370:	b2db      	uxtb	r3, r3
    7372:	2b00      	cmp	r3, #0
    7374:	d00f      	beq.n	7396 <gpio_nrfx_init+0x36>
		gpio_initialized = true;
    7376:	4b0a      	ldr	r3, [pc, #40]	; (73a0 <gpio_nrfx_init+0x40>)
    7378:	2201      	movs	r2, #1
    737a:	701a      	strb	r2, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    737c:	2200      	movs	r2, #0
    737e:	2105      	movs	r1, #5
    7380:	200d      	movs	r0, #13
    7382:	f7fd fbbf 	bl	4b04 <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
    7386:	200d      	movs	r0, #13
    7388:	f00b fcf9 	bl	12d7e <arch_irq_enable>
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
    738c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    7390:	4804      	ldr	r0, [pc, #16]	; (73a4 <gpio_nrfx_init+0x44>)
    7392:	f00c f9bb 	bl	1370c <nrf_gpiote_int_enable>
	}

	return 0;
    7396:	2300      	movs	r3, #0
}
    7398:	4618      	mov	r0, r3
    739a:	3708      	adds	r7, #8
    739c:	46bd      	mov	sp, r7
    739e:	bd80      	pop	{r7, pc}
    73a0:	20000d44 	.word	0x20000d44
    73a4:	5000d000 	.word	0x5000d000

000073a8 <k_is_pre_kernel>:
{
    73a8:	b480      	push	{r7}
    73aa:	af00      	add	r7, sp, #0
	return !z_sys_post_kernel;
    73ac:	4b08      	ldr	r3, [pc, #32]	; (73d0 <k_is_pre_kernel+0x28>)
    73ae:	781b      	ldrb	r3, [r3, #0]
    73b0:	2b00      	cmp	r3, #0
    73b2:	bf14      	ite	ne
    73b4:	2301      	movne	r3, #1
    73b6:	2300      	moveq	r3, #0
    73b8:	b2db      	uxtb	r3, r3
    73ba:	f083 0301 	eor.w	r3, r3, #1
    73be:	b2db      	uxtb	r3, r3
    73c0:	f003 0301 	and.w	r3, r3, #1
    73c4:	b2db      	uxtb	r3, r3
}
    73c6:	4618      	mov	r0, r3
    73c8:	46bd      	mov	sp, r7
    73ca:	bc80      	pop	{r7}
    73cc:	4770      	bx	lr
    73ce:	bf00      	nop
    73d0:	20000d45 	.word	0x20000d45

000073d4 <nrf_gpio_pin_port_decode>:
{
    73d4:	b580      	push	{r7, lr}
    73d6:	b082      	sub	sp, #8
    73d8:	af00      	add	r7, sp, #0
    73da:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    73dc:	687b      	ldr	r3, [r7, #4]
    73de:	681b      	ldr	r3, [r3, #0]
    73e0:	4618      	mov	r0, r3
    73e2:	f00c febe 	bl	14162 <nrf_gpio_pin_present_check>
    73e6:	4603      	mov	r3, r0
    73e8:	f083 0301 	eor.w	r3, r3, #1
    73ec:	b2db      	uxtb	r3, r3
    73ee:	2b00      	cmp	r3, #0
    73f0:	d00b      	beq.n	740a <nrf_gpio_pin_port_decode+0x36>
    73f2:	f240 231a 	movw	r3, #538	; 0x21a
    73f6:	4a10      	ldr	r2, [pc, #64]	; (7438 <nrf_gpio_pin_port_decode+0x64>)
    73f8:	4910      	ldr	r1, [pc, #64]	; (743c <nrf_gpio_pin_port_decode+0x68>)
    73fa:	4811      	ldr	r0, [pc, #68]	; (7440 <nrf_gpio_pin_port_decode+0x6c>)
    73fc:	f008 fe34 	bl	10068 <printk>
    7400:	f240 211a 	movw	r1, #538	; 0x21a
    7404:	480c      	ldr	r0, [pc, #48]	; (7438 <nrf_gpio_pin_port_decode+0x64>)
    7406:	f009 fc77 	bl	10cf8 <assert_post_action>
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    740a:	6878      	ldr	r0, [r7, #4]
    740c:	f00c fecd 	bl	141aa <nrf_gpio_pin_port_number_extract>
    7410:	4603      	mov	r3, r0
    7412:	2b00      	cmp	r3, #0
    7414:	d00b      	beq.n	742e <nrf_gpio_pin_port_decode+0x5a>
            NRFX_ASSERT(0);
    7416:	f240 231f 	movw	r3, #543	; 0x21f
    741a:	4a07      	ldr	r2, [pc, #28]	; (7438 <nrf_gpio_pin_port_decode+0x64>)
    741c:	4909      	ldr	r1, [pc, #36]	; (7444 <nrf_gpio_pin_port_decode+0x70>)
    741e:	4808      	ldr	r0, [pc, #32]	; (7440 <nrf_gpio_pin_port_decode+0x6c>)
    7420:	f008 fe22 	bl	10068 <printk>
    7424:	f240 211f 	movw	r1, #543	; 0x21f
    7428:	4803      	ldr	r0, [pc, #12]	; (7438 <nrf_gpio_pin_port_decode+0x64>)
    742a:	f009 fc65 	bl	10cf8 <assert_post_action>
        case 0: return NRF_P0;
    742e:	4b06      	ldr	r3, [pc, #24]	; (7448 <nrf_gpio_pin_port_decode+0x74>)
}
    7430:	4618      	mov	r0, r3
    7432:	3708      	adds	r7, #8
    7434:	46bd      	mov	sp, r7
    7436:	bd80      	pop	{r7, pc}
    7438:	00019f30 	.word	0x00019f30
    743c:	00019f64 	.word	0x00019f64
    7440:	00019f88 	.word	0x00019f88
    7444:	00019fa8 	.word	0x00019fa8
    7448:	50842500 	.word	0x50842500

0000744c <log_const_source_id>:
{
    744c:	b480      	push	{r7}
    744e:	b083      	sub	sp, #12
    7450:	af00      	add	r7, sp, #0
    7452:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    7454:	687b      	ldr	r3, [r7, #4]
    7456:	4a04      	ldr	r2, [pc, #16]	; (7468 <log_const_source_id+0x1c>)
    7458:	1a9b      	subs	r3, r3, r2
    745a:	08db      	lsrs	r3, r3, #3
}
    745c:	4618      	mov	r0, r3
    745e:	370c      	adds	r7, #12
    7460:	46bd      	mov	sp, r7
    7462:	bc80      	pop	{r7}
    7464:	4770      	bx	lr
    7466:	bf00      	nop
    7468:	00018788 	.word	0x00018788

0000746c <nrfx_gppi_channels_enable>:
{
    nrf_dppi_channels_disable_all(NRF_DPPIC);
}

__STATIC_INLINE void nrfx_gppi_channels_enable(uint32_t mask)
{
    746c:	b580      	push	{r7, lr}
    746e:	b082      	sub	sp, #8
    7470:	af00      	add	r7, sp, #0
    7472:	6078      	str	r0, [r7, #4]
    nrf_dppi_channels_enable(NRF_DPPIC, mask);
    7474:	6879      	ldr	r1, [r7, #4]
    7476:	4803      	ldr	r0, [pc, #12]	; (7484 <nrfx_gppi_channels_enable+0x18>)
    7478:	f00d f83b 	bl	144f2 <nrf_dppi_channels_enable>
}
    747c:	bf00      	nop
    747e:	3708      	adds	r7, #8
    7480:	46bd      	mov	sp, r7
    7482:	bd80      	pop	{r7, pc}
    7484:	50017000 	.word	0x50017000

00007488 <nrfx_gppi_event_endpoint_setup>:
{
    nrf_dppi_task_trigger(NRF_DPPIC, (nrf_dppi_task_t)task);
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    7488:	b580      	push	{r7, lr}
    748a:	b082      	sub	sp, #8
    748c:	af00      	add	r7, sp, #0
    748e:	4603      	mov	r3, r0
    7490:	6039      	str	r1, [r7, #0]
    7492:	71fb      	strb	r3, [r7, #7]
    NRFX_ASSERT(eep);
    7494:	683b      	ldr	r3, [r7, #0]
    7496:	2b00      	cmp	r3, #0
    7498:	d10b      	bne.n	74b2 <nrfx_gppi_event_endpoint_setup+0x2a>
    749a:	f44f 73f5 	mov.w	r3, #490	; 0x1ea
    749e:	4a0a      	ldr	r2, [pc, #40]	; (74c8 <nrfx_gppi_event_endpoint_setup+0x40>)
    74a0:	490a      	ldr	r1, [pc, #40]	; (74cc <nrfx_gppi_event_endpoint_setup+0x44>)
    74a2:	480b      	ldr	r0, [pc, #44]	; (74d0 <nrfx_gppi_event_endpoint_setup+0x48>)
    74a4:	f008 fde0 	bl	10068 <printk>
    74a8:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
    74ac:	4806      	ldr	r0, [pc, #24]	; (74c8 <nrfx_gppi_event_endpoint_setup+0x40>)
    74ae:	f009 fc23 	bl	10cf8 <assert_post_action>
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    74b2:	79fb      	ldrb	r3, [r7, #7]
    74b4:	683a      	ldr	r2, [r7, #0]
    74b6:	3280      	adds	r2, #128	; 0x80
    74b8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    74bc:	6013      	str	r3, [r2, #0]
}
    74be:	bf00      	nop
    74c0:	3708      	adds	r7, #8
    74c2:	46bd      	mov	sp, r7
    74c4:	bd80      	pop	{r7, pc}
    74c6:	bf00      	nop
    74c8:	00019fac 	.word	0x00019fac
    74cc:	00019fe4 	.word	0x00019fe4
    74d0:	00019f88 	.word	0x00019f88

000074d4 <nrfx_gppi_task_endpoint_setup>:

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    74d4:	b580      	push	{r7, lr}
    74d6:	b082      	sub	sp, #8
    74d8:	af00      	add	r7, sp, #0
    74da:	4603      	mov	r3, r0
    74dc:	6039      	str	r1, [r7, #0]
    74de:	71fb      	strb	r3, [r7, #7]
    NRFX_ASSERT(tep);
    74e0:	683b      	ldr	r3, [r7, #0]
    74e2:	2b00      	cmp	r3, #0
    74e4:	d10b      	bne.n	74fe <nrfx_gppi_task_endpoint_setup+0x2a>
    74e6:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
    74ea:	4a0a      	ldr	r2, [pc, #40]	; (7514 <nrfx_gppi_task_endpoint_setup+0x40>)
    74ec:	490a      	ldr	r1, [pc, #40]	; (7518 <nrfx_gppi_task_endpoint_setup+0x44>)
    74ee:	480b      	ldr	r0, [pc, #44]	; (751c <nrfx_gppi_task_endpoint_setup+0x48>)
    74f0:	f008 fdba 	bl	10068 <printk>
    74f4:	f44f 71f8 	mov.w	r1, #496	; 0x1f0
    74f8:	4806      	ldr	r0, [pc, #24]	; (7514 <nrfx_gppi_task_endpoint_setup+0x40>)
    74fa:	f009 fbfd 	bl	10cf8 <assert_post_action>
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    74fe:	79fb      	ldrb	r3, [r7, #7]
    7500:	683a      	ldr	r2, [r7, #0]
    7502:	3280      	adds	r2, #128	; 0x80
    7504:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    7508:	6013      	str	r3, [r2, #0]
}
    750a:	bf00      	nop
    750c:	3708      	adds	r7, #8
    750e:	46bd      	mov	sp, r7
    7510:	bd80      	pop	{r7, pc}
    7512:	bf00      	nop
    7514:	00019fac 	.word	0x00019fac
    7518:	00019fe8 	.word	0x00019fe8
    751c:	00019f88 	.word	0x00019f88

00007520 <baudrate_set>:
 * @param baudrate Baud rate
 *
 * @return 0 on success or error code
 */
static int baudrate_set(const struct device *dev, uint32_t baudrate)
{
    7520:	b580      	push	{r7, lr}
    7522:	b084      	sub	sp, #16
    7524:	af00      	add	r7, sp, #0
    7526:	6078      	str	r0, [r7, #4]
    7528:	6039      	str	r1, [r7, #0]
	nrf_uarte_baudrate_t nrf_baudrate; /* calculated baudrate divisor */
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
    752a:	6878      	ldr	r0, [r7, #4]
    752c:	f00d f81a 	bl	14564 <get_uarte_instance>
    7530:	60b8      	str	r0, [r7, #8]

	switch (baudrate) {
    7532:	683b      	ldr	r3, [r7, #0]
    7534:	4a83      	ldr	r2, [pc, #524]	; (7744 <baudrate_set+0x224>)
    7536:	4293      	cmp	r3, r2
    7538:	f000 80f3 	beq.w	7722 <baudrate_set+0x202>
    753c:	683b      	ldr	r3, [r7, #0]
    753e:	4a81      	ldr	r2, [pc, #516]	; (7744 <baudrate_set+0x224>)
    7540:	4293      	cmp	r3, r2
    7542:	f200 80f2 	bhi.w	772a <baudrate_set+0x20a>
    7546:	683b      	ldr	r3, [r7, #0]
    7548:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    754c:	f000 80e5 	beq.w	771a <baudrate_set+0x1fa>
    7550:	683b      	ldr	r3, [r7, #0]
    7552:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    7556:	f200 80e8 	bhi.w	772a <baudrate_set+0x20a>
    755a:	683b      	ldr	r3, [r7, #0]
    755c:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    7560:	f000 80d7 	beq.w	7712 <baudrate_set+0x1f2>
    7564:	683b      	ldr	r3, [r7, #0]
    7566:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    756a:	f200 80de 	bhi.w	772a <baudrate_set+0x20a>
    756e:	683b      	ldr	r3, [r7, #0]
    7570:	4a75      	ldr	r2, [pc, #468]	; (7748 <baudrate_set+0x228>)
    7572:	4293      	cmp	r3, r2
    7574:	f000 80c9 	beq.w	770a <baudrate_set+0x1ea>
    7578:	683b      	ldr	r3, [r7, #0]
    757a:	4a73      	ldr	r2, [pc, #460]	; (7748 <baudrate_set+0x228>)
    757c:	4293      	cmp	r3, r2
    757e:	f200 80d4 	bhi.w	772a <baudrate_set+0x20a>
    7582:	683b      	ldr	r3, [r7, #0]
    7584:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    7588:	f000 80bb 	beq.w	7702 <baudrate_set+0x1e2>
    758c:	683b      	ldr	r3, [r7, #0]
    758e:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    7592:	f200 80ca 	bhi.w	772a <baudrate_set+0x20a>
    7596:	683b      	ldr	r3, [r7, #0]
    7598:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    759c:	f000 80ad 	beq.w	76fa <baudrate_set+0x1da>
    75a0:	683b      	ldr	r3, [r7, #0]
    75a2:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    75a6:	f200 80c0 	bhi.w	772a <baudrate_set+0x20a>
    75aa:	683b      	ldr	r3, [r7, #0]
    75ac:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    75b0:	f000 80a0 	beq.w	76f4 <baudrate_set+0x1d4>
    75b4:	683b      	ldr	r3, [r7, #0]
    75b6:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    75ba:	f200 80b6 	bhi.w	772a <baudrate_set+0x20a>
    75be:	683b      	ldr	r3, [r7, #0]
    75c0:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    75c4:	f000 8092 	beq.w	76ec <baudrate_set+0x1cc>
    75c8:	683b      	ldr	r3, [r7, #0]
    75ca:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    75ce:	f200 80ac 	bhi.w	772a <baudrate_set+0x20a>
    75d2:	683b      	ldr	r3, [r7, #0]
    75d4:	f64d 22c0 	movw	r2, #56000	; 0xdac0
    75d8:	4293      	cmp	r3, r2
    75da:	f000 8083 	beq.w	76e4 <baudrate_set+0x1c4>
    75de:	683b      	ldr	r3, [r7, #0]
    75e0:	f64d 22c0 	movw	r2, #56000	; 0xdac0
    75e4:	4293      	cmp	r3, r2
    75e6:	f200 80a0 	bhi.w	772a <baudrate_set+0x20a>
    75ea:	683b      	ldr	r3, [r7, #0]
    75ec:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    75f0:	d074      	beq.n	76dc <baudrate_set+0x1bc>
    75f2:	683b      	ldr	r3, [r7, #0]
    75f4:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    75f8:	f200 8097 	bhi.w	772a <baudrate_set+0x20a>
    75fc:	683b      	ldr	r3, [r7, #0]
    75fe:	f647 2212 	movw	r2, #31250	; 0x7a12
    7602:	4293      	cmp	r3, r2
    7604:	d066      	beq.n	76d4 <baudrate_set+0x1b4>
    7606:	683b      	ldr	r3, [r7, #0]
    7608:	f647 2212 	movw	r2, #31250	; 0x7a12
    760c:	4293      	cmp	r3, r2
    760e:	f200 808c 	bhi.w	772a <baudrate_set+0x20a>
    7612:	683b      	ldr	r3, [r7, #0]
    7614:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    7618:	d059      	beq.n	76ce <baudrate_set+0x1ae>
    761a:	683b      	ldr	r3, [r7, #0]
    761c:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    7620:	f200 8083 	bhi.w	772a <baudrate_set+0x20a>
    7624:	683b      	ldr	r3, [r7, #0]
    7626:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    762a:	d04d      	beq.n	76c8 <baudrate_set+0x1a8>
    762c:	683b      	ldr	r3, [r7, #0]
    762e:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    7632:	d87a      	bhi.n	772a <baudrate_set+0x20a>
    7634:	683b      	ldr	r3, [r7, #0]
    7636:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    763a:	d042      	beq.n	76c2 <baudrate_set+0x1a2>
    763c:	683b      	ldr	r3, [r7, #0]
    763e:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    7642:	d872      	bhi.n	772a <baudrate_set+0x20a>
    7644:	683b      	ldr	r3, [r7, #0]
    7646:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    764a:	d037      	beq.n	76bc <baudrate_set+0x19c>
    764c:	683b      	ldr	r3, [r7, #0]
    764e:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    7652:	d86a      	bhi.n	772a <baudrate_set+0x20a>
    7654:	683b      	ldr	r3, [r7, #0]
    7656:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    765a:	d02c      	beq.n	76b6 <baudrate_set+0x196>
    765c:	683b      	ldr	r3, [r7, #0]
    765e:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    7662:	d862      	bhi.n	772a <baudrate_set+0x20a>
    7664:	683b      	ldr	r3, [r7, #0]
    7666:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    766a:	d020      	beq.n	76ae <baudrate_set+0x18e>
    766c:	683b      	ldr	r3, [r7, #0]
    766e:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    7672:	d85a      	bhi.n	772a <baudrate_set+0x20a>
    7674:	683b      	ldr	r3, [r7, #0]
    7676:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    767a:	d014      	beq.n	76a6 <baudrate_set+0x186>
    767c:	683b      	ldr	r3, [r7, #0]
    767e:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    7682:	d852      	bhi.n	772a <baudrate_set+0x20a>
    7684:	683b      	ldr	r3, [r7, #0]
    7686:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    768a:	d004      	beq.n	7696 <baudrate_set+0x176>
    768c:	683b      	ldr	r3, [r7, #0]
    768e:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    7692:	d004      	beq.n	769e <baudrate_set+0x17e>
    7694:	e049      	b.n	772a <baudrate_set+0x20a>
	case 300:
		/* value not supported by Nordic HAL */
		nrf_baudrate = 0x00014000;
    7696:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    769a:	60fb      	str	r3, [r7, #12]
		break;
    769c:	e048      	b.n	7730 <baudrate_set+0x210>
	case 600:
		/* value not supported by Nordic HAL */
		nrf_baudrate = 0x00027000;
    769e:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    76a2:	60fb      	str	r3, [r7, #12]
		break;
    76a4:	e044      	b.n	7730 <baudrate_set+0x210>
	case 1200:
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    76a6:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    76aa:	60fb      	str	r3, [r7, #12]
		break;
    76ac:	e040      	b.n	7730 <baudrate_set+0x210>
	case 2400:
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    76ae:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    76b2:	60fb      	str	r3, [r7, #12]
		break;
    76b4:	e03c      	b.n	7730 <baudrate_set+0x210>
	case 4800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    76b6:	4b25      	ldr	r3, [pc, #148]	; (774c <baudrate_set+0x22c>)
    76b8:	60fb      	str	r3, [r7, #12]
		break;
    76ba:	e039      	b.n	7730 <baudrate_set+0x210>
	case 9600:
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    76bc:	4b24      	ldr	r3, [pc, #144]	; (7750 <baudrate_set+0x230>)
    76be:	60fb      	str	r3, [r7, #12]
		break;
    76c0:	e036      	b.n	7730 <baudrate_set+0x210>
	case 14400:
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    76c2:	4b24      	ldr	r3, [pc, #144]	; (7754 <baudrate_set+0x234>)
    76c4:	60fb      	str	r3, [r7, #12]
		break;
    76c6:	e033      	b.n	7730 <baudrate_set+0x210>
	case 19200:
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    76c8:	4b23      	ldr	r3, [pc, #140]	; (7758 <baudrate_set+0x238>)
    76ca:	60fb      	str	r3, [r7, #12]
		break;
    76cc:	e030      	b.n	7730 <baudrate_set+0x210>
	case 28800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    76ce:	4b23      	ldr	r3, [pc, #140]	; (775c <baudrate_set+0x23c>)
    76d0:	60fb      	str	r3, [r7, #12]
		break;
    76d2:	e02d      	b.n	7730 <baudrate_set+0x210>
	case 31250:
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    76d4:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    76d8:	60fb      	str	r3, [r7, #12]
		break;
    76da:	e029      	b.n	7730 <baudrate_set+0x210>
	case 38400:
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    76dc:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    76e0:	60fb      	str	r3, [r7, #12]
		break;
    76e2:	e025      	b.n	7730 <baudrate_set+0x210>
	case 56000:
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    76e4:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    76e8:	60fb      	str	r3, [r7, #12]
		break;
    76ea:	e021      	b.n	7730 <baudrate_set+0x210>
	case 57600:
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    76ec:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    76f0:	60fb      	str	r3, [r7, #12]
		break;
    76f2:	e01d      	b.n	7730 <baudrate_set+0x210>
	case 76800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    76f4:	4b1a      	ldr	r3, [pc, #104]	; (7760 <baudrate_set+0x240>)
    76f6:	60fb      	str	r3, [r7, #12]
		break;
    76f8:	e01a      	b.n	7730 <baudrate_set+0x210>
	case 115200:
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    76fa:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    76fe:	60fb      	str	r3, [r7, #12]
		break;
    7700:	e016      	b.n	7730 <baudrate_set+0x210>
	case 230400:
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    7702:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    7706:	60fb      	str	r3, [r7, #12]
		break;
    7708:	e012      	b.n	7730 <baudrate_set+0x210>
	case 250000:
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    770a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    770e:	60fb      	str	r3, [r7, #12]
		break;
    7710:	e00e      	b.n	7730 <baudrate_set+0x210>
	case 460800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    7712:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    7716:	60fb      	str	r3, [r7, #12]
		break;
    7718:	e00a      	b.n	7730 <baudrate_set+0x210>
	case 921600:
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    771a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    771e:	60fb      	str	r3, [r7, #12]
		break;
    7720:	e006      	b.n	7730 <baudrate_set+0x210>
	case 1000000:
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    7722:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    7726:	60fb      	str	r3, [r7, #12]
		break;
    7728:	e002      	b.n	7730 <baudrate_set+0x210>
	default:
		return -EINVAL;
    772a:	f06f 0315 	mvn.w	r3, #21
    772e:	e004      	b.n	773a <baudrate_set+0x21a>
	}

	nrf_uarte_baudrate_set(uarte, nrf_baudrate);
    7730:	68f9      	ldr	r1, [r7, #12]
    7732:	68b8      	ldr	r0, [r7, #8]
    7734:	f00c fe7c 	bl	14430 <nrf_uarte_baudrate_set>

	return 0;
    7738:	2300      	movs	r3, #0
}
    773a:	4618      	mov	r0, r3
    773c:	3710      	adds	r7, #16
    773e:	46bd      	mov	sp, r7
    7740:	bd80      	pop	{r7, pc}
    7742:	bf00      	nop
    7744:	000f4240 	.word	0x000f4240
    7748:	0003d090 	.word	0x0003d090
    774c:	0013b000 	.word	0x0013b000
    7750:	00275000 	.word	0x00275000
    7754:	003af000 	.word	0x003af000
    7758:	004ea000 	.word	0x004ea000
    775c:	0075c000 	.word	0x0075c000
    7760:	013a9000 	.word	0x013a9000

00007764 <uarte_nrfx_rx_counting_init>:
static void timer_handler(nrf_timer_event_t event_type, void *p_context) { }
static void rx_timeout(struct k_timer *timer);
static void tx_timeout(struct k_timer *timer);

static int uarte_nrfx_rx_counting_init(const struct device *dev)
{
    7764:	b580      	push	{r7, lr}
    7766:	b08c      	sub	sp, #48	; 0x30
    7768:	af00      	add	r7, sp, #0
    776a:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    776c:	6878      	ldr	r0, [r7, #4]
    776e:	f00c fee3 	bl	14538 <get_dev_data>
    7772:	62f8      	str	r0, [r7, #44]	; 0x2c
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
    7774:	6878      	ldr	r0, [r7, #4]
    7776:	f00c feea 	bl	1454e <get_dev_config>
    777a:	62b8      	str	r0, [r7, #40]	; 0x28
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
    777c:	6878      	ldr	r0, [r7, #4]
    777e:	f00c fef1 	bl	14564 <get_uarte_instance>
    7782:	6278      	str	r0, [r7, #36]	; 0x24
	int ret;

	if (hw_rx_counting_enabled(data)) {
    7784:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    7786:	f00d f867 	bl	14858 <hw_rx_counting_enabled>
    778a:	4603      	mov	r3, r0
    778c:	2b00      	cmp	r3, #0
    778e:	d059      	beq.n	7844 <uarte_nrfx_rx_counting_init+0xe0>
		nrfx_timer_config_t tmr_config = NRFX_TIMER_DEFAULT_CONFIG;
    7790:	2300      	movs	r3, #0
    7792:	753b      	strb	r3, [r7, #20]
    7794:	2300      	movs	r3, #0
    7796:	757b      	strb	r3, [r7, #21]
    7798:	2300      	movs	r3, #0
    779a:	75bb      	strb	r3, [r7, #22]
    779c:	2307      	movs	r3, #7
    779e:	75fb      	strb	r3, [r7, #23]
    77a0:	2300      	movs	r3, #0
    77a2:	61bb      	str	r3, [r7, #24]

		tmr_config.mode = NRF_TIMER_MODE_COUNTER;
    77a4:	2301      	movs	r3, #1
    77a6:	757b      	strb	r3, [r7, #21]
		tmr_config.bit_width = NRF_TIMER_BIT_WIDTH_32;
    77a8:	2303      	movs	r3, #3
    77aa:	75bb      	strb	r3, [r7, #22]
		ret = nrfx_timer_init(&cfg->timer,
    77ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
    77ae:	3308      	adds	r3, #8
    77b0:	f107 0114 	add.w	r1, r7, #20
    77b4:	4a62      	ldr	r2, [pc, #392]	; (7940 <uarte_nrfx_rx_counting_init+0x1dc>)
    77b6:	4618      	mov	r0, r3
    77b8:	f002 fe28 	bl	a40c <nrfx_timer_init>
    77bc:	4603      	mov	r3, r0
    77be:	623b      	str	r3, [r7, #32]
				      &tmr_config,
				      timer_handler);
		if (ret != NRFX_SUCCESS) {
    77c0:	6a3b      	ldr	r3, [r7, #32]
    77c2:	4a60      	ldr	r2, [pc, #384]	; (7944 <uarte_nrfx_rx_counting_init+0x1e0>)
    77c4:	4293      	cmp	r3, r2
    77c6:	d033      	beq.n	7830 <uarte_nrfx_rx_counting_init+0xcc>
			LOG_ERR("Timer already initialized, "
    77c8:	2301      	movs	r3, #1
    77ca:	2b00      	cmp	r3, #0
    77cc:	d02a      	beq.n	7824 <uarte_nrfx_rx_counting_init+0xc0>
    77ce:	f00c fa40 	bl	13c52 <_is_user_context>
    77d2:	4603      	mov	r3, r0
    77d4:	77fb      	strb	r3, [r7, #31]
    77d6:	7c3b      	ldrb	r3, [r7, #16]
    77d8:	2201      	movs	r2, #1
    77da:	f362 0302 	bfi	r3, r2, #0, #3
    77de:	743b      	strb	r3, [r7, #16]
    77e0:	7c3b      	ldrb	r3, [r7, #16]
    77e2:	f36f 03c5 	bfc	r3, #3, #3
    77e6:	743b      	strb	r3, [r7, #16]
    77e8:	2301      	movs	r3, #1
    77ea:	2b00      	cmp	r3, #0
    77ec:	d009      	beq.n	7802 <uarte_nrfx_rx_counting_init+0x9e>
    77ee:	4b56      	ldr	r3, [pc, #344]	; (7948 <uarte_nrfx_rx_counting_init+0x1e4>)
    77f0:	681b      	ldr	r3, [r3, #0]
    77f2:	4618      	mov	r0, r3
    77f4:	f7ff fe2a 	bl	744c <log_const_source_id>
    77f8:	4603      	mov	r3, r0
    77fa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    77fe:	b29a      	uxth	r2, r3
    7800:	e000      	b.n	7804 <uarte_nrfx_rx_counting_init+0xa0>
    7802:	2200      	movs	r2, #0
    7804:	8a3b      	ldrh	r3, [r7, #16]
    7806:	f362 138f 	bfi	r3, r2, #6, #10
    780a:	823b      	strh	r3, [r7, #16]
    780c:	7ffb      	ldrb	r3, [r7, #31]
    780e:	2b00      	cmp	r3, #0
    7810:	d004      	beq.n	781c <uarte_nrfx_rx_counting_init+0xb8>
    7812:	494e      	ldr	r1, [pc, #312]	; (794c <uarte_nrfx_rx_counting_init+0x1e8>)
    7814:	8a38      	ldrh	r0, [r7, #16]
    7816:	f7fb f86b 	bl	28f0 <log_from_user>
    781a:	e003      	b.n	7824 <uarte_nrfx_rx_counting_init+0xc0>
    781c:	8a39      	ldrh	r1, [r7, #16]
    781e:	484b      	ldr	r0, [pc, #300]	; (794c <uarte_nrfx_rx_counting_init+0x1e8>)
    7820:	f009 feff 	bl	11622 <log_0>
				"switching to software byte counting.");
			data->async->hw_rx_counting = false;
    7824:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7826:	691b      	ldr	r3, [r3, #16]
    7828:	2200      	movs	r2, #0
    782a:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
    782e:	e009      	b.n	7844 <uarte_nrfx_rx_counting_init+0xe0>
		} else {
			nrfx_timer_enable(&cfg->timer);
    7830:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7832:	3308      	adds	r3, #8
    7834:	4618      	mov	r0, r3
    7836:	f002 ffa9 	bl	a78c <nrfx_timer_enable>
			nrfx_timer_clear(&cfg->timer);
    783a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    783c:	3308      	adds	r3, #8
    783e:	4618      	mov	r0, r3
    7840:	f003 f888 	bl	a954 <nrfx_timer_clear>
		}
	}

	if (hw_rx_counting_enabled(data)) {
    7844:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    7846:	f00d f807 	bl	14858 <hw_rx_counting_enabled>
    784a:	4603      	mov	r3, r0
    784c:	2b00      	cmp	r3, #0
    784e:	d043      	beq.n	78d8 <uarte_nrfx_rx_counting_init+0x174>
		ret = gppi_channel_alloc(&data->async->rx_cnt.ppi);
    7850:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7852:	691b      	ldr	r3, [r3, #16]
    7854:	33b0      	adds	r3, #176	; 0xb0
    7856:	4618      	mov	r0, r3
    7858:	f002 fcb6 	bl	a1c8 <nrfx_dppi_channel_alloc>
    785c:	4603      	mov	r3, r0
    785e:	623b      	str	r3, [r7, #32]
		if (ret != NRFX_SUCCESS) {
    7860:	6a3b      	ldr	r3, [r7, #32]
    7862:	4a38      	ldr	r2, [pc, #224]	; (7944 <uarte_nrfx_rx_counting_init+0x1e0>)
    7864:	4293      	cmp	r3, r2
    7866:	d037      	beq.n	78d8 <uarte_nrfx_rx_counting_init+0x174>
			LOG_ERR("Failed to allocate PPI Channel, "
    7868:	2301      	movs	r3, #1
    786a:	2b00      	cmp	r3, #0
    786c:	d02a      	beq.n	78c4 <uarte_nrfx_rx_counting_init+0x160>
    786e:	f00c f9f0 	bl	13c52 <_is_user_context>
    7872:	4603      	mov	r3, r0
    7874:	77bb      	strb	r3, [r7, #30]
    7876:	7b3b      	ldrb	r3, [r7, #12]
    7878:	2201      	movs	r2, #1
    787a:	f362 0302 	bfi	r3, r2, #0, #3
    787e:	733b      	strb	r3, [r7, #12]
    7880:	7b3b      	ldrb	r3, [r7, #12]
    7882:	f36f 03c5 	bfc	r3, #3, #3
    7886:	733b      	strb	r3, [r7, #12]
    7888:	2301      	movs	r3, #1
    788a:	2b00      	cmp	r3, #0
    788c:	d009      	beq.n	78a2 <uarte_nrfx_rx_counting_init+0x13e>
    788e:	4b2e      	ldr	r3, [pc, #184]	; (7948 <uarte_nrfx_rx_counting_init+0x1e4>)
    7890:	681b      	ldr	r3, [r3, #0]
    7892:	4618      	mov	r0, r3
    7894:	f7ff fdda 	bl	744c <log_const_source_id>
    7898:	4603      	mov	r3, r0
    789a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    789e:	b29a      	uxth	r2, r3
    78a0:	e000      	b.n	78a4 <uarte_nrfx_rx_counting_init+0x140>
    78a2:	2200      	movs	r2, #0
    78a4:	89bb      	ldrh	r3, [r7, #12]
    78a6:	f362 138f 	bfi	r3, r2, #6, #10
    78aa:	81bb      	strh	r3, [r7, #12]
    78ac:	7fbb      	ldrb	r3, [r7, #30]
    78ae:	2b00      	cmp	r3, #0
    78b0:	d004      	beq.n	78bc <uarte_nrfx_rx_counting_init+0x158>
    78b2:	4927      	ldr	r1, [pc, #156]	; (7950 <uarte_nrfx_rx_counting_init+0x1ec>)
    78b4:	89b8      	ldrh	r0, [r7, #12]
    78b6:	f7fb f81b 	bl	28f0 <log_from_user>
    78ba:	e003      	b.n	78c4 <uarte_nrfx_rx_counting_init+0x160>
    78bc:	89b9      	ldrh	r1, [r7, #12]
    78be:	4824      	ldr	r0, [pc, #144]	; (7950 <uarte_nrfx_rx_counting_init+0x1ec>)
    78c0:	f009 feaf 	bl	11622 <log_0>
				"switching to software byte counting.");
			data->async->hw_rx_counting = false;
    78c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    78c6:	691b      	ldr	r3, [r3, #16]
    78c8:	2200      	movs	r2, #0
    78ca:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
			nrfx_timer_uninit(&cfg->timer);
    78ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
    78d0:	3308      	adds	r3, #8
    78d2:	4618      	mov	r0, r3
    78d4:	f002 fef2 	bl	a6bc <nrfx_timer_uninit>
		}
	}

	if (hw_rx_counting_enabled(data)) {
    78d8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    78da:	f00c ffbd 	bl	14858 <hw_rx_counting_enabled>
    78de:	4603      	mov	r3, r0
    78e0:	2b00      	cmp	r3, #0
    78e2:	d023      	beq.n	792c <uarte_nrfx_rx_counting_init+0x1c8>
			return -EIO;
		}
#else
		nrf_uarte_publish_set(uarte,
				      NRF_UARTE_EVENT_RXDRDY,
				      data->async->rx_cnt.ppi);
    78e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    78e6:	691b      	ldr	r3, [r3, #16]
		nrf_uarte_publish_set(uarte,
    78e8:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
    78ec:	461a      	mov	r2, r3
    78ee:	f44f 7184 	mov.w	r1, #264	; 0x108
    78f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
    78f4:	f00c fcf3 	bl	142de <nrf_uarte_publish_set>
		nrf_timer_subscribe_set(cfg->timer.p_reg,
    78f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    78fa:	6898      	ldr	r0, [r3, #8]
					NRF_TIMER_TASK_COUNT,
					data->async->rx_cnt.ppi);
    78fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    78fe:	691b      	ldr	r3, [r3, #16]
		nrf_timer_subscribe_set(cfg->timer.p_reg,
    7900:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
    7904:	461a      	mov	r2, r3
    7906:	2108      	movs	r1, #8
    7908:	f00c fdde 	bl	144c8 <nrf_timer_subscribe_set>

#endif
		ret = gppi_channel_enable(data->async->rx_cnt.ppi);
    790c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    790e:	691b      	ldr	r3, [r3, #16]
    7910:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
    7914:	4618      	mov	r0, r3
    7916:	f002 fd01 	bl	a31c <nrfx_dppi_channel_enable>
    791a:	4603      	mov	r3, r0
    791c:	623b      	str	r3, [r7, #32]
		if (ret != NRFX_SUCCESS) {
    791e:	6a3b      	ldr	r3, [r7, #32]
    7920:	4a08      	ldr	r2, [pc, #32]	; (7944 <uarte_nrfx_rx_counting_init+0x1e0>)
    7922:	4293      	cmp	r3, r2
    7924:	d006      	beq.n	7934 <uarte_nrfx_rx_counting_init+0x1d0>
			return -EIO;
    7926:	f06f 0304 	mvn.w	r3, #4
    792a:	e004      	b.n	7936 <uarte_nrfx_rx_counting_init+0x1d2>
		}
	} else {
		nrf_uarte_int_enable(uarte, NRF_UARTE_INT_RXDRDY_MASK);
    792c:	2104      	movs	r1, #4
    792e:	6a78      	ldr	r0, [r7, #36]	; 0x24
    7930:	f00c fcaa 	bl	14288 <nrf_uarte_int_enable>
	}

	return 0;
    7934:	2300      	movs	r3, #0
}
    7936:	4618      	mov	r0, r3
    7938:	3730      	adds	r7, #48	; 0x30
    793a:	46bd      	mov	sp, r7
    793c:	bd80      	pop	{r7, pc}
    793e:	bf00      	nop
    7940:	00014873 	.word	0x00014873
    7944:	0bad0000 	.word	0x0bad0000
    7948:	20000100 	.word	0x20000100
    794c:	00019ffc 	.word	0x00019ffc
    7950:	0001a03c 	.word	0x0001a03c

00007954 <uarte_nrfx_init>:

static int uarte_nrfx_init(const struct device *dev)
{
    7954:	b580      	push	{r7, lr}
    7956:	b086      	sub	sp, #24
    7958:	af00      	add	r7, sp, #0
    795a:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    795c:	6878      	ldr	r0, [r7, #4]
    795e:	f00c fdeb 	bl	14538 <get_dev_data>
    7962:	6178      	str	r0, [r7, #20]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
    7964:	6878      	ldr	r0, [r7, #4]
    7966:	f00c fdfd 	bl	14564 <get_uarte_instance>
    796a:	6138      	str	r0, [r7, #16]

	int ret = uarte_nrfx_rx_counting_init(dev);
    796c:	6878      	ldr	r0, [r7, #4]
    796e:	f7ff fef9 	bl	7764 <uarte_nrfx_rx_counting_init>
    7972:	60f8      	str	r0, [r7, #12]

	if (ret != 0) {
    7974:	68fb      	ldr	r3, [r7, #12]
    7976:	2b00      	cmp	r3, #0
    7978:	d001      	beq.n	797e <uarte_nrfx_init+0x2a>
		return ret;
    797a:	68fb      	ldr	r3, [r7, #12]
    797c:	e04c      	b.n	7a18 <uarte_nrfx_init+0xc4>
	}
	nrf_uarte_int_enable(uarte,
    797e:	4928      	ldr	r1, [pc, #160]	; (7a20 <uarte_nrfx_init+0xcc>)
    7980:	6938      	ldr	r0, [r7, #16]
    7982:	f00c fc81 	bl	14288 <nrf_uarte_int_enable>
			     NRF_UARTE_INT_ENDRX_MASK |
			     NRF_UARTE_INT_RXSTARTED_MASK |
			     NRF_UARTE_INT_ERROR_MASK |
			     NRF_UARTE_INT_RXTO_MASK);
	nrf_uarte_enable(uarte);
    7986:	6938      	ldr	r0, [r7, #16]
    7988:	f00c fcd0 	bl	1432c <nrf_uarte_enable>
	/**
	 * Stop any currently running RX operations. This can occur when a
	 * bootloader sets up the UART hardware and does not clean it up
	 * before jumping to the next application.
	 */
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {
    798c:	f44f 71a6 	mov.w	r1, #332	; 0x14c
    7990:	6938      	ldr	r0, [r7, #16]
    7992:	f00c fc32 	bl	141fa <nrf_uarte_event_check>
    7996:	4603      	mov	r3, r0
    7998:	2b00      	cmp	r3, #0
    799a:	d01e      	beq.n	79da <uarte_nrfx_init+0x86>
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);
    799c:	2104      	movs	r1, #4
    799e:	6938      	ldr	r0, [r7, #16]
    79a0:	f00c fd10 	bl	143c4 <nrf_uarte_task_trigger>
		while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXTO)) {
    79a4:	bf00      	nop
    79a6:	f44f 71a2 	mov.w	r1, #324	; 0x144
    79aa:	6938      	ldr	r0, [r7, #16]
    79ac:	f00c fc25 	bl	141fa <nrf_uarte_event_check>
    79b0:	4603      	mov	r3, r0
    79b2:	f083 0301 	eor.w	r3, r3, #1
    79b6:	b2db      	uxtb	r3, r3
    79b8:	2b00      	cmp	r3, #0
    79ba:	d1f4      	bne.n	79a6 <uarte_nrfx_init+0x52>
			/* Busy wait for event to register */
		}
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);
    79bc:	f44f 71a6 	mov.w	r1, #332	; 0x14c
    79c0:	6938      	ldr	r0, [r7, #16]
    79c2:	f00c fc05 	bl	141d0 <nrf_uarte_event_clear>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
    79c6:	f44f 7188 	mov.w	r1, #272	; 0x110
    79ca:	6938      	ldr	r0, [r7, #16]
    79cc:	f00c fc00 	bl	141d0 <nrf_uarte_event_clear>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXTO);
    79d0:	f44f 71a2 	mov.w	r1, #324	; 0x144
    79d4:	6938      	ldr	r0, [r7, #16]
    79d6:	f00c fbfb 	bl	141d0 <nrf_uarte_event_clear>
	}

	k_timer_init(&data->async->rx_timeout_timer, rx_timeout, NULL);
    79da:	697b      	ldr	r3, [r7, #20]
    79dc:	691b      	ldr	r3, [r3, #16]
    79de:	3378      	adds	r3, #120	; 0x78
    79e0:	2200      	movs	r2, #0
    79e2:	4910      	ldr	r1, [pc, #64]	; (7a24 <uarte_nrfx_init+0xd0>)
    79e4:	4618      	mov	r0, r3
    79e6:	f010 fd0e 	bl	18406 <k_timer_init>
	k_timer_user_data_set(&data->async->rx_timeout_timer, data);
    79ea:	697b      	ldr	r3, [r7, #20]
    79ec:	691b      	ldr	r3, [r3, #16]
    79ee:	3378      	adds	r3, #120	; 0x78
    79f0:	6979      	ldr	r1, [r7, #20]
    79f2:	4618      	mov	r0, r3
    79f4:	f00c faf6 	bl	13fe4 <k_timer_user_data_set>
	k_timer_init(&data->async->tx_timeout_timer, tx_timeout, NULL);
    79f8:	697b      	ldr	r3, [r7, #20]
    79fa:	691b      	ldr	r3, [r3, #16]
    79fc:	3318      	adds	r3, #24
    79fe:	2200      	movs	r2, #0
    7a00:	4909      	ldr	r1, [pc, #36]	; (7a28 <uarte_nrfx_init+0xd4>)
    7a02:	4618      	mov	r0, r3
    7a04:	f010 fcff 	bl	18406 <k_timer_init>
	k_timer_user_data_set(&data->async->tx_timeout_timer, data);
    7a08:	697b      	ldr	r3, [r7, #20]
    7a0a:	691b      	ldr	r3, [r3, #16]
    7a0c:	3318      	adds	r3, #24
    7a0e:	6979      	ldr	r1, [r7, #20]
    7a10:	4618      	mov	r0, r3
    7a12:	f00c fae7 	bl	13fe4 <k_timer_user_data_set>

	return 0;
    7a16:	2300      	movs	r3, #0
}
    7a18:	4618      	mov	r0, r3
    7a1a:	3718      	adds	r7, #24
    7a1c:	46bd      	mov	sp, r7
    7a1e:	bd80      	pop	{r7, pc}
    7a20:	000a0210 	.word	0x000a0210
    7a24:	00014b77 	.word	0x00014b77
    7a28:	00014b1f 	.word	0x00014b1f

00007a2c <uarte_nrfx_rx_enable>:
}

static int uarte_nrfx_rx_enable(const struct device *dev, uint8_t *buf,
				size_t len,
				int32_t timeout)
{
    7a2c:	b580      	push	{r7, lr}
    7a2e:	b086      	sub	sp, #24
    7a30:	af00      	add	r7, sp, #0
    7a32:	60f8      	str	r0, [r7, #12]
    7a34:	60b9      	str	r1, [r7, #8]
    7a36:	607a      	str	r2, [r7, #4]
    7a38:	603b      	str	r3, [r7, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    7a3a:	68f8      	ldr	r0, [r7, #12]
    7a3c:	f00c fd7c 	bl	14538 <get_dev_data>
    7a40:	6178      	str	r0, [r7, #20]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
    7a42:	68f8      	ldr	r0, [r7, #12]
    7a44:	f00c fd8e 	bl	14564 <get_uarte_instance>
    7a48:	6138      	str	r0, [r7, #16]

	if (nrf_uarte_rx_pin_get(uarte) == NRF_UARTE_PSEL_DISCONNECTED) {
    7a4a:	6938      	ldr	r0, [r7, #16]
    7a4c:	f00c fc9b 	bl	14386 <nrf_uarte_rx_pin_get>
    7a50:	4603      	mov	r3, r0
    7a52:	f1b3 3fff 	cmp.w	r3, #4294967295
    7a56:	d111      	bne.n	7a7c <uarte_nrfx_rx_enable+0x50>
		__ASSERT(false, "TX only UARTE instance");
    7a58:	f44f 731a 	mov.w	r3, #616	; 0x268
    7a5c:	4a29      	ldr	r2, [pc, #164]	; (7b04 <uarte_nrfx_rx_enable+0xd8>)
    7a5e:	492a      	ldr	r1, [pc, #168]	; (7b08 <uarte_nrfx_rx_enable+0xdc>)
    7a60:	482a      	ldr	r0, [pc, #168]	; (7b0c <uarte_nrfx_rx_enable+0xe0>)
    7a62:	f008 fb01 	bl	10068 <printk>
    7a66:	482a      	ldr	r0, [pc, #168]	; (7b10 <uarte_nrfx_rx_enable+0xe4>)
    7a68:	f008 fafe 	bl	10068 <printk>
    7a6c:	f44f 711a 	mov.w	r1, #616	; 0x268
    7a70:	4824      	ldr	r0, [pc, #144]	; (7b04 <uarte_nrfx_rx_enable+0xd8>)
    7a72:	f009 f941 	bl	10cf8 <assert_post_action>
		return -ENOTSUP;
    7a76:	f06f 0322 	mvn.w	r3, #34	; 0x22
    7a7a:	e03f      	b.n	7afc <uarte_nrfx_rx_enable+0xd0>
	}

	data->async->rx_timeout = timeout;
    7a7c:	697b      	ldr	r3, [r7, #20]
    7a7e:	691b      	ldr	r3, [r3, #16]
    7a80:	683a      	ldr	r2, [r7, #0]
    7a82:	66da      	str	r2, [r3, #108]	; 0x6c
	data->async->rx_timeout_slab =
		MAX(timeout / RX_TIMEOUT_DIV,
    7a84:	683b      	ldr	r3, [r7, #0]
    7a86:	2b09      	cmp	r3, #9
    7a88:	dd07      	ble.n	7a9a <uarte_nrfx_rx_enable+0x6e>
    7a8a:	683b      	ldr	r3, [r7, #0]
    7a8c:	4a21      	ldr	r2, [pc, #132]	; (7b14 <uarte_nrfx_rx_enable+0xe8>)
    7a8e:	fb82 1203 	smull	r1, r2, r2, r3
    7a92:	1052      	asrs	r2, r2, #1
    7a94:	17db      	asrs	r3, r3, #31
    7a96:	1ad3      	subs	r3, r2, r3
    7a98:	e000      	b.n	7a9c <uarte_nrfx_rx_enable+0x70>
    7a9a:	2301      	movs	r3, #1
	data->async->rx_timeout_slab =
    7a9c:	697a      	ldr	r2, [r7, #20]
    7a9e:	6912      	ldr	r2, [r2, #16]
    7aa0:	6713      	str	r3, [r2, #112]	; 0x70
		    NRFX_CEIL_DIV(1000, CONFIG_SYS_CLOCK_TICKS_PER_SEC));

	data->async->rx_buf = buf;
    7aa2:	697b      	ldr	r3, [r7, #20]
    7aa4:	691b      	ldr	r3, [r3, #16]
    7aa6:	68ba      	ldr	r2, [r7, #8]
    7aa8:	651a      	str	r2, [r3, #80]	; 0x50
	data->async->rx_buf_len = len;
    7aaa:	697b      	ldr	r3, [r7, #20]
    7aac:	691b      	ldr	r3, [r3, #16]
    7aae:	687a      	ldr	r2, [r7, #4]
    7ab0:	655a      	str	r2, [r3, #84]	; 0x54
	data->async->rx_offset = 0;
    7ab2:	697b      	ldr	r3, [r7, #20]
    7ab4:	691b      	ldr	r3, [r3, #16]
    7ab6:	2200      	movs	r2, #0
    7ab8:	659a      	str	r2, [r3, #88]	; 0x58
	data->async->rx_next_buf = NULL;
    7aba:	697b      	ldr	r3, [r7, #20]
    7abc:	691b      	ldr	r3, [r3, #16]
    7abe:	2200      	movs	r2, #0
    7ac0:	65da      	str	r2, [r3, #92]	; 0x5c
	data->async->rx_next_buf_len = 0;
    7ac2:	697b      	ldr	r3, [r7, #20]
    7ac4:	691b      	ldr	r3, [r3, #16]
    7ac6:	2200      	movs	r2, #0
    7ac8:	661a      	str	r2, [r3, #96]	; 0x60
	nrf_uarte_rx_buffer_set(uarte, buf, len);
    7aca:	687a      	ldr	r2, [r7, #4]
    7acc:	68b9      	ldr	r1, [r7, #8]
    7ace:	6938      	ldr	r0, [r7, #16]
    7ad0:	f00c fcdb 	bl	1448a <nrf_uarte_rx_buffer_set>

	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
    7ad4:	f44f 7188 	mov.w	r1, #272	; 0x110
    7ad8:	6938      	ldr	r0, [r7, #16]
    7ada:	f00c fb79 	bl	141d0 <nrf_uarte_event_clear>
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);
    7ade:	f44f 71a6 	mov.w	r1, #332	; 0x14c
    7ae2:	6938      	ldr	r0, [r7, #16]
    7ae4:	f00c fb74 	bl	141d0 <nrf_uarte_event_clear>

	data->async->rx_enabled = true;
    7ae8:	697b      	ldr	r3, [r7, #20]
    7aea:	691b      	ldr	r3, [r3, #16]
    7aec:	2201      	movs	r2, #1
    7aee:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
    7af2:	2100      	movs	r1, #0
    7af4:	6938      	ldr	r0, [r7, #16]
    7af6:	f00c fc65 	bl	143c4 <nrf_uarte_task_trigger>
	return 0;
    7afa:	2300      	movs	r3, #0
}
    7afc:	4618      	mov	r0, r3
    7afe:	3718      	adds	r7, #24
    7b00:	46bd      	mov	sp, r7
    7b02:	bd80      	pop	{r7, pc}
    7b04:	0001a084 	.word	0x0001a084
    7b08:	00019fa8 	.word	0x00019fa8
    7b0c:	00019f88 	.word	0x00019f88
    7b10:	0001a0b8 	.word	0x0001a0b8
    7b14:	66666667 	.word	0x66666667

00007b18 <rxto_isr>:
 * finishing the reception after filling all provided buffers, in which case
 * the events UART_RX_BUF_RELEASED and UART_RX_DISABLED are reported
 * from endrx_isr.
 */
static void rxto_isr(const struct device *dev)
{
    7b18:	b580      	push	{r7, lr}
    7b1a:	b088      	sub	sp, #32
    7b1c:	af00      	add	r7, sp, #0
    7b1e:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    7b20:	6878      	ldr	r0, [r7, #4]
    7b22:	f00c fd09 	bl	14538 <get_dev_data>
    7b26:	61f8      	str	r0, [r7, #28]
	struct uart_event evt = {
    7b28:	f107 0308 	add.w	r3, r7, #8
    7b2c:	2200      	movs	r2, #0
    7b2e:	601a      	str	r2, [r3, #0]
    7b30:	605a      	str	r2, [r3, #4]
    7b32:	609a      	str	r2, [r3, #8]
    7b34:	60da      	str	r2, [r3, #12]
    7b36:	611a      	str	r2, [r3, #16]
    7b38:	2304      	movs	r3, #4
    7b3a:	723b      	strb	r3, [r7, #8]
		.type = UART_RX_BUF_RELEASED,
		.data.rx_buf.buf = data->async->rx_buf,
    7b3c:	69fb      	ldr	r3, [r7, #28]
    7b3e:	691b      	ldr	r3, [r3, #16]
    7b40:	6d1b      	ldr	r3, [r3, #80]	; 0x50
	struct uart_event evt = {
    7b42:	60fb      	str	r3, [r7, #12]
	};
	user_callback(dev, &evt);
    7b44:	f107 0308 	add.w	r3, r7, #8
    7b48:	4619      	mov	r1, r3
    7b4a:	6878      	ldr	r0, [r7, #4]
    7b4c:	f00c fff8 	bl	14b40 <user_callback>

	data->async->rx_buf = NULL;
    7b50:	69fb      	ldr	r3, [r7, #28]
    7b52:	691b      	ldr	r3, [r3, #16]
    7b54:	2200      	movs	r2, #0
    7b56:	651a      	str	r2, [r3, #80]	; 0x50
	if (data->async->rx_next_buf) {
    7b58:	69fb      	ldr	r3, [r7, #28]
    7b5a:	691b      	ldr	r3, [r3, #16]
    7b5c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    7b5e:	2b00      	cmp	r3, #0
    7b60:	d00f      	beq.n	7b82 <rxto_isr+0x6a>
		evt.type = UART_RX_BUF_RELEASED;
    7b62:	2304      	movs	r3, #4
    7b64:	723b      	strb	r3, [r7, #8]
		evt.data.rx_buf.buf = data->async->rx_next_buf;
    7b66:	69fb      	ldr	r3, [r7, #28]
    7b68:	691b      	ldr	r3, [r3, #16]
    7b6a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    7b6c:	60fb      	str	r3, [r7, #12]
		user_callback(dev, &evt);
    7b6e:	f107 0308 	add.w	r3, r7, #8
    7b72:	4619      	mov	r1, r3
    7b74:	6878      	ldr	r0, [r7, #4]
    7b76:	f00c ffe3 	bl	14b40 <user_callback>
		data->async->rx_next_buf = NULL;
    7b7a:	69fb      	ldr	r3, [r7, #28]
    7b7c:	691b      	ldr	r3, [r3, #16]
    7b7e:	2200      	movs	r2, #0
    7b80:	65da      	str	r2, [r3, #92]	; 0x5c
	}

	/* Flushing RX fifo requires buffer bigger than 4 bytes to empty fifo */
	static uint8_t flush_buf[5];

	nrf_uarte_rx_buffer_set(get_uarte_instance(dev), flush_buf, 5);
    7b82:	6878      	ldr	r0, [r7, #4]
    7b84:	f00c fcee 	bl	14564 <get_uarte_instance>
    7b88:	4603      	mov	r3, r0
    7b8a:	2205      	movs	r2, #5
    7b8c:	4907      	ldr	r1, [pc, #28]	; (7bac <rxto_isr+0x94>)
    7b8e:	4618      	mov	r0, r3
    7b90:	f00c fc7b 	bl	1448a <nrf_uarte_rx_buffer_set>
	/* Final part of handling RXTO event is in ENDRX interrupt handler.
	 * ENDRX is generated as a result of FLUSHRX task.
	 */
	nrf_uarte_task_trigger(get_uarte_instance(dev), NRF_UARTE_TASK_FLUSHRX);
    7b94:	6878      	ldr	r0, [r7, #4]
    7b96:	f00c fce5 	bl	14564 <get_uarte_instance>
    7b9a:	4603      	mov	r3, r0
    7b9c:	212c      	movs	r1, #44	; 0x2c
    7b9e:	4618      	mov	r0, r3
    7ba0:	f00c fc10 	bl	143c4 <nrf_uarte_task_trigger>
}
    7ba4:	bf00      	nop
    7ba6:	3720      	adds	r7, #32
    7ba8:	46bd      	mov	sp, r7
    7baa:	bd80      	pop	{r7, pc}
    7bac:	20000c9c 	.word	0x20000c9c

00007bb0 <endtx_stoptx_ppi_init>:
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int endtx_stoptx_ppi_init(NRF_UARTE_Type *uarte,
				 struct uarte_nrfx_data *data)
{
    7bb0:	b5b0      	push	{r4, r5, r7, lr}
    7bb2:	b084      	sub	sp, #16
    7bb4:	af00      	add	r7, sp, #0
    7bb6:	6078      	str	r0, [r7, #4]
    7bb8:	6039      	str	r1, [r7, #0]
	nrfx_err_t ret;

	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    7bba:	683b      	ldr	r3, [r7, #0]
    7bbc:	3316      	adds	r3, #22
    7bbe:	4618      	mov	r0, r3
    7bc0:	f002 fb02 	bl	a1c8 <nrfx_dppi_channel_alloc>
    7bc4:	60f8      	str	r0, [r7, #12]
	if (ret != NRFX_SUCCESS) {
    7bc6:	68fb      	ldr	r3, [r7, #12]
    7bc8:	4a29      	ldr	r2, [pc, #164]	; (7c70 <endtx_stoptx_ppi_init+0xc0>)
    7bca:	4293      	cmp	r3, r2
    7bcc:	d030      	beq.n	7c30 <endtx_stoptx_ppi_init+0x80>
		LOG_ERR("Failed to allocate PPI Channel");
    7bce:	2301      	movs	r3, #1
    7bd0:	2b00      	cmp	r3, #0
    7bd2:	d02a      	beq.n	7c2a <endtx_stoptx_ppi_init+0x7a>
    7bd4:	f00c f83d 	bl	13c52 <_is_user_context>
    7bd8:	4603      	mov	r3, r0
    7bda:	72fb      	strb	r3, [r7, #11]
    7bdc:	7a3b      	ldrb	r3, [r7, #8]
    7bde:	2201      	movs	r2, #1
    7be0:	f362 0302 	bfi	r3, r2, #0, #3
    7be4:	723b      	strb	r3, [r7, #8]
    7be6:	7a3b      	ldrb	r3, [r7, #8]
    7be8:	f36f 03c5 	bfc	r3, #3, #3
    7bec:	723b      	strb	r3, [r7, #8]
    7bee:	2301      	movs	r3, #1
    7bf0:	2b00      	cmp	r3, #0
    7bf2:	d009      	beq.n	7c08 <endtx_stoptx_ppi_init+0x58>
    7bf4:	4b1f      	ldr	r3, [pc, #124]	; (7c74 <endtx_stoptx_ppi_init+0xc4>)
    7bf6:	681b      	ldr	r3, [r3, #0]
    7bf8:	4618      	mov	r0, r3
    7bfa:	f7ff fc27 	bl	744c <log_const_source_id>
    7bfe:	4603      	mov	r3, r0
    7c00:	f3c3 0309 	ubfx	r3, r3, #0, #10
    7c04:	b29a      	uxth	r2, r3
    7c06:	e000      	b.n	7c0a <endtx_stoptx_ppi_init+0x5a>
    7c08:	2200      	movs	r2, #0
    7c0a:	893b      	ldrh	r3, [r7, #8]
    7c0c:	f362 138f 	bfi	r3, r2, #6, #10
    7c10:	813b      	strh	r3, [r7, #8]
    7c12:	7afb      	ldrb	r3, [r7, #11]
    7c14:	2b00      	cmp	r3, #0
    7c16:	d004      	beq.n	7c22 <endtx_stoptx_ppi_init+0x72>
    7c18:	4917      	ldr	r1, [pc, #92]	; (7c78 <endtx_stoptx_ppi_init+0xc8>)
    7c1a:	8938      	ldrh	r0, [r7, #8]
    7c1c:	f7fa fe68 	bl	28f0 <log_from_user>
    7c20:	e003      	b.n	7c2a <endtx_stoptx_ppi_init+0x7a>
    7c22:	8939      	ldrh	r1, [r7, #8]
    7c24:	4814      	ldr	r0, [pc, #80]	; (7c78 <endtx_stoptx_ppi_init+0xc8>)
    7c26:	f009 fcfc 	bl	11622 <log_0>
		return -EIO;
    7c2a:	f06f 0304 	mvn.w	r3, #4
    7c2e:	e01a      	b.n	7c66 <endtx_stoptx_ppi_init+0xb6>
	}

	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    7c30:	683b      	ldr	r3, [r7, #0]
    7c32:	7d9c      	ldrb	r4, [r3, #22]
    7c34:	f44f 7190 	mov.w	r1, #288	; 0x120
    7c38:	6878      	ldr	r0, [r7, #4]
    7c3a:	f00c faf2 	bl	14222 <nrf_uarte_event_address_get>
    7c3e:	4605      	mov	r5, r0
    7c40:	210c      	movs	r1, #12
    7c42:	6878      	ldr	r0, [r7, #4]
    7c44:	f00c fbce 	bl	143e4 <nrf_uarte_task_address_get>
    7c48:	4603      	mov	r3, r0
    7c4a:	461a      	mov	r2, r3
    7c4c:	4629      	mov	r1, r5
    7c4e:	4620      	mov	r0, r4
    7c50:	f00c fc5d 	bl	1450e <nrfx_gppi_channel_endpoints_setup>
		nrf_uarte_event_address_get(uarte, NRF_UARTE_EVENT_ENDTX),
		nrf_uarte_task_address_get(uarte, NRF_UARTE_TASK_STOPTX));
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    7c54:	683b      	ldr	r3, [r7, #0]
    7c56:	7d9b      	ldrb	r3, [r3, #22]
    7c58:	461a      	mov	r2, r3
    7c5a:	2301      	movs	r3, #1
    7c5c:	4093      	lsls	r3, r2
    7c5e:	4618      	mov	r0, r3
    7c60:	f7ff fc04 	bl	746c <nrfx_gppi_channels_enable>

	return 0;
    7c64:	2300      	movs	r3, #0
}
    7c66:	4618      	mov	r0, r3
    7c68:	3710      	adds	r7, #16
    7c6a:	46bd      	mov	sp, r7
    7c6c:	bdb0      	pop	{r4, r5, r7, pc}
    7c6e:	bf00      	nop
    7c70:	0bad0000 	.word	0x0bad0000
    7c74:	20000100 	.word	0x20000100
    7c78:	0001a0d4 	.word	0x0001a0d4

00007c7c <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    7c7c:	b590      	push	{r4, r7, lr}
    7c7e:	b087      	sub	sp, #28
    7c80:	af00      	add	r7, sp, #0
    7c82:	6078      	str	r0, [r7, #4]
    7c84:	4b0c      	ldr	r3, [pc, #48]	; (7cb8 <uarte_0_init+0x3c>)
    7c86:	f107 0408 	add.w	r4, r7, #8
    7c8a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    7c8c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    7c90:	2200      	movs	r2, #0
    7c92:	2101      	movs	r1, #1
    7c94:	2008      	movs	r0, #8
    7c96:	f7fc ff35 	bl	4b04 <z_arm_irq_priority_set>
    7c9a:	2008      	movs	r0, #8
    7c9c:	f00b f86f 	bl	12d7e <arch_irq_enable>
    7ca0:	f107 0308 	add.w	r3, r7, #8
    7ca4:	2201      	movs	r2, #1
    7ca6:	4619      	mov	r1, r3
    7ca8:	6878      	ldr	r0, [r7, #4]
    7caa:	f00d fd69 	bl	15780 <uarte_instance_init>
    7cae:	4603      	mov	r3, r0
    7cb0:	4618      	mov	r0, r3
    7cb2:	371c      	adds	r7, #28
    7cb4:	46bd      	mov	sp, r7
    7cb6:	bd90      	pop	{r4, r7, pc}
    7cb8:	0001a0fc 	.word	0x0001a0fc

00007cbc <uarte_1_init>:
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
    7cbc:	b590      	push	{r4, r7, lr}
    7cbe:	b087      	sub	sp, #28
    7cc0:	af00      	add	r7, sp, #0
    7cc2:	6078      	str	r0, [r7, #4]
    7cc4:	4b0c      	ldr	r3, [pc, #48]	; (7cf8 <uarte_1_init+0x3c>)
    7cc6:	f107 0408 	add.w	r4, r7, #8
    7cca:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    7ccc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    7cd0:	2200      	movs	r2, #0
    7cd2:	2101      	movs	r1, #1
    7cd4:	2009      	movs	r0, #9
    7cd6:	f7fc ff15 	bl	4b04 <z_arm_irq_priority_set>
    7cda:	2009      	movs	r0, #9
    7cdc:	f00b f84f 	bl	12d7e <arch_irq_enable>
    7ce0:	f107 0308 	add.w	r3, r7, #8
    7ce4:	2200      	movs	r2, #0
    7ce6:	4619      	mov	r1, r3
    7ce8:	6878      	ldr	r0, [r7, #4]
    7cea:	f00d fd49 	bl	15780 <uarte_instance_init>
    7cee:	4603      	mov	r3, r0
    7cf0:	4618      	mov	r0, r3
    7cf2:	371c      	adds	r7, #28
    7cf4:	46bd      	mov	sp, r7
    7cf6:	bd90      	pop	{r4, r7, pc}
    7cf8:	0001a114 	.word	0x0001a114

00007cfc <k_is_pre_kernel>:
{
    7cfc:	b480      	push	{r7}
    7cfe:	af00      	add	r7, sp, #0
	return !z_sys_post_kernel;
    7d00:	4b08      	ldr	r3, [pc, #32]	; (7d24 <k_is_pre_kernel+0x28>)
    7d02:	781b      	ldrb	r3, [r3, #0]
    7d04:	2b00      	cmp	r3, #0
    7d06:	bf14      	ite	ne
    7d08:	2301      	movne	r3, #1
    7d0a:	2300      	moveq	r3, #0
    7d0c:	b2db      	uxtb	r3, r3
    7d0e:	f083 0301 	eor.w	r3, r3, #1
    7d12:	b2db      	uxtb	r3, r3
    7d14:	f003 0301 	and.w	r3, r3, #1
    7d18:	b2db      	uxtb	r3, r3
}
    7d1a:	4618      	mov	r0, r3
    7d1c:	46bd      	mov	sp, r7
    7d1e:	bc80      	pop	{r7}
    7d20:	4770      	bx	lr
    7d22:	bf00      	nop
    7d24:	20000d45 	.word	0x20000d45

00007d28 <z_impl_gpio_pin_interrupt_configure>:
					   gpio_flags_t flags);

static inline int z_impl_gpio_pin_interrupt_configure(const struct device *port,
						      gpio_pin_t pin,
						      gpio_flags_t flags)
{
    7d28:	b590      	push	{r4, r7, lr}
    7d2a:	b08b      	sub	sp, #44	; 0x2c
    7d2c:	af00      	add	r7, sp, #0
    7d2e:	60f8      	str	r0, [r7, #12]
    7d30:	460b      	mov	r3, r1
    7d32:	607a      	str	r2, [r7, #4]
    7d34:	72fb      	strb	r3, [r7, #11]
	const struct gpio_driver_api *api =
    7d36:	68fb      	ldr	r3, [r7, #12]
    7d38:	689b      	ldr	r3, [r3, #8]
    7d3a:	627b      	str	r3, [r7, #36]	; 0x24
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
    7d3c:	68fb      	ldr	r3, [r7, #12]
    7d3e:	685b      	ldr	r3, [r3, #4]
    7d40:	623b      	str	r3, [r7, #32]
		(const struct gpio_driver_config *)port->config;
	const struct gpio_driver_data *const data =
    7d42:	68fb      	ldr	r3, [r7, #12]
    7d44:	68db      	ldr	r3, [r3, #12]
    7d46:	61fb      	str	r3, [r7, #28]
		(const struct gpio_driver_data *)port->data;
	enum gpio_int_trig trig;
	enum gpio_int_mode mode;

	__ASSERT_NO_MSG((flags & GPIO_INT_DEBOUNCE) == 0);
    7d48:	687b      	ldr	r3, [r7, #4]
    7d4a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
    7d4e:	2b00      	cmp	r3, #0
    7d50:	d00b      	beq.n	7d6a <z_impl_gpio_pin_interrupt_configure+0x42>
    7d52:	f44f 73f4 	mov.w	r3, #488	; 0x1e8
    7d56:	4a54      	ldr	r2, [pc, #336]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7d58:	4954      	ldr	r1, [pc, #336]	; (7eac <z_impl_gpio_pin_interrupt_configure+0x184>)
    7d5a:	4855      	ldr	r0, [pc, #340]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7d5c:	f008 f984 	bl	10068 <printk>
    7d60:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
    7d64:	4850      	ldr	r0, [pc, #320]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7d66:	f008 ffc7 	bl	10cf8 <assert_post_action>

	__ASSERT((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE))
    7d6a:	687b      	ldr	r3, [r7, #4]
    7d6c:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    7d70:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
    7d74:	d10e      	bne.n	7d94 <z_impl_gpio_pin_interrupt_configure+0x6c>
    7d76:	f44f 73f5 	mov.w	r3, #490	; 0x1ea
    7d7a:	4a4b      	ldr	r2, [pc, #300]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7d7c:	494d      	ldr	r1, [pc, #308]	; (7eb4 <z_impl_gpio_pin_interrupt_configure+0x18c>)
    7d7e:	484c      	ldr	r0, [pc, #304]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7d80:	f008 f972 	bl	10068 <printk>
    7d84:	484c      	ldr	r0, [pc, #304]	; (7eb8 <z_impl_gpio_pin_interrupt_configure+0x190>)
    7d86:	f008 f96f 	bl	10068 <printk>
    7d8a:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
    7d8e:	4846      	ldr	r0, [pc, #280]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7d90:	f008 ffb2 	bl	10cf8 <assert_post_action>
		 != (GPIO_INT_DISABLE | GPIO_INT_ENABLE),
		 "Cannot both enable and disable interrupts");

	__ASSERT((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE)) != 0U,
    7d94:	687b      	ldr	r3, [r7, #4]
    7d96:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    7d9a:	2b00      	cmp	r3, #0
    7d9c:	d10e      	bne.n	7dbc <z_impl_gpio_pin_interrupt_configure+0x94>
    7d9e:	f44f 73f7 	mov.w	r3, #494	; 0x1ee
    7da2:	4a41      	ldr	r2, [pc, #260]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7da4:	4945      	ldr	r1, [pc, #276]	; (7ebc <z_impl_gpio_pin_interrupt_configure+0x194>)
    7da6:	4842      	ldr	r0, [pc, #264]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7da8:	f008 f95e 	bl	10068 <printk>
    7dac:	4844      	ldr	r0, [pc, #272]	; (7ec0 <z_impl_gpio_pin_interrupt_configure+0x198>)
    7dae:	f008 f95b 	bl	10068 <printk>
    7db2:	f44f 71f7 	mov.w	r1, #494	; 0x1ee
    7db6:	483c      	ldr	r0, [pc, #240]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7db8:	f008 ff9e 	bl	10cf8 <assert_post_action>
		 "Must either enable or disable interrupts");

	__ASSERT(((flags & GPIO_INT_ENABLE) == 0) ||
    7dbc:	687b      	ldr	r3, [r7, #4]
    7dbe:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    7dc2:	2b00      	cmp	r3, #0
    7dc4:	d019      	beq.n	7dfa <z_impl_gpio_pin_interrupt_configure+0xd2>
    7dc6:	687b      	ldr	r3, [r7, #4]
    7dc8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    7dcc:	2b00      	cmp	r3, #0
    7dce:	d114      	bne.n	7dfa <z_impl_gpio_pin_interrupt_configure+0xd2>
    7dd0:	687b      	ldr	r3, [r7, #4]
    7dd2:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    7dd6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    7dda:	d10e      	bne.n	7dfa <z_impl_gpio_pin_interrupt_configure+0xd2>
    7ddc:	f240 13f1 	movw	r3, #497	; 0x1f1
    7de0:	4a31      	ldr	r2, [pc, #196]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7de2:	4938      	ldr	r1, [pc, #224]	; (7ec4 <z_impl_gpio_pin_interrupt_configure+0x19c>)
    7de4:	4832      	ldr	r0, [pc, #200]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7de6:	f008 f93f 	bl	10068 <printk>
    7dea:	4837      	ldr	r0, [pc, #220]	; (7ec8 <z_impl_gpio_pin_interrupt_configure+0x1a0>)
    7dec:	f008 f93c 	bl	10068 <printk>
    7df0:	f240 11f1 	movw	r1, #497	; 0x1f1
    7df4:	482c      	ldr	r0, [pc, #176]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7df6:	f008 ff7f 	bl	10cf8 <assert_post_action>
		 ((flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1)) !=
		  (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1)),
		 "Only one of GPIO_INT_LOW_0, GPIO_INT_HIGH_1 can be "
		 "enabled for a level interrupt.");

	__ASSERT(((flags & GPIO_INT_ENABLE) == 0) ||
    7dfa:	687b      	ldr	r3, [r7, #4]
    7dfc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    7e00:	2b00      	cmp	r3, #0
    7e02:	d013      	beq.n	7e2c <z_impl_gpio_pin_interrupt_configure+0x104>
    7e04:	687b      	ldr	r3, [r7, #4]
    7e06:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    7e0a:	2b00      	cmp	r3, #0
    7e0c:	d10e      	bne.n	7e2c <z_impl_gpio_pin_interrupt_configure+0x104>
    7e0e:	f44f 73fc 	mov.w	r3, #504	; 0x1f8
    7e12:	4a25      	ldr	r2, [pc, #148]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7e14:	492d      	ldr	r1, [pc, #180]	; (7ecc <z_impl_gpio_pin_interrupt_configure+0x1a4>)
    7e16:	4826      	ldr	r0, [pc, #152]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7e18:	f008 f926 	bl	10068 <printk>
    7e1c:	482c      	ldr	r0, [pc, #176]	; (7ed0 <z_impl_gpio_pin_interrupt_configure+0x1a8>)
    7e1e:	f008 f923 	bl	10068 <printk>
    7e22:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
    7e26:	4820      	ldr	r0, [pc, #128]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7e28:	f008 ff66 	bl	10cf8 <assert_post_action>
		 ((flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1)) != 0),
		 "At least one of GPIO_INT_LOW_0, GPIO_INT_HIGH_1 has to be "
		 "enabled.");

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    7e2c:	6a3b      	ldr	r3, [r7, #32]
    7e2e:	681a      	ldr	r2, [r3, #0]
    7e30:	7afb      	ldrb	r3, [r7, #11]
    7e32:	2101      	movs	r1, #1
    7e34:	fa01 f303 	lsl.w	r3, r1, r3
    7e38:	4013      	ands	r3, r2
    7e3a:	2b00      	cmp	r3, #0
    7e3c:	d10e      	bne.n	7e5c <z_impl_gpio_pin_interrupt_configure+0x134>
    7e3e:	f44f 73ff 	mov.w	r3, #510	; 0x1fe
    7e42:	4a19      	ldr	r2, [pc, #100]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7e44:	4923      	ldr	r1, [pc, #140]	; (7ed4 <z_impl_gpio_pin_interrupt_configure+0x1ac>)
    7e46:	481a      	ldr	r0, [pc, #104]	; (7eb0 <z_impl_gpio_pin_interrupt_configure+0x188>)
    7e48:	f008 f90e 	bl	10068 <printk>
    7e4c:	4822      	ldr	r0, [pc, #136]	; (7ed8 <z_impl_gpio_pin_interrupt_configure+0x1b0>)
    7e4e:	f008 f90b 	bl	10068 <printk>
    7e52:	f44f 71ff 	mov.w	r1, #510	; 0x1fe
    7e56:	4814      	ldr	r0, [pc, #80]	; (7ea8 <z_impl_gpio_pin_interrupt_configure+0x180>)
    7e58:	f008 ff4e 	bl	10cf8 <assert_post_action>
		 "Unsupported pin");

	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
    7e5c:	687b      	ldr	r3, [r7, #4]
    7e5e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    7e62:	2b00      	cmp	r3, #0
    7e64:	d00c      	beq.n	7e80 <z_impl_gpio_pin_interrupt_configure+0x158>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
    7e66:	69fb      	ldr	r3, [r7, #28]
    7e68:	681a      	ldr	r2, [r3, #0]
    7e6a:	7afb      	ldrb	r3, [r7, #11]
    7e6c:	2101      	movs	r1, #1
    7e6e:	fa01 f303 	lsl.w	r3, r1, r3
    7e72:	4013      	ands	r3, r2
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
    7e74:	2b00      	cmp	r3, #0
    7e76:	d003      	beq.n	7e80 <z_impl_gpio_pin_interrupt_configure+0x158>
		/* Invert signal bits */
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
    7e78:	687b      	ldr	r3, [r7, #4]
    7e7a:	f483 23c0 	eor.w	r3, r3, #393216	; 0x60000
    7e7e:	607b      	str	r3, [r7, #4]
	}

	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1));
    7e80:	687b      	ldr	r3, [r7, #4]
    7e82:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
    7e86:	61bb      	str	r3, [r7, #24]
	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
    7e88:	687b      	ldr	r3, [r7, #4]
    7e8a:	f403 33b0 	and.w	r3, r3, #90112	; 0x16000
    7e8e:	617b      	str	r3, [r7, #20]

	return api->pin_interrupt_configure(port, pin, mode, trig);
    7e90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    7e92:	699c      	ldr	r4, [r3, #24]
    7e94:	7af9      	ldrb	r1, [r7, #11]
    7e96:	69bb      	ldr	r3, [r7, #24]
    7e98:	697a      	ldr	r2, [r7, #20]
    7e9a:	68f8      	ldr	r0, [r7, #12]
    7e9c:	47a0      	blx	r4
    7e9e:	4603      	mov	r3, r0
}
    7ea0:	4618      	mov	r0, r3
    7ea2:	372c      	adds	r7, #44	; 0x2c
    7ea4:	46bd      	mov	sp, r7
    7ea6:	bd90      	pop	{r4, r7, pc}
    7ea8:	0001a124 	.word	0x0001a124
    7eac:	0001a150 	.word	0x0001a150
    7eb0:	0001a16c 	.word	0x0001a16c
    7eb4:	0001a18c 	.word	0x0001a18c
    7eb8:	0001a1d0 	.word	0x0001a1d0
    7ebc:	0001a1fc 	.word	0x0001a1fc
    7ec0:	0001a228 	.word	0x0001a228
    7ec4:	0001a254 	.word	0x0001a254
    7ec8:	0001a2d8 	.word	0x0001a2d8
    7ecc:	0001a32c 	.word	0x0001a32c
    7ed0:	0001a378 	.word	0x0001a378
    7ed4:	0001a3c0 	.word	0x0001a3c0
    7ed8:	0001a400 	.word	0x0001a400

00007edc <gpio_pin_configure>:
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_pin_configure(const struct device *port,
				     gpio_pin_t pin,
				     gpio_flags_t flags)
{
    7edc:	b580      	push	{r7, lr}
    7ede:	b088      	sub	sp, #32
    7ee0:	af00      	add	r7, sp, #0
    7ee2:	60f8      	str	r0, [r7, #12]
    7ee4:	460b      	mov	r3, r1
    7ee6:	607a      	str	r2, [r7, #4]
    7ee8:	72fb      	strb	r3, [r7, #11]
	const struct gpio_driver_api *api =
    7eea:	68fb      	ldr	r3, [r7, #12]
    7eec:	689b      	ldr	r3, [r3, #8]
    7eee:	61bb      	str	r3, [r7, #24]
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
    7ef0:	68fb      	ldr	r3, [r7, #12]
    7ef2:	685b      	ldr	r3, [r3, #4]
    7ef4:	617b      	str	r3, [r7, #20]
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
    7ef6:	68fb      	ldr	r3, [r7, #12]
    7ef8:	68db      	ldr	r3, [r3, #12]
    7efa:	613b      	str	r3, [r7, #16]
		(struct gpio_driver_data *)port->data;
	int ret;

	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
    7efc:	687b      	ldr	r3, [r7, #4]
    7efe:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7f02:	2b30      	cmp	r3, #48	; 0x30
    7f04:	d10e      	bne.n	7f24 <gpio_pin_configure+0x48>
    7f06:	f240 2329 	movw	r3, #553	; 0x229
    7f0a:	4a69      	ldr	r2, [pc, #420]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f0c:	4969      	ldr	r1, [pc, #420]	; (80b4 <CONFIG_FPROTECT_BLOCK_SIZE+0xb4>)
    7f0e:	486a      	ldr	r0, [pc, #424]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    7f10:	f008 f8aa 	bl	10068 <printk>
    7f14:	4869      	ldr	r0, [pc, #420]	; (80bc <CONFIG_FPROTECT_BLOCK_SIZE+0xbc>)
    7f16:	f008 f8a7 	bl	10068 <printk>
    7f1a:	f240 2129 	movw	r1, #553	; 0x229
    7f1e:	4864      	ldr	r0, [pc, #400]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f20:	f008 feea 	bl	10cf8 <assert_post_action>
		 (GPIO_PULL_UP | GPIO_PULL_DOWN),
		 "Pull Up and Pull Down should not be enabled simultaneously");

	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
    7f24:	687b      	ldr	r3, [r7, #4]
    7f26:	f403 7300 	and.w	r3, r3, #512	; 0x200
    7f2a:	2b00      	cmp	r3, #0
    7f2c:	d113      	bne.n	7f56 <gpio_pin_configure+0x7a>
    7f2e:	687b      	ldr	r3, [r7, #4]
    7f30:	f003 0302 	and.w	r3, r3, #2
    7f34:	2b00      	cmp	r3, #0
    7f36:	d00e      	beq.n	7f56 <gpio_pin_configure+0x7a>
    7f38:	f240 232d 	movw	r3, #557	; 0x22d
    7f3c:	4a5c      	ldr	r2, [pc, #368]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f3e:	4960      	ldr	r1, [pc, #384]	; (80c0 <CONFIG_FPROTECT_BLOCK_SIZE+0xc0>)
    7f40:	485d      	ldr	r0, [pc, #372]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    7f42:	f008 f891 	bl	10068 <printk>
    7f46:	485f      	ldr	r0, [pc, #380]	; (80c4 <CONFIG_FPROTECT_BLOCK_SIZE+0xc4>)
    7f48:	f008 f88e 	bl	10068 <printk>
    7f4c:	f240 212d 	movw	r1, #557	; 0x22d
    7f50:	4857      	ldr	r0, [pc, #348]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f52:	f008 fed1 	bl	10cf8 <assert_post_action>
		 "Output needs to be enabled for 'Open Drain', 'Open Source' "
		 "mode to be supported");

	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
    7f56:	687b      	ldr	r3, [r7, #4]
    7f58:	f003 0302 	and.w	r3, r3, #2
    7f5c:	2b00      	cmp	r3, #0
    7f5e:	d110      	bne.n	7f82 <gpio_pin_configure+0xa6>
    7f60:	687b      	ldr	r3, [r7, #4]
    7f62:	f003 0304 	and.w	r3, r3, #4
    7f66:	2b00      	cmp	r3, #0
    7f68:	d00b      	beq.n	7f82 <gpio_pin_configure+0xa6>
    7f6a:	f240 2331 	movw	r3, #561	; 0x231
    7f6e:	4a50      	ldr	r2, [pc, #320]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f70:	4955      	ldr	r1, [pc, #340]	; (80c8 <CONFIG_FPROTECT_BLOCK_SIZE+0xc8>)
    7f72:	4851      	ldr	r0, [pc, #324]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    7f74:	f008 f878 	bl	10068 <printk>
    7f78:	f240 2131 	movw	r1, #561	; 0x231
    7f7c:	484c      	ldr	r0, [pc, #304]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f7e:	f008 febb 	bl	10cf8 <assert_post_action>
			(flags & GPIO_LINE_OPEN_DRAIN) == 0);

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
    7f82:	687b      	ldr	r3, [r7, #4]
    7f84:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
    7f88:	2b00      	cmp	r3, #0
    7f8a:	d013      	beq.n	7fb4 <gpio_pin_configure+0xd8>
    7f8c:	687b      	ldr	r3, [r7, #4]
    7f8e:	f403 7300 	and.w	r3, r3, #512	; 0x200
    7f92:	2b00      	cmp	r3, #0
    7f94:	d10e      	bne.n	7fb4 <gpio_pin_configure+0xd8>
    7f96:	f44f 730d 	mov.w	r3, #564	; 0x234
    7f9a:	4a45      	ldr	r2, [pc, #276]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7f9c:	494b      	ldr	r1, [pc, #300]	; (80cc <CONFIG_FPROTECT_BLOCK_SIZE+0xcc>)
    7f9e:	4846      	ldr	r0, [pc, #280]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    7fa0:	f008 f862 	bl	10068 <printk>
    7fa4:	484a      	ldr	r0, [pc, #296]	; (80d0 <CONFIG_FPROTECT_BLOCK_SIZE+0xd0>)
    7fa6:	f008 f85f 	bl	10068 <printk>
    7faa:	f44f 710d 	mov.w	r1, #564	; 0x234
    7fae:	4840      	ldr	r0, [pc, #256]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7fb0:	f008 fea2 	bl	10cf8 <assert_post_action>
		 || (flags & GPIO_OUTPUT) != 0,
		 "Output needs to be enabled to be initialized low or high");

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
    7fb4:	687b      	ldr	r3, [r7, #4]
    7fb6:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
    7fba:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
    7fbe:	d10e      	bne.n	7fde <gpio_pin_configure+0x102>
    7fc0:	f44f 730e 	mov.w	r3, #568	; 0x238
    7fc4:	4a3a      	ldr	r2, [pc, #232]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7fc6:	4943      	ldr	r1, [pc, #268]	; (80d4 <CONFIG_FPROTECT_BLOCK_SIZE+0xd4>)
    7fc8:	483b      	ldr	r0, [pc, #236]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    7fca:	f008 f84d 	bl	10068 <printk>
    7fce:	4842      	ldr	r0, [pc, #264]	; (80d8 <CONFIG_FPROTECT_BLOCK_SIZE+0xd8>)
    7fd0:	f008 f84a 	bl	10068 <printk>
    7fd4:	f44f 710e 	mov.w	r1, #568	; 0x238
    7fd8:	4835      	ldr	r0, [pc, #212]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    7fda:	f008 fe8d 	bl	10cf8 <assert_post_action>
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
    7fde:	687b      	ldr	r3, [r7, #4]
    7fe0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    7fe4:	2b00      	cmp	r3, #0
    7fe6:	d00d      	beq.n	8004 <CONFIG_FPROTECT_BLOCK_SIZE+0x4>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    7fe8:	687b      	ldr	r3, [r7, #4]
    7fea:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
    7fee:	2b00      	cmp	r3, #0
    7ff0:	d008      	beq.n	8004 <CONFIG_FPROTECT_BLOCK_SIZE+0x4>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    7ff2:	687b      	ldr	r3, [r7, #4]
    7ff4:	f003 0301 	and.w	r3, r3, #1
    7ff8:	2b00      	cmp	r3, #0
    7ffa:	d003      	beq.n	8004 <CONFIG_FPROTECT_BLOCK_SIZE+0x4>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH
    7ffc:	687b      	ldr	r3, [r7, #4]
    7ffe:	f483 53e0 	eor.w	r3, r3, #7168	; 0x1c00
    8002:	607b      	str	r3, [r7, #4]
			| GPIO_OUTPUT_INIT_LOGICAL;
	}

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
    8004:	697b      	ldr	r3, [r7, #20]
    8006:	681a      	ldr	r2, [r3, #0]
    8008:	7afb      	ldrb	r3, [r7, #11]
    800a:	2101      	movs	r1, #1
    800c:	fa01 f303 	lsl.w	r3, r1, r3
    8010:	4013      	ands	r3, r2
    8012:	2b00      	cmp	r3, #0
    8014:	d10e      	bne.n	8034 <CONFIG_FPROTECT_BLOCK_SIZE+0x34>
    8016:	f44f 7311 	mov.w	r3, #580	; 0x244
    801a:	4a25      	ldr	r2, [pc, #148]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    801c:	492f      	ldr	r1, [pc, #188]	; (80dc <CONFIG_FPROTECT_BLOCK_SIZE+0xdc>)
    801e:	4826      	ldr	r0, [pc, #152]	; (80b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>)
    8020:	f008 f822 	bl	10068 <printk>
    8024:	482e      	ldr	r0, [pc, #184]	; (80e0 <CONFIG_FPROTECT_BLOCK_SIZE+0xe0>)
    8026:	f008 f81f 	bl	10068 <printk>
    802a:	f44f 7111 	mov.w	r1, #580	; 0x244
    802e:	4820      	ldr	r0, [pc, #128]	; (80b0 <CONFIG_FPROTECT_BLOCK_SIZE+0xb0>)
    8030:	f008 fe62 	bl	10cf8 <assert_post_action>
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
    8034:	7afb      	ldrb	r3, [r7, #11]
    8036:	687a      	ldr	r2, [r7, #4]
    8038:	4619      	mov	r1, r3
    803a:	68f8      	ldr	r0, [r7, #12]
    803c:	f00d ff89 	bl	15f52 <gpio_config>
    8040:	61f8      	str	r0, [r7, #28]
	if (ret != 0) {
    8042:	69fb      	ldr	r3, [r7, #28]
    8044:	2b00      	cmp	r3, #0
    8046:	d001      	beq.n	804c <CONFIG_FPROTECT_BLOCK_SIZE+0x4c>
		return ret;
    8048:	69fb      	ldr	r3, [r7, #28]
    804a:	e02d      	b.n	80a8 <CONFIG_FPROTECT_BLOCK_SIZE+0xa8>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    804c:	687b      	ldr	r3, [r7, #4]
    804e:	f003 0301 	and.w	r3, r3, #1
    8052:	2b00      	cmp	r3, #0
    8054:	d009      	beq.n	806a <CONFIG_FPROTECT_BLOCK_SIZE+0x6a>
		data->invert |= (gpio_port_pins_t)BIT(pin);
    8056:	693b      	ldr	r3, [r7, #16]
    8058:	681a      	ldr	r2, [r3, #0]
    805a:	7afb      	ldrb	r3, [r7, #11]
    805c:	2101      	movs	r1, #1
    805e:	fa01 f303 	lsl.w	r3, r1, r3
    8062:	431a      	orrs	r2, r3
    8064:	693b      	ldr	r3, [r7, #16]
    8066:	601a      	str	r2, [r3, #0]
    8068:	e009      	b.n	807e <CONFIG_FPROTECT_BLOCK_SIZE+0x7e>
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    806a:	693b      	ldr	r3, [r7, #16]
    806c:	681a      	ldr	r2, [r3, #0]
    806e:	7afb      	ldrb	r3, [r7, #11]
    8070:	2101      	movs	r1, #1
    8072:	fa01 f303 	lsl.w	r3, r1, r3
    8076:	43db      	mvns	r3, r3
    8078:	401a      	ands	r2, r3
    807a:	693b      	ldr	r3, [r7, #16]
    807c:	601a      	str	r2, [r3, #0]
	}
	if (((flags & (GPIO_INT_DISABLE | GPIO_INT_ENABLE)) != 0U)
    807e:	687b      	ldr	r3, [r7, #4]
    8080:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    8084:	2b00      	cmp	r3, #0
    8086:	d00e      	beq.n	80a6 <CONFIG_FPROTECT_BLOCK_SIZE+0xa6>
	    && (api->pin_interrupt_configure != NULL)) {
    8088:	69bb      	ldr	r3, [r7, #24]
    808a:	699b      	ldr	r3, [r3, #24]
    808c:	2b00      	cmp	r3, #0
    808e:	d00a      	beq.n	80a6 <CONFIG_FPROTECT_BLOCK_SIZE+0xa6>
		flags &= ~GPIO_INT_DEBOUNCE;
    8090:	687b      	ldr	r3, [r7, #4]
    8092:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
    8096:	607b      	str	r3, [r7, #4]
		ret = z_impl_gpio_pin_interrupt_configure(port, pin, flags);
    8098:	7afb      	ldrb	r3, [r7, #11]
    809a:	687a      	ldr	r2, [r7, #4]
    809c:	4619      	mov	r1, r3
    809e:	68f8      	ldr	r0, [r7, #12]
    80a0:	f7ff fe42 	bl	7d28 <z_impl_gpio_pin_interrupt_configure>
    80a4:	61f8      	str	r0, [r7, #28]
	}

	return ret;
    80a6:	69fb      	ldr	r3, [r7, #28]
}
    80a8:	4618      	mov	r0, r3
    80aa:	3720      	adds	r7, #32
    80ac:	46bd      	mov	sp, r7
    80ae:	bd80      	pop	{r7, pc}
    80b0:	0001a124 	.word	0x0001a124
    80b4:	0001a414 	.word	0x0001a414
    80b8:	0001a16c 	.word	0x0001a16c
    80bc:	0001a450 	.word	0x0001a450
    80c0:	0001a490 	.word	0x0001a490
    80c4:	0001a4c4 	.word	0x0001a4c4
    80c8:	0001a518 	.word	0x0001a518
    80cc:	0001a54c 	.word	0x0001a54c
    80d0:	0001a594 	.word	0x0001a594
    80d4:	0001a5d0 	.word	0x0001a5d0
    80d8:	0001a614 	.word	0x0001a614
    80dc:	0001a3c0 	.word	0x0001a3c0
    80e0:	0001a400 	.word	0x0001a400

000080e4 <gpio_init_callback>:
 * @param pin_mask A bit mask of relevant pins for the handler
 */
static inline void gpio_init_callback(struct gpio_callback *callback,
				      gpio_callback_handler_t handler,
				      gpio_port_pins_t pin_mask)
{
    80e4:	b580      	push	{r7, lr}
    80e6:	b084      	sub	sp, #16
    80e8:	af00      	add	r7, sp, #0
    80ea:	60f8      	str	r0, [r7, #12]
    80ec:	60b9      	str	r1, [r7, #8]
    80ee:	607a      	str	r2, [r7, #4]
	__ASSERT(callback, "Callback pointer should not be NULL");
    80f0:	68fb      	ldr	r3, [r7, #12]
    80f2:	2b00      	cmp	r3, #0
    80f4:	d10e      	bne.n	8114 <gpio_init_callback+0x30>
    80f6:	f240 4314 	movw	r3, #1044	; 0x414
    80fa:	4a14      	ldr	r2, [pc, #80]	; (814c <gpio_init_callback+0x68>)
    80fc:	4914      	ldr	r1, [pc, #80]	; (8150 <gpio_init_callback+0x6c>)
    80fe:	4815      	ldr	r0, [pc, #84]	; (8154 <gpio_init_callback+0x70>)
    8100:	f007 ffb2 	bl	10068 <printk>
    8104:	4814      	ldr	r0, [pc, #80]	; (8158 <gpio_init_callback+0x74>)
    8106:	f007 ffaf 	bl	10068 <printk>
    810a:	f240 4114 	movw	r1, #1044	; 0x414
    810e:	480f      	ldr	r0, [pc, #60]	; (814c <gpio_init_callback+0x68>)
    8110:	f008 fdf2 	bl	10cf8 <assert_post_action>
	__ASSERT(handler, "Callback handler pointer should not be NULL");
    8114:	68bb      	ldr	r3, [r7, #8]
    8116:	2b00      	cmp	r3, #0
    8118:	d10e      	bne.n	8138 <gpio_init_callback+0x54>
    811a:	f240 4315 	movw	r3, #1045	; 0x415
    811e:	4a0b      	ldr	r2, [pc, #44]	; (814c <gpio_init_callback+0x68>)
    8120:	490e      	ldr	r1, [pc, #56]	; (815c <gpio_init_callback+0x78>)
    8122:	480c      	ldr	r0, [pc, #48]	; (8154 <gpio_init_callback+0x70>)
    8124:	f007 ffa0 	bl	10068 <printk>
    8128:	480d      	ldr	r0, [pc, #52]	; (8160 <gpio_init_callback+0x7c>)
    812a:	f007 ff9d 	bl	10068 <printk>
    812e:	f240 4115 	movw	r1, #1045	; 0x415
    8132:	4806      	ldr	r0, [pc, #24]	; (814c <gpio_init_callback+0x68>)
    8134:	f008 fde0 	bl	10cf8 <assert_post_action>

	callback->handler = handler;
    8138:	68fb      	ldr	r3, [r7, #12]
    813a:	68ba      	ldr	r2, [r7, #8]
    813c:	605a      	str	r2, [r3, #4]
	callback->pin_mask = pin_mask;
    813e:	68fb      	ldr	r3, [r7, #12]
    8140:	687a      	ldr	r2, [r7, #4]
    8142:	609a      	str	r2, [r3, #8]
}
    8144:	bf00      	nop
    8146:	3710      	adds	r7, #16
    8148:	46bd      	mov	sp, r7
    814a:	bd80      	pop	{r7, pc}
    814c:	0001a124 	.word	0x0001a124
    8150:	0001a640 	.word	0x0001a640
    8154:	0001a16c 	.word	0x0001a16c
    8158:	0001a64c 	.word	0x0001a64c
    815c:	0001a674 	.word	0x0001a674
    8160:	0001a67c 	.word	0x0001a67c

00008164 <nrf_gpio_pin_port_decode>:
{
    8164:	b580      	push	{r7, lr}
    8166:	b082      	sub	sp, #8
    8168:	af00      	add	r7, sp, #0
    816a:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
    816c:	687b      	ldr	r3, [r7, #4]
    816e:	681b      	ldr	r3, [r3, #0]
    8170:	4618      	mov	r0, r3
    8172:	f00d ffc6 	bl	16102 <nrf_gpio_pin_present_check>
    8176:	4603      	mov	r3, r0
    8178:	f083 0301 	eor.w	r3, r3, #1
    817c:	b2db      	uxtb	r3, r3
    817e:	2b00      	cmp	r3, #0
    8180:	d00b      	beq.n	819a <nrf_gpio_pin_port_decode+0x36>
    8182:	f240 231a 	movw	r3, #538	; 0x21a
    8186:	4a10      	ldr	r2, [pc, #64]	; (81c8 <nrf_gpio_pin_port_decode+0x64>)
    8188:	4910      	ldr	r1, [pc, #64]	; (81cc <nrf_gpio_pin_port_decode+0x68>)
    818a:	4811      	ldr	r0, [pc, #68]	; (81d0 <nrf_gpio_pin_port_decode+0x6c>)
    818c:	f007 ff6c 	bl	10068 <printk>
    8190:	f240 211a 	movw	r1, #538	; 0x21a
    8194:	480c      	ldr	r0, [pc, #48]	; (81c8 <nrf_gpio_pin_port_decode+0x64>)
    8196:	f008 fdaf 	bl	10cf8 <assert_post_action>
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    819a:	6878      	ldr	r0, [r7, #4]
    819c:	f00d ffd5 	bl	1614a <nrf_gpio_pin_port_number_extract>
    81a0:	4603      	mov	r3, r0
    81a2:	2b00      	cmp	r3, #0
    81a4:	d00b      	beq.n	81be <nrf_gpio_pin_port_decode+0x5a>
            NRFX_ASSERT(0);
    81a6:	f240 231f 	movw	r3, #543	; 0x21f
    81aa:	4a07      	ldr	r2, [pc, #28]	; (81c8 <nrf_gpio_pin_port_decode+0x64>)
    81ac:	4909      	ldr	r1, [pc, #36]	; (81d4 <nrf_gpio_pin_port_decode+0x70>)
    81ae:	4808      	ldr	r0, [pc, #32]	; (81d0 <nrf_gpio_pin_port_decode+0x6c>)
    81b0:	f007 ff5a 	bl	10068 <printk>
    81b4:	f240 211f 	movw	r1, #543	; 0x21f
    81b8:	4803      	ldr	r0, [pc, #12]	; (81c8 <nrf_gpio_pin_port_decode+0x64>)
    81ba:	f008 fd9d 	bl	10cf8 <assert_post_action>
        case 0: return NRF_P0;
    81be:	4b06      	ldr	r3, [pc, #24]	; (81d8 <nrf_gpio_pin_port_decode+0x74>)
}
    81c0:	4618      	mov	r0, r3
    81c2:	3708      	adds	r7, #8
    81c4:	46bd      	mov	sp, r7
    81c6:	bd80      	pop	{r7, pc}
    81c8:	0001a6ac 	.word	0x0001a6ac
    81cc:	0001a6e0 	.word	0x0001a6e0
    81d0:	0001a16c 	.word	0x0001a16c
    81d4:	0001a704 	.word	0x0001a704
    81d8:	50842500 	.word	0x50842500

000081dc <nrf_gpiote_in_event_get>:
    return (nrf_gpiote_task_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, TASKS_CLR[index]);
}
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    81dc:	b580      	push	{r7, lr}
    81de:	b082      	sub	sp, #8
    81e0:	af00      	add	r7, sp, #0
    81e2:	4603      	mov	r3, r0
    81e4:	71fb      	strb	r3, [r7, #7]
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    81e6:	79fb      	ldrb	r3, [r7, #7]
    81e8:	2b07      	cmp	r3, #7
    81ea:	d90b      	bls.n	8204 <nrf_gpiote_in_event_get+0x28>
    81ec:	f240 2386 	movw	r3, #646	; 0x286
    81f0:	4a09      	ldr	r2, [pc, #36]	; (8218 <nrf_gpiote_in_event_get+0x3c>)
    81f2:	490a      	ldr	r1, [pc, #40]	; (821c <nrf_gpiote_in_event_get+0x40>)
    81f4:	480a      	ldr	r0, [pc, #40]	; (8220 <nrf_gpiote_in_event_get+0x44>)
    81f6:	f007 ff37 	bl	10068 <printk>
    81fa:	f240 2186 	movw	r1, #646	; 0x286
    81fe:	4806      	ldr	r0, [pc, #24]	; (8218 <nrf_gpiote_in_event_get+0x3c>)
    8200:	f008 fd7a 	bl	10cf8 <assert_post_action>
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    8204:	79fb      	ldrb	r3, [r7, #7]
    8206:	009b      	lsls	r3, r3, #2
    8208:	f503 7380 	add.w	r3, r3, #256	; 0x100
    820c:	b29b      	uxth	r3, r3
}
    820e:	4618      	mov	r0, r3
    8210:	3708      	adds	r7, #8
    8212:	46bd      	mov	sp, r7
    8214:	bd80      	pop	{r7, pc}
    8216:	bf00      	nop
    8218:	0001a708 	.word	0x0001a708
    821c:	0001a740 	.word	0x0001a740
    8220:	0001a16c 	.word	0x0001a16c

00008224 <log_const_source_id>:
{
    8224:	b480      	push	{r7}
    8226:	b083      	sub	sp, #12
    8228:	af00      	add	r7, sp, #0
    822a:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    822c:	687b      	ldr	r3, [r7, #4]
    822e:	4a04      	ldr	r2, [pc, #16]	; (8240 <log_const_source_id+0x1c>)
    8230:	1a9b      	subs	r3, r3, r2
    8232:	08db      	lsrs	r3, r3, #3
}
    8234:	4618      	mov	r0, r3
    8236:	370c      	adds	r7, #12
    8238:	46bd      	mov	sp, r7
    823a:	bc80      	pop	{r7}
    823c:	4770      	bx	lr
    823e:	bf00      	nop
    8240:	00018788 	.word	0x00018788

00008244 <ctrl_pin_set>:
{
	return dev->config;
}

static void ctrl_pin_set(const struct lpuart_bidir_gpio *io, bool force)
{
    8244:	b580      	push	{r7, lr}
    8246:	b086      	sub	sp, #24
    8248:	af00      	add	r7, sp, #0
    824a:	6078      	str	r0, [r7, #4]
    824c:	460b      	mov	r3, r1
    824e:	70fb      	strb	r3, [r7, #3]
	if (force) {
    8250:	78fb      	ldrb	r3, [r7, #3]
    8252:	2b00      	cmp	r3, #0
    8254:	d010      	beq.n	8278 <ctrl_pin_set+0x34>
		nrf_gpio_pin_set(io->nrf_pin);
    8256:	687b      	ldr	r3, [r7, #4]
    8258:	7c5b      	ldrb	r3, [r3, #17]
    825a:	4618      	mov	r0, r3
    825c:	f00d feec 	bl	16038 <nrf_gpio_pin_set>
		nrf_gpiote_te_default(NRF_GPIOTE, io->ch);
    8260:	687b      	ldr	r3, [r7, #4]
    8262:	7c9b      	ldrb	r3, [r3, #18]
    8264:	4619      	mov	r1, r3
    8266:	481e      	ldr	r0, [pc, #120]	; (82e0 <ctrl_pin_set+0x9c>)
    8268:	f00e f81e 	bl	162a8 <nrf_gpiote_te_default>
		nrf_gpio_cfg_output(io->nrf_pin);
    826c:	687b      	ldr	r3, [r7, #4]
    826e:	7c5b      	ldrb	r3, [r3, #17]
    8270:	4618      	mov	r0, r3
    8272:	f00d febb 	bl	15fec <nrf_gpio_cfg_output>
		return;
    8276:	e02f      	b.n	82d8 <ctrl_pin_set+0x94>
	__asm__ volatile(
    8278:	f04f 0320 	mov.w	r3, #32
    827c:	f3ef 8211 	mrs	r2, BASEPRI
    8280:	f383 8811 	msr	BASEPRI, r3
    8284:	f3bf 8f6f 	isb	sy
    8288:	60fa      	str	r2, [r7, #12]
    828a:	60bb      	str	r3, [r7, #8]
	return key;
    828c:	68fb      	ldr	r3, [r7, #12]
	}

	int key = irq_lock();
    828e:	617b      	str	r3, [r7, #20]
	 * This might be solved in the next iteration but it will required
	 * extension to the GPIO driver to use LATCH for sensing. In case of
	 * sensing it is possible to switch from output to input in single
	 * operation (change or NRF_GPIO->PIN_CNF register).
	 */
	nrf_gpiote_te_default(NRF_GPIOTE, io->ch);
    8290:	687b      	ldr	r3, [r7, #4]
    8292:	7c9b      	ldrb	r3, [r3, #18]
    8294:	4619      	mov	r1, r3
    8296:	4812      	ldr	r0, [pc, #72]	; (82e0 <ctrl_pin_set+0x9c>)
    8298:	f00e f806 	bl	162a8 <nrf_gpiote_te_default>
	nrf_gpiote_event_configure(NRF_GPIOTE, io->ch, io->nrf_pin,
    829c:	687b      	ldr	r3, [r7, #4]
    829e:	7c9b      	ldrb	r3, [r3, #18]
    82a0:	4619      	mov	r1, r3
    82a2:	687b      	ldr	r3, [r7, #4]
    82a4:	7c5b      	ldrb	r3, [r3, #17]
    82a6:	461a      	mov	r2, r3
    82a8:	2302      	movs	r3, #2
    82aa:	480d      	ldr	r0, [pc, #52]	; (82e0 <ctrl_pin_set+0x9c>)
    82ac:	f00d ffa2 	bl	161f4 <nrf_gpiote_event_configure>
					NRF_GPIOTE_POLARITY_HITOLO);

	nrf_gpio_cfg_input(io->nrf_pin, NRF_GPIO_PIN_PULLUP);
    82b0:	687b      	ldr	r3, [r7, #4]
    82b2:	7c5b      	ldrb	r3, [r3, #17]
    82b4:	2103      	movs	r1, #3
    82b6:	4618      	mov	r0, r3
    82b8:	f00d feaa 	bl	16010 <nrf_gpio_cfg_input>
	nrf_gpiote_event_enable(NRF_GPIOTE, io->ch);
    82bc:	687b      	ldr	r3, [r7, #4]
    82be:	7c9b      	ldrb	r3, [r3, #18]
    82c0:	4619      	mov	r1, r3
    82c2:	4807      	ldr	r0, [pc, #28]	; (82e0 <ctrl_pin_set+0x9c>)
    82c4:	f00d ff7e 	bl	161c4 <nrf_gpiote_event_enable>

	irq_unlock(key);
    82c8:	697b      	ldr	r3, [r7, #20]
    82ca:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
    82cc:	693b      	ldr	r3, [r7, #16]
    82ce:	f383 8811 	msr	BASEPRI, r3
    82d2:	f3bf 8f6f 	isb	sy
}
    82d6:	bf00      	nop
}
    82d8:	3718      	adds	r7, #24
    82da:	46bd      	mov	sp, r7
    82dc:	bd80      	pop	{r7, pc}
    82de:	bf00      	nop
    82e0:	5000d000 	.word	0x5000d000

000082e4 <ctrl_pin_clear>:

/* Sets pin to output and sets low state. */
static void ctrl_pin_clear(const struct lpuart_bidir_gpio *io)
{
    82e4:	b580      	push	{r7, lr}
    82e6:	b082      	sub	sp, #8
    82e8:	af00      	add	r7, sp, #0
    82ea:	6078      	str	r0, [r7, #4]
	nrf_gpio_pin_clear(io->nrf_pin);
    82ec:	687b      	ldr	r3, [r7, #4]
    82ee:	7c5b      	ldrb	r3, [r3, #17]
    82f0:	4618      	mov	r0, r3
    82f2:	f00d feb6 	bl	16062 <nrf_gpio_pin_clear>
	nrf_gpiote_te_default(NRF_GPIOTE, io->ch);
    82f6:	687b      	ldr	r3, [r7, #4]
    82f8:	7c9b      	ldrb	r3, [r3, #18]
    82fa:	4619      	mov	r1, r3
    82fc:	4805      	ldr	r0, [pc, #20]	; (8314 <ctrl_pin_clear+0x30>)
    82fe:	f00d ffd3 	bl	162a8 <nrf_gpiote_te_default>
	nrf_gpio_cfg_output(io->nrf_pin);
    8302:	687b      	ldr	r3, [r7, #4]
    8304:	7c5b      	ldrb	r3, [r3, #17]
    8306:	4618      	mov	r0, r3
    8308:	f00d fe70 	bl	15fec <nrf_gpio_cfg_output>
}
    830c:	bf00      	nop
    830e:	3708      	adds	r7, #8
    8310:	46bd      	mov	sp, r7
    8312:	bd80      	pop	{r7, pc}
    8314:	5000d000 	.word	0x5000d000

00008318 <ctrl_pin_idle>:

/* Sets pin to idle state. In case of request pin it means out,low and in case
 * of response pin it means in, nopull, low to high detection enabled.
 */
static void ctrl_pin_idle(const struct lpuart_bidir_gpio *io)
{
    8318:	b580      	push	{r7, lr}
    831a:	b082      	sub	sp, #8
    831c:	af00      	add	r7, sp, #0
    831e:	6078      	str	r0, [r7, #4]
	if (io->req) {
    8320:	687b      	ldr	r3, [r7, #4]
    8322:	7cdb      	ldrb	r3, [r3, #19]
    8324:	2b00      	cmp	r3, #0
    8326:	d003      	beq.n	8330 <ctrl_pin_idle+0x18>
		ctrl_pin_clear(io);
    8328:	6878      	ldr	r0, [r7, #4]
    832a:	f7ff ffdb 	bl	82e4 <ctrl_pin_clear>
		return;
    832e:	e01b      	b.n	8368 <ctrl_pin_idle+0x50>
	}

	nrf_gpiote_te_default(NRF_GPIOTE, io->ch);
    8330:	687b      	ldr	r3, [r7, #4]
    8332:	7c9b      	ldrb	r3, [r3, #18]
    8334:	4619      	mov	r1, r3
    8336:	480e      	ldr	r0, [pc, #56]	; (8370 <ctrl_pin_idle+0x58>)
    8338:	f00d ffb6 	bl	162a8 <nrf_gpiote_te_default>
	nrf_gpiote_event_configure(NRF_GPIOTE, io->ch, io->nrf_pin,
    833c:	687b      	ldr	r3, [r7, #4]
    833e:	7c9b      	ldrb	r3, [r3, #18]
    8340:	4619      	mov	r1, r3
    8342:	687b      	ldr	r3, [r7, #4]
    8344:	7c5b      	ldrb	r3, [r3, #17]
    8346:	461a      	mov	r2, r3
    8348:	2301      	movs	r3, #1
    834a:	4809      	ldr	r0, [pc, #36]	; (8370 <ctrl_pin_idle+0x58>)
    834c:	f00d ff52 	bl	161f4 <nrf_gpiote_event_configure>
					NRF_GPIOTE_POLARITY_LOTOHI);

	nrf_gpio_cfg_input(io->nrf_pin, NRF_GPIO_PIN_NOPULL);
    8350:	687b      	ldr	r3, [r7, #4]
    8352:	7c5b      	ldrb	r3, [r3, #17]
    8354:	2100      	movs	r1, #0
    8356:	4618      	mov	r0, r3
    8358:	f00d fe5a 	bl	16010 <nrf_gpio_cfg_input>
	nrf_gpiote_event_enable(NRF_GPIOTE, io->ch);
    835c:	687b      	ldr	r3, [r7, #4]
    835e:	7c9b      	ldrb	r3, [r3, #18]
    8360:	4619      	mov	r1, r3
    8362:	4803      	ldr	r0, [pc, #12]	; (8370 <ctrl_pin_idle+0x58>)
    8364:	f00d ff2e 	bl	161c4 <nrf_gpiote_event_enable>
}
    8368:	3708      	adds	r7, #8
    836a:	46bd      	mov	sp, r7
    836c:	bd80      	pop	{r7, pc}
    836e:	bf00      	nop
    8370:	5000d000 	.word	0x5000d000

00008374 <activate_rx>:
/* Function enables RX, after that it informs transmitter about readiness by
 * clearing the pin (out, low) and then reconfigures to in, pullup + high to low
 * detection to detect end of transfer.
 */
static void activate_rx(struct lpuart_data *data)
{
    8374:	b580      	push	{r7, lr}
    8376:	b086      	sub	sp, #24
    8378:	af00      	add	r7, sp, #0
    837a:	6078      	str	r0, [r7, #4]
	int err;

	if (data->rx_buf == NULL) {
    837c:	687b      	ldr	r3, [r7, #4]
    837e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    8380:	2b00      	cmp	r3, #0
    8382:	d12f      	bne.n	83e4 <activate_rx+0x70>
		LOG_ERR("RX: Request before enabling RX");
    8384:	2303      	movs	r3, #3
    8386:	2b00      	cmp	r3, #0
    8388:	f000 808e 	beq.w	84a8 <activate_rx+0x134>
    838c:	f00d fab6 	bl	158fc <_is_user_context>
    8390:	4603      	mov	r3, r0
    8392:	74bb      	strb	r3, [r7, #18]
    8394:	7c3b      	ldrb	r3, [r7, #16]
    8396:	2201      	movs	r2, #1
    8398:	f362 0302 	bfi	r3, r2, #0, #3
    839c:	743b      	strb	r3, [r7, #16]
    839e:	7c3b      	ldrb	r3, [r7, #16]
    83a0:	f36f 03c5 	bfc	r3, #3, #3
    83a4:	743b      	strb	r3, [r7, #16]
    83a6:	2303      	movs	r3, #3
    83a8:	2b00      	cmp	r3, #0
    83aa:	d009      	beq.n	83c0 <activate_rx+0x4c>
    83ac:	4b40      	ldr	r3, [pc, #256]	; (84b0 <activate_rx+0x13c>)
    83ae:	681b      	ldr	r3, [r3, #0]
    83b0:	4618      	mov	r0, r3
    83b2:	f7ff ff37 	bl	8224 <log_const_source_id>
    83b6:	4603      	mov	r3, r0
    83b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    83bc:	b29a      	uxth	r2, r3
    83be:	e000      	b.n	83c2 <activate_rx+0x4e>
    83c0:	2200      	movs	r2, #0
    83c2:	8a3b      	ldrh	r3, [r7, #16]
    83c4:	f362 138f 	bfi	r3, r2, #6, #10
    83c8:	823b      	strh	r3, [r7, #16]
    83ca:	7cbb      	ldrb	r3, [r7, #18]
    83cc:	2b00      	cmp	r3, #0
    83ce:	d004      	beq.n	83da <activate_rx+0x66>
    83d0:	4938      	ldr	r1, [pc, #224]	; (84b4 <activate_rx+0x140>)
    83d2:	8a38      	ldrh	r0, [r7, #16]
    83d4:	f7fa fa8c 	bl	28f0 <log_from_user>
		return;
    83d8:	e066      	b.n	84a8 <activate_rx+0x134>
		LOG_ERR("RX: Request before enabling RX");
    83da:	8a39      	ldrh	r1, [r7, #16]
    83dc:	4835      	ldr	r0, [pc, #212]	; (84b4 <activate_rx+0x140>)
    83de:	f009 f920 	bl	11622 <log_0>
		return;
    83e2:	e061      	b.n	84a8 <activate_rx+0x134>
	}

	err = uart_rx_enable(data->uart, data->rx_buf,
    83e4:	687b      	ldr	r3, [r7, #4]
    83e6:	6818      	ldr	r0, [r3, #0]
    83e8:	687b      	ldr	r3, [r7, #4]
    83ea:	6f99      	ldr	r1, [r3, #120]	; 0x78
    83ec:	687b      	ldr	r3, [r7, #4]
    83ee:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    83f0:	687b      	ldr	r3, [r7, #4]
    83f2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    83f6:	f00d fd43 	bl	15e80 <uart_rx_enable>
    83fa:	6178      	str	r0, [r7, #20]
				data->rx_len, data->rx_timeout);
	__ASSERT(err == 0, "RX: Enabling failed (err:%d)", err);
    83fc:	697b      	ldr	r3, [r7, #20]
    83fe:	2b00      	cmp	r3, #0
    8400:	d00d      	beq.n	841e <activate_rx+0xaa>
    8402:	23d3      	movs	r3, #211	; 0xd3
    8404:	4a2c      	ldr	r2, [pc, #176]	; (84b8 <activate_rx+0x144>)
    8406:	492d      	ldr	r1, [pc, #180]	; (84bc <activate_rx+0x148>)
    8408:	482d      	ldr	r0, [pc, #180]	; (84c0 <activate_rx+0x14c>)
    840a:	f007 fe2d 	bl	10068 <printk>
    840e:	6979      	ldr	r1, [r7, #20]
    8410:	482c      	ldr	r0, [pc, #176]	; (84c4 <activate_rx+0x150>)
    8412:	f007 fe29 	bl	10068 <printk>
    8416:	21d3      	movs	r1, #211	; 0xd3
    8418:	4827      	ldr	r0, [pc, #156]	; (84b8 <activate_rx+0x144>)
    841a:	f008 fc6d 	bl	10cf8 <assert_post_action>

	/* Ready. Confirm by toggling the pin. */
	ctrl_pin_clear(&data->rdy_pin);
    841e:	687b      	ldr	r3, [r7, #4]
    8420:	3318      	adds	r3, #24
    8422:	4618      	mov	r0, r3
    8424:	f7ff ff5e 	bl	82e4 <ctrl_pin_clear>
	ctrl_pin_set(&data->rdy_pin, false);
    8428:	687b      	ldr	r3, [r7, #4]
    842a:	3318      	adds	r3, #24
    842c:	2100      	movs	r1, #0
    842e:	4618      	mov	r0, r3
    8430:	f7ff ff08 	bl	8244 <ctrl_pin_set>
	LOG_DBG("RX: Ready");
    8434:	2303      	movs	r3, #3
    8436:	2b03      	cmp	r3, #3
    8438:	d92d      	bls.n	8496 <activate_rx+0x122>
    843a:	f00d fa5f 	bl	158fc <_is_user_context>
    843e:	4603      	mov	r3, r0
    8440:	74fb      	strb	r3, [r7, #19]
    8442:	7b3b      	ldrb	r3, [r7, #12]
    8444:	2204      	movs	r2, #4
    8446:	f362 0302 	bfi	r3, r2, #0, #3
    844a:	733b      	strb	r3, [r7, #12]
    844c:	7b3b      	ldrb	r3, [r7, #12]
    844e:	f36f 03c5 	bfc	r3, #3, #3
    8452:	733b      	strb	r3, [r7, #12]
    8454:	2303      	movs	r3, #3
    8456:	2b00      	cmp	r3, #0
    8458:	d009      	beq.n	846e <activate_rx+0xfa>
    845a:	4b15      	ldr	r3, [pc, #84]	; (84b0 <activate_rx+0x13c>)
    845c:	681b      	ldr	r3, [r3, #0]
    845e:	4618      	mov	r0, r3
    8460:	f7ff fee0 	bl	8224 <log_const_source_id>
    8464:	4603      	mov	r3, r0
    8466:	f3c3 0309 	ubfx	r3, r3, #0, #10
    846a:	b29a      	uxth	r2, r3
    846c:	e000      	b.n	8470 <activate_rx+0xfc>
    846e:	2200      	movs	r2, #0
    8470:	89bb      	ldrh	r3, [r7, #12]
    8472:	f362 138f 	bfi	r3, r2, #6, #10
    8476:	81bb      	strh	r3, [r7, #12]
    8478:	7cfb      	ldrb	r3, [r7, #19]
    847a:	2b00      	cmp	r3, #0
    847c:	d005      	beq.n	848a <activate_rx+0x116>
    847e:	4a12      	ldr	r2, [pc, #72]	; (84c8 <activate_rx+0x154>)
    8480:	4912      	ldr	r1, [pc, #72]	; (84cc <activate_rx+0x158>)
    8482:	89b8      	ldrh	r0, [r7, #12]
    8484:	f7fa fa34 	bl	28f0 <log_from_user>
    8488:	e005      	b.n	8496 <activate_rx+0x122>
    848a:	4b0f      	ldr	r3, [pc, #60]	; (84c8 <activate_rx+0x154>)
    848c:	89ba      	ldrh	r2, [r7, #12]
    848e:	4619      	mov	r1, r3
    8490:	480e      	ldr	r0, [pc, #56]	; (84cc <activate_rx+0x158>)
    8492:	f009 f8db 	bl	1164c <log_1>
	data->rx_req = false;
    8496:	687b      	ldr	r3, [r7, #4]
    8498:	2200      	movs	r2, #0
    849a:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
	data->rx_state = RX_ACTIVE;
    849e:	687b      	ldr	r3, [r7, #4]
    84a0:	2202      	movs	r2, #2
    84a2:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
    84a6:	e000      	b.n	84aa <activate_rx+0x136>
		return;
    84a8:	bf00      	nop
}
    84aa:	3718      	adds	r7, #24
    84ac:	46bd      	mov	sp, r7
    84ae:	bd80      	pop	{r7, pc}
    84b0:	20000148 	.word	0x20000148
    84b4:	0001a754 	.word	0x0001a754
    84b8:	0001a774 	.word	0x0001a774
    84bc:	0001a7a8 	.word	0x0001a7a8
    84c0:	0001a16c 	.word	0x0001a16c
    84c4:	0001a7b4 	.word	0x0001a7b4
    84c8:	0001ccec 	.word	0x0001ccec
    84cc:	0001a7d4 	.word	0x0001a7d4

000084d0 <deactivate_rx>:

/* Called when end of transfer is detected. It sets response pin to idle and
 * disables RX.
 */
static void deactivate_rx(struct lpuart_data *data)
{
    84d0:	b580      	push	{r7, lr}
    84d2:	b086      	sub	sp, #24
    84d4:	af00      	add	r7, sp, #0
    84d6:	6078      	str	r0, [r7, #4]
	int err;

	ctrl_pin_idle(&data->rdy_pin);
    84d8:	687b      	ldr	r3, [r7, #4]
    84da:	3318      	adds	r3, #24
    84dc:	4618      	mov	r0, r3
    84de:	f7ff ff1b 	bl	8318 <ctrl_pin_idle>
	if (nrf_gpio_pin_read(data->rdy_pin.nrf_pin)) {
    84e2:	687b      	ldr	r3, [r7, #4]
    84e4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    84e8:	4618      	mov	r0, r3
    84ea:	f00d fdcf 	bl	1608c <nrf_gpio_pin_read>
    84ee:	4603      	mov	r3, r0
    84f0:	2b00      	cmp	r3, #0
    84f2:	d03f      	beq.n	8574 <deactivate_rx+0xa4>
		LOG_DBG("RX: Request pending while deactivating");
    84f4:	2303      	movs	r3, #3
    84f6:	2b03      	cmp	r3, #3
    84f8:	d92d      	bls.n	8556 <deactivate_rx+0x86>
    84fa:	f00d f9ff 	bl	158fc <_is_user_context>
    84fe:	4603      	mov	r3, r0
    8500:	75fb      	strb	r3, [r7, #23]
    8502:	7b3b      	ldrb	r3, [r7, #12]
    8504:	2204      	movs	r2, #4
    8506:	f362 0302 	bfi	r3, r2, #0, #3
    850a:	733b      	strb	r3, [r7, #12]
    850c:	7b3b      	ldrb	r3, [r7, #12]
    850e:	f36f 03c5 	bfc	r3, #3, #3
    8512:	733b      	strb	r3, [r7, #12]
    8514:	2303      	movs	r3, #3
    8516:	2b00      	cmp	r3, #0
    8518:	d009      	beq.n	852e <deactivate_rx+0x5e>
    851a:	4b37      	ldr	r3, [pc, #220]	; (85f8 <deactivate_rx+0x128>)
    851c:	681b      	ldr	r3, [r3, #0]
    851e:	4618      	mov	r0, r3
    8520:	f7ff fe80 	bl	8224 <log_const_source_id>
    8524:	4603      	mov	r3, r0
    8526:	f3c3 0309 	ubfx	r3, r3, #0, #10
    852a:	b29a      	uxth	r2, r3
    852c:	e000      	b.n	8530 <deactivate_rx+0x60>
    852e:	2200      	movs	r2, #0
    8530:	89bb      	ldrh	r3, [r7, #12]
    8532:	f362 138f 	bfi	r3, r2, #6, #10
    8536:	81bb      	strh	r3, [r7, #12]
    8538:	7dfb      	ldrb	r3, [r7, #23]
    853a:	2b00      	cmp	r3, #0
    853c:	d005      	beq.n	854a <deactivate_rx+0x7a>
    853e:	4a2f      	ldr	r2, [pc, #188]	; (85fc <deactivate_rx+0x12c>)
    8540:	492f      	ldr	r1, [pc, #188]	; (8600 <deactivate_rx+0x130>)
    8542:	89b8      	ldrh	r0, [r7, #12]
    8544:	f7fa f9d4 	bl	28f0 <log_from_user>
    8548:	e005      	b.n	8556 <deactivate_rx+0x86>
    854a:	4b2c      	ldr	r3, [pc, #176]	; (85fc <deactivate_rx+0x12c>)
    854c:	89ba      	ldrh	r2, [r7, #12]
    854e:	4619      	mov	r1, r3
    8550:	482b      	ldr	r0, [pc, #172]	; (8600 <deactivate_rx+0x130>)
    8552:	f009 f87b 	bl	1164c <log_1>
		/* pin is set high, another request pending. */
		nrf_gpiote_event_clear(NRF_GPIOTE,
    8556:	687b      	ldr	r3, [r7, #4]
    8558:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
    855c:	4618      	mov	r0, r3
    855e:	f7ff fe3d 	bl	81dc <nrf_gpiote_in_event_get>
    8562:	4603      	mov	r3, r0
    8564:	4619      	mov	r1, r3
    8566:	4827      	ldr	r0, [pc, #156]	; (8604 <deactivate_rx+0x134>)
    8568:	f00d fe02 	bl	16170 <nrf_gpiote_event_clear>
				     nrf_gpiote_in_event_get(data->rdy_pin.ch));
		data->rx_req = true;
    856c:	687b      	ldr	r3, [r7, #4]
    856e:	2201      	movs	r2, #1
    8570:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
	}

	/* abort rx */
	data->rx_state = RX_TO_IDLE;
    8574:	687b      	ldr	r3, [r7, #4]
    8576:	2203      	movs	r2, #3
    8578:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	err = uart_rx_disable(data->uart);
    857c:	687b      	ldr	r3, [r7, #4]
    857e:	681b      	ldr	r3, [r3, #0]
    8580:	4618      	mov	r0, r3
    8582:	f00d fc8f 	bl	15ea4 <uart_rx_disable>
    8586:	6138      	str	r0, [r7, #16]
	if (err < 0) {
    8588:	693b      	ldr	r3, [r7, #16]
    858a:	2b00      	cmp	r3, #0
    858c:	da30      	bge.n	85f0 <deactivate_rx+0x120>
		LOG_ERR("RX: Failed to disable (err: %d)", err);
    858e:	2303      	movs	r3, #3
    8590:	2b00      	cmp	r3, #0
    8592:	d02d      	beq.n	85f0 <deactivate_rx+0x120>
    8594:	f00d f9b2 	bl	158fc <_is_user_context>
    8598:	4603      	mov	r3, r0
    859a:	73fb      	strb	r3, [r7, #15]
    859c:	7a3b      	ldrb	r3, [r7, #8]
    859e:	2201      	movs	r2, #1
    85a0:	f362 0302 	bfi	r3, r2, #0, #3
    85a4:	723b      	strb	r3, [r7, #8]
    85a6:	7a3b      	ldrb	r3, [r7, #8]
    85a8:	f36f 03c5 	bfc	r3, #3, #3
    85ac:	723b      	strb	r3, [r7, #8]
    85ae:	2303      	movs	r3, #3
    85b0:	2b00      	cmp	r3, #0
    85b2:	d009      	beq.n	85c8 <deactivate_rx+0xf8>
    85b4:	4b10      	ldr	r3, [pc, #64]	; (85f8 <deactivate_rx+0x128>)
    85b6:	681b      	ldr	r3, [r3, #0]
    85b8:	4618      	mov	r0, r3
    85ba:	f7ff fe33 	bl	8224 <log_const_source_id>
    85be:	4603      	mov	r3, r0
    85c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    85c4:	b29a      	uxth	r2, r3
    85c6:	e000      	b.n	85ca <deactivate_rx+0xfa>
    85c8:	2200      	movs	r2, #0
    85ca:	893b      	ldrh	r3, [r7, #8]
    85cc:	f362 138f 	bfi	r3, r2, #6, #10
    85d0:	813b      	strh	r3, [r7, #8]
    85d2:	7bfb      	ldrb	r3, [r7, #15]
    85d4:	2b00      	cmp	r3, #0
    85d6:	d005      	beq.n	85e4 <deactivate_rx+0x114>
    85d8:	693a      	ldr	r2, [r7, #16]
    85da:	490b      	ldr	r1, [pc, #44]	; (8608 <deactivate_rx+0x138>)
    85dc:	8938      	ldrh	r0, [r7, #8]
    85de:	f7fa f987 	bl	28f0 <log_from_user>
	}
}
    85e2:	e005      	b.n	85f0 <deactivate_rx+0x120>
		LOG_ERR("RX: Failed to disable (err: %d)", err);
    85e4:	693b      	ldr	r3, [r7, #16]
    85e6:	893a      	ldrh	r2, [r7, #8]
    85e8:	4619      	mov	r1, r3
    85ea:	4807      	ldr	r0, [pc, #28]	; (8608 <deactivate_rx+0x138>)
    85ec:	f009 f82e 	bl	1164c <log_1>
}
    85f0:	bf00      	nop
    85f2:	3718      	adds	r7, #24
    85f4:	46bd      	mov	sp, r7
    85f6:	bd80      	pop	{r7, pc}
    85f8:	20000148 	.word	0x20000148
    85fc:	0001ccf8 	.word	0x0001ccf8
    8600:	0001a7e4 	.word	0x0001a7e4
    8604:	5000d000 	.word	0x5000d000
    8608:	0001a810 	.word	0x0001a810

0000860c <on_req_pin_change>:
	data->tx_buf = NULL;
	data->tx_active = false;
}

static void on_req_pin_change(struct lpuart_data *data)
{
    860c:	b580      	push	{r7, lr}
    860e:	b08e      	sub	sp, #56	; 0x38
    8610:	af00      	add	r7, sp, #0
    8612:	6078      	str	r0, [r7, #4]
	int key;
	const uint8_t *buf;
	size_t len;
	int err;

	if (data->tx_buf == NULL) {
    8614:	687b      	ldr	r3, [r7, #4]
    8616:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8618:	2b00      	cmp	r3, #0
    861a:	d133      	bne.n	8684 <on_req_pin_change+0x78>
		LOG_WRN("TX: request confirmed but no data to send");
    861c:	2303      	movs	r3, #3
    861e:	2b01      	cmp	r3, #1
    8620:	d92c      	bls.n	867c <on_req_pin_change+0x70>
    8622:	f00d f96b 	bl	158fc <_is_user_context>
    8626:	4603      	mov	r3, r0
    8628:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    862c:	7c3b      	ldrb	r3, [r7, #16]
    862e:	2202      	movs	r2, #2
    8630:	f362 0302 	bfi	r3, r2, #0, #3
    8634:	743b      	strb	r3, [r7, #16]
    8636:	7c3b      	ldrb	r3, [r7, #16]
    8638:	f36f 03c5 	bfc	r3, #3, #3
    863c:	743b      	strb	r3, [r7, #16]
    863e:	2303      	movs	r3, #3
    8640:	2b00      	cmp	r3, #0
    8642:	d009      	beq.n	8658 <on_req_pin_change+0x4c>
    8644:	4b5f      	ldr	r3, [pc, #380]	; (87c4 <on_req_pin_change+0x1b8>)
    8646:	681b      	ldr	r3, [r3, #0]
    8648:	4618      	mov	r0, r3
    864a:	f7ff fdeb 	bl	8224 <log_const_source_id>
    864e:	4603      	mov	r3, r0
    8650:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8654:	b29a      	uxth	r2, r3
    8656:	e000      	b.n	865a <on_req_pin_change+0x4e>
    8658:	2200      	movs	r2, #0
    865a:	8a3b      	ldrh	r3, [r7, #16]
    865c:	f362 138f 	bfi	r3, r2, #6, #10
    8660:	823b      	strh	r3, [r7, #16]
    8662:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    8666:	2b00      	cmp	r3, #0
    8668:	d004      	beq.n	8674 <on_req_pin_change+0x68>
    866a:	4957      	ldr	r1, [pc, #348]	; (87c8 <on_req_pin_change+0x1bc>)
    866c:	8a38      	ldrh	r0, [r7, #16]
    866e:	f7fa f93f 	bl	28f0 <log_from_user>
    8672:	e003      	b.n	867c <on_req_pin_change+0x70>
    8674:	8a39      	ldrh	r1, [r7, #16]
    8676:	4854      	ldr	r0, [pc, #336]	; (87c8 <on_req_pin_change+0x1bc>)
    8678:	f008 ffd3 	bl	11622 <log_0>
		tx_complete(data);
    867c:	6878      	ldr	r0, [r7, #4]
    867e:	f00d fe3a 	bl	162f6 <tx_complete>
		/* aborted */
		return;
    8682:	e09c      	b.n	87be <on_req_pin_change+0x1b2>
	}

	LOG_DBG("TX: Confirmed, starting.");
    8684:	2303      	movs	r3, #3
    8686:	2b03      	cmp	r3, #3
    8688:	d92f      	bls.n	86ea <on_req_pin_change+0xde>
    868a:	f00d f937 	bl	158fc <_is_user_context>
    868e:	4603      	mov	r3, r0
    8690:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    8694:	7b3b      	ldrb	r3, [r7, #12]
    8696:	2204      	movs	r2, #4
    8698:	f362 0302 	bfi	r3, r2, #0, #3
    869c:	733b      	strb	r3, [r7, #12]
    869e:	7b3b      	ldrb	r3, [r7, #12]
    86a0:	f36f 03c5 	bfc	r3, #3, #3
    86a4:	733b      	strb	r3, [r7, #12]
    86a6:	2303      	movs	r3, #3
    86a8:	2b00      	cmp	r3, #0
    86aa:	d009      	beq.n	86c0 <on_req_pin_change+0xb4>
    86ac:	4b45      	ldr	r3, [pc, #276]	; (87c4 <on_req_pin_change+0x1b8>)
    86ae:	681b      	ldr	r3, [r3, #0]
    86b0:	4618      	mov	r0, r3
    86b2:	f7ff fdb7 	bl	8224 <log_const_source_id>
    86b6:	4603      	mov	r3, r0
    86b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    86bc:	b29a      	uxth	r2, r3
    86be:	e000      	b.n	86c2 <on_req_pin_change+0xb6>
    86c0:	2200      	movs	r2, #0
    86c2:	89bb      	ldrh	r3, [r7, #12]
    86c4:	f362 138f 	bfi	r3, r2, #6, #10
    86c8:	81bb      	strh	r3, [r7, #12]
    86ca:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    86ce:	2b00      	cmp	r3, #0
    86d0:	d005      	beq.n	86de <on_req_pin_change+0xd2>
    86d2:	4a3e      	ldr	r2, [pc, #248]	; (87cc <on_req_pin_change+0x1c0>)
    86d4:	493e      	ldr	r1, [pc, #248]	; (87d0 <on_req_pin_change+0x1c4>)
    86d6:	89b8      	ldrh	r0, [r7, #12]
    86d8:	f7fa f90a 	bl	28f0 <log_from_user>
    86dc:	e005      	b.n	86ea <on_req_pin_change+0xde>
    86de:	4b3b      	ldr	r3, [pc, #236]	; (87cc <on_req_pin_change+0x1c0>)
    86e0:	89ba      	ldrh	r2, [r7, #12]
    86e2:	4619      	mov	r1, r3
    86e4:	483a      	ldr	r0, [pc, #232]	; (87d0 <on_req_pin_change+0x1c4>)
    86e6:	f008 ffb1 	bl	1164c <log_1>
	ctrl_pin_set(&data->req_pin, true);
    86ea:	687b      	ldr	r3, [r7, #4]
    86ec:	3304      	adds	r3, #4
    86ee:	2101      	movs	r1, #1
    86f0:	4618      	mov	r0, r3
    86f2:	f7ff fda7 	bl	8244 <ctrl_pin_set>
	k_timer_stop(&data->tx_timer);
    86f6:	687b      	ldr	r3, [r7, #4]
    86f8:	3330      	adds	r3, #48	; 0x30
    86fa:	4618      	mov	r0, r3
    86fc:	f00d facc 	bl	15c98 <k_timer_stop>
	__asm__ volatile(
    8700:	f04f 0320 	mov.w	r3, #32
    8704:	f3ef 8211 	mrs	r2, BASEPRI
    8708:	f383 8811 	msr	BASEPRI, r3
    870c:	f3bf 8f6f 	isb	sy
    8710:	61ba      	str	r2, [r7, #24]
    8712:	617b      	str	r3, [r7, #20]
	return key;
    8714:	69bb      	ldr	r3, [r7, #24]

	key = irq_lock();
    8716:	633b      	str	r3, [r7, #48]	; 0x30
	data->tx_active = true;
    8718:	687b      	ldr	r3, [r7, #4]
    871a:	2201      	movs	r2, #1
    871c:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
	buf = data->tx_buf;
    8720:	687b      	ldr	r3, [r7, #4]
    8722:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8724:	62fb      	str	r3, [r7, #44]	; 0x2c
	len = data->tx_len;
    8726:	687b      	ldr	r3, [r7, #4]
    8728:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    872a:	62bb      	str	r3, [r7, #40]	; 0x28
	irq_unlock(key);
    872c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    872e:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    8730:	69fb      	ldr	r3, [r7, #28]
    8732:	f383 8811 	msr	BASEPRI, r3
    8736:	f3bf 8f6f 	isb	sy
}
    873a:	bf00      	nop
	err = uart_tx(data->uart, buf, len, 0);
    873c:	687b      	ldr	r3, [r7, #4]
    873e:	6818      	ldr	r0, [r3, #0]
    8740:	2300      	movs	r3, #0
    8742:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8744:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    8746:	f00d fb7d 	bl	15e44 <uart_tx>
    874a:	6278      	str	r0, [r7, #36]	; 0x24
	if (err < 0) {
    874c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    874e:	2b00      	cmp	r3, #0
    8750:	da35      	bge.n	87be <on_req_pin_change+0x1b2>
		LOG_ERR("TX: Not started (error: %d)", err);
    8752:	2303      	movs	r3, #3
    8754:	2b00      	cmp	r3, #0
    8756:	d02f      	beq.n	87b8 <on_req_pin_change+0x1ac>
    8758:	f00d f8d0 	bl	158fc <_is_user_context>
    875c:	4603      	mov	r3, r0
    875e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    8762:	7a3b      	ldrb	r3, [r7, #8]
    8764:	2201      	movs	r2, #1
    8766:	f362 0302 	bfi	r3, r2, #0, #3
    876a:	723b      	strb	r3, [r7, #8]
    876c:	7a3b      	ldrb	r3, [r7, #8]
    876e:	f36f 03c5 	bfc	r3, #3, #3
    8772:	723b      	strb	r3, [r7, #8]
    8774:	2303      	movs	r3, #3
    8776:	2b00      	cmp	r3, #0
    8778:	d009      	beq.n	878e <on_req_pin_change+0x182>
    877a:	4b12      	ldr	r3, [pc, #72]	; (87c4 <on_req_pin_change+0x1b8>)
    877c:	681b      	ldr	r3, [r3, #0]
    877e:	4618      	mov	r0, r3
    8780:	f7ff fd50 	bl	8224 <log_const_source_id>
    8784:	4603      	mov	r3, r0
    8786:	f3c3 0309 	ubfx	r3, r3, #0, #10
    878a:	b29a      	uxth	r2, r3
    878c:	e000      	b.n	8790 <on_req_pin_change+0x184>
    878e:	2200      	movs	r2, #0
    8790:	893b      	ldrh	r3, [r7, #8]
    8792:	f362 138f 	bfi	r3, r2, #6, #10
    8796:	813b      	strh	r3, [r7, #8]
    8798:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    879c:	2b00      	cmp	r3, #0
    879e:	d005      	beq.n	87ac <on_req_pin_change+0x1a0>
    87a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    87a2:	490c      	ldr	r1, [pc, #48]	; (87d4 <on_req_pin_change+0x1c8>)
    87a4:	8938      	ldrh	r0, [r7, #8]
    87a6:	f7fa f8a3 	bl	28f0 <log_from_user>
    87aa:	e005      	b.n	87b8 <on_req_pin_change+0x1ac>
    87ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    87ae:	893a      	ldrh	r2, [r7, #8]
    87b0:	4619      	mov	r1, r3
    87b2:	4808      	ldr	r0, [pc, #32]	; (87d4 <on_req_pin_change+0x1c8>)
    87b4:	f008 ff4a 	bl	1164c <log_1>
		tx_complete(data);
    87b8:	6878      	ldr	r0, [r7, #4]
    87ba:	f00d fd9c 	bl	162f6 <tx_complete>
	}
}
    87be:	3738      	adds	r7, #56	; 0x38
    87c0:	46bd      	mov	sp, r7
    87c2:	bd80      	pop	{r7, pc}
    87c4:	20000148 	.word	0x20000148
    87c8:	0001a830 	.word	0x0001a830
    87cc:	0001cd08 	.word	0x0001cd08
    87d0:	0001a85c 	.word	0x0001a85c
    87d4:	0001a87c 	.word	0x0001a87c

000087d8 <on_rdy_pin_change>:

static void on_rdy_pin_change(struct lpuart_data *data)
{
    87d8:	b580      	push	{r7, lr}
    87da:	b084      	sub	sp, #16
    87dc:	af00      	add	r7, sp, #0
    87de:	6078      	str	r0, [r7, #4]
	if (nrf_gpiote_event_polarity_get(NRF_GPIOTE, data->rdy_pin.ch)
    87e0:	687b      	ldr	r3, [r7, #4]
    87e2:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
    87e6:	4619      	mov	r1, r3
    87e8:	484e      	ldr	r0, [pc, #312]	; (8924 <on_rdy_pin_change+0x14c>)
    87ea:	f00d fd49 	bl	16280 <nrf_gpiote_event_polarity_get>
    87ee:	4603      	mov	r3, r0
    87f0:	2b01      	cmp	r3, #1
    87f2:	d14e      	bne.n	8892 <on_rdy_pin_change+0xba>
		== NRF_GPIOTE_POLARITY_LOTOHI) {
		__ASSERT_NO_MSG(data->rx_state != RX_ACTIVE);
    87f4:	687b      	ldr	r3, [r7, #4]
    87f6:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    87fa:	2b02      	cmp	r3, #2
    87fc:	d10b      	bne.n	8816 <on_rdy_pin_change+0x3e>
    87fe:	f44f 738f 	mov.w	r3, #286	; 0x11e
    8802:	4a49      	ldr	r2, [pc, #292]	; (8928 <on_rdy_pin_change+0x150>)
    8804:	4949      	ldr	r1, [pc, #292]	; (892c <on_rdy_pin_change+0x154>)
    8806:	484a      	ldr	r0, [pc, #296]	; (8930 <on_rdy_pin_change+0x158>)
    8808:	f007 fc2e 	bl	10068 <printk>
    880c:	f44f 718f 	mov.w	r1, #286	; 0x11e
    8810:	4845      	ldr	r0, [pc, #276]	; (8928 <on_rdy_pin_change+0x150>)
    8812:	f008 fa71 	bl	10cf8 <assert_post_action>

		LOG_DBG("RX: Request detected.");
    8816:	2303      	movs	r3, #3
    8818:	2b03      	cmp	r3, #3
    881a:	d92d      	bls.n	8878 <on_rdy_pin_change+0xa0>
    881c:	f00d f86e 	bl	158fc <_is_user_context>
    8820:	4603      	mov	r3, r0
    8822:	73bb      	strb	r3, [r7, #14]
    8824:	7b3b      	ldrb	r3, [r7, #12]
    8826:	2204      	movs	r2, #4
    8828:	f362 0302 	bfi	r3, r2, #0, #3
    882c:	733b      	strb	r3, [r7, #12]
    882e:	7b3b      	ldrb	r3, [r7, #12]
    8830:	f36f 03c5 	bfc	r3, #3, #3
    8834:	733b      	strb	r3, [r7, #12]
    8836:	2303      	movs	r3, #3
    8838:	2b00      	cmp	r3, #0
    883a:	d009      	beq.n	8850 <on_rdy_pin_change+0x78>
    883c:	4b3d      	ldr	r3, [pc, #244]	; (8934 <on_rdy_pin_change+0x15c>)
    883e:	681b      	ldr	r3, [r3, #0]
    8840:	4618      	mov	r0, r3
    8842:	f7ff fcef 	bl	8224 <log_const_source_id>
    8846:	4603      	mov	r3, r0
    8848:	f3c3 0309 	ubfx	r3, r3, #0, #10
    884c:	b29a      	uxth	r2, r3
    884e:	e000      	b.n	8852 <on_rdy_pin_change+0x7a>
    8850:	2200      	movs	r2, #0
    8852:	89bb      	ldrh	r3, [r7, #12]
    8854:	f362 138f 	bfi	r3, r2, #6, #10
    8858:	81bb      	strh	r3, [r7, #12]
    885a:	7bbb      	ldrb	r3, [r7, #14]
    885c:	2b00      	cmp	r3, #0
    885e:	d005      	beq.n	886c <on_rdy_pin_change+0x94>
    8860:	4a35      	ldr	r2, [pc, #212]	; (8938 <on_rdy_pin_change+0x160>)
    8862:	4936      	ldr	r1, [pc, #216]	; (893c <on_rdy_pin_change+0x164>)
    8864:	89b8      	ldrh	r0, [r7, #12]
    8866:	f7fa f843 	bl	28f0 <log_from_user>
    886a:	e005      	b.n	8878 <on_rdy_pin_change+0xa0>
    886c:	4b32      	ldr	r3, [pc, #200]	; (8938 <on_rdy_pin_change+0x160>)
    886e:	89ba      	ldrh	r2, [r7, #12]
    8870:	4619      	mov	r1, r3
    8872:	4832      	ldr	r0, [pc, #200]	; (893c <on_rdy_pin_change+0x164>)
    8874:	f008 feea 	bl	1164c <log_1>
		data->rx_req = true;
    8878:	687b      	ldr	r3, [r7, #4]
    887a:	2201      	movs	r2, #1
    887c:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
		if (data->rx_state == RX_IDLE) {
    8880:	687b      	ldr	r3, [r7, #4]
    8882:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8886:	2b01      	cmp	r3, #1
    8888:	d148      	bne.n	891c <on_rdy_pin_change+0x144>
			activate_rx(data);
    888a:	6878      	ldr	r0, [r7, #4]
    888c:	f7ff fd72 	bl	8374 <activate_rx>
		__ASSERT_NO_MSG(data->rx_state == RX_ACTIVE);

		LOG_DBG("RX: End detected.");
		deactivate_rx(data);
	}
}
    8890:	e044      	b.n	891c <on_rdy_pin_change+0x144>
		__ASSERT_NO_MSG(data->rx_state == RX_ACTIVE);
    8892:	687b      	ldr	r3, [r7, #4]
    8894:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8898:	2b02      	cmp	r3, #2
    889a:	d00b      	beq.n	88b4 <on_rdy_pin_change+0xdc>
    889c:	f44f 7393 	mov.w	r3, #294	; 0x126
    88a0:	4a21      	ldr	r2, [pc, #132]	; (8928 <on_rdy_pin_change+0x150>)
    88a2:	4927      	ldr	r1, [pc, #156]	; (8940 <on_rdy_pin_change+0x168>)
    88a4:	4822      	ldr	r0, [pc, #136]	; (8930 <on_rdy_pin_change+0x158>)
    88a6:	f007 fbdf 	bl	10068 <printk>
    88aa:	f44f 7193 	mov.w	r1, #294	; 0x126
    88ae:	481e      	ldr	r0, [pc, #120]	; (8928 <on_rdy_pin_change+0x150>)
    88b0:	f008 fa22 	bl	10cf8 <assert_post_action>
		LOG_DBG("RX: End detected.");
    88b4:	2303      	movs	r3, #3
    88b6:	2b03      	cmp	r3, #3
    88b8:	d92d      	bls.n	8916 <on_rdy_pin_change+0x13e>
    88ba:	f00d f81f 	bl	158fc <_is_user_context>
    88be:	4603      	mov	r3, r0
    88c0:	73fb      	strb	r3, [r7, #15]
    88c2:	7a3b      	ldrb	r3, [r7, #8]
    88c4:	2204      	movs	r2, #4
    88c6:	f362 0302 	bfi	r3, r2, #0, #3
    88ca:	723b      	strb	r3, [r7, #8]
    88cc:	7a3b      	ldrb	r3, [r7, #8]
    88ce:	f36f 03c5 	bfc	r3, #3, #3
    88d2:	723b      	strb	r3, [r7, #8]
    88d4:	2303      	movs	r3, #3
    88d6:	2b00      	cmp	r3, #0
    88d8:	d009      	beq.n	88ee <on_rdy_pin_change+0x116>
    88da:	4b16      	ldr	r3, [pc, #88]	; (8934 <on_rdy_pin_change+0x15c>)
    88dc:	681b      	ldr	r3, [r3, #0]
    88de:	4618      	mov	r0, r3
    88e0:	f7ff fca0 	bl	8224 <log_const_source_id>
    88e4:	4603      	mov	r3, r0
    88e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    88ea:	b29a      	uxth	r2, r3
    88ec:	e000      	b.n	88f0 <on_rdy_pin_change+0x118>
    88ee:	2200      	movs	r2, #0
    88f0:	893b      	ldrh	r3, [r7, #8]
    88f2:	f362 138f 	bfi	r3, r2, #6, #10
    88f6:	813b      	strh	r3, [r7, #8]
    88f8:	7bfb      	ldrb	r3, [r7, #15]
    88fa:	2b00      	cmp	r3, #0
    88fc:	d005      	beq.n	890a <on_rdy_pin_change+0x132>
    88fe:	4a0e      	ldr	r2, [pc, #56]	; (8938 <on_rdy_pin_change+0x160>)
    8900:	4910      	ldr	r1, [pc, #64]	; (8944 <on_rdy_pin_change+0x16c>)
    8902:	8938      	ldrh	r0, [r7, #8]
    8904:	f7f9 fff4 	bl	28f0 <log_from_user>
    8908:	e005      	b.n	8916 <on_rdy_pin_change+0x13e>
    890a:	4b0b      	ldr	r3, [pc, #44]	; (8938 <on_rdy_pin_change+0x160>)
    890c:	893a      	ldrh	r2, [r7, #8]
    890e:	4619      	mov	r1, r3
    8910:	480c      	ldr	r0, [pc, #48]	; (8944 <on_rdy_pin_change+0x16c>)
    8912:	f008 fe9b 	bl	1164c <log_1>
		deactivate_rx(data);
    8916:	6878      	ldr	r0, [r7, #4]
    8918:	f7ff fdda 	bl	84d0 <deactivate_rx>
}
    891c:	bf00      	nop
    891e:	3710      	adds	r7, #16
    8920:	46bd      	mov	sp, r7
    8922:	bd80      	pop	{r7, pc}
    8924:	5000d000 	.word	0x5000d000
    8928:	0001a774 	.word	0x0001a774
    892c:	0001a898 	.word	0x0001a898
    8930:	0001a16c 	.word	0x0001a16c
    8934:	20000148 	.word	0x20000148
    8938:	0001cd1c 	.word	0x0001cd1c
    893c:	0001a8b4 	.word	0x0001a8b4
    8940:	0001a8d0 	.word	0x0001a8d0
    8944:	0001a8ec 	.word	0x0001a8ec

00008948 <ctrl_pin_configure>:
	on_rdy_pin_change(data);
}

static int ctrl_pin_configure(struct lpuart_bidir_gpio *io,
			      const struct lpuart_pin_config *cfg, bool req)
{
    8948:	b580      	push	{r7, lr}
    894a:	b08e      	sub	sp, #56	; 0x38
    894c:	af02      	add	r7, sp, #8
    894e:	60f8      	str	r0, [r7, #12]
    8950:	60b9      	str	r1, [r7, #8]
    8952:	4613      	mov	r3, r2
    8954:	71fb      	strb	r3, [r7, #7]
	int err;
	size_t i;

	io->pin = cfg->pin;
    8956:	68bb      	ldr	r3, [r7, #8]
    8958:	791a      	ldrb	r2, [r3, #4]
    895a:	68fb      	ldr	r3, [r7, #12]
    895c:	741a      	strb	r2, [r3, #16]
	io->nrf_pin = cfg->nrf_pin;
    895e:	68bb      	ldr	r3, [r7, #8]
    8960:	795a      	ldrb	r2, [r3, #5]
    8962:	68fb      	ldr	r3, [r7, #12]
    8964:	745a      	strb	r2, [r3, #17]
	io->req = req;
    8966:	68fb      	ldr	r3, [r7, #12]
    8968:	79fa      	ldrb	r2, [r7, #7]
    896a:	74da      	strb	r2, [r3, #19]
	io->port = device_get_binding(cfg->port_name);
    896c:	68bb      	ldr	r3, [r7, #8]
    896e:	681b      	ldr	r3, [r3, #0]
    8970:	4618      	mov	r0, r3
    8972:	f00d f9b5 	bl	15ce0 <device_get_binding>
    8976:	4602      	mov	r2, r0
    8978:	68fb      	ldr	r3, [r7, #12]
    897a:	60da      	str	r2, [r3, #12]
	if (!io->port) {
    897c:	68fb      	ldr	r3, [r7, #12]
    897e:	68db      	ldr	r3, [r3, #12]
    8980:	2b00      	cmp	r3, #0
    8982:	d102      	bne.n	898a <ctrl_pin_configure+0x42>
		return -ENODEV;
    8984:	f06f 0312 	mvn.w	r3, #18
    8988:	e0bd      	b.n	8b06 <ctrl_pin_configure+0x1be>
	}

	gpio_init_callback(&io->callback, gpio_handler, BIT(io->pin));
    898a:	68f8      	ldr	r0, [r7, #12]
    898c:	68fb      	ldr	r3, [r7, #12]
    898e:	7c1b      	ldrb	r3, [r3, #16]
    8990:	461a      	mov	r2, r3
    8992:	2301      	movs	r3, #1
    8994:	4093      	lsls	r3, r2
    8996:	461a      	mov	r2, r3
    8998:	495d      	ldr	r1, [pc, #372]	; (8b10 <ctrl_pin_configure+0x1c8>)
    899a:	f7ff fba3 	bl	80e4 <gpio_init_callback>

	err = gpio_pin_configure(io->port, io->pin, GPIO_INPUT);
    899e:	68fb      	ldr	r3, [r7, #12]
    89a0:	68d8      	ldr	r0, [r3, #12]
    89a2:	68fb      	ldr	r3, [r7, #12]
    89a4:	7c1b      	ldrb	r3, [r3, #16]
    89a6:	f44f 7280 	mov.w	r2, #256	; 0x100
    89aa:	4619      	mov	r1, r3
    89ac:	f7ff fa96 	bl	7edc <gpio_pin_configure>
    89b0:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (err < 0) {
    89b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89b4:	2b00      	cmp	r3, #0
    89b6:	da01      	bge.n	89bc <ctrl_pin_configure+0x74>
		return err;
    89b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89ba:	e0a4      	b.n	8b06 <ctrl_pin_configure+0x1be>
	}

	err = gpio_add_callback(io->port, &io->callback);
    89bc:	68fb      	ldr	r3, [r7, #12]
    89be:	68db      	ldr	r3, [r3, #12]
    89c0:	68fa      	ldr	r2, [r7, #12]
    89c2:	4611      	mov	r1, r2
    89c4:	4618      	mov	r0, r3
    89c6:	f00d faaa 	bl	15f1e <gpio_add_callback>
    89ca:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (err < 0) {
    89cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89ce:	2b00      	cmp	r3, #0
    89d0:	da01      	bge.n	89d6 <ctrl_pin_configure+0x8e>
		return err;
    89d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89d4:	e097      	b.n	8b06 <ctrl_pin_configure+0x1be>
	}

	err = gpio_pin_interrupt_configure(io->port, io->pin, req ?
    89d6:	68fb      	ldr	r3, [r7, #12]
    89d8:	68d8      	ldr	r0, [r3, #12]
    89da:	68fb      	ldr	r3, [r7, #12]
    89dc:	7c19      	ldrb	r1, [r3, #16]
    89de:	79fb      	ldrb	r3, [r7, #7]
    89e0:	2b00      	cmp	r3, #0
    89e2:	d002      	beq.n	89ea <ctrl_pin_configure+0xa2>
    89e4:	f44f 3350 	mov.w	r3, #212992	; 0x34000
    89e8:	e001      	b.n	89ee <ctrl_pin_configure+0xa6>
    89ea:	f44f 23a8 	mov.w	r3, #344064	; 0x54000
    89ee:	461a      	mov	r2, r3
    89f0:	f00d fac1 	bl	15f76 <gpio_pin_interrupt_configure>
    89f4:	62f8      	str	r0, [r7, #44]	; 0x2c
				GPIO_INT_EDGE_FALLING : GPIO_INT_EDGE_RISING);
	if (err < 0) {
    89f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89f8:	2b00      	cmp	r3, #0
    89fa:	da01      	bge.n	8a00 <ctrl_pin_configure+0xb8>
		return err;
    89fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    89fe:	e082      	b.n	8b06 <ctrl_pin_configure+0x1be>
	}

	/* It is a hacky way to determine which channel is used for given pin.
	 * GPIO driver implementation change may lead to break.
	 */
	for (i = 0; i < GPIOTE_CH_NUM; i++) {
    8a00:	2300      	movs	r3, #0
    8a02:	62bb      	str	r3, [r7, #40]	; 0x28
    8a04:	e010      	b.n	8a28 <ctrl_pin_configure+0xe0>
		if (nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == io->nrf_pin) {
    8a06:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    8a08:	4842      	ldr	r0, [pc, #264]	; (8b14 <ctrl_pin_configure+0x1cc>)
    8a0a:	f00d fc26 	bl	1625a <nrf_gpiote_event_pin_get>
    8a0e:	4602      	mov	r2, r0
    8a10:	68fb      	ldr	r3, [r7, #12]
    8a12:	7c5b      	ldrb	r3, [r3, #17]
    8a14:	429a      	cmp	r2, r3
    8a16:	d104      	bne.n	8a22 <ctrl_pin_configure+0xda>
			io->ch = i;
    8a18:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8a1a:	b2da      	uxtb	r2, r3
    8a1c:	68fb      	ldr	r3, [r7, #12]
    8a1e:	749a      	strb	r2, [r3, #18]
			break;
    8a20:	e005      	b.n	8a2e <ctrl_pin_configure+0xe6>
	for (i = 0; i < GPIOTE_CH_NUM; i++) {
    8a22:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8a24:	3301      	adds	r3, #1
    8a26:	62bb      	str	r3, [r7, #40]	; 0x28
    8a28:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8a2a:	2b07      	cmp	r3, #7
    8a2c:	d9eb      	bls.n	8a06 <ctrl_pin_configure+0xbe>
		}
	}
	__ASSERT(i < GPIOTE_CH_NUM, "Used channel not found");
    8a2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8a30:	2b07      	cmp	r3, #7
    8a32:	d90e      	bls.n	8a52 <ctrl_pin_configure+0x10a>
    8a34:	f44f 73b4 	mov.w	r3, #360	; 0x168
    8a38:	4a37      	ldr	r2, [pc, #220]	; (8b18 <ctrl_pin_configure+0x1d0>)
    8a3a:	4938      	ldr	r1, [pc, #224]	; (8b1c <ctrl_pin_configure+0x1d4>)
    8a3c:	4838      	ldr	r0, [pc, #224]	; (8b20 <ctrl_pin_configure+0x1d8>)
    8a3e:	f007 fb13 	bl	10068 <printk>
    8a42:	4838      	ldr	r0, [pc, #224]	; (8b24 <ctrl_pin_configure+0x1dc>)
    8a44:	f007 fb10 	bl	10068 <printk>
    8a48:	f44f 71b4 	mov.w	r1, #360	; 0x168
    8a4c:	4832      	ldr	r0, [pc, #200]	; (8b18 <ctrl_pin_configure+0x1d0>)
    8a4e:	f008 f953 	bl	10cf8 <assert_post_action>

	ctrl_pin_idle(io);
    8a52:	68f8      	ldr	r0, [r7, #12]
    8a54:	f7ff fc60 	bl	8318 <ctrl_pin_idle>

	LOG_DBG("Pin %d configured, gpiote ch:%d, mode:%s",
    8a58:	2303      	movs	r3, #3
    8a5a:	2b03      	cmp	r3, #3
    8a5c:	d952      	bls.n	8b04 <ctrl_pin_configure+0x1bc>
    8a5e:	f00c ff4d 	bl	158fc <_is_user_context>
    8a62:	4603      	mov	r3, r0
    8a64:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    8a68:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    8a6c:	2204      	movs	r2, #4
    8a6e:	f362 0302 	bfi	r3, r2, #0, #3
    8a72:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    8a76:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    8a7a:	f36f 03c5 	bfc	r3, #3, #3
    8a7e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    8a82:	2303      	movs	r3, #3
    8a84:	2b00      	cmp	r3, #0
    8a86:	d009      	beq.n	8a9c <ctrl_pin_configure+0x154>
    8a88:	4b27      	ldr	r3, [pc, #156]	; (8b28 <ctrl_pin_configure+0x1e0>)
    8a8a:	681b      	ldr	r3, [r3, #0]
    8a8c:	4618      	mov	r0, r3
    8a8e:	f7ff fbc9 	bl	8224 <log_const_source_id>
    8a92:	4603      	mov	r3, r0
    8a94:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8a98:	b29a      	uxth	r2, r3
    8a9a:	e000      	b.n	8a9e <ctrl_pin_configure+0x156>
    8a9c:	2200      	movs	r2, #0
    8a9e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    8aa0:	f362 138f 	bfi	r3, r2, #6, #10
    8aa4:	84bb      	strh	r3, [r7, #36]	; 0x24
    8aa6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    8aaa:	2b00      	cmp	r3, #0
    8aac:	d014      	beq.n	8ad8 <ctrl_pin_configure+0x190>
    8aae:	68fb      	ldr	r3, [r7, #12]
    8ab0:	7c5b      	ldrb	r3, [r3, #17]
    8ab2:	4619      	mov	r1, r3
    8ab4:	68fb      	ldr	r3, [r7, #12]
    8ab6:	7c9b      	ldrb	r3, [r3, #18]
    8ab8:	461a      	mov	r2, r3
    8aba:	79fb      	ldrb	r3, [r7, #7]
    8abc:	2b00      	cmp	r3, #0
    8abe:	d001      	beq.n	8ac4 <ctrl_pin_configure+0x17c>
    8ac0:	4b1a      	ldr	r3, [pc, #104]	; (8b2c <ctrl_pin_configure+0x1e4>)
    8ac2:	e000      	b.n	8ac6 <ctrl_pin_configure+0x17e>
    8ac4:	4b1a      	ldr	r3, [pc, #104]	; (8b30 <ctrl_pin_configure+0x1e8>)
    8ac6:	9301      	str	r3, [sp, #4]
    8ac8:	9200      	str	r2, [sp, #0]
    8aca:	460b      	mov	r3, r1
    8acc:	4a19      	ldr	r2, [pc, #100]	; (8b34 <ctrl_pin_configure+0x1ec>)
    8ace:	491a      	ldr	r1, [pc, #104]	; (8b38 <ctrl_pin_configure+0x1f0>)
    8ad0:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
    8ad2:	f7f9 ff0d 	bl	28f0 <log_from_user>
    8ad6:	e015      	b.n	8b04 <ctrl_pin_configure+0x1bc>
    8ad8:	4b16      	ldr	r3, [pc, #88]	; (8b34 <ctrl_pin_configure+0x1ec>)
    8ada:	617b      	str	r3, [r7, #20]
    8adc:	68fb      	ldr	r3, [r7, #12]
    8ade:	7c5b      	ldrb	r3, [r3, #17]
    8ae0:	61bb      	str	r3, [r7, #24]
    8ae2:	68fb      	ldr	r3, [r7, #12]
    8ae4:	7c9b      	ldrb	r3, [r3, #18]
    8ae6:	61fb      	str	r3, [r7, #28]
    8ae8:	79fb      	ldrb	r3, [r7, #7]
    8aea:	2b00      	cmp	r3, #0
    8aec:	d001      	beq.n	8af2 <ctrl_pin_configure+0x1aa>
    8aee:	4b0f      	ldr	r3, [pc, #60]	; (8b2c <ctrl_pin_configure+0x1e4>)
    8af0:	e000      	b.n	8af4 <ctrl_pin_configure+0x1ac>
    8af2:	4b0f      	ldr	r3, [pc, #60]	; (8b30 <ctrl_pin_configure+0x1e8>)
    8af4:	623b      	str	r3, [r7, #32]
    8af6:	f107 0114 	add.w	r1, r7, #20
    8afa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
    8afc:	2204      	movs	r2, #4
    8afe:	480e      	ldr	r0, [pc, #56]	; (8b38 <ctrl_pin_configure+0x1f0>)
    8b00:	f008 fdee 	bl	116e0 <log_n>
		io->nrf_pin, io->ch, req ? "req" : "rdy");
	return 0;
    8b04:	2300      	movs	r3, #0
}
    8b06:	4618      	mov	r0, r3
    8b08:	3730      	adds	r7, #48	; 0x30
    8b0a:	46bd      	mov	sp, r7
    8b0c:	bd80      	pop	{r7, pc}
    8b0e:	bf00      	nop
    8b10:	0001631f 	.word	0x0001631f
    8b14:	5000d000 	.word	0x5000d000
    8b18:	0001a774 	.word	0x0001a774
    8b1c:	0001a904 	.word	0x0001a904
    8b20:	0001a16c 	.word	0x0001a16c
    8b24:	0001a90c 	.word	0x0001a90c
    8b28:	20000148 	.word	0x20000148
    8b2c:	0001a928 	.word	0x0001a928
    8b30:	0001a92c 	.word	0x0001a92c
    8b34:	0001cd30 	.word	0x0001cd30
    8b38:	0001a930 	.word	0x0001a930

00008b3c <uart_callback>:
	}
}

static void uart_callback(const struct device *uart, struct uart_event *evt,
			  void *user_data)
{
    8b3c:	b580      	push	{r7, lr}
    8b3e:	b092      	sub	sp, #72	; 0x48
    8b40:	af02      	add	r7, sp, #8
    8b42:	60f8      	str	r0, [r7, #12]
    8b44:	60b9      	str	r1, [r7, #8]
    8b46:	607a      	str	r2, [r7, #4]
	struct device *dev = user_data;
    8b48:	687b      	ldr	r3, [r7, #4]
    8b4a:	63fb      	str	r3, [r7, #60]	; 0x3c
	struct lpuart_data *data = get_dev_data(dev);
    8b4c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8b4e:	f00d fbbc 	bl	162ca <get_dev_data>
    8b52:	63b8      	str	r0, [r7, #56]	; 0x38

	switch (evt->type) {
    8b54:	68bb      	ldr	r3, [r7, #8]
    8b56:	781b      	ldrb	r3, [r3, #0]
    8b58:	2b06      	cmp	r3, #6
    8b5a:	f200 812c 	bhi.w	8db6 <uart_callback+0x27a>
    8b5e:	a201      	add	r2, pc, #4	; (adr r2, 8b64 <uart_callback+0x28>)
    8b60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8b64:	00008b81 	.word	0x00008b81
    8b68:	00008bab 	.word	0x00008bab
    8b6c:	00008c23 	.word	0x00008c23
    8b70:	00008cc5 	.word	0x00008cc5
    8b74:	00008cd7 	.word	0x00008cd7
    8b78:	00008ce1 	.word	0x00008ce1
    8b7c:	00008dab 	.word	0x00008dab
	case UART_TX_DONE:
	{
		const uint8_t *txbuf = evt->data.tx.buf;
    8b80:	68bb      	ldr	r3, [r7, #8]
    8b82:	685b      	ldr	r3, [r3, #4]
    8b84:	633b      	str	r3, [r7, #48]	; 0x30

		tx_complete(data);
    8b86:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    8b88:	f00d fbb5 	bl	162f6 <tx_complete>
		if (txbuf == (void *)&data->txbyte) {
    8b8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8b8e:	3368      	adds	r3, #104	; 0x68
    8b90:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8b92:	429a      	cmp	r2, r3
    8b94:	d104      	bne.n	8ba0 <uart_callback+0x64>
			data->txbyte = -1;
    8b96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8b98:	f04f 32ff 	mov.w	r2, #4294967295
    8b9c:	669a      	str	r2, [r3, #104]	; 0x68
		} else {
			user_callback(dev, evt);
		}

		break;
    8b9e:	e10a      	b.n	8db6 <uart_callback+0x27a>
			user_callback(dev, evt);
    8ba0:	68b9      	ldr	r1, [r7, #8]
    8ba2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8ba4:	f00d fbee 	bl	16384 <user_callback>
		break;
    8ba8:	e105      	b.n	8db6 <uart_callback+0x27a>
	}
	case UART_TX_ABORTED:
		LOG_DBG("tx aborted");
    8baa:	2303      	movs	r3, #3
    8bac:	2b03      	cmp	r3, #3
    8bae:	d933      	bls.n	8c18 <uart_callback+0xdc>
    8bb0:	f00c fea4 	bl	158fc <_is_user_context>
    8bb4:	4603      	mov	r3, r0
    8bb6:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    8bba:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    8bbe:	2204      	movs	r2, #4
    8bc0:	f362 0302 	bfi	r3, r2, #0, #3
    8bc4:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    8bc8:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    8bcc:	f36f 03c5 	bfc	r3, #3, #3
    8bd0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    8bd4:	2303      	movs	r3, #3
    8bd6:	2b00      	cmp	r3, #0
    8bd8:	d009      	beq.n	8bee <uart_callback+0xb2>
    8bda:	4b79      	ldr	r3, [pc, #484]	; (8dc0 <uart_callback+0x284>)
    8bdc:	681b      	ldr	r3, [r3, #0]
    8bde:	4618      	mov	r0, r3
    8be0:	f7ff fb20 	bl	8224 <log_const_source_id>
    8be4:	4603      	mov	r3, r0
    8be6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8bea:	b29a      	uxth	r2, r3
    8bec:	e000      	b.n	8bf0 <uart_callback+0xb4>
    8bee:	2200      	movs	r2, #0
    8bf0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    8bf2:	f362 138f 	bfi	r3, r2, #6, #10
    8bf6:	85bb      	strh	r3, [r7, #44]	; 0x2c
    8bf8:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    8bfc:	2b00      	cmp	r3, #0
    8bfe:	d005      	beq.n	8c0c <uart_callback+0xd0>
    8c00:	4a70      	ldr	r2, [pc, #448]	; (8dc4 <uart_callback+0x288>)
    8c02:	4971      	ldr	r1, [pc, #452]	; (8dc8 <uart_callback+0x28c>)
    8c04:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
    8c06:	f7f9 fe73 	bl	28f0 <log_from_user>
    8c0a:	e005      	b.n	8c18 <uart_callback+0xdc>
    8c0c:	4b6d      	ldr	r3, [pc, #436]	; (8dc4 <uart_callback+0x288>)
    8c0e:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
    8c10:	4619      	mov	r1, r3
    8c12:	486d      	ldr	r0, [pc, #436]	; (8dc8 <uart_callback+0x28c>)
    8c14:	f008 fd1a 	bl	1164c <log_1>
		user_callback(dev, evt);
    8c18:	68b9      	ldr	r1, [r7, #8]
    8c1a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8c1c:	f00d fbb2 	bl	16384 <user_callback>
		break;
    8c20:	e0c9      	b.n	8db6 <uart_callback+0x27a>

	case UART_RX_RDY:
		LOG_DBG("RX: Ready buf:%p, offset: %d,len: %d",
    8c22:	2303      	movs	r3, #3
    8c24:	2b03      	cmp	r3, #3
    8c26:	d948      	bls.n	8cba <uart_callback+0x17e>
    8c28:	f00c fe68 	bl	158fc <_is_user_context>
    8c2c:	4603      	mov	r3, r0
    8c2e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    8c32:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    8c36:	2204      	movs	r2, #4
    8c38:	f362 0302 	bfi	r3, r2, #0, #3
    8c3c:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    8c40:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    8c44:	f36f 03c5 	bfc	r3, #3, #3
    8c48:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    8c4c:	2303      	movs	r3, #3
    8c4e:	2b00      	cmp	r3, #0
    8c50:	d009      	beq.n	8c66 <uart_callback+0x12a>
    8c52:	4b5b      	ldr	r3, [pc, #364]	; (8dc0 <uart_callback+0x284>)
    8c54:	681b      	ldr	r3, [r3, #0]
    8c56:	4618      	mov	r0, r3
    8c58:	f7ff fae4 	bl	8224 <log_const_source_id>
    8c5c:	4603      	mov	r3, r0
    8c5e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8c62:	b29a      	uxth	r2, r3
    8c64:	e000      	b.n	8c68 <uart_callback+0x12c>
    8c66:	2200      	movs	r2, #0
    8c68:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    8c6a:	f362 138f 	bfi	r3, r2, #6, #10
    8c6e:	853b      	strh	r3, [r7, #40]	; 0x28
    8c70:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    8c74:	2b00      	cmp	r3, #0
    8c76:	d00e      	beq.n	8c96 <uart_callback+0x15a>
    8c78:	68bb      	ldr	r3, [r7, #8]
    8c7a:	6859      	ldr	r1, [r3, #4]
    8c7c:	68bb      	ldr	r3, [r7, #8]
    8c7e:	689b      	ldr	r3, [r3, #8]
    8c80:	68ba      	ldr	r2, [r7, #8]
    8c82:	68d2      	ldr	r2, [r2, #12]
    8c84:	9201      	str	r2, [sp, #4]
    8c86:	9300      	str	r3, [sp, #0]
    8c88:	460b      	mov	r3, r1
    8c8a:	4a4e      	ldr	r2, [pc, #312]	; (8dc4 <uart_callback+0x288>)
    8c8c:	494f      	ldr	r1, [pc, #316]	; (8dcc <uart_callback+0x290>)
    8c8e:	8d38      	ldrh	r0, [r7, #40]	; 0x28
    8c90:	f7f9 fe2e 	bl	28f0 <log_from_user>
    8c94:	e011      	b.n	8cba <uart_callback+0x17e>
    8c96:	4b4b      	ldr	r3, [pc, #300]	; (8dc4 <uart_callback+0x288>)
    8c98:	61bb      	str	r3, [r7, #24]
    8c9a:	68bb      	ldr	r3, [r7, #8]
    8c9c:	685b      	ldr	r3, [r3, #4]
    8c9e:	61fb      	str	r3, [r7, #28]
    8ca0:	68bb      	ldr	r3, [r7, #8]
    8ca2:	689b      	ldr	r3, [r3, #8]
    8ca4:	623b      	str	r3, [r7, #32]
    8ca6:	68bb      	ldr	r3, [r7, #8]
    8ca8:	68db      	ldr	r3, [r3, #12]
    8caa:	627b      	str	r3, [r7, #36]	; 0x24
    8cac:	f107 0118 	add.w	r1, r7, #24
    8cb0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    8cb2:	2204      	movs	r2, #4
    8cb4:	4845      	ldr	r0, [pc, #276]	; (8dcc <uart_callback+0x290>)
    8cb6:	f008 fd13 	bl	116e0 <log_n>
		     evt->data.rx.buf, evt->data.rx.offset, evt->data.rx.len);
		user_callback(dev, evt);
    8cba:	68b9      	ldr	r1, [r7, #8]
    8cbc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8cbe:	f00d fb61 	bl	16384 <user_callback>
		break;
    8cc2:	e078      	b.n	8db6 <uart_callback+0x27a>

	case UART_RX_BUF_REQUEST:
		/* If packet will fit in the provided buffer do not request
		 * additional buffer.
		 */
		if (data->rx_len < CONFIG_NRF_SW_LPUART_MAX_PACKET_SIZE) {
    8cc4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8cc6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    8cc8:	2b7f      	cmp	r3, #127	; 0x7f
    8cca:	d873      	bhi.n	8db4 <uart_callback+0x278>
			user_callback(dev, evt);
    8ccc:	68b9      	ldr	r1, [r7, #8]
    8cce:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8cd0:	f00d fb58 	bl	16384 <user_callback>
		}
		break;
    8cd4:	e06e      	b.n	8db4 <uart_callback+0x278>

	case UART_RX_BUF_RELEASED:
		user_callback(dev, evt);
    8cd6:	68b9      	ldr	r1, [r7, #8]
    8cd8:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8cda:	f00d fb53 	bl	16384 <user_callback>
		break;
    8cde:	e06a      	b.n	8db6 <uart_callback+0x27a>

	case UART_RX_DISABLED:
		LOG_DBG("Rx disabled");
    8ce0:	2303      	movs	r3, #3
    8ce2:	2b03      	cmp	r3, #3
    8ce4:	d92f      	bls.n	8d46 <uart_callback+0x20a>
    8ce6:	f00c fe09 	bl	158fc <_is_user_context>
    8cea:	4603      	mov	r3, r0
    8cec:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    8cf0:	7d3b      	ldrb	r3, [r7, #20]
    8cf2:	2204      	movs	r2, #4
    8cf4:	f362 0302 	bfi	r3, r2, #0, #3
    8cf8:	753b      	strb	r3, [r7, #20]
    8cfa:	7d3b      	ldrb	r3, [r7, #20]
    8cfc:	f36f 03c5 	bfc	r3, #3, #3
    8d00:	753b      	strb	r3, [r7, #20]
    8d02:	2303      	movs	r3, #3
    8d04:	2b00      	cmp	r3, #0
    8d06:	d009      	beq.n	8d1c <uart_callback+0x1e0>
    8d08:	4b2d      	ldr	r3, [pc, #180]	; (8dc0 <uart_callback+0x284>)
    8d0a:	681b      	ldr	r3, [r3, #0]
    8d0c:	4618      	mov	r0, r3
    8d0e:	f7ff fa89 	bl	8224 <log_const_source_id>
    8d12:	4603      	mov	r3, r0
    8d14:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8d18:	b29a      	uxth	r2, r3
    8d1a:	e000      	b.n	8d1e <uart_callback+0x1e2>
    8d1c:	2200      	movs	r2, #0
    8d1e:	8abb      	ldrh	r3, [r7, #20]
    8d20:	f362 138f 	bfi	r3, r2, #6, #10
    8d24:	82bb      	strh	r3, [r7, #20]
    8d26:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    8d2a:	2b00      	cmp	r3, #0
    8d2c:	d005      	beq.n	8d3a <uart_callback+0x1fe>
    8d2e:	4a25      	ldr	r2, [pc, #148]	; (8dc4 <uart_callback+0x288>)
    8d30:	4927      	ldr	r1, [pc, #156]	; (8dd0 <uart_callback+0x294>)
    8d32:	8ab8      	ldrh	r0, [r7, #20]
    8d34:	f7f9 fddc 	bl	28f0 <log_from_user>
    8d38:	e005      	b.n	8d46 <uart_callback+0x20a>
    8d3a:	4b22      	ldr	r3, [pc, #136]	; (8dc4 <uart_callback+0x288>)
    8d3c:	8aba      	ldrh	r2, [r7, #20]
    8d3e:	4619      	mov	r1, r3
    8d40:	4823      	ldr	r0, [pc, #140]	; (8dd0 <uart_callback+0x294>)
    8d42:	f008 fc83 	bl	1164c <log_1>
		__ASSERT_NO_MSG((data->rx_state != RX_ACTIVE) &&
    8d46:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d48:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8d4c:	2b02      	cmp	r3, #2
    8d4e:	d009      	beq.n	8d64 <uart_callback+0x228>
    8d50:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d52:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8d56:	2b01      	cmp	r3, #1
    8d58:	d004      	beq.n	8d64 <uart_callback+0x228>
    8d5a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d5c:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8d60:	2b00      	cmp	r3, #0
    8d62:	d10b      	bne.n	8d7c <uart_callback+0x240>
    8d64:	f240 13b3 	movw	r3, #435	; 0x1b3
    8d68:	4a1a      	ldr	r2, [pc, #104]	; (8dd4 <uart_callback+0x298>)
    8d6a:	491b      	ldr	r1, [pc, #108]	; (8dd8 <uart_callback+0x29c>)
    8d6c:	481b      	ldr	r0, [pc, #108]	; (8ddc <uart_callback+0x2a0>)
    8d6e:	f007 f97b 	bl	10068 <printk>
    8d72:	f240 11b3 	movw	r1, #435	; 0x1b3
    8d76:	4817      	ldr	r0, [pc, #92]	; (8dd4 <uart_callback+0x298>)
    8d78:	f007 ffbe 	bl	10cf8 <assert_post_action>
			 (data->rx_state != RX_IDLE) &&
			 (data->rx_state != RX_OFF));

		if (data->rx_state == RX_TO_IDLE) {
    8d7c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d7e:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8d82:	2b03      	cmp	r3, #3
    8d84:	d103      	bne.n	8d8e <uart_callback+0x252>
			/* Need to request new buffer since uart was disabled */
			evt->type = UART_RX_BUF_REQUEST;
    8d86:	68bb      	ldr	r3, [r7, #8]
    8d88:	2203      	movs	r2, #3
    8d8a:	701a      	strb	r2, [r3, #0]
    8d8c:	e008      	b.n	8da0 <uart_callback+0x264>
		} else if (data->rx_state == RX_TO_OFF) {
    8d8e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d90:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    8d94:	2b04      	cmp	r3, #4
    8d96:	d103      	bne.n	8da0 <uart_callback+0x264>
			data->rx_state = RX_OFF;
    8d98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    8d9a:	2200      	movs	r2, #0
    8d9c:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		}
		user_callback(dev, evt);
    8da0:	68b9      	ldr	r1, [r7, #8]
    8da2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8da4:	f00d faee 	bl	16384 <user_callback>
		break;
    8da8:	e005      	b.n	8db6 <uart_callback+0x27a>
	case UART_RX_STOPPED:
		user_callback(dev, evt);
    8daa:	68b9      	ldr	r1, [r7, #8]
    8dac:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    8dae:	f00d fae9 	bl	16384 <user_callback>
		break;
    8db2:	e000      	b.n	8db6 <uart_callback+0x27a>
		break;
    8db4:	bf00      	nop
	}
}
    8db6:	bf00      	nop
    8db8:	3740      	adds	r7, #64	; 0x40
    8dba:	46bd      	mov	sp, r7
    8dbc:	bd80      	pop	{r7, pc}
    8dbe:	bf00      	nop
    8dc0:	20000148 	.word	0x20000148
    8dc4:	0001cd44 	.word	0x0001cd44
    8dc8:	0001a960 	.word	0x0001a960
    8dcc:	0001a970 	.word	0x0001a970
    8dd0:	0001a99c 	.word	0x0001a99c
    8dd4:	0001a774 	.word	0x0001a774
    8dd8:	0001a9ac 	.word	0x0001a9ac
    8ddc:	0001a16c 	.word	0x0001a16c

00008de0 <tx_timeout>:

static void tx_timeout(struct k_timer *timer)
{
    8de0:	b580      	push	{r7, lr}
    8de2:	b08c      	sub	sp, #48	; 0x30
    8de4:	af00      	add	r7, sp, #0
    8de6:	6078      	str	r0, [r7, #4]
	struct device *dev = k_timer_user_data_get(timer);
    8de8:	6878      	ldr	r0, [r7, #4]
    8dea:	f00c ff6d 	bl	15cc8 <k_timer_user_data_get>
    8dee:	62f8      	str	r0, [r7, #44]	; 0x2c
	struct lpuart_data *data = get_dev_data(dev);
    8df0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    8df2:	f00d fa6a 	bl	162ca <get_dev_data>
    8df6:	62b8      	str	r0, [r7, #40]	; 0x28
	const uint8_t *txbuf = data->tx_buf;
    8df8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8dfa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8dfc:	627b      	str	r3, [r7, #36]	; 0x24
	int err;

	if (data->tx_active) {
    8dfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e00:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    8e04:	2b00      	cmp	r3, #0
    8e06:	d04f      	beq.n	8ea8 <tx_timeout+0xc8>
		err = uart_tx_abort(data->uart);
    8e08:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8e0a:	681b      	ldr	r3, [r3, #0]
    8e0c:	4618      	mov	r0, r3
    8e0e:	f00d f82b 	bl	15e68 <uart_tx_abort>
    8e12:	6238      	str	r0, [r7, #32]
		if (err == -EFAULT) {
    8e14:	6a3b      	ldr	r3, [r7, #32]
    8e16:	f113 0f0e 	cmn.w	r3, #14
    8e1a:	d131      	bne.n	8e80 <tx_timeout+0xa0>
			LOG_DBG("No active transfer. Already finished?");
    8e1c:	2303      	movs	r3, #3
    8e1e:	2b03      	cmp	r3, #3
    8e20:	d962      	bls.n	8ee8 <tx_timeout+0x108>
    8e22:	f00c fd6b 	bl	158fc <_is_user_context>
    8e26:	4603      	mov	r3, r0
    8e28:	77fb      	strb	r3, [r7, #31]
    8e2a:	7f3b      	ldrb	r3, [r7, #28]
    8e2c:	2204      	movs	r2, #4
    8e2e:	f362 0302 	bfi	r3, r2, #0, #3
    8e32:	773b      	strb	r3, [r7, #28]
    8e34:	7f3b      	ldrb	r3, [r7, #28]
    8e36:	f36f 03c5 	bfc	r3, #3, #3
    8e3a:	773b      	strb	r3, [r7, #28]
    8e3c:	2303      	movs	r3, #3
    8e3e:	2b00      	cmp	r3, #0
    8e40:	d009      	beq.n	8e56 <tx_timeout+0x76>
    8e42:	4b2b      	ldr	r3, [pc, #172]	; (8ef0 <tx_timeout+0x110>)
    8e44:	681b      	ldr	r3, [r3, #0]
    8e46:	4618      	mov	r0, r3
    8e48:	f7ff f9ec 	bl	8224 <log_const_source_id>
    8e4c:	4603      	mov	r3, r0
    8e4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8e52:	b29a      	uxth	r2, r3
    8e54:	e000      	b.n	8e58 <tx_timeout+0x78>
    8e56:	2200      	movs	r2, #0
    8e58:	8bbb      	ldrh	r3, [r7, #28]
    8e5a:	f362 138f 	bfi	r3, r2, #6, #10
    8e5e:	83bb      	strh	r3, [r7, #28]
    8e60:	7ffb      	ldrb	r3, [r7, #31]
    8e62:	2b00      	cmp	r3, #0
    8e64:	d005      	beq.n	8e72 <tx_timeout+0x92>
    8e66:	4a23      	ldr	r2, [pc, #140]	; (8ef4 <tx_timeout+0x114>)
    8e68:	4923      	ldr	r1, [pc, #140]	; (8ef8 <tx_timeout+0x118>)
    8e6a:	8bb8      	ldrh	r0, [r7, #28]
    8e6c:	f7f9 fd40 	bl	28f0 <log_from_user>
		} else if (err < 0) {
			__ASSERT(0, "Unexpected tx_abort error:%d", err);
		}
		return;
    8e70:	e03a      	b.n	8ee8 <tx_timeout+0x108>
			LOG_DBG("No active transfer. Already finished?");
    8e72:	4b20      	ldr	r3, [pc, #128]	; (8ef4 <tx_timeout+0x114>)
    8e74:	8bba      	ldrh	r2, [r7, #28]
    8e76:	4619      	mov	r1, r3
    8e78:	481f      	ldr	r0, [pc, #124]	; (8ef8 <tx_timeout+0x118>)
    8e7a:	f008 fbe7 	bl	1164c <log_1>
		return;
    8e7e:	e033      	b.n	8ee8 <tx_timeout+0x108>
		} else if (err < 0) {
    8e80:	6a3b      	ldr	r3, [r7, #32]
    8e82:	2b00      	cmp	r3, #0
    8e84:	da30      	bge.n	8ee8 <tx_timeout+0x108>
			__ASSERT(0, "Unexpected tx_abort error:%d", err);
    8e86:	f240 13d1 	movw	r3, #465	; 0x1d1
    8e8a:	4a1c      	ldr	r2, [pc, #112]	; (8efc <tx_timeout+0x11c>)
    8e8c:	491c      	ldr	r1, [pc, #112]	; (8f00 <tx_timeout+0x120>)
    8e8e:	481d      	ldr	r0, [pc, #116]	; (8f04 <tx_timeout+0x124>)
    8e90:	f007 f8ea 	bl	10068 <printk>
    8e94:	6a39      	ldr	r1, [r7, #32]
    8e96:	481c      	ldr	r0, [pc, #112]	; (8f08 <tx_timeout+0x128>)
    8e98:	f007 f8e6 	bl	10068 <printk>
    8e9c:	f240 11d1 	movw	r1, #465	; 0x1d1
    8ea0:	4816      	ldr	r0, [pc, #88]	; (8efc <tx_timeout+0x11c>)
    8ea2:	f007 ff29 	bl	10cf8 <assert_post_action>
		return;
    8ea6:	e01f      	b.n	8ee8 <tx_timeout+0x108>
	}

	tx_complete(data);
    8ea8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    8eaa:	f00d fa24 	bl	162f6 <tx_complete>

	if (txbuf == (void *)&data->txbyte) {
    8eae:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8eb0:	3368      	adds	r3, #104	; 0x68
    8eb2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8eb4:	429a      	cmp	r2, r3
    8eb6:	d104      	bne.n	8ec2 <tx_timeout+0xe2>
		data->txbyte = -1;
    8eb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8eba:	f04f 32ff 	mov.w	r2, #4294967295
    8ebe:	669a      	str	r2, [r3, #104]	; 0x68
    8ec0:	e013      	b.n	8eea <tx_timeout+0x10a>
	} else {
		struct uart_event evt = {
    8ec2:	f107 0308 	add.w	r3, r7, #8
    8ec6:	2200      	movs	r2, #0
    8ec8:	601a      	str	r2, [r3, #0]
    8eca:	605a      	str	r2, [r3, #4]
    8ecc:	609a      	str	r2, [r3, #8]
    8ece:	60da      	str	r2, [r3, #12]
    8ed0:	611a      	str	r2, [r3, #16]
    8ed2:	2301      	movs	r3, #1
    8ed4:	723b      	strb	r3, [r7, #8]
    8ed6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8ed8:	60fb      	str	r3, [r7, #12]
					.len = 0
				}
			}
		};

		user_callback(dev, &evt);
    8eda:	f107 0308 	add.w	r3, r7, #8
    8ede:	4619      	mov	r1, r3
    8ee0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    8ee2:	f00d fa4f 	bl	16384 <user_callback>
    8ee6:	e000      	b.n	8eea <tx_timeout+0x10a>
		return;
    8ee8:	bf00      	nop
	}
}
    8eea:	3730      	adds	r7, #48	; 0x30
    8eec:	46bd      	mov	sp, r7
    8eee:	bd80      	pop	{r7, pc}
    8ef0:	20000148 	.word	0x20000148
    8ef4:	0001cd54 	.word	0x0001cd54
    8ef8:	0001aa08 	.word	0x0001aa08
    8efc:	0001a774 	.word	0x0001a774
    8f00:	0001a704 	.word	0x0001a704
    8f04:	0001a16c 	.word	0x0001a16c
    8f08:	0001aa34 	.word	0x0001aa34

00008f0c <api_tx>:

static int api_tx(const struct device *dev, const uint8_t *buf,
		  size_t len, int32_t timeout)
{
    8f0c:	b590      	push	{r4, r7, lr}
    8f0e:	b089      	sub	sp, #36	; 0x24
    8f10:	af02      	add	r7, sp, #8
    8f12:	60f8      	str	r0, [r7, #12]
    8f14:	60b9      	str	r1, [r7, #8]
    8f16:	607a      	str	r2, [r7, #4]
    8f18:	603b      	str	r3, [r7, #0]
	struct lpuart_data *data = get_dev_data(dev);
    8f1a:	68f8      	ldr	r0, [r7, #12]
    8f1c:	f00d f9d5 	bl	162ca <get_dev_data>
    8f20:	6178      	str	r0, [r7, #20]

	if (!atomic_ptr_cas((atomic_ptr_t *)&data->tx_buf, NULL, (void *)buf)) {
    8f22:	697b      	ldr	r3, [r7, #20]
    8f24:	336c      	adds	r3, #108	; 0x6c
    8f26:	68ba      	ldr	r2, [r7, #8]
    8f28:	2100      	movs	r1, #0
    8f2a:	4618      	mov	r0, r3
    8f2c:	f00c fd0f 	bl	1594e <atomic_ptr_cas>
    8f30:	4603      	mov	r3, r0
    8f32:	f083 0301 	eor.w	r3, r3, #1
    8f36:	b2db      	uxtb	r3, r3
    8f38:	2b00      	cmp	r3, #0
    8f3a:	d002      	beq.n	8f42 <api_tx+0x36>
		return -EBUSY;
    8f3c:	f06f 010f 	mvn.w	r1, #15
    8f40:	e060      	b.n	9004 <api_tx+0xf8>
	}

	LOG_DBG("tx len:%d", len);
    8f42:	2303      	movs	r3, #3
    8f44:	2b03      	cmp	r3, #3
    8f46:	d92e      	bls.n	8fa6 <api_tx+0x9a>
    8f48:	f00c fcd8 	bl	158fc <_is_user_context>
    8f4c:	4603      	mov	r3, r0
    8f4e:	74fb      	strb	r3, [r7, #19]
    8f50:	7c3b      	ldrb	r3, [r7, #16]
    8f52:	2204      	movs	r2, #4
    8f54:	f362 0302 	bfi	r3, r2, #0, #3
    8f58:	743b      	strb	r3, [r7, #16]
    8f5a:	7c3b      	ldrb	r3, [r7, #16]
    8f5c:	f36f 03c5 	bfc	r3, #3, #3
    8f60:	743b      	strb	r3, [r7, #16]
    8f62:	2303      	movs	r3, #3
    8f64:	2b00      	cmp	r3, #0
    8f66:	d009      	beq.n	8f7c <api_tx+0x70>
    8f68:	4b29      	ldr	r3, [pc, #164]	; (9010 <api_tx+0x104>)
    8f6a:	681b      	ldr	r3, [r3, #0]
    8f6c:	4618      	mov	r0, r3
    8f6e:	f7ff f959 	bl	8224 <log_const_source_id>
    8f72:	4603      	mov	r3, r0
    8f74:	f3c3 0309 	ubfx	r3, r3, #0, #10
    8f78:	b29a      	uxth	r2, r3
    8f7a:	e000      	b.n	8f7e <api_tx+0x72>
    8f7c:	2200      	movs	r2, #0
    8f7e:	8a3b      	ldrh	r3, [r7, #16]
    8f80:	f362 138f 	bfi	r3, r2, #6, #10
    8f84:	823b      	strh	r3, [r7, #16]
    8f86:	7cfb      	ldrb	r3, [r7, #19]
    8f88:	2b00      	cmp	r3, #0
    8f8a:	d006      	beq.n	8f9a <api_tx+0x8e>
    8f8c:	687b      	ldr	r3, [r7, #4]
    8f8e:	4a21      	ldr	r2, [pc, #132]	; (9014 <api_tx+0x108>)
    8f90:	4921      	ldr	r1, [pc, #132]	; (9018 <api_tx+0x10c>)
    8f92:	8a38      	ldrh	r0, [r7, #16]
    8f94:	f7f9 fcac 	bl	28f0 <log_from_user>
    8f98:	e005      	b.n	8fa6 <api_tx+0x9a>
    8f9a:	491e      	ldr	r1, [pc, #120]	; (9014 <api_tx+0x108>)
    8f9c:	8a3b      	ldrh	r3, [r7, #16]
    8f9e:	687a      	ldr	r2, [r7, #4]
    8fa0:	481d      	ldr	r0, [pc, #116]	; (9018 <api_tx+0x10c>)
    8fa2:	f008 fb6a 	bl	1167a <log_2>
	data->tx_len = len;
    8fa6:	697b      	ldr	r3, [r7, #20]
    8fa8:	687a      	ldr	r2, [r7, #4]
    8faa:	671a      	str	r2, [r3, #112]	; 0x70
	k_timer_start(&data->tx_timer, SYS_TIMEOUT_MS(timeout), K_NO_WAIT);
    8fac:	697b      	ldr	r3, [r7, #20]
    8fae:	f103 0430 	add.w	r4, r3, #48	; 0x30
    8fb2:	683b      	ldr	r3, [r7, #0]
    8fb4:	f1b3 3fff 	cmp.w	r3, #4294967295
    8fb8:	d104      	bne.n	8fc4 <api_tx+0xb8>
    8fba:	f04f 30ff 	mov.w	r0, #4294967295
    8fbe:	f04f 31ff 	mov.w	r1, #4294967295
    8fc2:	e00d      	b.n	8fe0 <api_tx+0xd4>
    8fc4:	683b      	ldr	r3, [r7, #0]
    8fc6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    8fca:	461a      	mov	r2, r3
    8fcc:	ea4f 73e2 	mov.w	r3, r2, asr #31
    8fd0:	4610      	mov	r0, r2
    8fd2:	4619      	mov	r1, r3
    8fd4:	f00c fce8 	bl	159a8 <k_ms_to_ticks_ceil64>
    8fd8:	4602      	mov	r2, r0
    8fda:	460b      	mov	r3, r1
    8fdc:	4610      	mov	r0, r2
    8fde:	4619      	mov	r1, r3
    8fe0:	f04f 0200 	mov.w	r2, #0
    8fe4:	f04f 0300 	mov.w	r3, #0
    8fe8:	e9cd 2300 	strd	r2, r3, [sp]
    8fec:	4602      	mov	r2, r0
    8fee:	460b      	mov	r3, r1
    8ff0:	4620      	mov	r0, r4
    8ff2:	f00c fe3e 	bl	15c72 <k_timer_start>

	ctrl_pin_set(&data->req_pin, false);
    8ff6:	697b      	ldr	r3, [r7, #20]
    8ff8:	3304      	adds	r3, #4
    8ffa:	2100      	movs	r1, #0
    8ffc:	4618      	mov	r0, r3
    8ffe:	f7ff f921 	bl	8244 <ctrl_pin_set>

	return 0;
    9002:	2100      	movs	r1, #0
    9004:	460b      	mov	r3, r1
}
    9006:	4618      	mov	r0, r3
    9008:	371c      	adds	r7, #28
    900a:	46bd      	mov	sp, r7
    900c:	bd90      	pop	{r4, r7, pc}
    900e:	bf00      	nop
    9010:	20000148 	.word	0x20000148
    9014:	0001cd60 	.word	0x0001cd60
    9018:	0001aa54 	.word	0x0001aa54

0000901c <api_rx_enable>:
	return err;
}

static int api_rx_enable(const struct device *dev, uint8_t *buf,
			 size_t len, int32_t timeout)
{
    901c:	b580      	push	{r7, lr}
    901e:	b08c      	sub	sp, #48	; 0x30
    9020:	af00      	add	r7, sp, #0
    9022:	60f8      	str	r0, [r7, #12]
    9024:	60b9      	str	r1, [r7, #8]
    9026:	607a      	str	r2, [r7, #4]
    9028:	603b      	str	r3, [r7, #0]
	struct lpuart_data *data = get_dev_data(dev);
    902a:	68f8      	ldr	r0, [r7, #12]
    902c:	f00d f94d 	bl	162ca <get_dev_data>
    9030:	62f8      	str	r0, [r7, #44]	; 0x2c
	bool pending_rx;
	int key;

	__ASSERT_NO_MSG(data->rx_state == RX_OFF);
    9032:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9034:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    9038:	2b00      	cmp	r3, #0
    903a:	d00b      	beq.n	9054 <api_rx_enable+0x38>
    903c:	f240 2329 	movw	r3, #553	; 0x229
    9040:	4a48      	ldr	r2, [pc, #288]	; (9164 <api_rx_enable+0x148>)
    9042:	4949      	ldr	r1, [pc, #292]	; (9168 <api_rx_enable+0x14c>)
    9044:	4849      	ldr	r0, [pc, #292]	; (916c <api_rx_enable+0x150>)
    9046:	f007 f80f 	bl	10068 <printk>
    904a:	f240 2129 	movw	r1, #553	; 0x229
    904e:	4845      	ldr	r0, [pc, #276]	; (9164 <api_rx_enable+0x148>)
    9050:	f007 fe52 	bl	10cf8 <assert_post_action>

	if (atomic_ptr_cas((atomic_ptr_t *)&data->rx_buf, NULL, buf) == false) {
    9054:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9056:	3378      	adds	r3, #120	; 0x78
    9058:	68ba      	ldr	r2, [r7, #8]
    905a:	2100      	movs	r1, #0
    905c:	4618      	mov	r0, r3
    905e:	f00c fc76 	bl	1594e <atomic_ptr_cas>
    9062:	4603      	mov	r3, r0
    9064:	f083 0301 	eor.w	r3, r3, #1
    9068:	b2db      	uxtb	r3, r3
    906a:	2b00      	cmp	r3, #0
    906c:	d002      	beq.n	9074 <api_rx_enable+0x58>
		return -EBUSY;
    906e:	f06f 030f 	mvn.w	r3, #15
    9072:	e072      	b.n	915a <api_rx_enable+0x13e>
	}

	data->rx_len = len;
    9074:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9076:	687a      	ldr	r2, [r7, #4]
    9078:	67da      	str	r2, [r3, #124]	; 0x7c
	data->rx_timeout = timeout;
    907a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    907c:	683a      	ldr	r2, [r7, #0]
    907e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	data->rx_state = RX_IDLE;
    9082:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9084:	2201      	movs	r2, #1
    9086:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c

	LOG_DBG("RX: Enabling");
    908a:	2303      	movs	r3, #3
    908c:	2b03      	cmp	r3, #3
    908e:	d92f      	bls.n	90f0 <api_rx_enable+0xd4>
    9090:	f00c fc34 	bl	158fc <_is_user_context>
    9094:	4603      	mov	r3, r0
    9096:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    909a:	7c3b      	ldrb	r3, [r7, #16]
    909c:	2204      	movs	r2, #4
    909e:	f362 0302 	bfi	r3, r2, #0, #3
    90a2:	743b      	strb	r3, [r7, #16]
    90a4:	7c3b      	ldrb	r3, [r7, #16]
    90a6:	f36f 03c5 	bfc	r3, #3, #3
    90aa:	743b      	strb	r3, [r7, #16]
    90ac:	2303      	movs	r3, #3
    90ae:	2b00      	cmp	r3, #0
    90b0:	d009      	beq.n	90c6 <api_rx_enable+0xaa>
    90b2:	4b2f      	ldr	r3, [pc, #188]	; (9170 <api_rx_enable+0x154>)
    90b4:	681b      	ldr	r3, [r3, #0]
    90b6:	4618      	mov	r0, r3
    90b8:	f7ff f8b4 	bl	8224 <log_const_source_id>
    90bc:	4603      	mov	r3, r0
    90be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    90c2:	b29a      	uxth	r2, r3
    90c4:	e000      	b.n	90c8 <api_rx_enable+0xac>
    90c6:	2200      	movs	r2, #0
    90c8:	8a3b      	ldrh	r3, [r7, #16]
    90ca:	f362 138f 	bfi	r3, r2, #6, #10
    90ce:	823b      	strh	r3, [r7, #16]
    90d0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    90d4:	2b00      	cmp	r3, #0
    90d6:	d005      	beq.n	90e4 <api_rx_enable+0xc8>
    90d8:	4a26      	ldr	r2, [pc, #152]	; (9174 <api_rx_enable+0x158>)
    90da:	4927      	ldr	r1, [pc, #156]	; (9178 <api_rx_enable+0x15c>)
    90dc:	8a38      	ldrh	r0, [r7, #16]
    90de:	f7f9 fc07 	bl	28f0 <log_from_user>
    90e2:	e005      	b.n	90f0 <api_rx_enable+0xd4>
    90e4:	4b23      	ldr	r3, [pc, #140]	; (9174 <api_rx_enable+0x158>)
    90e6:	8a3a      	ldrh	r2, [r7, #16]
    90e8:	4619      	mov	r1, r3
    90ea:	4823      	ldr	r0, [pc, #140]	; (9178 <api_rx_enable+0x15c>)
    90ec:	f008 faae 	bl	1164c <log_1>
	__asm__ volatile(
    90f0:	f04f 0320 	mov.w	r3, #32
    90f4:	f3ef 8211 	mrs	r2, BASEPRI
    90f8:	f383 8811 	msr	BASEPRI, r3
    90fc:	f3bf 8f6f 	isb	sy
    9100:	61fa      	str	r2, [r7, #28]
    9102:	61bb      	str	r3, [r7, #24]
	return key;
    9104:	69fb      	ldr	r3, [r7, #28]

	key = irq_lock();
    9106:	627b      	str	r3, [r7, #36]	; 0x24
	pending_rx = nrf_gpio_pin_read(data->rdy_pin.nrf_pin)
    9108:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    910a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
    910e:	4618      	mov	r0, r3
    9110:	f00c ffbc 	bl	1608c <nrf_gpio_pin_read>
    9114:	4603      	mov	r3, r0
		     && (data->rx_state == RX_IDLE);
    9116:	2b00      	cmp	r3, #0
    9118:	d006      	beq.n	9128 <api_rx_enable+0x10c>
    911a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    911c:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    9120:	2b01      	cmp	r3, #1
    9122:	d101      	bne.n	9128 <api_rx_enable+0x10c>
    9124:	2301      	movs	r3, #1
    9126:	e000      	b.n	912a <api_rx_enable+0x10e>
    9128:	2300      	movs	r3, #0
	pending_rx = nrf_gpio_pin_read(data->rdy_pin.nrf_pin)
    912a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    912e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    9132:	f003 0301 	and.w	r3, r3, #1
    9136:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	irq_unlock(key);
    913a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    913c:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    913e:	697b      	ldr	r3, [r7, #20]
    9140:	f383 8811 	msr	BASEPRI, r3
    9144:	f3bf 8f6f 	isb	sy
}
    9148:	bf00      	nop

	if (pending_rx) {
    914a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    914e:	2b00      	cmp	r3, #0
    9150:	d002      	beq.n	9158 <api_rx_enable+0x13c>
		activate_rx(data);
    9152:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    9154:	f7ff f90e 	bl	8374 <activate_rx>
	}

	return 0;
    9158:	2300      	movs	r3, #0
}
    915a:	4618      	mov	r0, r3
    915c:	3730      	adds	r7, #48	; 0x30
    915e:	46bd      	mov	sp, r7
    9160:	bd80      	pop	{r7, pc}
    9162:	bf00      	nop
    9164:	0001a774 	.word	0x0001a774
    9168:	0001aa64 	.word	0x0001aa64
    916c:	0001a16c 	.word	0x0001a16c
    9170:	20000148 	.word	0x20000148
    9174:	0001cd68 	.word	0x0001cd68
    9178:	0001aa80 	.word	0x0001aa80

0000917c <api_rx_buf_rsp>:

static int api_rx_buf_rsp(const struct device *dev, uint8_t *buf, size_t len)
{
    917c:	b580      	push	{r7, lr}
    917e:	b088      	sub	sp, #32
    9180:	af00      	add	r7, sp, #0
    9182:	60f8      	str	r0, [r7, #12]
    9184:	60b9      	str	r1, [r7, #8]
    9186:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
    9188:	68f8      	ldr	r0, [r7, #12]
    918a:	f00d f89e 	bl	162ca <get_dev_data>
    918e:	61f8      	str	r0, [r7, #28]

	__ASSERT_NO_MSG((data->rx_state != RX_OFF) &&
    9190:	69fb      	ldr	r3, [r7, #28]
    9192:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    9196:	2b00      	cmp	r3, #0
    9198:	d004      	beq.n	91a4 <api_rx_buf_rsp+0x28>
    919a:	69fb      	ldr	r3, [r7, #28]
    919c:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    91a0:	2b04      	cmp	r3, #4
    91a2:	d10b      	bne.n	91bc <api_rx_buf_rsp+0x40>
    91a4:	f240 2345 	movw	r3, #581	; 0x245
    91a8:	4a48      	ldr	r2, [pc, #288]	; (92cc <api_rx_buf_rsp+0x150>)
    91aa:	4949      	ldr	r1, [pc, #292]	; (92d0 <api_rx_buf_rsp+0x154>)
    91ac:	4849      	ldr	r0, [pc, #292]	; (92d4 <api_rx_buf_rsp+0x158>)
    91ae:	f006 ff5b 	bl	10068 <printk>
    91b2:	f240 2145 	movw	r1, #581	; 0x245
    91b6:	4845      	ldr	r0, [pc, #276]	; (92cc <api_rx_buf_rsp+0x150>)
    91b8:	f007 fd9e 	bl	10cf8 <assert_post_action>
		 (data->rx_state != RX_TO_OFF));

	if (data->rx_state == RX_TO_IDLE) {
    91bc:	69fb      	ldr	r3, [r7, #28]
    91be:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
    91c2:	2b03      	cmp	r3, #3
    91c4:	d176      	bne.n	92b4 <api_rx_buf_rsp+0x138>
		data->rx_buf = buf;
    91c6:	69fb      	ldr	r3, [r7, #28]
    91c8:	68ba      	ldr	r2, [r7, #8]
    91ca:	679a      	str	r2, [r3, #120]	; 0x78
		data->rx_len = len;
    91cc:	69fb      	ldr	r3, [r7, #28]
    91ce:	687a      	ldr	r2, [r7, #4]
    91d0:	67da      	str	r2, [r3, #124]	; 0x7c

		if (data->rx_req) {
    91d2:	69fb      	ldr	r3, [r7, #28]
    91d4:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
    91d8:	2b00      	cmp	r3, #0
    91da:	d034      	beq.n	9246 <api_rx_buf_rsp+0xca>
			LOG_DBG("RX: Pending request. Activating RX");
    91dc:	2303      	movs	r3, #3
    91de:	2b03      	cmp	r3, #3
    91e0:	d92d      	bls.n	923e <api_rx_buf_rsp+0xc2>
    91e2:	f00c fb8b 	bl	158fc <_is_user_context>
    91e6:	4603      	mov	r3, r0
    91e8:	76bb      	strb	r3, [r7, #26]
    91ea:	7e3b      	ldrb	r3, [r7, #24]
    91ec:	2204      	movs	r2, #4
    91ee:	f362 0302 	bfi	r3, r2, #0, #3
    91f2:	763b      	strb	r3, [r7, #24]
    91f4:	7e3b      	ldrb	r3, [r7, #24]
    91f6:	f36f 03c5 	bfc	r3, #3, #3
    91fa:	763b      	strb	r3, [r7, #24]
    91fc:	2303      	movs	r3, #3
    91fe:	2b00      	cmp	r3, #0
    9200:	d009      	beq.n	9216 <api_rx_buf_rsp+0x9a>
    9202:	4b35      	ldr	r3, [pc, #212]	; (92d8 <api_rx_buf_rsp+0x15c>)
    9204:	681b      	ldr	r3, [r3, #0]
    9206:	4618      	mov	r0, r3
    9208:	f7ff f80c 	bl	8224 <log_const_source_id>
    920c:	4603      	mov	r3, r0
    920e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    9212:	b29a      	uxth	r2, r3
    9214:	e000      	b.n	9218 <api_rx_buf_rsp+0x9c>
    9216:	2200      	movs	r2, #0
    9218:	8b3b      	ldrh	r3, [r7, #24]
    921a:	f362 138f 	bfi	r3, r2, #6, #10
    921e:	833b      	strh	r3, [r7, #24]
    9220:	7ebb      	ldrb	r3, [r7, #26]
    9222:	2b00      	cmp	r3, #0
    9224:	d005      	beq.n	9232 <api_rx_buf_rsp+0xb6>
    9226:	4a2d      	ldr	r2, [pc, #180]	; (92dc <api_rx_buf_rsp+0x160>)
    9228:	492d      	ldr	r1, [pc, #180]	; (92e0 <api_rx_buf_rsp+0x164>)
    922a:	8b38      	ldrh	r0, [r7, #24]
    922c:	f7f9 fb60 	bl	28f0 <log_from_user>
    9230:	e005      	b.n	923e <api_rx_buf_rsp+0xc2>
    9232:	4b2a      	ldr	r3, [pc, #168]	; (92dc <api_rx_buf_rsp+0x160>)
    9234:	8b3a      	ldrh	r2, [r7, #24]
    9236:	4619      	mov	r1, r3
    9238:	4829      	ldr	r0, [pc, #164]	; (92e0 <api_rx_buf_rsp+0x164>)
    923a:	f008 fa07 	bl	1164c <log_1>
			activate_rx(data);
    923e:	69f8      	ldr	r0, [r7, #28]
    9240:	f7ff f898 	bl	8374 <activate_rx>
    9244:	e034      	b.n	92b0 <api_rx_buf_rsp+0x134>
		} else {
			data->rx_state = RX_IDLE;
    9246:	69fb      	ldr	r3, [r7, #28]
    9248:	2201      	movs	r2, #1
    924a:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
			LOG_DBG("RX: Idle");
    924e:	2303      	movs	r3, #3
    9250:	2b03      	cmp	r3, #3
    9252:	d92d      	bls.n	92b0 <api_rx_buf_rsp+0x134>
    9254:	f00c fb52 	bl	158fc <_is_user_context>
    9258:	4603      	mov	r3, r0
    925a:	76fb      	strb	r3, [r7, #27]
    925c:	7d3b      	ldrb	r3, [r7, #20]
    925e:	2204      	movs	r2, #4
    9260:	f362 0302 	bfi	r3, r2, #0, #3
    9264:	753b      	strb	r3, [r7, #20]
    9266:	7d3b      	ldrb	r3, [r7, #20]
    9268:	f36f 03c5 	bfc	r3, #3, #3
    926c:	753b      	strb	r3, [r7, #20]
    926e:	2303      	movs	r3, #3
    9270:	2b00      	cmp	r3, #0
    9272:	d009      	beq.n	9288 <api_rx_buf_rsp+0x10c>
    9274:	4b18      	ldr	r3, [pc, #96]	; (92d8 <api_rx_buf_rsp+0x15c>)
    9276:	681b      	ldr	r3, [r3, #0]
    9278:	4618      	mov	r0, r3
    927a:	f7fe ffd3 	bl	8224 <log_const_source_id>
    927e:	4603      	mov	r3, r0
    9280:	f3c3 0309 	ubfx	r3, r3, #0, #10
    9284:	b29a      	uxth	r2, r3
    9286:	e000      	b.n	928a <api_rx_buf_rsp+0x10e>
    9288:	2200      	movs	r2, #0
    928a:	8abb      	ldrh	r3, [r7, #20]
    928c:	f362 138f 	bfi	r3, r2, #6, #10
    9290:	82bb      	strh	r3, [r7, #20]
    9292:	7efb      	ldrb	r3, [r7, #27]
    9294:	2b00      	cmp	r3, #0
    9296:	d005      	beq.n	92a4 <api_rx_buf_rsp+0x128>
    9298:	4a10      	ldr	r2, [pc, #64]	; (92dc <api_rx_buf_rsp+0x160>)
    929a:	4912      	ldr	r1, [pc, #72]	; (92e4 <api_rx_buf_rsp+0x168>)
    929c:	8ab8      	ldrh	r0, [r7, #20]
    929e:	f7f9 fb27 	bl	28f0 <log_from_user>
    92a2:	e005      	b.n	92b0 <api_rx_buf_rsp+0x134>
    92a4:	4b0d      	ldr	r3, [pc, #52]	; (92dc <api_rx_buf_rsp+0x160>)
    92a6:	8aba      	ldrh	r2, [r7, #20]
    92a8:	4619      	mov	r1, r3
    92aa:	480e      	ldr	r0, [pc, #56]	; (92e4 <api_rx_buf_rsp+0x168>)
    92ac:	f008 f9ce 	bl	1164c <log_1>
		}

		return 0;
    92b0:	2300      	movs	r3, #0
    92b2:	e007      	b.n	92c4 <api_rx_buf_rsp+0x148>
	}

	return uart_rx_buf_rsp(data->uart, buf, len);
    92b4:	69fb      	ldr	r3, [r7, #28]
    92b6:	681b      	ldr	r3, [r3, #0]
    92b8:	687a      	ldr	r2, [r7, #4]
    92ba:	68b9      	ldr	r1, [r7, #8]
    92bc:	4618      	mov	r0, r3
    92be:	f00c fd6b 	bl	15d98 <uart_rx_buf_rsp>
    92c2:	4603      	mov	r3, r0
}
    92c4:	4618      	mov	r0, r3
    92c6:	3720      	adds	r7, #32
    92c8:	46bd      	mov	sp, r7
    92ca:	bd80      	pop	{r7, pc}
    92cc:	0001a774 	.word	0x0001a774
    92d0:	0001aa94 	.word	0x0001aa94
    92d4:	0001a16c 	.word	0x0001a16c
    92d8:	20000148 	.word	0x20000148
    92dc:	0001cd78 	.word	0x0001cd78
    92e0:	0001aad0 	.word	0x0001aad0
    92e4:	0001aaf8 	.word	0x0001aaf8

000092e8 <int_driven_rx_feed>:
	return data->int_driven.rxlen - data->int_driven.rxrd;
}

static void int_driven_rx_feed(const struct device *dev,
			       struct lpuart_data *data)
{
    92e8:	b580      	push	{r7, lr}
    92ea:	b084      	sub	sp, #16
    92ec:	af00      	add	r7, sp, #0
    92ee:	6078      	str	r0, [r7, #4]
    92f0:	6039      	str	r1, [r7, #0]
	int err;

	data->int_driven.rxlen = 0;
    92f2:	683b      	ldr	r3, [r7, #0]
    92f4:	2200      	movs	r2, #0
    92f6:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
	data->int_driven.rxrd = 0;
    92fa:	683b      	ldr	r3, [r7, #0]
    92fc:	2200      	movs	r2, #0
    92fe:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
	err = api_rx_buf_rsp(dev, data->int_driven.rxbuf,
    9302:	683b      	ldr	r3, [r7, #0]
    9304:	f503 738e 	add.w	r3, r3, #284	; 0x11c
    9308:	2280      	movs	r2, #128	; 0x80
    930a:	4619      	mov	r1, r3
    930c:	6878      	ldr	r0, [r7, #4]
    930e:	f7ff ff35 	bl	917c <api_rx_buf_rsp>
    9312:	60f8      	str	r0, [r7, #12]
			     sizeof(data->int_driven.rxbuf));
	__ASSERT_NO_MSG(err >= 0);
    9314:	68fb      	ldr	r3, [r7, #12]
    9316:	2b00      	cmp	r3, #0
    9318:	da0b      	bge.n	9332 <int_driven_rx_feed+0x4a>
    931a:	f240 2373 	movw	r3, #627	; 0x273
    931e:	4a07      	ldr	r2, [pc, #28]	; (933c <int_driven_rx_feed+0x54>)
    9320:	4907      	ldr	r1, [pc, #28]	; (9340 <int_driven_rx_feed+0x58>)
    9322:	4808      	ldr	r0, [pc, #32]	; (9344 <int_driven_rx_feed+0x5c>)
    9324:	f006 fea0 	bl	10068 <printk>
    9328:	f240 2173 	movw	r1, #627	; 0x273
    932c:	4803      	ldr	r0, [pc, #12]	; (933c <int_driven_rx_feed+0x54>)
    932e:	f007 fce3 	bl	10cf8 <assert_post_action>
}
    9332:	bf00      	nop
    9334:	3710      	adds	r7, #16
    9336:	46bd      	mov	sp, r7
    9338:	bd80      	pop	{r7, pc}
    933a:	bf00      	nop
    933c:	0001a774 	.word	0x0001a774
    9340:	0001ab08 	.word	0x0001ab08
    9344:	0001a16c 	.word	0x0001a16c

00009348 <int_driven_evt_handler>:

static void int_driven_evt_handler(const struct device *lpuart,
				   struct uart_event *evt,
				   void *user_data)
{
    9348:	b580      	push	{r7, lr}
    934a:	b088      	sub	sp, #32
    934c:	af00      	add	r7, sp, #0
    934e:	60f8      	str	r0, [r7, #12]
    9350:	60b9      	str	r1, [r7, #8]
    9352:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(lpuart);
    9354:	68f8      	ldr	r0, [r7, #12]
    9356:	f00c ffb8 	bl	162ca <get_dev_data>
    935a:	61b8      	str	r0, [r7, #24]
	bool call_handler = false;
    935c:	2300      	movs	r3, #0
    935e:	77fb      	strb	r3, [r7, #31]

	switch (evt->type) {
    9360:	68bb      	ldr	r3, [r7, #8]
    9362:	781b      	ldrb	r3, [r3, #0]
    9364:	2b06      	cmp	r3, #6
    9366:	d864      	bhi.n	9432 <int_driven_evt_handler+0xea>
    9368:	a201      	add	r2, pc, #4	; (adr r2, 9370 <int_driven_evt_handler+0x28>)
    936a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    936e:	bf00      	nop
    9370:	0000938d 	.word	0x0000938d
    9374:	00009433 	.word	0x00009433
    9378:	0000939b 	.word	0x0000939b
    937c:	000093d1 	.word	0x000093d1
    9380:	00009433 	.word	0x00009433
    9384:	000093f1 	.word	0x000093f1
    9388:	000093e7 	.word	0x000093e7
	case UART_TX_DONE:
		data->int_driven.txlen = 0;
    938c:	69bb      	ldr	r3, [r7, #24]
    938e:	2200      	movs	r2, #0
    9390:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		call_handler = true;
    9394:	2301      	movs	r3, #1
    9396:	77fb      	strb	r3, [r7, #31]
		break;
    9398:	e050      	b.n	943c <int_driven_evt_handler+0xf4>
	case UART_RX_RDY:
		__ASSERT_NO_MSG(data->int_driven.rxlen == 0);
    939a:	69bb      	ldr	r3, [r7, #24]
    939c:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
    93a0:	2b00      	cmp	r3, #0
    93a2:	d00b      	beq.n	93bc <int_driven_evt_handler+0x74>
    93a4:	f240 2383 	movw	r3, #643	; 0x283
    93a8:	4a2c      	ldr	r2, [pc, #176]	; (945c <int_driven_evt_handler+0x114>)
    93aa:	492d      	ldr	r1, [pc, #180]	; (9460 <int_driven_evt_handler+0x118>)
    93ac:	482d      	ldr	r0, [pc, #180]	; (9464 <int_driven_evt_handler+0x11c>)
    93ae:	f006 fe5b 	bl	10068 <printk>
    93b2:	f240 2183 	movw	r1, #643	; 0x283
    93b6:	4829      	ldr	r0, [pc, #164]	; (945c <int_driven_evt_handler+0x114>)
    93b8:	f007 fc9e 	bl	10cf8 <assert_post_action>
		data->int_driven.rxlen = evt->data.rx.len;
    93bc:	68bb      	ldr	r3, [r7, #8]
    93be:	68da      	ldr	r2, [r3, #12]
    93c0:	69bb      	ldr	r3, [r7, #24]
    93c2:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
		call_handler = data->int_driven.rx_enabled;
    93c6:	69bb      	ldr	r3, [r7, #24]
    93c8:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
    93cc:	77fb      	strb	r3, [r7, #31]
		break;
    93ce:	e035      	b.n	943c <int_driven_evt_handler+0xf4>
	case UART_RX_BUF_REQUEST:
		if (int_driven_rd_available(data) == 0) {
    93d0:	69b8      	ldr	r0, [r7, #24]
    93d2:	f00d f859 	bl	16488 <int_driven_rd_available>
    93d6:	4603      	mov	r3, r0
    93d8:	2b00      	cmp	r3, #0
    93da:	d12c      	bne.n	9436 <int_driven_evt_handler+0xee>
			int_driven_rx_feed(lpuart, data);
    93dc:	69b9      	ldr	r1, [r7, #24]
    93de:	68f8      	ldr	r0, [r7, #12]
    93e0:	f7ff ff82 	bl	92e8 <int_driven_rx_feed>
		}
		break;
    93e4:	e027      	b.n	9436 <int_driven_evt_handler+0xee>
	case UART_RX_STOPPED:
		call_handler = data->int_driven.err_enabled;
    93e6:	69bb      	ldr	r3, [r7, #24]
    93e8:	f893 31a6 	ldrb.w	r3, [r3, #422]	; 0x1a6
    93ec:	77fb      	strb	r3, [r7, #31]
		break;
    93ee:	e025      	b.n	943c <int_driven_evt_handler+0xf4>
	case UART_RX_DISABLED:
	{
		int err;

		data->int_driven.rxlen = 0;
    93f0:	69bb      	ldr	r3, [r7, #24]
    93f2:	2200      	movs	r2, #0
    93f4:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
		data->int_driven.rxrd = 0;
    93f8:	69bb      	ldr	r3, [r7, #24]
    93fa:	2200      	movs	r2, #0
    93fc:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
		err = api_rx_enable(lpuart, data->int_driven.rxbuf,
    9400:	69bb      	ldr	r3, [r7, #24]
    9402:	f503 718e 	add.w	r1, r3, #284	; 0x11c
    9406:	2301      	movs	r3, #1
    9408:	2280      	movs	r2, #128	; 0x80
    940a:	68f8      	ldr	r0, [r7, #12]
    940c:	f7ff fe06 	bl	901c <api_rx_enable>
    9410:	6178      	str	r0, [r7, #20]
					sizeof(data->int_driven.rxbuf), 1);
		__ASSERT_NO_MSG(err >= 0);
    9412:	697b      	ldr	r3, [r7, #20]
    9414:	2b00      	cmp	r3, #0
    9416:	da10      	bge.n	943a <int_driven_evt_handler+0xf2>
    9418:	f240 2397 	movw	r3, #663	; 0x297
    941c:	4a0f      	ldr	r2, [pc, #60]	; (945c <int_driven_evt_handler+0x114>)
    941e:	4912      	ldr	r1, [pc, #72]	; (9468 <int_driven_evt_handler+0x120>)
    9420:	4810      	ldr	r0, [pc, #64]	; (9464 <int_driven_evt_handler+0x11c>)
    9422:	f006 fe21 	bl	10068 <printk>
    9426:	f240 2197 	movw	r1, #663	; 0x297
    942a:	480c      	ldr	r0, [pc, #48]	; (945c <int_driven_evt_handler+0x114>)
    942c:	f007 fc64 	bl	10cf8 <assert_post_action>
		break;
    9430:	e003      	b.n	943a <int_driven_evt_handler+0xf2>
	}
	default:
		break;
    9432:	bf00      	nop
    9434:	e002      	b.n	943c <int_driven_evt_handler+0xf4>
		break;
    9436:	bf00      	nop
    9438:	e000      	b.n	943c <int_driven_evt_handler+0xf4>
		break;
    943a:	bf00      	nop
	}

	if (call_handler) {
    943c:	7ffb      	ldrb	r3, [r7, #31]
    943e:	2b00      	cmp	r3, #0
    9440:	d008      	beq.n	9454 <int_driven_evt_handler+0x10c>
		data->int_driven.callback(lpuart, data->int_driven.user_data);
    9442:	69bb      	ldr	r3, [r7, #24]
    9444:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    9448:	69ba      	ldr	r2, [r7, #24]
    944a:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
    944e:	4611      	mov	r1, r2
    9450:	68f8      	ldr	r0, [r7, #12]
    9452:	4798      	blx	r3
	}
}
    9454:	bf00      	nop
    9456:	3720      	adds	r7, #32
    9458:	46bd      	mov	sp, r7
    945a:	bd80      	pop	{r7, pc}
    945c:	0001a774 	.word	0x0001a774
    9460:	0001ab14 	.word	0x0001ab14
    9464:	0001a16c 	.word	0x0001a16c
    9468:	0001ab08 	.word	0x0001ab08

0000946c <lpuart_init>:
}

#endif /* CONFIG_NRF_SW_LPUART_INT_DRIVEN */

static int lpuart_init(const struct device *dev)
{
    946c:	b580      	push	{r7, lr}
    946e:	b086      	sub	sp, #24
    9470:	af00      	add	r7, sp, #0
    9472:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
    9474:	6878      	ldr	r0, [r7, #4]
    9476:	f00c ff28 	bl	162ca <get_dev_data>
    947a:	6178      	str	r0, [r7, #20]
	const struct lpuart_config *cfg = get_dev_config(dev);
    947c:	6878      	ldr	r0, [r7, #4]
    947e:	f00c ff2f 	bl	162e0 <get_dev_config>
    9482:	6138      	str	r0, [r7, #16]
	int err;

	data->uart = device_get_binding(cfg->uart_name);
    9484:	693b      	ldr	r3, [r7, #16]
    9486:	681b      	ldr	r3, [r3, #0]
    9488:	4618      	mov	r0, r3
    948a:	f00c fc29 	bl	15ce0 <device_get_binding>
    948e:	4602      	mov	r2, r0
    9490:	697b      	ldr	r3, [r7, #20]
    9492:	601a      	str	r2, [r3, #0]
	if (data->uart == NULL) {
    9494:	697b      	ldr	r3, [r7, #20]
    9496:	681b      	ldr	r3, [r3, #0]
    9498:	2b00      	cmp	r3, #0
    949a:	d102      	bne.n	94a2 <lpuart_init+0x36>
		return -ENODEV;
    949c:	f06f 0312 	mvn.w	r3, #18
    94a0:	e053      	b.n	954a <lpuart_init+0xde>
	}

	err = ctrl_pin_configure(&data->req_pin, &cfg->req, true);
    94a2:	697b      	ldr	r3, [r7, #20]
    94a4:	1d18      	adds	r0, r3, #4
    94a6:	693b      	ldr	r3, [r7, #16]
    94a8:	3304      	adds	r3, #4
    94aa:	2201      	movs	r2, #1
    94ac:	4619      	mov	r1, r3
    94ae:	f7ff fa4b 	bl	8948 <ctrl_pin_configure>
    94b2:	60f8      	str	r0, [r7, #12]
	if (err < 0) {
    94b4:	68fb      	ldr	r3, [r7, #12]
    94b6:	2b00      	cmp	r3, #0
    94b8:	da02      	bge.n	94c0 <lpuart_init+0x54>
		return -EINVAL;
    94ba:	f06f 0315 	mvn.w	r3, #21
    94be:	e044      	b.n	954a <lpuart_init+0xde>
	}

	err = ctrl_pin_configure(&data->rdy_pin, &cfg->rdy, false);
    94c0:	697b      	ldr	r3, [r7, #20]
    94c2:	f103 0018 	add.w	r0, r3, #24
    94c6:	693b      	ldr	r3, [r7, #16]
    94c8:	330c      	adds	r3, #12
    94ca:	2200      	movs	r2, #0
    94cc:	4619      	mov	r1, r3
    94ce:	f7ff fa3b 	bl	8948 <ctrl_pin_configure>
    94d2:	60f8      	str	r0, [r7, #12]
	if (err < 0) {
    94d4:	68fb      	ldr	r3, [r7, #12]
    94d6:	2b00      	cmp	r3, #0
    94d8:	da02      	bge.n	94e0 <lpuart_init+0x74>
		return -EINVAL;
    94da:	f06f 0315 	mvn.w	r3, #21
    94de:	e034      	b.n	954a <lpuart_init+0xde>
	}

	k_timer_init(&data->tx_timer, tx_timeout, NULL);
    94e0:	697b      	ldr	r3, [r7, #20]
    94e2:	3330      	adds	r3, #48	; 0x30
    94e4:	2200      	movs	r2, #0
    94e6:	491b      	ldr	r1, [pc, #108]	; (9554 <lpuart_init+0xe8>)
    94e8:	4618      	mov	r0, r3
    94ea:	f00e ff8c 	bl	18406 <k_timer_init>
	k_timer_user_data_set(&data->tx_timer, (void *)dev);
    94ee:	697b      	ldr	r3, [r7, #20]
    94f0:	3330      	adds	r3, #48	; 0x30
    94f2:	6879      	ldr	r1, [r7, #4]
    94f4:	4618      	mov	r0, r3
    94f6:	f00c fbda 	bl	15cae <k_timer_user_data_set>

	err = uart_callback_set(data->uart, uart_callback, (void *)dev);
    94fa:	697b      	ldr	r3, [r7, #20]
    94fc:	681b      	ldr	r3, [r3, #0]
    94fe:	687a      	ldr	r2, [r7, #4]
    9500:	4915      	ldr	r1, [pc, #84]	; (9558 <lpuart_init+0xec>)
    9502:	4618      	mov	r0, r3
    9504:	f00c fbf8 	bl	15cf8 <uart_callback_set>
    9508:	60f8      	str	r0, [r7, #12]
	if (err < 0) {
    950a:	68fb      	ldr	r3, [r7, #12]
    950c:	2b00      	cmp	r3, #0
    950e:	da02      	bge.n	9516 <lpuart_init+0xaa>
		return -EINVAL;
    9510:	f06f 0315 	mvn.w	r3, #21
    9514:	e019      	b.n	954a <lpuart_init+0xde>
	}

#if CONFIG_NRF_SW_LPUART_INT_DRIVEN
	err = uart_callback_set(dev, int_driven_evt_handler, NULL);
    9516:	2200      	movs	r2, #0
    9518:	4910      	ldr	r1, [pc, #64]	; (955c <lpuart_init+0xf0>)
    951a:	6878      	ldr	r0, [r7, #4]
    951c:	f00c fbec 	bl	15cf8 <uart_callback_set>
    9520:	60f8      	str	r0, [r7, #12]
	if (err < 0) {
    9522:	68fb      	ldr	r3, [r7, #12]
    9524:	2b00      	cmp	r3, #0
    9526:	da02      	bge.n	952e <lpuart_init+0xc2>
		return -EINVAL;
    9528:	f06f 0315 	mvn.w	r3, #21
    952c:	e00d      	b.n	954a <lpuart_init+0xde>
	}

	err = api_rx_enable(dev, data->int_driven.rxbuf,
    952e:	697b      	ldr	r3, [r7, #20]
    9530:	f503 718e 	add.w	r1, r3, #284	; 0x11c
    9534:	2301      	movs	r3, #1
    9536:	2280      	movs	r2, #128	; 0x80
    9538:	6878      	ldr	r0, [r7, #4]
    953a:	f7ff fd6f 	bl	901c <api_rx_enable>
    953e:	60f8      	str	r0, [r7, #12]
				sizeof(data->int_driven.rxbuf), 1);
#endif

	data->txbyte = -1;
    9540:	697b      	ldr	r3, [r7, #20]
    9542:	f04f 32ff 	mov.w	r2, #4294967295
    9546:	669a      	str	r2, [r3, #104]	; 0x68

	return err;
    9548:	68fb      	ldr	r3, [r7, #12]
}
    954a:	4618      	mov	r0, r3
    954c:	3718      	adds	r7, #24
    954e:	46bd      	mov	sp, r7
    9550:	bd80      	pop	{r7, pc}
    9552:	bf00      	nop
    9554:	00008de1 	.word	0x00008de1
    9558:	00008b3d 	.word	0x00008b3d
    955c:	00009349 	.word	0x00009349

00009560 <log_const_source_id>:
{
    9560:	b480      	push	{r7}
    9562:	b083      	sub	sp, #12
    9564:	af00      	add	r7, sp, #0
    9566:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    9568:	687b      	ldr	r3, [r7, #4]
    956a:	4a04      	ldr	r2, [pc, #16]	; (957c <log_const_source_id+0x1c>)
    956c:	1a9b      	subs	r3, r3, r2
    956e:	08db      	lsrs	r3, r3, #3
}
    9570:	4618      	mov	r0, r3
    9572:	370c      	adds	r7, #12
    9574:	46bd      	mov	sp, r7
    9576:	bc80      	pop	{r7}
    9578:	4770      	bx	lr
    957a:	bf00      	nop
    957c:	00018788 	.word	0x00018788

00009580 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
    9580:	b580      	push	{r7, lr}
    9582:	b084      	sub	sp, #16
    9584:	af00      	add	r7, sp, #0
    9586:	6078      	str	r0, [r7, #4]
    9588:	6039      	str	r1, [r7, #0]
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();
    958a:	f00d f9a7 	bl	168dc <log_panic>

	LOG_ERR("Resetting system");
    958e:	2303      	movs	r3, #3
    9590:	2b00      	cmp	r3, #0
    9592:	d02a      	beq.n	95ea <k_sys_fatal_error_handler+0x6a>
    9594:	f00d f99b 	bl	168ce <_is_user_context>
    9598:	4603      	mov	r3, r0
    959a:	73fb      	strb	r3, [r7, #15]
    959c:	7b3b      	ldrb	r3, [r7, #12]
    959e:	2201      	movs	r2, #1
    95a0:	f362 0302 	bfi	r3, r2, #0, #3
    95a4:	733b      	strb	r3, [r7, #12]
    95a6:	7b3b      	ldrb	r3, [r7, #12]
    95a8:	f36f 03c5 	bfc	r3, #3, #3
    95ac:	733b      	strb	r3, [r7, #12]
    95ae:	2303      	movs	r3, #3
    95b0:	2b00      	cmp	r3, #0
    95b2:	d009      	beq.n	95c8 <k_sys_fatal_error_handler+0x48>
    95b4:	4b0e      	ldr	r3, [pc, #56]	; (95f0 <k_sys_fatal_error_handler+0x70>)
    95b6:	681b      	ldr	r3, [r3, #0]
    95b8:	4618      	mov	r0, r3
    95ba:	f7ff ffd1 	bl	9560 <log_const_source_id>
    95be:	4603      	mov	r3, r0
    95c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    95c4:	b29a      	uxth	r2, r3
    95c6:	e000      	b.n	95ca <k_sys_fatal_error_handler+0x4a>
    95c8:	2200      	movs	r2, #0
    95ca:	89bb      	ldrh	r3, [r7, #12]
    95cc:	f362 138f 	bfi	r3, r2, #6, #10
    95d0:	81bb      	strh	r3, [r7, #12]
    95d2:	7bfb      	ldrb	r3, [r7, #15]
    95d4:	2b00      	cmp	r3, #0
    95d6:	d004      	beq.n	95e2 <k_sys_fatal_error_handler+0x62>
    95d8:	4906      	ldr	r1, [pc, #24]	; (95f4 <k_sys_fatal_error_handler+0x74>)
    95da:	89b8      	ldrh	r0, [r7, #12]
    95dc:	f7f9 f988 	bl	28f0 <log_from_user>
    95e0:	e003      	b.n	95ea <k_sys_fatal_error_handler+0x6a>
    95e2:	89b9      	ldrh	r1, [r7, #12]
    95e4:	4803      	ldr	r0, [pc, #12]	; (95f4 <k_sys_fatal_error_handler+0x74>)
    95e6:	f008 f81c 	bl	11622 <log_0>
	sys_arch_reboot(0);
    95ea:	2000      	movs	r0, #0
    95ec:	f009 fc5f 	bl	12eae <sys_arch_reboot>
    95f0:	2000014c 	.word	0x2000014c
    95f4:	0001ab54 	.word	0x0001ab54

000095f8 <hw_cc3xx_init>:
#include <nrf_cc3xx_platform.h>

#if CONFIG_HW_CC3XX

static int hw_cc3xx_init(const struct device *dev)
{
    95f8:	b580      	push	{r7, lr}
    95fa:	b084      	sub	sp, #16
    95fc:	af00      	add	r7, sp, #0
    95fe:	6078      	str	r0, [r7, #4]
	int res;

	__ASSERT_NO_MSG(dev != NULL);
    9600:	687b      	ldr	r3, [r7, #4]
    9602:	2b00      	cmp	r3, #0
    9604:	d109      	bne.n	961a <hw_cc3xx_init+0x22>
    9606:	2318      	movs	r3, #24
    9608:	4a0a      	ldr	r2, [pc, #40]	; (9634 <hw_cc3xx_init+0x3c>)
    960a:	490b      	ldr	r1, [pc, #44]	; (9638 <hw_cc3xx_init+0x40>)
    960c:	480b      	ldr	r0, [pc, #44]	; (963c <hw_cc3xx_init+0x44>)
    960e:	f006 fd2b 	bl	10068 <printk>
    9612:	2118      	movs	r1, #24
    9614:	4807      	ldr	r0, [pc, #28]	; (9634 <hw_cc3xx_init+0x3c>)
    9616:	f007 fb6f 	bl	10cf8 <assert_post_action>

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
    961a:	f7fb f89d 	bl	4758 <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
    961e:	f7fb f96f 	bl	4900 <nrf_cc3xx_platform_mutex_init>

	/* Initialize the cc3xx HW with or without RNG support */
#if CONFIG_ENTROPY_CC3XX
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
    9622:	f006 f8fd 	bl	f820 <nrf_cc3xx_platform_init_no_rng>
    9626:	60f8      	str	r0, [r7, #12]
#endif
	return res;
    9628:	68fb      	ldr	r3, [r7, #12]
}
    962a:	4618      	mov	r0, r3
    962c:	3710      	adds	r7, #16
    962e:	46bd      	mov	sp, r7
    9630:	bd80      	pop	{r7, pc}
    9632:	bf00      	nop
    9634:	0001ab68 	.word	0x0001ab68
    9638:	0001ab94 	.word	0x0001ab94
    963c:	0001aba8 	.word	0x0001aba8

00009640 <__NVIC_SystemReset>:
{
    9640:	b480      	push	{r7}
    9642:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
    9644:	f3bf 8f4f 	dsb	sy
}
    9648:	bf00      	nop
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    964a:	4b06      	ldr	r3, [pc, #24]	; (9664 <__NVIC_SystemReset+0x24>)
    964c:	68db      	ldr	r3, [r3, #12]
    964e:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    9652:	4904      	ldr	r1, [pc, #16]	; (9664 <__NVIC_SystemReset+0x24>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    9654:	4b04      	ldr	r3, [pc, #16]	; (9668 <__NVIC_SystemReset+0x28>)
    9656:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    9658:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
    965a:	f3bf 8f4f 	dsb	sy
}
    965e:	bf00      	nop
    __NOP();
    9660:	bf00      	nop
    9662:	e7fd      	b.n	9660 <__NVIC_SystemReset+0x20>
    9664:	e000ed00 	.word	0xe000ed00
    9668:	05fa0004 	.word	0x05fa0004

0000966c <nrf91_errata_6>:
#ifndef NRF91_ERRATA_6_ENABLE_WORKAROUND
    #define NRF91_ERRATA_6_ENABLE_WORKAROUND NRF91_ERRATA_6_PRESENT
#endif

static bool nrf91_errata_6(void)
{
    966c:	b480      	push	{r7}
    966e:	b083      	sub	sp, #12
    9670:	af00      	add	r7, sp, #0
    #ifndef NRF91_SERIES
        return false;
    #else
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    9672:	4b0e      	ldr	r3, [pc, #56]	; (96ac <nrf91_errata_6+0x40>)
    9674:	681b      	ldr	r3, [r3, #0]
    9676:	607b      	str	r3, [r7, #4]
            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    9678:	4b0d      	ldr	r3, [pc, #52]	; (96b0 <nrf91_errata_6+0x44>)
    967a:	681b      	ldr	r3, [r3, #0]
    967c:	603b      	str	r3, [r7, #0]
        #endif
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            if (var1 == 0x09)
    967e:	687b      	ldr	r3, [r7, #4]
    9680:	2b09      	cmp	r3, #9
    9682:	d10c      	bne.n	969e <nrf91_errata_6+0x32>
            {
                switch(var2)
    9684:	683b      	ldr	r3, [r7, #0]
    9686:	2b01      	cmp	r3, #1
    9688:	d003      	beq.n	9692 <nrf91_errata_6+0x26>
    968a:	683b      	ldr	r3, [r7, #0]
    968c:	2b02      	cmp	r3, #2
    968e:	d002      	beq.n	9696 <nrf91_errata_6+0x2a>
    9690:	e003      	b.n	969a <nrf91_errata_6+0x2e>
                {
                    case 0x01ul:
                        return true;
    9692:	2301      	movs	r3, #1
    9694:	e004      	b.n	96a0 <nrf91_errata_6+0x34>
                    case 0x02ul:
                        return true;
    9696:	2301      	movs	r3, #1
    9698:	e002      	b.n	96a0 <nrf91_errata_6+0x34>
                    default:
                        return true;
    969a:	2301      	movs	r3, #1
    969c:	e000      	b.n	96a0 <nrf91_errata_6+0x34>
                }
            }
        #endif
        return false;
    969e:	2300      	movs	r3, #0
    #endif
}
    96a0:	4618      	mov	r0, r3
    96a2:	370c      	adds	r7, #12
    96a4:	46bd      	mov	sp, r7
    96a6:	bc80      	pop	{r7}
    96a8:	4770      	bx	lr
    96aa:	bf00      	nop
    96ac:	00ff0130 	.word	0x00ff0130
    96b0:	00ff0134 	.word	0x00ff0134

000096b4 <nrf91_errata_14>:
#ifndef NRF91_ERRATA_14_ENABLE_WORKAROUND
    #define NRF91_ERRATA_14_ENABLE_WORKAROUND NRF91_ERRATA_14_PRESENT
#endif

static bool nrf91_errata_14(void)
{
    96b4:	b480      	push	{r7}
    96b6:	b083      	sub	sp, #12
    96b8:	af00      	add	r7, sp, #0
    #ifndef NRF91_SERIES
        return false;
    #else
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    96ba:	4b0e      	ldr	r3, [pc, #56]	; (96f4 <nrf91_errata_14+0x40>)
    96bc:	681b      	ldr	r3, [r3, #0]
    96be:	607b      	str	r3, [r7, #4]
            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    96c0:	4b0d      	ldr	r3, [pc, #52]	; (96f8 <nrf91_errata_14+0x44>)
    96c2:	681b      	ldr	r3, [r3, #0]
    96c4:	603b      	str	r3, [r7, #0]
        #endif
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            if (var1 == 0x09)
    96c6:	687b      	ldr	r3, [r7, #4]
    96c8:	2b09      	cmp	r3, #9
    96ca:	d10c      	bne.n	96e6 <nrf91_errata_14+0x32>
            {
                switch(var2)
    96cc:	683b      	ldr	r3, [r7, #0]
    96ce:	2b01      	cmp	r3, #1
    96d0:	d003      	beq.n	96da <nrf91_errata_14+0x26>
    96d2:	683b      	ldr	r3, [r7, #0]
    96d4:	2b02      	cmp	r3, #2
    96d6:	d002      	beq.n	96de <nrf91_errata_14+0x2a>
    96d8:	e003      	b.n	96e2 <nrf91_errata_14+0x2e>
                {
                    case 0x01ul:
                        return true;
    96da:	2301      	movs	r3, #1
    96dc:	e004      	b.n	96e8 <nrf91_errata_14+0x34>
                    case 0x02ul:
                        return false;
    96de:	2300      	movs	r3, #0
    96e0:	e002      	b.n	96e8 <nrf91_errata_14+0x34>
                    default:
                        return false;
    96e2:	2300      	movs	r3, #0
    96e4:	e000      	b.n	96e8 <nrf91_errata_14+0x34>
                }
            }
        #endif
        return false;
    96e6:	2300      	movs	r3, #0
    #endif
}
    96e8:	4618      	mov	r0, r3
    96ea:	370c      	adds	r7, #12
    96ec:	46bd      	mov	sp, r7
    96ee:	bc80      	pop	{r7}
    96f0:	4770      	bx	lr
    96f2:	bf00      	nop
    96f4:	00ff0130 	.word	0x00ff0130
    96f8:	00ff0134 	.word	0x00ff0134

000096fc <nrf91_errata_15>:
#ifndef NRF91_ERRATA_15_ENABLE_WORKAROUND
    #define NRF91_ERRATA_15_ENABLE_WORKAROUND NRF91_ERRATA_15_PRESENT
#endif

static bool nrf91_errata_15(void)
{
    96fc:	b480      	push	{r7}
    96fe:	b083      	sub	sp, #12
    9700:	af00      	add	r7, sp, #0
    #ifndef NRF91_SERIES
        return false;
    #else
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    9702:	4b0e      	ldr	r3, [pc, #56]	; (973c <nrf91_errata_15+0x40>)
    9704:	681b      	ldr	r3, [r3, #0]
    9706:	607b      	str	r3, [r7, #4]
            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    9708:	4b0d      	ldr	r3, [pc, #52]	; (9740 <nrf91_errata_15+0x44>)
    970a:	681b      	ldr	r3, [r3, #0]
    970c:	603b      	str	r3, [r7, #0]
        #endif
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            if (var1 == 0x09)
    970e:	687b      	ldr	r3, [r7, #4]
    9710:	2b09      	cmp	r3, #9
    9712:	d10c      	bne.n	972e <nrf91_errata_15+0x32>
            {
                switch(var2)
    9714:	683b      	ldr	r3, [r7, #0]
    9716:	2b01      	cmp	r3, #1
    9718:	d003      	beq.n	9722 <nrf91_errata_15+0x26>
    971a:	683b      	ldr	r3, [r7, #0]
    971c:	2b02      	cmp	r3, #2
    971e:	d002      	beq.n	9726 <nrf91_errata_15+0x2a>
    9720:	e003      	b.n	972a <nrf91_errata_15+0x2e>
                {
                    case 0x01ul:
                        return false;
    9722:	2300      	movs	r3, #0
    9724:	e004      	b.n	9730 <nrf91_errata_15+0x34>
                    case 0x02ul:
                        return true;
    9726:	2301      	movs	r3, #1
    9728:	e002      	b.n	9730 <nrf91_errata_15+0x34>
                    default:
                        return true;
    972a:	2301      	movs	r3, #1
    972c:	e000      	b.n	9730 <nrf91_errata_15+0x34>
                }
            }
        #endif
        return false;
    972e:	2300      	movs	r3, #0
    #endif
}
    9730:	4618      	mov	r0, r3
    9732:	370c      	adds	r7, #12
    9734:	46bd      	mov	sp, r7
    9736:	bc80      	pop	{r7}
    9738:	4770      	bx	lr
    973a:	bf00      	nop
    973c:	00ff0130 	.word	0x00ff0130
    9740:	00ff0134 	.word	0x00ff0134

00009744 <nrf91_errata_20>:
#ifndef NRF91_ERRATA_20_ENABLE_WORKAROUND
    #define NRF91_ERRATA_20_ENABLE_WORKAROUND NRF91_ERRATA_20_PRESENT
#endif

static bool nrf91_errata_20(void)
{
    9744:	b480      	push	{r7}
    9746:	b083      	sub	sp, #12
    9748:	af00      	add	r7, sp, #0
    #ifndef NRF91_SERIES
        return false;
    #else
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    974a:	4b0e      	ldr	r3, [pc, #56]	; (9784 <nrf91_errata_20+0x40>)
    974c:	681b      	ldr	r3, [r3, #0]
    974e:	607b      	str	r3, [r7, #4]
            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    9750:	4b0d      	ldr	r3, [pc, #52]	; (9788 <nrf91_errata_20+0x44>)
    9752:	681b      	ldr	r3, [r3, #0]
    9754:	603b      	str	r3, [r7, #0]
        #endif
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            if (var1 == 0x09)
    9756:	687b      	ldr	r3, [r7, #4]
    9758:	2b09      	cmp	r3, #9
    975a:	d10c      	bne.n	9776 <nrf91_errata_20+0x32>
            {
                switch(var2)
    975c:	683b      	ldr	r3, [r7, #0]
    975e:	2b01      	cmp	r3, #1
    9760:	d003      	beq.n	976a <nrf91_errata_20+0x26>
    9762:	683b      	ldr	r3, [r7, #0]
    9764:	2b02      	cmp	r3, #2
    9766:	d002      	beq.n	976e <nrf91_errata_20+0x2a>
    9768:	e003      	b.n	9772 <nrf91_errata_20+0x2e>
                {
                    case 0x01ul:
                        return true;
    976a:	2301      	movs	r3, #1
    976c:	e004      	b.n	9778 <nrf91_errata_20+0x34>
                    case 0x02ul:
                        return false;
    976e:	2300      	movs	r3, #0
    9770:	e002      	b.n	9778 <nrf91_errata_20+0x34>
                    default:
                        return false;
    9772:	2300      	movs	r3, #0
    9774:	e000      	b.n	9778 <nrf91_errata_20+0x34>
                }
            }
        #endif
        return false;
    9776:	2300      	movs	r3, #0
    #endif
}
    9778:	4618      	mov	r0, r3
    977a:	370c      	adds	r7, #12
    977c:	46bd      	mov	sp, r7
    977e:	bc80      	pop	{r7}
    9780:	4770      	bx	lr
    9782:	bf00      	nop
    9784:	00ff0130 	.word	0x00ff0130
    9788:	00ff0134 	.word	0x00ff0134

0000978c <nrf91_errata_31>:
#ifndef NRF91_ERRATA_31_ENABLE_WORKAROUND
    #define NRF91_ERRATA_31_ENABLE_WORKAROUND NRF91_ERRATA_31_PRESENT
#endif

static bool nrf91_errata_31(void)
{
    978c:	b480      	push	{r7}
    978e:	b083      	sub	sp, #12
    9790:	af00      	add	r7, sp, #0
    #ifndef NRF91_SERIES
        return false;
    #else
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    9792:	4b0e      	ldr	r3, [pc, #56]	; (97cc <nrf91_errata_31+0x40>)
    9794:	681b      	ldr	r3, [r3, #0]
    9796:	607b      	str	r3, [r7, #4]
            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    9798:	4b0d      	ldr	r3, [pc, #52]	; (97d0 <nrf91_errata_31+0x44>)
    979a:	681b      	ldr	r3, [r3, #0]
    979c:	603b      	str	r3, [r7, #0]
        #endif
        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
            if (var1 == 0x09)
    979e:	687b      	ldr	r3, [r7, #4]
    97a0:	2b09      	cmp	r3, #9
    97a2:	d10c      	bne.n	97be <nrf91_errata_31+0x32>
            {
                switch(var2)
    97a4:	683b      	ldr	r3, [r7, #0]
    97a6:	2b01      	cmp	r3, #1
    97a8:	d003      	beq.n	97b2 <nrf91_errata_31+0x26>
    97aa:	683b      	ldr	r3, [r7, #0]
    97ac:	2b02      	cmp	r3, #2
    97ae:	d002      	beq.n	97b6 <nrf91_errata_31+0x2a>
    97b0:	e003      	b.n	97ba <nrf91_errata_31+0x2e>
                {
                    case 0x01ul:
                        return true;
    97b2:	2301      	movs	r3, #1
    97b4:	e004      	b.n	97c0 <nrf91_errata_31+0x34>
                    case 0x02ul:
                        return true;
    97b6:	2301      	movs	r3, #1
    97b8:	e002      	b.n	97c0 <nrf91_errata_31+0x34>
                    default:
                        return true;
    97ba:	2301      	movs	r3, #1
    97bc:	e000      	b.n	97c0 <nrf91_errata_31+0x34>
                }
            }
        #endif
        return false;
    97be:	2300      	movs	r3, #0
    #endif
}
    97c0:	4618      	mov	r0, r3
    97c2:	370c      	adds	r7, #12
    97c4:	46bd      	mov	sp, r7
    97c6:	bc80      	pop	{r7}
    97c8:	4770      	bx	lr
    97ca:	bf00      	nop
    97cc:	00ff0130 	.word	0x00ff0130
    97d0:	00ff0134 	.word	0x00ff0134

000097d4 <SystemCoreClockUpdate>:
    static bool uicr_HFXOSRC_erased(void);
    static bool uicr_HFXOCNT_erased(void);
#endif

void SystemCoreClockUpdate(void)
{
    97d4:	b480      	push	{r7}
    97d6:	af00      	add	r7, sp, #0
    SystemCoreClock = __SYSTEM_CLOCK;
    97d8:	4b03      	ldr	r3, [pc, #12]	; (97e8 <SystemCoreClockUpdate+0x14>)
    97da:	4a04      	ldr	r2, [pc, #16]	; (97ec <SystemCoreClockUpdate+0x18>)
    97dc:	601a      	str	r2, [r3, #0]
}
    97de:	bf00      	nop
    97e0:	46bd      	mov	sp, r7
    97e2:	bc80      	pop	{r7}
    97e4:	4770      	bx	lr
    97e6:	bf00      	nop
    97e8:	20000150 	.word	0x20000150
    97ec:	03d09000 	.word	0x03d09000

000097f0 <SystemInit>:

void SystemInit(void)
{
    97f0:	b580      	push	{r7, lr}
    97f2:	b082      	sub	sp, #8
    97f4:	af00      	add	r7, sp, #0
          SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
        #endif
        
        /* Workaround for Errata 6 "POWER: SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
            for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf91_errata_6()){
    97f6:	f7ff ff39 	bl	966c <nrf91_errata_6>
    97fa:	4603      	mov	r3, r0
    97fc:	2b00      	cmp	r3, #0
    97fe:	d009      	beq.n	9814 <SystemInit+0x24>
            NRF_POWER_S->EVENTS_SLEEPENTER = (POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated << POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos);
    9800:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    9804:	2200      	movs	r2, #0
    9806:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
            NRF_POWER_S->EVENTS_SLEEPEXIT = (POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated << POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos);
    980a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    980e:	2200      	movs	r2, #0
    9810:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
        }

        /* Workaround for Errata 14 "REGULATORS: LDO mode at startup" found at the Errata document
            for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf91_errata_14()){
    9814:	f7ff ff4e 	bl	96b4 <nrf91_errata_14>
    9818:	4603      	mov	r3, r0
    981a:	2b00      	cmp	r3, #0
    981c:	d006      	beq.n	982c <SystemInit+0x3c>
            *((volatile uint32_t *)0x50004A38) = 0x01ul;
    981e:	4b57      	ldr	r3, [pc, #348]	; (997c <SystemInit+0x18c>)
    9820:	2201      	movs	r2, #1
    9822:	601a      	str	r2, [r3, #0]
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    9824:	4b56      	ldr	r3, [pc, #344]	; (9980 <SystemInit+0x190>)
    9826:	2201      	movs	r2, #1
    9828:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
        }

        /* Workaround for Errata 15 "REGULATORS: LDO mode at startup" found at the Errata document
            for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf91_errata_15()){
    982c:	f7ff ff66 	bl	96fc <nrf91_errata_15>
    9830:	4603      	mov	r3, r0
    9832:	2b00      	cmp	r3, #0
    9834:	d003      	beq.n	983e <SystemInit+0x4e>
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    9836:	4b52      	ldr	r3, [pc, #328]	; (9980 <SystemInit+0x190>)
    9838:	2201      	movs	r2, #1
    983a:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
        }

        /* Workaround for Errata 20 "RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
            for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf91_errata_20()){
    983e:	f7ff ff81 	bl	9744 <nrf91_errata_20>
    9842:	4603      	mov	r3, r0
    9844:	2b00      	cmp	r3, #0
    9846:	d002      	beq.n	984e <SystemInit+0x5e>
            *((volatile uint32_t *)0x5003AEE4) = 0xE;
    9848:	4b4e      	ldr	r3, [pc, #312]	; (9984 <SystemInit+0x194>)
    984a:	220e      	movs	r2, #14
    984c:	601a      	str	r2, [r3, #0]
        }

        /* Workaround for Errata 31 "XOSC32k Startup Failure" found at the Errata document
            for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf91_errata_31()){
    984e:	f7ff ff9d 	bl	978c <nrf91_errata_31>
    9852:	4603      	mov	r3, r0
    9854:	2b00      	cmp	r3, #0
    9856:	d005      	beq.n	9864 <SystemInit+0x74>
            *((volatile uint32_t *)0x5000470Cul) = 0x0;
    9858:	4b4b      	ldr	r3, [pc, #300]	; (9988 <SystemInit+0x198>)
    985a:	2200      	movs	r2, #0
    985c:	601a      	str	r2, [r3, #0]
            *((volatile uint32_t *)0x50004710ul) = 0x1;
    985e:	4b4b      	ldr	r3, [pc, #300]	; (998c <SystemInit+0x19c>)
    9860:	2201      	movs	r2, #1
    9862:	601a      	str	r2, [r3, #0]
        }

        /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
         until one ADDR is not initialized. */
        uint32_t index = 0;
    9864:	2300      	movs	r3, #0
    9866:	607b      	str	r3, [r7, #4]
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    9868:	2300      	movs	r3, #0
    986a:	607b      	str	r3, [r7, #4]
    986c:	e011      	b.n	9892 <SystemInit+0xa2>
          #if defined ( __ICCARM__ )
              #pragma diag_suppress=Pa082
          #endif
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    986e:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
    9872:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
    9876:	687b      	ldr	r3, [r7, #4]
    9878:	3360      	adds	r3, #96	; 0x60
    987a:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    987e:	4619      	mov	r1, r3
    9880:	687b      	ldr	r3, [r7, #4]
    9882:	3360      	adds	r3, #96	; 0x60
    9884:	00db      	lsls	r3, r3, #3
    9886:	4413      	add	r3, r2
    9888:	685b      	ldr	r3, [r3, #4]
    988a:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    988c:	687b      	ldr	r3, [r7, #4]
    988e:	3301      	adds	r3, #1
    9890:	607b      	str	r3, [r7, #4]
    9892:	687b      	ldr	r3, [r7, #4]
    9894:	2bff      	cmp	r3, #255	; 0xff
    9896:	d808      	bhi.n	98aa <SystemInit+0xba>
    9898:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
    989c:	687b      	ldr	r3, [r7, #4]
    989e:	3360      	adds	r3, #96	; 0x60
    98a0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    98a4:	f1b3 3fff 	cmp.w	r3, #4294967295
    98a8:	d1e1      	bne.n	986e <SystemInit+0x7e>
              #pragma diag_default=Pa082
          #endif
        }

        /* Set UICR->HFXOSRC and UICR->HFXOCNT to working defaults if UICR was erased */
        if (uicr_HFXOSRC_erased() || uicr_HFXOCNT_erased()) {
    98aa:	f000 f88b 	bl	99c4 <uicr_HFXOSRC_erased>
    98ae:	4603      	mov	r3, r0
    98b0:	2b00      	cmp	r3, #0
    98b2:	d104      	bne.n	98be <SystemInit+0xce>
    98b4:	f000 f876 	bl	99a4 <uicr_HFXOCNT_erased>
    98b8:	4603      	mov	r3, r0
    98ba:	2b00      	cmp	r3, #0
    98bc:	d04f      	beq.n	995e <SystemInit+0x16e>
          /* Wait for pending NVMC operations to finish */
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    98be:	bf00      	nop
    98c0:	4b33      	ldr	r3, [pc, #204]	; (9990 <SystemInit+0x1a0>)
    98c2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    98c6:	2b01      	cmp	r3, #1
    98c8:	d1fa      	bne.n	98c0 <SystemInit+0xd0>

          /* Enable write mode in NVMC */
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Wen;
    98ca:	4b31      	ldr	r3, [pc, #196]	; (9990 <SystemInit+0x1a0>)
    98cc:	2201      	movs	r2, #1
    98ce:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    98d2:	bf00      	nop
    98d4:	4b2e      	ldr	r3, [pc, #184]	; (9990 <SystemInit+0x1a0>)
    98d6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    98da:	2b01      	cmp	r3, #1
    98dc:	d1fa      	bne.n	98d4 <SystemInit+0xe4>

          if (uicr_HFXOSRC_erased()){
    98de:	f000 f871 	bl	99c4 <uicr_HFXOSRC_erased>
    98e2:	4603      	mov	r3, r0
    98e4:	2b00      	cmp	r3, #0
    98e6:	d013      	beq.n	9910 <SystemInit+0x120>
            /* Write default value to UICR->HFXOSRC */
            uicr_erased_value = NRF_UICR_S->HFXOSRC;
    98e8:	4b2a      	ldr	r3, [pc, #168]	; (9994 <SystemInit+0x1a4>)
    98ea:	69db      	ldr	r3, [r3, #28]
    98ec:	4a2a      	ldr	r2, [pc, #168]	; (9998 <SystemInit+0x1a8>)
    98ee:	6013      	str	r3, [r2, #0]
            uicr_new_value = (uicr_erased_value & ~UICR_HFXOSRC_HFXOSRC_Msk) | UICR_HFXOSRC_HFXOSRC_TCXO;
    98f0:	4b29      	ldr	r3, [pc, #164]	; (9998 <SystemInit+0x1a8>)
    98f2:	681b      	ldr	r3, [r3, #0]
    98f4:	f023 0301 	bic.w	r3, r3, #1
    98f8:	4a28      	ldr	r2, [pc, #160]	; (999c <SystemInit+0x1ac>)
    98fa:	6013      	str	r3, [r2, #0]
            NRF_UICR_S->HFXOSRC = uicr_new_value;
    98fc:	4a25      	ldr	r2, [pc, #148]	; (9994 <SystemInit+0x1a4>)
    98fe:	4b27      	ldr	r3, [pc, #156]	; (999c <SystemInit+0x1ac>)
    9900:	681b      	ldr	r3, [r3, #0]
    9902:	61d3      	str	r3, [r2, #28]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    9904:	bf00      	nop
    9906:	4b22      	ldr	r3, [pc, #136]	; (9990 <SystemInit+0x1a0>)
    9908:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    990c:	2b01      	cmp	r3, #1
    990e:	d1fa      	bne.n	9906 <SystemInit+0x116>
          }

          if (uicr_HFXOCNT_erased()){
    9910:	f000 f848 	bl	99a4 <uicr_HFXOCNT_erased>
    9914:	4603      	mov	r3, r0
    9916:	2b00      	cmp	r3, #0
    9918:	d015      	beq.n	9946 <SystemInit+0x156>
            /* Write default value to UICR->HFXOCNT */
            uicr_erased_value = NRF_UICR_S->HFXOCNT;
    991a:	4b1e      	ldr	r3, [pc, #120]	; (9994 <SystemInit+0x1a4>)
    991c:	6a1b      	ldr	r3, [r3, #32]
    991e:	4a1e      	ldr	r2, [pc, #120]	; (9998 <SystemInit+0x1a8>)
    9920:	6013      	str	r3, [r2, #0]
            uicr_new_value = (uicr_erased_value & ~UICR_HFXOCNT_HFXOCNT_Msk) | 0x20;
    9922:	4b1d      	ldr	r3, [pc, #116]	; (9998 <SystemInit+0x1a8>)
    9924:	681b      	ldr	r3, [r3, #0]
    9926:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    992a:	f043 0320 	orr.w	r3, r3, #32
    992e:	4a1b      	ldr	r2, [pc, #108]	; (999c <SystemInit+0x1ac>)
    9930:	6013      	str	r3, [r2, #0]
            NRF_UICR_S->HFXOCNT = uicr_new_value;
    9932:	4a18      	ldr	r2, [pc, #96]	; (9994 <SystemInit+0x1a4>)
    9934:	4b19      	ldr	r3, [pc, #100]	; (999c <SystemInit+0x1ac>)
    9936:	681b      	ldr	r3, [r3, #0]
    9938:	6213      	str	r3, [r2, #32]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    993a:	bf00      	nop
    993c:	4b14      	ldr	r3, [pc, #80]	; (9990 <SystemInit+0x1a0>)
    993e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    9942:	2b01      	cmp	r3, #1
    9944:	d1fa      	bne.n	993c <SystemInit+0x14c>
          }

          /* Enable read mode in NVMC */
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Ren;
    9946:	4b12      	ldr	r3, [pc, #72]	; (9990 <SystemInit+0x1a0>)
    9948:	2200      	movs	r2, #0
    994a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    994e:	bf00      	nop
    9950:	4b0f      	ldr	r3, [pc, #60]	; (9990 <SystemInit+0x1a0>)
    9952:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    9956:	2b01      	cmp	r3, #1
    9958:	d1fa      	bne.n	9950 <SystemInit+0x160>

          /* Reset to apply clock select update */
          NVIC_SystemReset();
    995a:	f7ff fe71 	bl	9640 <__NVIC_SystemReset>
             */
        #endif

        /* Allow Non-Secure code to run FPU instructions. 
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10);
    995e:	4b10      	ldr	r3, [pc, #64]	; (99a0 <SystemInit+0x1b0>)
    9960:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    9964:	4a0e      	ldr	r2, [pc, #56]	; (99a0 <SystemInit+0x1b0>)
    9966:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    996a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
    996e:	f7ff ff31 	bl	97d4 <SystemCoreClockUpdate>
}
    9972:	bf00      	nop
    9974:	3708      	adds	r7, #8
    9976:	46bd      	mov	sp, r7
    9978:	bd80      	pop	{r7, pc}
    997a:	bf00      	nop
    997c:	50004a38 	.word	0x50004a38
    9980:	50004000 	.word	0x50004000
    9984:	5003aee4 	.word	0x5003aee4
    9988:	5000470c 	.word	0x5000470c
    998c:	50004710 	.word	0x50004710
    9990:	50039000 	.word	0x50039000
    9994:	00ff8000 	.word	0x00ff8000
    9998:	20000ca4 	.word	0x20000ca4
    999c:	20000ca8 	.word	0x20000ca8
    99a0:	e000ed00 	.word	0xe000ed00

000099a4 <uicr_HFXOCNT_erased>:


#if !defined(NRF_TRUSTZONE_NONSECURE)

    bool uicr_HFXOCNT_erased()
    {
    99a4:	b480      	push	{r7}
    99a6:	af00      	add	r7, sp, #0
        if (NRF_UICR_S->HFXOCNT == 0xFFFFFFFFul) {
    99a8:	4b05      	ldr	r3, [pc, #20]	; (99c0 <uicr_HFXOCNT_erased+0x1c>)
    99aa:	6a1b      	ldr	r3, [r3, #32]
    99ac:	f1b3 3fff 	cmp.w	r3, #4294967295
    99b0:	d101      	bne.n	99b6 <uicr_HFXOCNT_erased+0x12>
            return true;
    99b2:	2301      	movs	r3, #1
    99b4:	e000      	b.n	99b8 <uicr_HFXOCNT_erased+0x14>
        }
        return false;
    99b6:	2300      	movs	r3, #0
    }
    99b8:	4618      	mov	r0, r3
    99ba:	46bd      	mov	sp, r7
    99bc:	bc80      	pop	{r7}
    99be:	4770      	bx	lr
    99c0:	00ff8000 	.word	0x00ff8000

000099c4 <uicr_HFXOSRC_erased>:
    
    
    bool uicr_HFXOSRC_erased()
    {
    99c4:	b480      	push	{r7}
    99c6:	af00      	add	r7, sp, #0
        if ((NRF_UICR_S->HFXOSRC & UICR_HFXOSRC_HFXOSRC_Msk) != UICR_HFXOSRC_HFXOSRC_TCXO) {
    99c8:	4b06      	ldr	r3, [pc, #24]	; (99e4 <uicr_HFXOSRC_erased+0x20>)
    99ca:	69db      	ldr	r3, [r3, #28]
    99cc:	f003 0301 	and.w	r3, r3, #1
    99d0:	2b00      	cmp	r3, #0
    99d2:	d001      	beq.n	99d8 <uicr_HFXOSRC_erased+0x14>
            return true;
    99d4:	2301      	movs	r3, #1
    99d6:	e000      	b.n	99da <uicr_HFXOSRC_erased+0x16>
        }
        return false;
    99d8:	2300      	movs	r3, #0
    }
    99da:	4618      	mov	r0, r3
    99dc:	46bd      	mov	sp, r7
    99de:	bc80      	pop	{r7}
    99e0:	4770      	bx	lr
    99e2:	bf00      	nop
    99e4:	00ff8000 	.word	0x00ff8000

000099e8 <nrfx_error_string_get>:
{
	k_busy_wait(usec_to_wait);
}

char const *nrfx_error_string_get(nrfx_err_t code)
{
    99e8:	b480      	push	{r7}
    99ea:	b083      	sub	sp, #12
    99ec:	af00      	add	r7, sp, #0
    99ee:	6078      	str	r0, [r7, #4]
	#define NRFX_ERROR_STRING_CASE(code)  case code: return #code
	switch (code) {
    99f0:	687b      	ldr	r3, [r7, #4]
    99f2:	4a33      	ldr	r2, [pc, #204]	; (9ac0 <nrfx_error_string_get+0xd8>)
    99f4:	4293      	cmp	r3, r2
    99f6:	d05a      	beq.n	9aae <nrfx_error_string_get+0xc6>
    99f8:	687b      	ldr	r3, [r7, #4]
    99fa:	4a31      	ldr	r2, [pc, #196]	; (9ac0 <nrfx_error_string_get+0xd8>)
    99fc:	4293      	cmp	r3, r2
    99fe:	d858      	bhi.n	9ab2 <nrfx_error_string_get+0xca>
    9a00:	687b      	ldr	r3, [r7, #4]
    9a02:	4a30      	ldr	r2, [pc, #192]	; (9ac4 <nrfx_error_string_get+0xdc>)
    9a04:	4293      	cmp	r3, r2
    9a06:	d050      	beq.n	9aaa <nrfx_error_string_get+0xc2>
    9a08:	687b      	ldr	r3, [r7, #4]
    9a0a:	4a2e      	ldr	r2, [pc, #184]	; (9ac4 <nrfx_error_string_get+0xdc>)
    9a0c:	4293      	cmp	r3, r2
    9a0e:	d850      	bhi.n	9ab2 <nrfx_error_string_get+0xca>
    9a10:	687b      	ldr	r3, [r7, #4]
    9a12:	4a2d      	ldr	r2, [pc, #180]	; (9ac8 <nrfx_error_string_get+0xe0>)
    9a14:	4293      	cmp	r3, r2
    9a16:	d227      	bcs.n	9a68 <nrfx_error_string_get+0x80>
    9a18:	687b      	ldr	r3, [r7, #4]
    9a1a:	4a2c      	ldr	r2, [pc, #176]	; (9acc <nrfx_error_string_get+0xe4>)
    9a1c:	4293      	cmp	r3, r2
    9a1e:	d348      	bcc.n	9ab2 <nrfx_error_string_get+0xca>
    9a20:	687b      	ldr	r3, [r7, #4]
    9a22:	f103 4374 	add.w	r3, r3, #4093640704	; 0xf4000000
    9a26:	f503 03a6 	add.w	r3, r3, #5439488	; 0x530000
    9a2a:	2b0c      	cmp	r3, #12
    9a2c:	d841      	bhi.n	9ab2 <nrfx_error_string_get+0xca>
    9a2e:	a201      	add	r2, pc, #4	; (adr r2, 9a34 <nrfx_error_string_get+0x4c>)
    9a30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9a34:	00009a73 	.word	0x00009a73
    9a38:	00009a77 	.word	0x00009a77
    9a3c:	00009a7b 	.word	0x00009a7b
    9a40:	00009a7f 	.word	0x00009a7f
    9a44:	00009a83 	.word	0x00009a83
    9a48:	00009a87 	.word	0x00009a87
    9a4c:	00009a8b 	.word	0x00009a8b
    9a50:	00009a8f 	.word	0x00009a8f
    9a54:	00009a93 	.word	0x00009a93
    9a58:	00009a97 	.word	0x00009a97
    9a5c:	00009a9b 	.word	0x00009a9b
    9a60:	00009a9f 	.word	0x00009a9f
    9a64:	00009aa3 	.word	0x00009aa3
    9a68:	687b      	ldr	r3, [r7, #4]
    9a6a:	4a19      	ldr	r2, [pc, #100]	; (9ad0 <nrfx_error_string_get+0xe8>)
    9a6c:	4293      	cmp	r3, r2
    9a6e:	d01a      	beq.n	9aa6 <nrfx_error_string_get+0xbe>
    9a70:	e01f      	b.n	9ab2 <nrfx_error_string_get+0xca>
		NRFX_ERROR_STRING_CASE(NRFX_SUCCESS);
    9a72:	4b18      	ldr	r3, [pc, #96]	; (9ad4 <nrfx_error_string_get+0xec>)
    9a74:	e01e      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_INTERNAL);
    9a76:	4b18      	ldr	r3, [pc, #96]	; (9ad8 <nrfx_error_string_get+0xf0>)
    9a78:	e01c      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_NO_MEM);
    9a7a:	4b18      	ldr	r3, [pc, #96]	; (9adc <nrfx_error_string_get+0xf4>)
    9a7c:	e01a      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_NOT_SUPPORTED);
    9a7e:	4b18      	ldr	r3, [pc, #96]	; (9ae0 <nrfx_error_string_get+0xf8>)
    9a80:	e018      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_INVALID_PARAM);
    9a82:	4b18      	ldr	r3, [pc, #96]	; (9ae4 <nrfx_error_string_get+0xfc>)
    9a84:	e016      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_INVALID_STATE);
    9a86:	4b18      	ldr	r3, [pc, #96]	; (9ae8 <nrfx_error_string_get+0x100>)
    9a88:	e014      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_INVALID_LENGTH);
    9a8a:	4b18      	ldr	r3, [pc, #96]	; (9aec <nrfx_error_string_get+0x104>)
    9a8c:	e012      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_TIMEOUT);
    9a8e:	4b18      	ldr	r3, [pc, #96]	; (9af0 <nrfx_error_string_get+0x108>)
    9a90:	e010      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_FORBIDDEN);
    9a92:	4b18      	ldr	r3, [pc, #96]	; (9af4 <nrfx_error_string_get+0x10c>)
    9a94:	e00e      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_NULL);
    9a96:	4b18      	ldr	r3, [pc, #96]	; (9af8 <nrfx_error_string_get+0x110>)
    9a98:	e00c      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_INVALID_ADDR);
    9a9a:	4b18      	ldr	r3, [pc, #96]	; (9afc <nrfx_error_string_get+0x114>)
    9a9c:	e00a      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_BUSY);
    9a9e:	4b18      	ldr	r3, [pc, #96]	; (9b00 <nrfx_error_string_get+0x118>)
    9aa0:	e008      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_ALREADY_INITIALIZED);
    9aa2:	4b18      	ldr	r3, [pc, #96]	; (9b04 <nrfx_error_string_get+0x11c>)
    9aa4:	e006      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_DRV_TWI_ERR_OVERRUN);
    9aa6:	4b18      	ldr	r3, [pc, #96]	; (9b08 <nrfx_error_string_get+0x120>)
    9aa8:	e004      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_DRV_TWI_ERR_ANACK);
    9aaa:	4b18      	ldr	r3, [pc, #96]	; (9b0c <nrfx_error_string_get+0x124>)
    9aac:	e002      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		NRFX_ERROR_STRING_CASE(NRFX_ERROR_DRV_TWI_ERR_DNACK);
    9aae:	4b18      	ldr	r3, [pc, #96]	; (9b10 <nrfx_error_string_get+0x128>)
    9ab0:	e000      	b.n	9ab4 <nrfx_error_string_get+0xcc>
		default: return "unknown";
    9ab2:	4b18      	ldr	r3, [pc, #96]	; (9b14 <nrfx_error_string_get+0x12c>)
	}
}
    9ab4:	4618      	mov	r0, r3
    9ab6:	370c      	adds	r7, #12
    9ab8:	46bd      	mov	sp, r7
    9aba:	bc80      	pop	{r7}
    9abc:	4770      	bx	lr
    9abe:	bf00      	nop
    9ac0:	0bae0002 	.word	0x0bae0002
    9ac4:	0bae0001 	.word	0x0bae0001
    9ac8:	0bad000d 	.word	0x0bad000d
    9acc:	0bad0000 	.word	0x0bad0000
    9ad0:	0bae0000 	.word	0x0bae0000
    9ad4:	0001abd4 	.word	0x0001abd4
    9ad8:	0001abe4 	.word	0x0001abe4
    9adc:	0001abf8 	.word	0x0001abf8
    9ae0:	0001ac0c 	.word	0x0001ac0c
    9ae4:	0001ac28 	.word	0x0001ac28
    9ae8:	0001ac44 	.word	0x0001ac44
    9aec:	0001ac60 	.word	0x0001ac60
    9af0:	0001ac7c 	.word	0x0001ac7c
    9af4:	0001ac90 	.word	0x0001ac90
    9af8:	0001aca8 	.word	0x0001aca8
    9afc:	0001acb8 	.word	0x0001acb8
    9b00:	0001acd0 	.word	0x0001acd0
    9b04:	0001ace0 	.word	0x0001ace0
    9b08:	0001ad00 	.word	0x0001ad00
    9b0c:	0001ad20 	.word	0x0001ad20
    9b10:	0001ad40 	.word	0x0001ad40
    9b14:	0001ad60 	.word	0x0001ad60

00009b18 <nrf_clock_is_running>:
{
    9b18:	b580      	push	{r7, lr}
    9b1a:	b084      	sub	sp, #16
    9b1c:	af00      	add	r7, sp, #0
    9b1e:	60f8      	str	r0, [r7, #12]
    9b20:	460b      	mov	r3, r1
    9b22:	607a      	str	r2, [r7, #4]
    9b24:	72fb      	strb	r3, [r7, #11]
    switch (domain)
    9b26:	7afb      	ldrb	r3, [r7, #11]
    9b28:	2b00      	cmp	r3, #0
    9b2a:	d002      	beq.n	9b32 <nrf_clock_is_running+0x1a>
    9b2c:	2b01      	cmp	r3, #1
    9b2e:	d015      	beq.n	9b5c <nrf_clock_is_running+0x44>
    9b30:	e029      	b.n	9b86 <nrf_clock_is_running+0x6e>
            if (p_clk_src != NULL)
    9b32:	687b      	ldr	r3, [r7, #4]
    9b34:	2b00      	cmp	r3, #0
    9b36:	d008      	beq.n	9b4a <nrf_clock_is_running+0x32>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    9b38:	68fb      	ldr	r3, [r7, #12]
    9b3a:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    9b3e:	b2db      	uxtb	r3, r3
    9b40:	f003 0303 	and.w	r3, r3, #3
    9b44:	b2da      	uxtb	r2, r3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    9b46:	687b      	ldr	r3, [r7, #4]
    9b48:	701a      	strb	r2, [r3, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    9b4a:	68fb      	ldr	r3, [r7, #12]
    9b4c:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    9b50:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    9b54:	2b00      	cmp	r3, #0
    9b56:	d024      	beq.n	9ba2 <nrf_clock_is_running+0x8a>
                return true;
    9b58:	2301      	movs	r3, #1
    9b5a:	e026      	b.n	9baa <nrf_clock_is_running+0x92>
            if (p_clk_src != NULL)
    9b5c:	687b      	ldr	r3, [r7, #4]
    9b5e:	2b00      	cmp	r3, #0
    9b60:	d008      	beq.n	9b74 <nrf_clock_is_running+0x5c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    9b62:	68fb      	ldr	r3, [r7, #12]
    9b64:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    9b68:	b2db      	uxtb	r3, r3
    9b6a:	f003 0301 	and.w	r3, r3, #1
    9b6e:	b2da      	uxtb	r2, r3
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    9b70:	687b      	ldr	r3, [r7, #4]
    9b72:	701a      	strb	r2, [r3, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    9b74:	68fb      	ldr	r3, [r7, #12]
    9b76:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    9b7a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    9b7e:	2b00      	cmp	r3, #0
    9b80:	d011      	beq.n	9ba6 <nrf_clock_is_running+0x8e>
                return true;
    9b82:	2301      	movs	r3, #1
    9b84:	e011      	b.n	9baa <nrf_clock_is_running+0x92>
            NRFX_ASSERT(0);
    9b86:	f240 3342 	movw	r3, #834	; 0x342
    9b8a:	4a0a      	ldr	r2, [pc, #40]	; (9bb4 <nrf_clock_is_running+0x9c>)
    9b8c:	490a      	ldr	r1, [pc, #40]	; (9bb8 <nrf_clock_is_running+0xa0>)
    9b8e:	480b      	ldr	r0, [pc, #44]	; (9bbc <nrf_clock_is_running+0xa4>)
    9b90:	f006 fa6a 	bl	10068 <printk>
    9b94:	f240 3142 	movw	r1, #834	; 0x342
    9b98:	4806      	ldr	r0, [pc, #24]	; (9bb4 <nrf_clock_is_running+0x9c>)
    9b9a:	f007 f8ad 	bl	10cf8 <assert_post_action>
            return false;
    9b9e:	2300      	movs	r3, #0
    9ba0:	e003      	b.n	9baa <nrf_clock_is_running+0x92>
            break;
    9ba2:	bf00      	nop
    9ba4:	e000      	b.n	9ba8 <nrf_clock_is_running+0x90>
            break;
    9ba6:	bf00      	nop
    return false;
    9ba8:	2300      	movs	r3, #0
}
    9baa:	4618      	mov	r0, r3
    9bac:	3710      	adds	r7, #16
    9bae:	46bd      	mov	sp, r7
    9bb0:	bd80      	pop	{r7, pc}
    9bb2:	bf00      	nop
    9bb4:	0001ad68 	.word	0x0001ad68
    9bb8:	0001ad9c 	.word	0x0001ad9c
    9bbc:	0001ada0 	.word	0x0001ada0

00009bc0 <log_const_source_id>:
{
    9bc0:	b480      	push	{r7}
    9bc2:	b083      	sub	sp, #12
    9bc4:	af00      	add	r7, sp, #0
    9bc6:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    9bc8:	687b      	ldr	r3, [r7, #4]
    9bca:	4a04      	ldr	r2, [pc, #16]	; (9bdc <log_const_source_id+0x1c>)
    9bcc:	1a9b      	subs	r3, r3, r2
    9bce:	08db      	lsrs	r3, r3, #3
}
    9bd0:	4618      	mov	r0, r3
    9bd2:	370c      	adds	r7, #12
    9bd4:	46bd      	mov	sp, r7
    9bd6:	bc80      	pop	{r7}
    9bd8:	4770      	bx	lr
    9bda:	bf00      	nop
    9bdc:	00018788 	.word	0x00018788

00009be0 <nrfx_clock_init>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    9be0:	b590      	push	{r4, r7, lr}
    9be2:	b085      	sub	sp, #20
    9be4:	af00      	add	r7, sp, #0
    9be6:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(event_handler);
    9be8:	687b      	ldr	r3, [r7, #4]
    9bea:	2b00      	cmp	r3, #0
    9bec:	d109      	bne.n	9c02 <nrfx_clock_init+0x22>
    9bee:	23b3      	movs	r3, #179	; 0xb3
    9bf0:	4a2b      	ldr	r2, [pc, #172]	; (9ca0 <nrfx_clock_init+0xc0>)
    9bf2:	492c      	ldr	r1, [pc, #176]	; (9ca4 <nrfx_clock_init+0xc4>)
    9bf4:	482c      	ldr	r0, [pc, #176]	; (9ca8 <nrfx_clock_init+0xc8>)
    9bf6:	f006 fa37 	bl	10068 <printk>
    9bfa:	21b3      	movs	r1, #179	; 0xb3
    9bfc:	4828      	ldr	r0, [pc, #160]	; (9ca0 <nrfx_clock_init+0xc0>)
    9bfe:	f007 f87b 	bl	10cf8 <assert_post_action>

    nrfx_err_t err_code = NRFX_SUCCESS;
    9c02:	4b2a      	ldr	r3, [pc, #168]	; (9cac <nrfx_clock_init+0xcc>)
    9c04:	60fb      	str	r3, [r7, #12]
    if (m_clock_cb.module_initialized)
    9c06:	4b2a      	ldr	r3, [pc, #168]	; (9cb0 <nrfx_clock_init+0xd0>)
    9c08:	791b      	ldrb	r3, [r3, #4]
    9c0a:	2b00      	cmp	r3, #0
    9c0c:	d002      	beq.n	9c14 <nrfx_clock_init+0x34>
    {
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    9c0e:	4b29      	ldr	r3, [pc, #164]	; (9cb4 <nrfx_clock_init+0xd4>)
    9c10:	60fb      	str	r3, [r7, #12]
    9c12:	e005      	b.n	9c20 <nrfx_clock_init+0x40>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    9c14:	4a26      	ldr	r2, [pc, #152]	; (9cb0 <nrfx_clock_init+0xd0>)
    9c16:	687b      	ldr	r3, [r7, #4]
    9c18:	6013      	str	r3, [r2, #0]
        m_clock_cb.module_initialized = true;
    9c1a:	4b25      	ldr	r3, [pc, #148]	; (9cb0 <nrfx_clock_init+0xd0>)
    9c1c:	2201      	movs	r2, #1
    9c1e:	711a      	strb	r2, [r3, #4]
#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        m_clock_cb.hfclk_started = false;
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    9c20:	2300      	movs	r3, #0
    9c22:	2b02      	cmp	r3, #2
    9c24:	d936      	bls.n	9c94 <nrfx_clock_init+0xb4>
    9c26:	f00c ff28 	bl	16a7a <_is_user_context>
    9c2a:	4603      	mov	r3, r0
    9c2c:	72fb      	strb	r3, [r7, #11]
    9c2e:	7a3b      	ldrb	r3, [r7, #8]
    9c30:	2203      	movs	r2, #3
    9c32:	f362 0302 	bfi	r3, r2, #0, #3
    9c36:	723b      	strb	r3, [r7, #8]
    9c38:	7a3b      	ldrb	r3, [r7, #8]
    9c3a:	f36f 03c5 	bfc	r3, #3, #3
    9c3e:	723b      	strb	r3, [r7, #8]
    9c40:	2300      	movs	r3, #0
    9c42:	2b00      	cmp	r3, #0
    9c44:	d009      	beq.n	9c5a <nrfx_clock_init+0x7a>
    9c46:	4b1c      	ldr	r3, [pc, #112]	; (9cb8 <nrfx_clock_init+0xd8>)
    9c48:	681b      	ldr	r3, [r3, #0]
    9c4a:	4618      	mov	r0, r3
    9c4c:	f7ff ffb8 	bl	9bc0 <log_const_source_id>
    9c50:	4603      	mov	r3, r0
    9c52:	f3c3 0309 	ubfx	r3, r3, #0, #10
    9c56:	b29a      	uxth	r2, r3
    9c58:	e000      	b.n	9c5c <nrfx_clock_init+0x7c>
    9c5a:	2200      	movs	r2, #0
    9c5c:	893b      	ldrh	r3, [r7, #8]
    9c5e:	f362 138f 	bfi	r3, r2, #6, #10
    9c62:	813b      	strh	r3, [r7, #8]
    9c64:	7afb      	ldrb	r3, [r7, #11]
    9c66:	2b00      	cmp	r3, #0
    9c68:	d009      	beq.n	9c7e <nrfx_clock_init+0x9e>
    9c6a:	68f8      	ldr	r0, [r7, #12]
    9c6c:	f7ff febc 	bl	99e8 <nrfx_error_string_get>
    9c70:	4603      	mov	r3, r0
    9c72:	4a12      	ldr	r2, [pc, #72]	; (9cbc <nrfx_clock_init+0xdc>)
    9c74:	4912      	ldr	r1, [pc, #72]	; (9cc0 <nrfx_clock_init+0xe0>)
    9c76:	8938      	ldrh	r0, [r7, #8]
    9c78:	f7f8 fe3a 	bl	28f0 <log_from_user>
    9c7c:	e00a      	b.n	9c94 <nrfx_clock_init+0xb4>
    9c7e:	4c0f      	ldr	r4, [pc, #60]	; (9cbc <nrfx_clock_init+0xdc>)
    9c80:	68f8      	ldr	r0, [r7, #12]
    9c82:	f7ff feb1 	bl	99e8 <nrfx_error_string_get>
    9c86:	4603      	mov	r3, r0
    9c88:	461a      	mov	r2, r3
    9c8a:	893b      	ldrh	r3, [r7, #8]
    9c8c:	4621      	mov	r1, r4
    9c8e:	480c      	ldr	r0, [pc, #48]	; (9cc0 <nrfx_clock_init+0xe0>)
    9c90:	f007 fcf3 	bl	1167a <log_2>
    return err_code;
    9c94:	68fb      	ldr	r3, [r7, #12]
}
    9c96:	4618      	mov	r0, r3
    9c98:	3714      	adds	r7, #20
    9c9a:	46bd      	mov	sp, r7
    9c9c:	bd90      	pop	{r4, r7, pc}
    9c9e:	bf00      	nop
    9ca0:	0001adc0 	.word	0x0001adc0
    9ca4:	0001ae00 	.word	0x0001ae00
    9ca8:	0001ada0 	.word	0x0001ada0
    9cac:	0bad0000 	.word	0x0bad0000
    9cb0:	20000cb0 	.word	0x20000cb0
    9cb4:	0bad000c 	.word	0x0bad000c
    9cb8:	20000cac 	.word	0x20000cac
    9cbc:	0001cd88 	.word	0x0001cd88
    9cc0:	0001ae10 	.word	0x0001ae10

00009cc4 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
    9cc4:	b580      	push	{r7, lr}
    9cc6:	b082      	sub	sp, #8
    9cc8:	af00      	add	r7, sp, #0
    NRFX_ASSERT(m_clock_cb.module_initialized);
    9cca:	4b22      	ldr	r3, [pc, #136]	; (9d54 <nrfx_clock_enable+0x90>)
    9ccc:	791b      	ldrb	r3, [r3, #4]
    9cce:	f083 0301 	eor.w	r3, r3, #1
    9cd2:	b2db      	uxtb	r3, r3
    9cd4:	2b00      	cmp	r3, #0
    9cd6:	d009      	beq.n	9cec <nrfx_clock_enable+0x28>
    9cd8:	23cc      	movs	r3, #204	; 0xcc
    9cda:	4a1f      	ldr	r2, [pc, #124]	; (9d58 <nrfx_clock_enable+0x94>)
    9cdc:	491f      	ldr	r1, [pc, #124]	; (9d5c <nrfx_clock_enable+0x98>)
    9cde:	4820      	ldr	r0, [pc, #128]	; (9d60 <nrfx_clock_enable+0x9c>)
    9ce0:	f006 f9c2 	bl	10068 <printk>
    9ce4:	21cc      	movs	r1, #204	; 0xcc
    9ce6:	481c      	ldr	r0, [pc, #112]	; (9d58 <nrfx_clock_enable+0x94>)
    9ce8:	f007 f806 	bl	10cf8 <assert_post_action>
    nrfx_power_clock_irq_init();
    9cec:	f00c fe97 	bl	16a1e <nrfx_power_clock_irq_init>
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
    9cf0:	2300      	movs	r3, #0
    9cf2:	2b02      	cmp	r3, #2
    9cf4:	d92a      	bls.n	9d4c <nrfx_clock_enable+0x88>
    9cf6:	f00c fec0 	bl	16a7a <_is_user_context>
    9cfa:	4603      	mov	r3, r0
    9cfc:	71fb      	strb	r3, [r7, #7]
    9cfe:	793b      	ldrb	r3, [r7, #4]
    9d00:	2203      	movs	r2, #3
    9d02:	f362 0302 	bfi	r3, r2, #0, #3
    9d06:	713b      	strb	r3, [r7, #4]
    9d08:	793b      	ldrb	r3, [r7, #4]
    9d0a:	f36f 03c5 	bfc	r3, #3, #3
    9d0e:	713b      	strb	r3, [r7, #4]
    9d10:	2300      	movs	r3, #0
    9d12:	2b00      	cmp	r3, #0
    9d14:	d009      	beq.n	9d2a <nrfx_clock_enable+0x66>
    9d16:	4b13      	ldr	r3, [pc, #76]	; (9d64 <nrfx_clock_enable+0xa0>)
    9d18:	681b      	ldr	r3, [r3, #0]
    9d1a:	4618      	mov	r0, r3
    9d1c:	f7ff ff50 	bl	9bc0 <log_const_source_id>
    9d20:	4603      	mov	r3, r0
    9d22:	f3c3 0309 	ubfx	r3, r3, #0, #10
    9d26:	b29a      	uxth	r2, r3
    9d28:	e000      	b.n	9d2c <nrfx_clock_enable+0x68>
    9d2a:	2200      	movs	r2, #0
    9d2c:	88bb      	ldrh	r3, [r7, #4]
    9d2e:	f362 138f 	bfi	r3, r2, #6, #10
    9d32:	80bb      	strh	r3, [r7, #4]
    9d34:	79fb      	ldrb	r3, [r7, #7]
    9d36:	2b00      	cmp	r3, #0
    9d38:	d004      	beq.n	9d44 <nrfx_clock_enable+0x80>
    9d3a:	490b      	ldr	r1, [pc, #44]	; (9d68 <nrfx_clock_enable+0xa4>)
    9d3c:	88b8      	ldrh	r0, [r7, #4]
    9d3e:	f7f8 fdd7 	bl	28f0 <log_from_user>
}
    9d42:	e003      	b.n	9d4c <nrfx_clock_enable+0x88>
    NRFX_LOG_INFO("Module enabled.");
    9d44:	88b9      	ldrh	r1, [r7, #4]
    9d46:	4808      	ldr	r0, [pc, #32]	; (9d68 <nrfx_clock_enable+0xa4>)
    9d48:	f007 fc6b 	bl	11622 <log_0>
}
    9d4c:	bf00      	nop
    9d4e:	3708      	adds	r7, #8
    9d50:	46bd      	mov	sp, r7
    9d52:	bd80      	pop	{r7, pc}
    9d54:	20000cb0 	.word	0x20000cb0
    9d58:	0001adc0 	.word	0x0001adc0
    9d5c:	0001ae30 	.word	0x0001ae30
    9d60:	0001ada0 	.word	0x0001ada0
    9d64:	20000cac 	.word	0x20000cac
    9d68:	0001ae50 	.word	0x0001ae50

00009d6c <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    9d6c:	b580      	push	{r7, lr}
    9d6e:	b084      	sub	sp, #16
    9d70:	af00      	add	r7, sp, #0
    9d72:	4603      	mov	r3, r0
    9d74:	71fb      	strb	r3, [r7, #7]
    NRFX_ASSERT(m_clock_cb.module_initialized);
    9d76:	4b32      	ldr	r3, [pc, #200]	; (9e40 <nrfx_clock_start+0xd4>)
    9d78:	791b      	ldrb	r3, [r3, #4]
    9d7a:	f083 0301 	eor.w	r3, r3, #1
    9d7e:	b2db      	uxtb	r3, r3
    9d80:	2b00      	cmp	r3, #0
    9d82:	d00b      	beq.n	9d9c <nrfx_clock_start+0x30>
    9d84:	f44f 7384 	mov.w	r3, #264	; 0x108
    9d88:	4a2e      	ldr	r2, [pc, #184]	; (9e44 <nrfx_clock_start+0xd8>)
    9d8a:	492f      	ldr	r1, [pc, #188]	; (9e48 <nrfx_clock_start+0xdc>)
    9d8c:	482f      	ldr	r0, [pc, #188]	; (9e4c <nrfx_clock_start+0xe0>)
    9d8e:	f006 f96b 	bl	10068 <printk>
    9d92:	f44f 7184 	mov.w	r1, #264	; 0x108
    9d96:	482b      	ldr	r0, [pc, #172]	; (9e44 <nrfx_clock_start+0xd8>)
    9d98:	f006 ffae 	bl	10cf8 <assert_post_action>
    switch (domain)
    9d9c:	79fb      	ldrb	r3, [r7, #7]
    9d9e:	2b00      	cmp	r3, #0
    9da0:	d002      	beq.n	9da8 <nrfx_clock_start+0x3c>
    9da2:	2b01      	cmp	r3, #1
    9da4:	d02a      	beq.n	9dfc <nrfx_clock_start+0x90>
    9da6:	e03a      	b.n	9e1e <nrfx_clock_start+0xb2>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    9da8:	f107 030f 	add.w	r3, r7, #15
    9dac:	461a      	mov	r2, r3
    9dae:	2100      	movs	r1, #0
    9db0:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9db4:	f7ff feb0 	bl	9b18 <nrf_clock_is_running>
    9db8:	4603      	mov	r3, r0
    9dba:	2b00      	cmp	r3, #0
    9dbc:	d008      	beq.n	9dd0 <nrfx_clock_start+0x64>
                    lfclksrc == NRFX_CLOCK_CONFIG_LF_SRC)
    9dbe:	7bfb      	ldrb	r3, [r7, #15]
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    9dc0:	2b02      	cmp	r3, #2
    9dc2:	d105      	bne.n	9dd0 <nrfx_clock_start+0x64>
                {
                    // If the two-stage LFXO procedure has finished already
                    // use the configured LF clock source.
                    nrf_clock_lf_src_set(NRF_CLOCK, (nrf_clock_lfclk_t)NRFX_CLOCK_CONFIG_LF_SRC);
    9dc4:	2102      	movs	r1, #2
    9dc6:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9dca:	f00c fe19 	bl	16a00 <nrf_clock_lf_src_set>
    9dce:	e004      	b.n	9dda <nrfx_clock_start+0x6e>
                else
                {
                    // If the two-stage LFXO procedure hasn't started yet
                    // or the RC stage is in progress,
                    // use the RC oscillator as LF clock source.
                    nrf_clock_lf_src_set(NRF_CLOCK, NRF_CLOCK_LFCLK_RC);
    9dd0:	2101      	movs	r1, #1
    9dd2:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9dd6:	f00c fe13 	bl	16a00 <nrf_clock_lf_src_set>
                }
            }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED);
    9dda:	f44f 7182 	mov.w	r1, #260	; 0x104
    9dde:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9de2:	f00c fde4 	bl	169ae <nrf_clock_event_clear>
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
    9de6:	2102      	movs	r1, #2
    9de8:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9dec:	f00c fdb3 	bl	16956 <nrf_clock_int_enable>
#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)
            nrfx_clock_anomaly_132();
#endif
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_LFCLKSTART);
    9df0:	2108      	movs	r1, #8
    9df2:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9df6:	f00c fdca 	bl	1698e <nrf_clock_task_trigger>
            break;
    9dfa:	e01d      	b.n	9e38 <nrfx_clock_start+0xcc>
        case NRF_CLOCK_DOMAIN_HFCLK:
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
    9dfc:	f44f 7180 	mov.w	r1, #256	; 0x100
    9e00:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9e04:	f00c fdd3 	bl	169ae <nrf_clock_event_clear>
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);
    9e08:	2101      	movs	r1, #1
    9e0a:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9e0e:	f00c fda2 	bl	16956 <nrf_clock_int_enable>
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKSTART);
    9e12:	2100      	movs	r1, #0
    9e14:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9e18:	f00c fdb9 	bl	1698e <nrf_clock_task_trigger>
            break;
    9e1c:	e00c      	b.n	9e38 <nrfx_clock_start+0xcc>
            nrf_clock_int_enable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTART);
            break;
#endif
        default:
            NRFX_ASSERT(0);
    9e1e:	f44f 739d 	mov.w	r3, #314	; 0x13a
    9e22:	4a08      	ldr	r2, [pc, #32]	; (9e44 <nrfx_clock_start+0xd8>)
    9e24:	490a      	ldr	r1, [pc, #40]	; (9e50 <nrfx_clock_start+0xe4>)
    9e26:	4809      	ldr	r0, [pc, #36]	; (9e4c <nrfx_clock_start+0xe0>)
    9e28:	f006 f91e 	bl	10068 <printk>
    9e2c:	f44f 719d 	mov.w	r1, #314	; 0x13a
    9e30:	4804      	ldr	r0, [pc, #16]	; (9e44 <nrfx_clock_start+0xd8>)
    9e32:	f006 ff61 	bl	10cf8 <assert_post_action>
            break;
    9e36:	bf00      	nop
    }
}
    9e38:	bf00      	nop
    9e3a:	3710      	adds	r7, #16
    9e3c:	46bd      	mov	sp, r7
    9e3e:	bd80      	pop	{r7, pc}
    9e40:	20000cb0 	.word	0x20000cb0
    9e44:	0001adc0 	.word	0x0001adc0
    9e48:	0001ae30 	.word	0x0001ae30
    9e4c:	0001ada0 	.word	0x0001ada0
    9e50:	0001ad9c 	.word	0x0001ad9c

00009e54 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    9e54:	b580      	push	{r7, lr}
    9e56:	b086      	sub	sp, #24
    9e58:	af00      	add	r7, sp, #0
    9e5a:	4603      	mov	r3, r0
    9e5c:	71fb      	strb	r3, [r7, #7]
    NRFX_ASSERT(m_clock_cb.module_initialized);
    9e5e:	4b63      	ldr	r3, [pc, #396]	; (9fec <nrfx_clock_stop+0x198>)
    9e60:	791b      	ldrb	r3, [r3, #4]
    9e62:	f083 0301 	eor.w	r3, r3, #1
    9e66:	b2db      	uxtb	r3, r3
    9e68:	2b00      	cmp	r3, #0
    9e6a:	d00b      	beq.n	9e84 <nrfx_clock_stop+0x30>
    9e6c:	f240 1341 	movw	r3, #321	; 0x141
    9e70:	4a5f      	ldr	r2, [pc, #380]	; (9ff0 <nrfx_clock_stop+0x19c>)
    9e72:	4960      	ldr	r1, [pc, #384]	; (9ff4 <nrfx_clock_stop+0x1a0>)
    9e74:	4860      	ldr	r0, [pc, #384]	; (9ff8 <nrfx_clock_stop+0x1a4>)
    9e76:	f006 f8f7 	bl	10068 <printk>
    9e7a:	f240 1141 	movw	r1, #321	; 0x141
    9e7e:	485c      	ldr	r0, [pc, #368]	; (9ff0 <nrfx_clock_stop+0x19c>)
    9e80:	f006 ff3a 	bl	10cf8 <assert_post_action>
    switch (domain)
    9e84:	79fb      	ldrb	r3, [r7, #7]
    9e86:	2b00      	cmp	r3, #0
    9e88:	d002      	beq.n	9e90 <nrfx_clock_stop+0x3c>
    9e8a:	2b01      	cmp	r3, #1
    9e8c:	d011      	beq.n	9eb2 <nrfx_clock_stop+0x5e>
    9e8e:	e021      	b.n	9ed4 <nrfx_clock_stop+0x80>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
            nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
    9e90:	2102      	movs	r1, #2
    9e92:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9e96:	f00c fd6c 	bl	16972 <nrf_clock_int_disable>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED);
    9e9a:	f44f 7182 	mov.w	r1, #260	; 0x104
    9e9e:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9ea2:	f00c fd84 	bl	169ae <nrf_clock_event_clear>
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_LFCLKSTOP);
    9ea6:	210c      	movs	r1, #12
    9ea8:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9eac:	f00c fd6f 	bl	1698e <nrf_clock_task_trigger>
            break;
    9eb0:	e01d      	b.n	9eee <nrfx_clock_stop+0x9a>
        case NRF_CLOCK_DOMAIN_HFCLK:
            nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);
    9eb2:	2101      	movs	r1, #1
    9eb4:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9eb8:	f00c fd5b 	bl	16972 <nrf_clock_int_disable>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
    9ebc:	f44f 7180 	mov.w	r1, #256	; 0x100
    9ec0:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9ec4:	f00c fd73 	bl	169ae <nrf_clock_event_clear>
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKSTOP);
    9ec8:	2104      	movs	r1, #4
    9eca:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    9ece:	f00c fd5e 	bl	1698e <nrf_clock_task_trigger>
            break;
    9ed2:	e00c      	b.n	9eee <nrfx_clock_stop+0x9a>
            nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKAUDIOSTOP);
            break;
#endif
        default:
            NRFX_ASSERT(0);
    9ed4:	f240 135d 	movw	r3, #349	; 0x15d
    9ed8:	4a45      	ldr	r2, [pc, #276]	; (9ff0 <nrfx_clock_stop+0x19c>)
    9eda:	4948      	ldr	r1, [pc, #288]	; (9ffc <nrfx_clock_stop+0x1a8>)
    9edc:	4846      	ldr	r0, [pc, #280]	; (9ff8 <nrfx_clock_stop+0x1a4>)
    9ede:	f006 f8c3 	bl	10068 <printk>
    9ee2:	f240 115d 	movw	r1, #349	; 0x15d
    9ee6:	4842      	ldr	r0, [pc, #264]	; (9ff0 <nrfx_clock_stop+0x19c>)
    9ee8:	f006 ff06 	bl	10cf8 <assert_post_action>
            return;
    9eec:	e07a      	b.n	9fe4 <nrfx_clock_stop+0x190>
    }

    bool stopped;
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    9eee:	79fb      	ldrb	r3, [r7, #7]
    9ef0:	2b01      	cmp	r3, #1
    9ef2:	d123      	bne.n	9f3c <nrfx_clock_stop+0xe8>
    {
        nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    9ef4:	2301      	movs	r3, #1
    9ef6:	737b      	strb	r3, [r7, #13]
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    9ef8:	2300      	movs	r3, #0
    9efa:	73fb      	strb	r3, [r7, #15]
    9efc:	f242 7310 	movw	r3, #10000	; 0x2710
    9f00:	617b      	str	r3, [r7, #20]
    9f02:	f107 020d 	add.w	r2, r7, #13
    9f06:	79fb      	ldrb	r3, [r7, #7]
    9f08:	4611      	mov	r1, r2
    9f0a:	4618      	mov	r0, r3
    9f0c:	f00c fda3 	bl	16a56 <nrfx_clock_is_running>
    9f10:	4603      	mov	r3, r0
    9f12:	f083 0301 	eor.w	r3, r3, #1
    9f16:	b2db      	uxtb	r3, r3
    9f18:	2b00      	cmp	r3, #0
    9f1a:	d102      	bne.n	9f22 <nrfx_clock_stop+0xce>
    9f1c:	7b7b      	ldrb	r3, [r7, #13]
    9f1e:	2b01      	cmp	r3, #1
    9f20:	d002      	beq.n	9f28 <nrfx_clock_stop+0xd4>
    9f22:	2301      	movs	r3, #1
    9f24:	73fb      	strb	r3, [r7, #15]
    9f26:	e025      	b.n	9f74 <nrfx_clock_stop+0x120>
    9f28:	2001      	movs	r0, #1
    9f2a:	f00c fcf2 	bl	16912 <nrfx_busy_wait>
    9f2e:	697b      	ldr	r3, [r7, #20]
    9f30:	3b01      	subs	r3, #1
    9f32:	617b      	str	r3, [r7, #20]
    9f34:	697b      	ldr	r3, [r7, #20]
    9f36:	2b00      	cmp	r3, #0
    9f38:	d1e3      	bne.n	9f02 <nrfx_clock_stop+0xae>
    9f3a:	e01b      	b.n	9f74 <nrfx_clock_stop+0x120>
                       (clk_src != NRF_CLOCK_HFCLK_HIGH_ACCURACY)), 10000, 1, stopped);
    }
    else
    {
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    9f3c:	2300      	movs	r3, #0
    9f3e:	73fb      	strb	r3, [r7, #15]
    9f40:	f242 7310 	movw	r3, #10000	; 0x2710
    9f44:	613b      	str	r3, [r7, #16]
    9f46:	79fb      	ldrb	r3, [r7, #7]
    9f48:	2100      	movs	r1, #0
    9f4a:	4618      	mov	r0, r3
    9f4c:	f00c fd83 	bl	16a56 <nrfx_clock_is_running>
    9f50:	4603      	mov	r3, r0
    9f52:	f083 0301 	eor.w	r3, r3, #1
    9f56:	b2db      	uxtb	r3, r3
    9f58:	2b00      	cmp	r3, #0
    9f5a:	d002      	beq.n	9f62 <nrfx_clock_stop+0x10e>
    9f5c:	2301      	movs	r3, #1
    9f5e:	73fb      	strb	r3, [r7, #15]
    9f60:	e008      	b.n	9f74 <nrfx_clock_stop+0x120>
    9f62:	2001      	movs	r0, #1
    9f64:	f00c fcd5 	bl	16912 <nrfx_busy_wait>
    9f68:	693b      	ldr	r3, [r7, #16]
    9f6a:	3b01      	subs	r3, #1
    9f6c:	613b      	str	r3, [r7, #16]
    9f6e:	693b      	ldr	r3, [r7, #16]
    9f70:	2b00      	cmp	r3, #0
    9f72:	d1e8      	bne.n	9f46 <nrfx_clock_stop+0xf2>
    }

    if (!stopped)
    9f74:	7bfb      	ldrb	r3, [r7, #15]
    9f76:	f083 0301 	eor.w	r3, r3, #1
    9f7a:	b2db      	uxtb	r3, r3
    9f7c:	2b00      	cmp	r3, #0
    9f7e:	d031      	beq.n	9fe4 <nrfx_clock_stop+0x190>
    {
        NRFX_LOG_ERROR("Failed to stop clock domain: %d.", domain);
    9f80:	2300      	movs	r3, #0
    9f82:	2b00      	cmp	r3, #0
    9f84:	d02e      	beq.n	9fe4 <nrfx_clock_stop+0x190>
    9f86:	f00c fd78 	bl	16a7a <_is_user_context>
    9f8a:	4603      	mov	r3, r0
    9f8c:	73bb      	strb	r3, [r7, #14]
    9f8e:	7a3b      	ldrb	r3, [r7, #8]
    9f90:	2201      	movs	r2, #1
    9f92:	f362 0302 	bfi	r3, r2, #0, #3
    9f96:	723b      	strb	r3, [r7, #8]
    9f98:	7a3b      	ldrb	r3, [r7, #8]
    9f9a:	f36f 03c5 	bfc	r3, #3, #3
    9f9e:	723b      	strb	r3, [r7, #8]
    9fa0:	2300      	movs	r3, #0
    9fa2:	2b00      	cmp	r3, #0
    9fa4:	d009      	beq.n	9fba <nrfx_clock_stop+0x166>
    9fa6:	4b16      	ldr	r3, [pc, #88]	; (a000 <nrfx_clock_stop+0x1ac>)
    9fa8:	681b      	ldr	r3, [r3, #0]
    9faa:	4618      	mov	r0, r3
    9fac:	f7ff fe08 	bl	9bc0 <log_const_source_id>
    9fb0:	4603      	mov	r3, r0
    9fb2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    9fb6:	b29a      	uxth	r2, r3
    9fb8:	e000      	b.n	9fbc <nrfx_clock_stop+0x168>
    9fba:	2200      	movs	r2, #0
    9fbc:	893b      	ldrh	r3, [r7, #8]
    9fbe:	f362 138f 	bfi	r3, r2, #6, #10
    9fc2:	813b      	strh	r3, [r7, #8]
    9fc4:	7bbb      	ldrb	r3, [r7, #14]
    9fc6:	2b00      	cmp	r3, #0
    9fc8:	d006      	beq.n	9fd8 <nrfx_clock_stop+0x184>
    9fca:	79fb      	ldrb	r3, [r7, #7]
    9fcc:	461a      	mov	r2, r3
    9fce:	490d      	ldr	r1, [pc, #52]	; (a004 <nrfx_clock_stop+0x1b0>)
    9fd0:	8938      	ldrh	r0, [r7, #8]
    9fd2:	f7f8 fc8d 	bl	28f0 <log_from_user>
    9fd6:	e005      	b.n	9fe4 <nrfx_clock_stop+0x190>
    9fd8:	79fb      	ldrb	r3, [r7, #7]
    9fda:	893a      	ldrh	r2, [r7, #8]
    9fdc:	4619      	mov	r1, r3
    9fde:	4809      	ldr	r0, [pc, #36]	; (a004 <nrfx_clock_stop+0x1b0>)
    9fe0:	f007 fb34 	bl	1164c <log_1>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    9fe4:	3718      	adds	r7, #24
    9fe6:	46bd      	mov	sp, r7
    9fe8:	bd80      	pop	{r7, pc}
    9fea:	bf00      	nop
    9fec:	20000cb0 	.word	0x20000cb0
    9ff0:	0001adc0 	.word	0x0001adc0
    9ff4:	0001ae30 	.word	0x0001ae30
    9ff8:	0001ada0 	.word	0x0001ada0
    9ffc:	0001ad9c 	.word	0x0001ad9c
    a000:	20000cac 	.word	0x20000cac
    a004:	0001ae84 	.word	0x0001ae84

0000a008 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    a008:	b580      	push	{r7, lr}
    a00a:	b082      	sub	sp, #8
    a00c:	af00      	add	r7, sp, #0
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    a00e:	f44f 7180 	mov.w	r1, #256	; 0x100
    a012:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a016:	f00c fcdf 	bl	169d8 <nrf_clock_event_check>
    a01a:	4603      	mov	r3, r0
    a01c:	2b00      	cmp	r3, #0
    a01e:	d03f      	beq.n	a0a0 <nrfx_power_clock_irq_handler+0x98>
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
    a020:	f44f 7180 	mov.w	r1, #256	; 0x100
    a024:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a028:	f00c fcc1 	bl	169ae <nrf_clock_event_clear>
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
    a02c:	2300      	movs	r3, #0
    a02e:	2b03      	cmp	r3, #3
    a030:	d92d      	bls.n	a08e <nrfx_power_clock_irq_handler+0x86>
    a032:	f00c fd22 	bl	16a7a <_is_user_context>
    a036:	4603      	mov	r3, r0
    a038:	71fb      	strb	r3, [r7, #7]
    a03a:	793b      	ldrb	r3, [r7, #4]
    a03c:	2204      	movs	r2, #4
    a03e:	f362 0302 	bfi	r3, r2, #0, #3
    a042:	713b      	strb	r3, [r7, #4]
    a044:	793b      	ldrb	r3, [r7, #4]
    a046:	f36f 03c5 	bfc	r3, #3, #3
    a04a:	713b      	strb	r3, [r7, #4]
    a04c:	2300      	movs	r3, #0
    a04e:	2b00      	cmp	r3, #0
    a050:	d009      	beq.n	a066 <nrfx_power_clock_irq_handler+0x5e>
    a052:	4b44      	ldr	r3, [pc, #272]	; (a164 <nrfx_power_clock_irq_handler+0x15c>)
    a054:	681b      	ldr	r3, [r3, #0]
    a056:	4618      	mov	r0, r3
    a058:	f7ff fdb2 	bl	9bc0 <log_const_source_id>
    a05c:	4603      	mov	r3, r0
    a05e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a062:	b29a      	uxth	r2, r3
    a064:	e000      	b.n	a068 <nrfx_power_clock_irq_handler+0x60>
    a066:	2200      	movs	r2, #0
    a068:	88bb      	ldrh	r3, [r7, #4]
    a06a:	f362 138f 	bfi	r3, r2, #6, #10
    a06e:	80bb      	strh	r3, [r7, #4]
    a070:	79fb      	ldrb	r3, [r7, #7]
    a072:	2b00      	cmp	r3, #0
    a074:	d005      	beq.n	a082 <nrfx_power_clock_irq_handler+0x7a>
    a076:	4a3c      	ldr	r2, [pc, #240]	; (a168 <nrfx_power_clock_irq_handler+0x160>)
    a078:	493c      	ldr	r1, [pc, #240]	; (a16c <nrfx_power_clock_irq_handler+0x164>)
    a07a:	88b8      	ldrh	r0, [r7, #4]
    a07c:	f7f8 fc38 	bl	28f0 <log_from_user>
    a080:	e005      	b.n	a08e <nrfx_power_clock_irq_handler+0x86>
    a082:	4b39      	ldr	r3, [pc, #228]	; (a168 <nrfx_power_clock_irq_handler+0x160>)
    a084:	88ba      	ldrh	r2, [r7, #4]
    a086:	4619      	mov	r1, r3
    a088:	4838      	ldr	r0, [pc, #224]	; (a16c <nrfx_power_clock_irq_handler+0x164>)
    a08a:	f007 fadf 	bl	1164c <log_1>
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);
    a08e:	2101      	movs	r1, #1
    a090:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a094:	f00c fc6d 	bl	16972 <nrf_clock_int_disable>
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    a098:	4b35      	ldr	r3, [pc, #212]	; (a170 <nrfx_power_clock_irq_handler+0x168>)
    a09a:	681b      	ldr	r3, [r3, #0]
    a09c:	2000      	movs	r0, #0
    a09e:	4798      	blx	r3
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    a0a0:	f44f 7182 	mov.w	r1, #260	; 0x104
    a0a4:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a0a8:	f00c fc96 	bl	169d8 <nrf_clock_event_check>
    a0ac:	4603      	mov	r3, r0
    a0ae:	2b00      	cmp	r3, #0
    a0b0:	d054      	beq.n	a15c <nrfx_power_clock_irq_handler+0x154>
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED);
    a0b2:	f44f 7182 	mov.w	r1, #260	; 0x104
    a0b6:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a0ba:	f00c fc78 	bl	169ae <nrf_clock_event_clear>
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");
    a0be:	2300      	movs	r3, #0
    a0c0:	2b03      	cmp	r3, #3
    a0c2:	d92d      	bls.n	a120 <nrfx_power_clock_irq_handler+0x118>
    a0c4:	f00c fcd9 	bl	16a7a <_is_user_context>
    a0c8:	4603      	mov	r3, r0
    a0ca:	71bb      	strb	r3, [r7, #6]
    a0cc:	783b      	ldrb	r3, [r7, #0]
    a0ce:	2204      	movs	r2, #4
    a0d0:	f362 0302 	bfi	r3, r2, #0, #3
    a0d4:	703b      	strb	r3, [r7, #0]
    a0d6:	783b      	ldrb	r3, [r7, #0]
    a0d8:	f36f 03c5 	bfc	r3, #3, #3
    a0dc:	703b      	strb	r3, [r7, #0]
    a0de:	2300      	movs	r3, #0
    a0e0:	2b00      	cmp	r3, #0
    a0e2:	d009      	beq.n	a0f8 <nrfx_power_clock_irq_handler+0xf0>
    a0e4:	4b1f      	ldr	r3, [pc, #124]	; (a164 <nrfx_power_clock_irq_handler+0x15c>)
    a0e6:	681b      	ldr	r3, [r3, #0]
    a0e8:	4618      	mov	r0, r3
    a0ea:	f7ff fd69 	bl	9bc0 <log_const_source_id>
    a0ee:	4603      	mov	r3, r0
    a0f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a0f4:	b29a      	uxth	r2, r3
    a0f6:	e000      	b.n	a0fa <nrfx_power_clock_irq_handler+0xf2>
    a0f8:	2200      	movs	r2, #0
    a0fa:	883b      	ldrh	r3, [r7, #0]
    a0fc:	f362 138f 	bfi	r3, r2, #6, #10
    a100:	803b      	strh	r3, [r7, #0]
    a102:	79bb      	ldrb	r3, [r7, #6]
    a104:	2b00      	cmp	r3, #0
    a106:	d005      	beq.n	a114 <nrfx_power_clock_irq_handler+0x10c>
    a108:	4a17      	ldr	r2, [pc, #92]	; (a168 <nrfx_power_clock_irq_handler+0x160>)
    a10a:	491a      	ldr	r1, [pc, #104]	; (a174 <nrfx_power_clock_irq_handler+0x16c>)
    a10c:	8838      	ldrh	r0, [r7, #0]
    a10e:	f7f8 fbef 	bl	28f0 <log_from_user>
    a112:	e005      	b.n	a120 <nrfx_power_clock_irq_handler+0x118>
    a114:	4b14      	ldr	r3, [pc, #80]	; (a168 <nrfx_power_clock_irq_handler+0x160>)
    a116:	883a      	ldrh	r2, [r7, #0]
    a118:	4619      	mov	r1, r3
    a11a:	4816      	ldr	r0, [pc, #88]	; (a174 <nrfx_power_clock_irq_handler+0x16c>)
    a11c:	f007 fa96 	bl	1164c <log_1>

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
    a120:	1cfb      	adds	r3, r7, #3
    a122:	461a      	mov	r2, r3
    a124:	2100      	movs	r1, #0
    a126:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a12a:	f7ff fcf5 	bl	9b18 <nrf_clock_is_running>
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    a12e:	78fb      	ldrb	r3, [r7, #3]
    a130:	2b01      	cmp	r3, #1
    a132:	d10a      	bne.n	a14a <nrfx_power_clock_irq_handler+0x142>
        {
            // After the LFRC oscillator start switch to external source.
            nrf_clock_lf_src_set(NRF_CLOCK, (nrf_clock_lfclk_t)NRFX_CLOCK_CONFIG_LF_SRC);
    a134:	2102      	movs	r1, #2
    a136:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a13a:	f00c fc61 	bl	16a00 <nrf_clock_lf_src_set>
            nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_LFCLKSTART);
    a13e:	2108      	movs	r1, #8
    a140:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a144:	f00c fc23 	bl	1698e <nrf_clock_task_trigger>
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    a148:	e008      	b.n	a15c <nrfx_power_clock_irq_handler+0x154>
            nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
    a14a:	2102      	movs	r1, #2
    a14c:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    a150:	f00c fc0f 	bl	16972 <nrf_clock_int_disable>
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    a154:	4b06      	ldr	r3, [pc, #24]	; (a170 <nrfx_power_clock_irq_handler+0x168>)
    a156:	681b      	ldr	r3, [r3, #0]
    a158:	2001      	movs	r0, #1
    a15a:	4798      	blx	r3
}
    a15c:	bf00      	nop
    a15e:	3708      	adds	r7, #8
    a160:	46bd      	mov	sp, r7
    a162:	bd80      	pop	{r7, pc}
    a164:	20000cac 	.word	0x20000cac
    a168:	0001cd98 	.word	0x0001cd98
    a16c:	0001aea8 	.word	0x0001aea8
    a170:	20000cb0 	.word	0x20000cb0
    a174:	0001aed0 	.word	0x0001aed0

0000a178 <log_const_source_id>:
{
    a178:	b480      	push	{r7}
    a17a:	b083      	sub	sp, #12
    a17c:	af00      	add	r7, sp, #0
    a17e:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    a180:	687b      	ldr	r3, [r7, #4]
    a182:	4a04      	ldr	r2, [pc, #16]	; (a194 <log_const_source_id+0x1c>)
    a184:	1a9b      	subs	r3, r3, r2
    a186:	08db      	lsrs	r3, r3, #3
}
    a188:	4618      	mov	r0, r3
    a18a:	370c      	adds	r7, #12
    a18c:	46bd      	mov	sp, r7
    a18e:	bc80      	pop	{r7}
    a190:	4770      	bx	lr
    a192:	bf00      	nop
    a194:	00018788 	.word	0x00018788

0000a198 <channel_is_allocated>:
static uint32_t m_allocated_channels;

static uint8_t  m_allocated_groups;

static bool channel_is_allocated(uint8_t channel)
{
    a198:	b480      	push	{r7}
    a19a:	b083      	sub	sp, #12
    a19c:	af00      	add	r7, sp, #0
    a19e:	4603      	mov	r3, r0
    a1a0:	71fb      	strb	r3, [r7, #7]
    return ((m_allocated_channels & DPPI_BIT_SET(channel)) != 0);
    a1a2:	4b08      	ldr	r3, [pc, #32]	; (a1c4 <channel_is_allocated+0x2c>)
    a1a4:	681a      	ldr	r2, [r3, #0]
    a1a6:	79fb      	ldrb	r3, [r7, #7]
    a1a8:	fa22 f303 	lsr.w	r3, r2, r3
    a1ac:	f003 0301 	and.w	r3, r3, #1
    a1b0:	2b00      	cmp	r3, #0
    a1b2:	bf14      	ite	ne
    a1b4:	2301      	movne	r3, #1
    a1b6:	2300      	moveq	r3, #0
    a1b8:	b2db      	uxtb	r3, r3
}
    a1ba:	4618      	mov	r0, r3
    a1bc:	370c      	adds	r7, #12
    a1be:	46bd      	mov	sp, r7
    a1c0:	bc80      	pop	{r7}
    a1c2:	4770      	bx	lr
    a1c4:	20000cbc 	.word	0x20000cbc

0000a1c8 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = 0;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
    a1c8:	b590      	push	{r4, r7, lr}
    a1ca:	b089      	sub	sp, #36	; 0x24
    a1cc:	af00      	add	r7, sp, #0
    a1ce:	6078      	str	r0, [r7, #4]
    nrfx_err_t err_code;

    // Get mask of available DPPI channels
    uint32_t remaining_channels = DPPI_AVAILABLE_CHANNELS_MASK & ~(m_allocated_channels);
    a1d0:	4b4b      	ldr	r3, [pc, #300]	; (a300 <nrfx_dppi_channel_alloc+0x138>)
    a1d2:	681b      	ldr	r3, [r3, #0]
    a1d4:	43db      	mvns	r3, r3
    a1d6:	b29b      	uxth	r3, r3
    a1d8:	617b      	str	r3, [r7, #20]
    uint8_t channel = 0;
    a1da:	2300      	movs	r3, #0
    a1dc:	74fb      	strb	r3, [r7, #19]

    if (!remaining_channels)
    a1de:	697b      	ldr	r3, [r7, #20]
    a1e0:	2b00      	cmp	r3, #0
    a1e2:	d140      	bne.n	a266 <nrfx_dppi_channel_alloc+0x9e>
    {
        err_code = NRFX_ERROR_NO_MEM;
    a1e4:	4b47      	ldr	r3, [pc, #284]	; (a304 <nrfx_dppi_channel_alloc+0x13c>)
    a1e6:	61fb      	str	r3, [r7, #28]
        NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    a1e8:	2300      	movs	r3, #0
    a1ea:	2b02      	cmp	r3, #2
    a1ec:	d936      	bls.n	a25c <nrfx_dppi_channel_alloc+0x94>
    a1ee:	f00c fc59 	bl	16aa4 <_is_user_context>
    a1f2:	4603      	mov	r3, r0
    a1f4:	74bb      	strb	r3, [r7, #18]
    a1f6:	7c3b      	ldrb	r3, [r7, #16]
    a1f8:	2203      	movs	r2, #3
    a1fa:	f362 0302 	bfi	r3, r2, #0, #3
    a1fe:	743b      	strb	r3, [r7, #16]
    a200:	7c3b      	ldrb	r3, [r7, #16]
    a202:	f36f 03c5 	bfc	r3, #3, #3
    a206:	743b      	strb	r3, [r7, #16]
    a208:	2300      	movs	r3, #0
    a20a:	2b00      	cmp	r3, #0
    a20c:	d009      	beq.n	a222 <nrfx_dppi_channel_alloc+0x5a>
    a20e:	4b3e      	ldr	r3, [pc, #248]	; (a308 <nrfx_dppi_channel_alloc+0x140>)
    a210:	681b      	ldr	r3, [r3, #0]
    a212:	4618      	mov	r0, r3
    a214:	f7ff ffb0 	bl	a178 <log_const_source_id>
    a218:	4603      	mov	r3, r0
    a21a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a21e:	b29a      	uxth	r2, r3
    a220:	e000      	b.n	a224 <nrfx_dppi_channel_alloc+0x5c>
    a222:	2200      	movs	r2, #0
    a224:	8a3b      	ldrh	r3, [r7, #16]
    a226:	f362 138f 	bfi	r3, r2, #6, #10
    a22a:	823b      	strh	r3, [r7, #16]
    a22c:	7cbb      	ldrb	r3, [r7, #18]
    a22e:	2b00      	cmp	r3, #0
    a230:	d009      	beq.n	a246 <nrfx_dppi_channel_alloc+0x7e>
    a232:	69f8      	ldr	r0, [r7, #28]
    a234:	f7ff fbd8 	bl	99e8 <nrfx_error_string_get>
    a238:	4603      	mov	r3, r0
    a23a:	4a34      	ldr	r2, [pc, #208]	; (a30c <nrfx_dppi_channel_alloc+0x144>)
    a23c:	4934      	ldr	r1, [pc, #208]	; (a310 <nrfx_dppi_channel_alloc+0x148>)
    a23e:	8a38      	ldrh	r0, [r7, #16]
    a240:	f7f8 fb56 	bl	28f0 <log_from_user>
    a244:	e00a      	b.n	a25c <nrfx_dppi_channel_alloc+0x94>
    a246:	4c31      	ldr	r4, [pc, #196]	; (a30c <nrfx_dppi_channel_alloc+0x144>)
    a248:	69f8      	ldr	r0, [r7, #28]
    a24a:	f7ff fbcd 	bl	99e8 <nrfx_error_string_get>
    a24e:	4603      	mov	r3, r0
    a250:	461a      	mov	r2, r3
    a252:	8a3b      	ldrh	r3, [r7, #16]
    a254:	4621      	mov	r1, r4
    a256:	482e      	ldr	r0, [pc, #184]	; (a310 <nrfx_dppi_channel_alloc+0x148>)
    a258:	f007 fa0f 	bl	1167a <log_2>
        return err_code;
    a25c:	69fb      	ldr	r3, [r7, #28]
    a25e:	e04a      	b.n	a2f6 <nrfx_dppi_channel_alloc+0x12e>
    }

    // Find first free channel
    while (!(remaining_channels & DPPI_BIT_SET(channel)))
    {
        channel++;
    a260:	7cfb      	ldrb	r3, [r7, #19]
    a262:	3301      	adds	r3, #1
    a264:	74fb      	strb	r3, [r7, #19]
    while (!(remaining_channels & DPPI_BIT_SET(channel)))
    a266:	7cfb      	ldrb	r3, [r7, #19]
    a268:	697a      	ldr	r2, [r7, #20]
    a26a:	fa22 f303 	lsr.w	r3, r2, r3
    a26e:	f003 0301 	and.w	r3, r3, #1
    a272:	2b00      	cmp	r3, #0
    a274:	d0f4      	beq.n	a260 <nrfx_dppi_channel_alloc+0x98>
    }

    m_allocated_channels |= DPPI_BIT_SET(channel);
    a276:	7cfb      	ldrb	r3, [r7, #19]
    a278:	2201      	movs	r2, #1
    a27a:	409a      	lsls	r2, r3
    a27c:	4b20      	ldr	r3, [pc, #128]	; (a300 <nrfx_dppi_channel_alloc+0x138>)
    a27e:	681b      	ldr	r3, [r3, #0]
    a280:	4313      	orrs	r3, r2
    a282:	4a1f      	ldr	r2, [pc, #124]	; (a300 <nrfx_dppi_channel_alloc+0x138>)
    a284:	6013      	str	r3, [r2, #0]
    *p_channel = channel;
    a286:	687b      	ldr	r3, [r7, #4]
    a288:	7cfa      	ldrb	r2, [r7, #19]
    a28a:	701a      	strb	r2, [r3, #0]

    err_code = NRFX_SUCCESS;
    a28c:	4b21      	ldr	r3, [pc, #132]	; (a314 <nrfx_dppi_channel_alloc+0x14c>)
    a28e:	61fb      	str	r3, [r7, #28]
    NRFX_LOG_INFO("Allocated channel: %d.", channel);
    a290:	2300      	movs	r3, #0
    a292:	2b02      	cmp	r3, #2
    a294:	d92e      	bls.n	a2f4 <nrfx_dppi_channel_alloc+0x12c>
    a296:	f00c fc05 	bl	16aa4 <_is_user_context>
    a29a:	4603      	mov	r3, r0
    a29c:	76fb      	strb	r3, [r7, #27]
    a29e:	7b3b      	ldrb	r3, [r7, #12]
    a2a0:	2203      	movs	r2, #3
    a2a2:	f362 0302 	bfi	r3, r2, #0, #3
    a2a6:	733b      	strb	r3, [r7, #12]
    a2a8:	7b3b      	ldrb	r3, [r7, #12]
    a2aa:	f36f 03c5 	bfc	r3, #3, #3
    a2ae:	733b      	strb	r3, [r7, #12]
    a2b0:	2300      	movs	r3, #0
    a2b2:	2b00      	cmp	r3, #0
    a2b4:	d009      	beq.n	a2ca <nrfx_dppi_channel_alloc+0x102>
    a2b6:	4b14      	ldr	r3, [pc, #80]	; (a308 <nrfx_dppi_channel_alloc+0x140>)
    a2b8:	681b      	ldr	r3, [r3, #0]
    a2ba:	4618      	mov	r0, r3
    a2bc:	f7ff ff5c 	bl	a178 <log_const_source_id>
    a2c0:	4603      	mov	r3, r0
    a2c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a2c6:	b29a      	uxth	r2, r3
    a2c8:	e000      	b.n	a2cc <nrfx_dppi_channel_alloc+0x104>
    a2ca:	2200      	movs	r2, #0
    a2cc:	89bb      	ldrh	r3, [r7, #12]
    a2ce:	f362 138f 	bfi	r3, r2, #6, #10
    a2d2:	81bb      	strh	r3, [r7, #12]
    a2d4:	7efb      	ldrb	r3, [r7, #27]
    a2d6:	2b00      	cmp	r3, #0
    a2d8:	d006      	beq.n	a2e8 <nrfx_dppi_channel_alloc+0x120>
    a2da:	7cfb      	ldrb	r3, [r7, #19]
    a2dc:	461a      	mov	r2, r3
    a2de:	490e      	ldr	r1, [pc, #56]	; (a318 <nrfx_dppi_channel_alloc+0x150>)
    a2e0:	89b8      	ldrh	r0, [r7, #12]
    a2e2:	f7f8 fb05 	bl	28f0 <log_from_user>
    a2e6:	e005      	b.n	a2f4 <nrfx_dppi_channel_alloc+0x12c>
    a2e8:	7cfb      	ldrb	r3, [r7, #19]
    a2ea:	89ba      	ldrh	r2, [r7, #12]
    a2ec:	4619      	mov	r1, r3
    a2ee:	480a      	ldr	r0, [pc, #40]	; (a318 <nrfx_dppi_channel_alloc+0x150>)
    a2f0:	f007 f9ac 	bl	1164c <log_1>
    return err_code;
    a2f4:	69fb      	ldr	r3, [r7, #28]
}
    a2f6:	4618      	mov	r0, r3
    a2f8:	3724      	adds	r7, #36	; 0x24
    a2fa:	46bd      	mov	sp, r7
    a2fc:	bd90      	pop	{r4, r7, pc}
    a2fe:	bf00      	nop
    a300:	20000cbc 	.word	0x20000cbc
    a304:	0bad0002 	.word	0x0bad0002
    a308:	20000cb8 	.word	0x20000cb8
    a30c:	0001cdb8 	.word	0x0001cdb8
    a310:	0001aef8 	.word	0x0001aef8
    a314:	0bad0000 	.word	0x0bad0000
    a318:	0001af18 	.word	0x0001af18

0000a31c <nrfx_dppi_channel_enable>:
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}

nrfx_err_t nrfx_dppi_channel_enable(uint8_t channel)
{
    a31c:	b590      	push	{r4, r7, lr}
    a31e:	b085      	sub	sp, #20
    a320:	af00      	add	r7, sp, #0
    a322:	4603      	mov	r3, r0
    a324:	71fb      	strb	r3, [r7, #7]
    nrfx_err_t err_code = NRFX_SUCCESS;
    a326:	4b2b      	ldr	r3, [pc, #172]	; (a3d4 <nrfx_dppi_channel_enable+0xb8>)
    a328:	60fb      	str	r3, [r7, #12]

    if (!channel_is_allocated(channel))
    a32a:	79fb      	ldrb	r3, [r7, #7]
    a32c:	4618      	mov	r0, r3
    a32e:	f7ff ff33 	bl	a198 <channel_is_allocated>
    a332:	4603      	mov	r3, r0
    a334:	f083 0301 	eor.w	r3, r3, #1
    a338:	b2db      	uxtb	r3, r3
    a33a:	2b00      	cmp	r3, #0
    a33c:	d002      	beq.n	a344 <nrfx_dppi_channel_enable+0x28>
    {
        err_code = NRFX_ERROR_INVALID_PARAM;
    a33e:	4b26      	ldr	r3, [pc, #152]	; (a3d8 <nrfx_dppi_channel_enable+0xbc>)
    a340:	60fb      	str	r3, [r7, #12]
    a342:	e007      	b.n	a354 <nrfx_dppi_channel_enable+0x38>
    }
    else
    {
        nrf_dppi_channels_enable(NRF_DPPIC, DPPI_BIT_SET(channel));
    a344:	79fb      	ldrb	r3, [r7, #7]
    a346:	2201      	movs	r2, #1
    a348:	fa02 f303 	lsl.w	r3, r2, r3
    a34c:	4619      	mov	r1, r3
    a34e:	4823      	ldr	r0, [pc, #140]	; (a3dc <nrfx_dppi_channel_enable+0xc0>)
    a350:	f00c fb9a 	bl	16a88 <nrf_dppi_channels_enable>
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    a354:	2300      	movs	r3, #0
    a356:	2b02      	cmp	r3, #2
    a358:	d936      	bls.n	a3c8 <nrfx_dppi_channel_enable+0xac>
    a35a:	f00c fba3 	bl	16aa4 <_is_user_context>
    a35e:	4603      	mov	r3, r0
    a360:	72fb      	strb	r3, [r7, #11]
    a362:	7a3b      	ldrb	r3, [r7, #8]
    a364:	2203      	movs	r2, #3
    a366:	f362 0302 	bfi	r3, r2, #0, #3
    a36a:	723b      	strb	r3, [r7, #8]
    a36c:	7a3b      	ldrb	r3, [r7, #8]
    a36e:	f36f 03c5 	bfc	r3, #3, #3
    a372:	723b      	strb	r3, [r7, #8]
    a374:	2300      	movs	r3, #0
    a376:	2b00      	cmp	r3, #0
    a378:	d009      	beq.n	a38e <nrfx_dppi_channel_enable+0x72>
    a37a:	4b19      	ldr	r3, [pc, #100]	; (a3e0 <nrfx_dppi_channel_enable+0xc4>)
    a37c:	681b      	ldr	r3, [r3, #0]
    a37e:	4618      	mov	r0, r3
    a380:	f7ff fefa 	bl	a178 <log_const_source_id>
    a384:	4603      	mov	r3, r0
    a386:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a38a:	b29a      	uxth	r2, r3
    a38c:	e000      	b.n	a390 <nrfx_dppi_channel_enable+0x74>
    a38e:	2200      	movs	r2, #0
    a390:	893b      	ldrh	r3, [r7, #8]
    a392:	f362 138f 	bfi	r3, r2, #6, #10
    a396:	813b      	strh	r3, [r7, #8]
    a398:	7afb      	ldrb	r3, [r7, #11]
    a39a:	2b00      	cmp	r3, #0
    a39c:	d009      	beq.n	a3b2 <nrfx_dppi_channel_enable+0x96>
    a39e:	68f8      	ldr	r0, [r7, #12]
    a3a0:	f7ff fb22 	bl	99e8 <nrfx_error_string_get>
    a3a4:	4603      	mov	r3, r0
    a3a6:	4a0f      	ldr	r2, [pc, #60]	; (a3e4 <nrfx_dppi_channel_enable+0xc8>)
    a3a8:	490f      	ldr	r1, [pc, #60]	; (a3e8 <nrfx_dppi_channel_enable+0xcc>)
    a3aa:	8938      	ldrh	r0, [r7, #8]
    a3ac:	f7f8 faa0 	bl	28f0 <log_from_user>
    a3b0:	e00a      	b.n	a3c8 <nrfx_dppi_channel_enable+0xac>
    a3b2:	4c0c      	ldr	r4, [pc, #48]	; (a3e4 <nrfx_dppi_channel_enable+0xc8>)
    a3b4:	68f8      	ldr	r0, [r7, #12]
    a3b6:	f7ff fb17 	bl	99e8 <nrfx_error_string_get>
    a3ba:	4603      	mov	r3, r0
    a3bc:	461a      	mov	r2, r3
    a3be:	893b      	ldrh	r3, [r7, #8]
    a3c0:	4621      	mov	r1, r4
    a3c2:	4809      	ldr	r0, [pc, #36]	; (a3e8 <nrfx_dppi_channel_enable+0xcc>)
    a3c4:	f007 f959 	bl	1167a <log_2>
    return err_code;
    a3c8:	68fb      	ldr	r3, [r7, #12]
}
    a3ca:	4618      	mov	r0, r3
    a3cc:	3714      	adds	r7, #20
    a3ce:	46bd      	mov	sp, r7
    a3d0:	bd90      	pop	{r4, r7, pc}
    a3d2:	bf00      	nop
    a3d4:	0bad0000 	.word	0x0bad0000
    a3d8:	0bad0004 	.word	0x0bad0004
    a3dc:	50017000 	.word	0x50017000
    a3e0:	20000cb8 	.word	0x20000cb8
    a3e4:	0001cdd0 	.word	0x0001cdd0
    a3e8:	0001aef8 	.word	0x0001aef8

0000a3ec <log_const_source_id>:
{
    a3ec:	b480      	push	{r7}
    a3ee:	b083      	sub	sp, #12
    a3f0:	af00      	add	r7, sp, #0
    a3f2:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    a3f4:	687b      	ldr	r3, [r7, #4]
    a3f6:	4a04      	ldr	r2, [pc, #16]	; (a408 <log_const_source_id+0x1c>)
    a3f8:	1a9b      	subs	r3, r3, r2
    a3fa:	08db      	lsrs	r3, r3, #3
}
    a3fc:	4618      	mov	r0, r3
    a3fe:	370c      	adds	r7, #12
    a400:	46bd      	mov	sp, r7
    a402:	bc80      	pop	{r7}
    a404:	4770      	bx	lr
    a406:	bf00      	nop
    a408:	00018788 	.word	0x00018788

0000a40c <nrfx_timer_init>:
static timer_control_block_t m_cb[NRFX_TIMER_ENABLED_COUNT];

nrfx_err_t nrfx_timer_init(nrfx_timer_t const *        p_instance,
                           nrfx_timer_config_t const * p_config,
                           nrfx_timer_event_handler_t  timer_event_handler)
{
    a40c:	b590      	push	{r4, r7, lr}
    a40e:	b08b      	sub	sp, #44	; 0x2c
    a410:	af00      	add	r7, sp, #0
    a412:	60f8      	str	r0, [r7, #12]
    a414:	60b9      	str	r1, [r7, #8]
    a416:	607a      	str	r2, [r7, #4]
    timer_control_block_t * p_cb = &m_cb[p_instance->instance_id];
    a418:	68fb      	ldr	r3, [r7, #12]
    a41a:	791b      	ldrb	r3, [r3, #4]
    a41c:	461a      	mov	r2, r3
    a41e:	4613      	mov	r3, r2
    a420:	005b      	lsls	r3, r3, #1
    a422:	4413      	add	r3, r2
    a424:	009b      	lsls	r3, r3, #2
    a426:	4a97      	ldr	r2, [pc, #604]	; (a684 <nrfx_timer_init+0x278>)
    a428:	4413      	add	r3, r2
    a42a:	627b      	str	r3, [r7, #36]	; 0x24
#ifdef SOFTDEVICE_PRESENT
    NRFX_ASSERT(p_instance->p_reg != NRF_TIMER0);
#endif
    NRFX_ASSERT(p_config);
    a42c:	68bb      	ldr	r3, [r7, #8]
    a42e:	2b00      	cmp	r3, #0
    a430:	d109      	bne.n	a446 <nrfx_timer_init+0x3a>
    a432:	2351      	movs	r3, #81	; 0x51
    a434:	4a94      	ldr	r2, [pc, #592]	; (a688 <nrfx_timer_init+0x27c>)
    a436:	4995      	ldr	r1, [pc, #596]	; (a68c <nrfx_timer_init+0x280>)
    a438:	4895      	ldr	r0, [pc, #596]	; (a690 <nrfx_timer_init+0x284>)
    a43a:	f005 fe15 	bl	10068 <printk>
    a43e:	2151      	movs	r1, #81	; 0x51
    a440:	4891      	ldr	r0, [pc, #580]	; (a688 <nrfx_timer_init+0x27c>)
    a442:	f006 fc59 	bl	10cf8 <assert_post_action>
    NRFX_ASSERT(timer_event_handler);
    a446:	687b      	ldr	r3, [r7, #4]
    a448:	2b00      	cmp	r3, #0
    a44a:	d109      	bne.n	a460 <nrfx_timer_init+0x54>
    a44c:	2352      	movs	r3, #82	; 0x52
    a44e:	4a8e      	ldr	r2, [pc, #568]	; (a688 <nrfx_timer_init+0x27c>)
    a450:	4990      	ldr	r1, [pc, #576]	; (a694 <nrfx_timer_init+0x288>)
    a452:	488f      	ldr	r0, [pc, #572]	; (a690 <nrfx_timer_init+0x284>)
    a454:	f005 fe08 	bl	10068 <printk>
    a458:	2152      	movs	r1, #82	; 0x52
    a45a:	488b      	ldr	r0, [pc, #556]	; (a688 <nrfx_timer_init+0x27c>)
    a45c:	f006 fc4c 	bl	10cf8 <assert_post_action>

    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    a460:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a462:	7a1b      	ldrb	r3, [r3, #8]
    a464:	2b00      	cmp	r3, #0
    a466:	d03d      	beq.n	a4e4 <nrfx_timer_init+0xd8>
    {
        err_code = NRFX_ERROR_INVALID_STATE;
    a468:	4b8b      	ldr	r3, [pc, #556]	; (a698 <nrfx_timer_init+0x28c>)
    a46a:	61fb      	str	r3, [r7, #28]
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
    a46c:	2300      	movs	r3, #0
    a46e:	2b01      	cmp	r3, #1
    a470:	d936      	bls.n	a4e0 <nrfx_timer_init+0xd4>
    a472:	f00c fbec 	bl	16c4e <_is_user_context>
    a476:	4603      	mov	r3, r0
    a478:	76bb      	strb	r3, [r7, #26]
    a47a:	7e3b      	ldrb	r3, [r7, #24]
    a47c:	2202      	movs	r2, #2
    a47e:	f362 0302 	bfi	r3, r2, #0, #3
    a482:	763b      	strb	r3, [r7, #24]
    a484:	7e3b      	ldrb	r3, [r7, #24]
    a486:	f36f 03c5 	bfc	r3, #3, #3
    a48a:	763b      	strb	r3, [r7, #24]
    a48c:	2300      	movs	r3, #0
    a48e:	2b00      	cmp	r3, #0
    a490:	d009      	beq.n	a4a6 <nrfx_timer_init+0x9a>
    a492:	4b82      	ldr	r3, [pc, #520]	; (a69c <nrfx_timer_init+0x290>)
    a494:	681b      	ldr	r3, [r3, #0]
    a496:	4618      	mov	r0, r3
    a498:	f7ff ffa8 	bl	a3ec <log_const_source_id>
    a49c:	4603      	mov	r3, r0
    a49e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a4a2:	b29a      	uxth	r2, r3
    a4a4:	e000      	b.n	a4a8 <nrfx_timer_init+0x9c>
    a4a6:	2200      	movs	r2, #0
    a4a8:	8b3b      	ldrh	r3, [r7, #24]
    a4aa:	f362 138f 	bfi	r3, r2, #6, #10
    a4ae:	833b      	strh	r3, [r7, #24]
    a4b0:	7ebb      	ldrb	r3, [r7, #26]
    a4b2:	2b00      	cmp	r3, #0
    a4b4:	d009      	beq.n	a4ca <nrfx_timer_init+0xbe>
    a4b6:	69f8      	ldr	r0, [r7, #28]
    a4b8:	f7ff fa96 	bl	99e8 <nrfx_error_string_get>
    a4bc:	4603      	mov	r3, r0
    a4be:	4a78      	ldr	r2, [pc, #480]	; (a6a0 <nrfx_timer_init+0x294>)
    a4c0:	4978      	ldr	r1, [pc, #480]	; (a6a4 <nrfx_timer_init+0x298>)
    a4c2:	8b38      	ldrh	r0, [r7, #24]
    a4c4:	f7f8 fa14 	bl	28f0 <log_from_user>
    a4c8:	e00a      	b.n	a4e0 <nrfx_timer_init+0xd4>
    a4ca:	4c75      	ldr	r4, [pc, #468]	; (a6a0 <nrfx_timer_init+0x294>)
    a4cc:	69f8      	ldr	r0, [r7, #28]
    a4ce:	f7ff fa8b 	bl	99e8 <nrfx_error_string_get>
    a4d2:	4603      	mov	r3, r0
    a4d4:	461a      	mov	r2, r3
    a4d6:	8b3b      	ldrh	r3, [r7, #24]
    a4d8:	4621      	mov	r1, r4
    a4da:	4872      	ldr	r0, [pc, #456]	; (a6a4 <nrfx_timer_init+0x298>)
    a4dc:	f007 f8cd 	bl	1167a <log_2>
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    a4e0:	69fb      	ldr	r3, [r7, #28]
    a4e2:	e0cb      	b.n	a67c <nrfx_timer_init+0x270>
    }

    NRFX_ASSERT(NRF_TIMER_IS_BIT_WIDTH_VALID(p_instance->p_reg, p_config->bit_width));
    a4e4:	68fb      	ldr	r3, [r7, #12]
    a4e6:	681b      	ldr	r3, [r3, #0]
    a4e8:	4a6f      	ldr	r2, [pc, #444]	; (a6a8 <nrfx_timer_init+0x29c>)
    a4ea:	4293      	cmp	r3, r2
    a4ec:	d10f      	bne.n	a50e <nrfx_timer_init+0x102>
    a4ee:	68bb      	ldr	r3, [r7, #8]
    a4f0:	789b      	ldrb	r3, [r3, #2]
    a4f2:	2b01      	cmp	r3, #1
    a4f4:	d03f      	beq.n	a576 <nrfx_timer_init+0x16a>
    a4f6:	68bb      	ldr	r3, [r7, #8]
    a4f8:	789b      	ldrb	r3, [r3, #2]
    a4fa:	2b00      	cmp	r3, #0
    a4fc:	d03b      	beq.n	a576 <nrfx_timer_init+0x16a>
    a4fe:	68bb      	ldr	r3, [r7, #8]
    a500:	789b      	ldrb	r3, [r3, #2]
    a502:	2b02      	cmp	r3, #2
    a504:	d037      	beq.n	a576 <nrfx_timer_init+0x16a>
    a506:	68bb      	ldr	r3, [r7, #8]
    a508:	789b      	ldrb	r3, [r3, #2]
    a50a:	2b03      	cmp	r3, #3
    a50c:	d033      	beq.n	a576 <nrfx_timer_init+0x16a>
    a50e:	68fb      	ldr	r3, [r7, #12]
    a510:	681b      	ldr	r3, [r3, #0]
    a512:	4a66      	ldr	r2, [pc, #408]	; (a6ac <nrfx_timer_init+0x2a0>)
    a514:	4293      	cmp	r3, r2
    a516:	d10f      	bne.n	a538 <nrfx_timer_init+0x12c>
    a518:	68bb      	ldr	r3, [r7, #8]
    a51a:	789b      	ldrb	r3, [r3, #2]
    a51c:	2b01      	cmp	r3, #1
    a51e:	d02a      	beq.n	a576 <nrfx_timer_init+0x16a>
    a520:	68bb      	ldr	r3, [r7, #8]
    a522:	789b      	ldrb	r3, [r3, #2]
    a524:	2b00      	cmp	r3, #0
    a526:	d026      	beq.n	a576 <nrfx_timer_init+0x16a>
    a528:	68bb      	ldr	r3, [r7, #8]
    a52a:	789b      	ldrb	r3, [r3, #2]
    a52c:	2b02      	cmp	r3, #2
    a52e:	d022      	beq.n	a576 <nrfx_timer_init+0x16a>
    a530:	68bb      	ldr	r3, [r7, #8]
    a532:	789b      	ldrb	r3, [r3, #2]
    a534:	2b03      	cmp	r3, #3
    a536:	d01e      	beq.n	a576 <nrfx_timer_init+0x16a>
    a538:	68fb      	ldr	r3, [r7, #12]
    a53a:	681b      	ldr	r3, [r3, #0]
    a53c:	4a5c      	ldr	r2, [pc, #368]	; (a6b0 <nrfx_timer_init+0x2a4>)
    a53e:	4293      	cmp	r3, r2
    a540:	d10f      	bne.n	a562 <nrfx_timer_init+0x156>
    a542:	68bb      	ldr	r3, [r7, #8]
    a544:	789b      	ldrb	r3, [r3, #2]
    a546:	2b01      	cmp	r3, #1
    a548:	d015      	beq.n	a576 <nrfx_timer_init+0x16a>
    a54a:	68bb      	ldr	r3, [r7, #8]
    a54c:	789b      	ldrb	r3, [r3, #2]
    a54e:	2b00      	cmp	r3, #0
    a550:	d011      	beq.n	a576 <nrfx_timer_init+0x16a>
    a552:	68bb      	ldr	r3, [r7, #8]
    a554:	789b      	ldrb	r3, [r3, #2]
    a556:	2b02      	cmp	r3, #2
    a558:	d00d      	beq.n	a576 <nrfx_timer_init+0x16a>
    a55a:	68bb      	ldr	r3, [r7, #8]
    a55c:	789b      	ldrb	r3, [r3, #2]
    a55e:	2b03      	cmp	r3, #3
    a560:	d009      	beq.n	a576 <nrfx_timer_init+0x16a>
    a562:	235f      	movs	r3, #95	; 0x5f
    a564:	4a48      	ldr	r2, [pc, #288]	; (a688 <nrfx_timer_init+0x27c>)
    a566:	4953      	ldr	r1, [pc, #332]	; (a6b4 <nrfx_timer_init+0x2a8>)
    a568:	4849      	ldr	r0, [pc, #292]	; (a690 <nrfx_timer_init+0x284>)
    a56a:	f005 fd7d 	bl	10068 <printk>
    a56e:	215f      	movs	r1, #95	; 0x5f
    a570:	4845      	ldr	r0, [pc, #276]	; (a688 <nrfx_timer_init+0x27c>)
    a572:	f006 fbc1 	bl	10cf8 <assert_post_action>

    p_cb->handler = timer_event_handler;
    a576:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a578:	687a      	ldr	r2, [r7, #4]
    a57a:	601a      	str	r2, [r3, #0]
    p_cb->context = p_config->p_context;
    a57c:	68bb      	ldr	r3, [r7, #8]
    a57e:	685a      	ldr	r2, [r3, #4]
    a580:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a582:	605a      	str	r2, [r3, #4]

    uint8_t i;
    for (i = 0; i < p_instance->cc_channel_count; ++i)
    a584:	2300      	movs	r3, #0
    a586:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    a58a:	e010      	b.n	a5ae <nrfx_timer_init+0x1a2>
    {
        nrf_timer_event_clear(p_instance->p_reg,
    a58c:	68fb      	ldr	r3, [r7, #12]
    a58e:	681c      	ldr	r4, [r3, #0]
    a590:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    a594:	4618      	mov	r0, r3
    a596:	f00c fb4c 	bl	16c32 <nrf_timer_compare_event_get>
    a59a:	4603      	mov	r3, r0
    a59c:	4619      	mov	r1, r3
    a59e:	4620      	mov	r0, r4
    a5a0:	f00c faae 	bl	16b00 <nrf_timer_event_clear>
    for (i = 0; i < p_instance->cc_channel_count; ++i)
    a5a4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    a5a8:	3301      	adds	r3, #1
    a5aa:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    a5ae:	68fb      	ldr	r3, [r7, #12]
    a5b0:	795b      	ldrb	r3, [r3, #5]
    a5b2:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    a5b6:	429a      	cmp	r2, r3
    a5b8:	d3e8      	bcc.n	a58c <nrfx_timer_init+0x180>
                              nrf_timer_compare_event_get(i));
    }

    NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
        p_config->interrupt_priority);
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    a5ba:	68fb      	ldr	r3, [r7, #12]
    a5bc:	681b      	ldr	r3, [r3, #0]
    a5be:	4618      	mov	r0, r3
    a5c0:	f00c fa77 	bl	16ab2 <nrfx_get_irq_number>
    a5c4:	4603      	mov	r3, r0
    a5c6:	4618      	mov	r0, r3
    a5c8:	f008 fbd9 	bl	12d7e <arch_irq_enable>

    nrf_timer_mode_set(p_instance->p_reg, p_config->mode);
    a5cc:	68fb      	ldr	r3, [r7, #12]
    a5ce:	681a      	ldr	r2, [r3, #0]
    a5d0:	68bb      	ldr	r3, [r7, #8]
    a5d2:	785b      	ldrb	r3, [r3, #1]
    a5d4:	4619      	mov	r1, r3
    a5d6:	4610      	mov	r0, r2
    a5d8:	f00c fac8 	bl	16b6c <nrf_timer_mode_set>
    nrf_timer_bit_width_set(p_instance->p_reg, p_config->bit_width);
    a5dc:	68fb      	ldr	r3, [r7, #12]
    a5de:	681a      	ldr	r2, [r3, #0]
    a5e0:	68bb      	ldr	r3, [r7, #8]
    a5e2:	789b      	ldrb	r3, [r3, #2]
    a5e4:	4619      	mov	r1, r3
    a5e6:	4610      	mov	r0, r2
    a5e8:	f00c fad7 	bl	16b9a <nrf_timer_bit_width_set>
    nrf_timer_frequency_set(p_instance->p_reg, p_config->frequency);
    a5ec:	68fb      	ldr	r3, [r7, #12]
    a5ee:	681a      	ldr	r2, [r3, #0]
    a5f0:	68bb      	ldr	r3, [r7, #8]
    a5f2:	781b      	ldrb	r3, [r3, #0]
    a5f4:	4619      	mov	r1, r3
    a5f6:	4610      	mov	r0, r2
    a5f8:	f00c fae6 	bl	16bc8 <nrf_timer_frequency_set>

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    a5fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    a5fe:	2201      	movs	r2, #1
    a600:	721a      	strb	r2, [r3, #8]

    err_code = NRFX_SUCCESS;
    a602:	4b2d      	ldr	r3, [pc, #180]	; (a6b8 <nrfx_timer_init+0x2ac>)
    a604:	61fb      	str	r3, [r7, #28]
    NRFX_LOG_INFO("Function: %s, error code: %s.",
    a606:	2300      	movs	r3, #0
    a608:	2b02      	cmp	r3, #2
    a60a:	d936      	bls.n	a67a <nrfx_timer_init+0x26e>
    a60c:	f00c fb1f 	bl	16c4e <_is_user_context>
    a610:	4603      	mov	r3, r0
    a612:	76fb      	strb	r3, [r7, #27]
    a614:	7d3b      	ldrb	r3, [r7, #20]
    a616:	2203      	movs	r2, #3
    a618:	f362 0302 	bfi	r3, r2, #0, #3
    a61c:	753b      	strb	r3, [r7, #20]
    a61e:	7d3b      	ldrb	r3, [r7, #20]
    a620:	f36f 03c5 	bfc	r3, #3, #3
    a624:	753b      	strb	r3, [r7, #20]
    a626:	2300      	movs	r3, #0
    a628:	2b00      	cmp	r3, #0
    a62a:	d009      	beq.n	a640 <nrfx_timer_init+0x234>
    a62c:	4b1b      	ldr	r3, [pc, #108]	; (a69c <nrfx_timer_init+0x290>)
    a62e:	681b      	ldr	r3, [r3, #0]
    a630:	4618      	mov	r0, r3
    a632:	f7ff fedb 	bl	a3ec <log_const_source_id>
    a636:	4603      	mov	r3, r0
    a638:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a63c:	b29a      	uxth	r2, r3
    a63e:	e000      	b.n	a642 <nrfx_timer_init+0x236>
    a640:	2200      	movs	r2, #0
    a642:	8abb      	ldrh	r3, [r7, #20]
    a644:	f362 138f 	bfi	r3, r2, #6, #10
    a648:	82bb      	strh	r3, [r7, #20]
    a64a:	7efb      	ldrb	r3, [r7, #27]
    a64c:	2b00      	cmp	r3, #0
    a64e:	d009      	beq.n	a664 <nrfx_timer_init+0x258>
    a650:	69f8      	ldr	r0, [r7, #28]
    a652:	f7ff f9c9 	bl	99e8 <nrfx_error_string_get>
    a656:	4603      	mov	r3, r0
    a658:	4a11      	ldr	r2, [pc, #68]	; (a6a0 <nrfx_timer_init+0x294>)
    a65a:	4912      	ldr	r1, [pc, #72]	; (a6a4 <nrfx_timer_init+0x298>)
    a65c:	8ab8      	ldrh	r0, [r7, #20]
    a65e:	f7f8 f947 	bl	28f0 <log_from_user>
    a662:	e00a      	b.n	a67a <nrfx_timer_init+0x26e>
    a664:	4c0e      	ldr	r4, [pc, #56]	; (a6a0 <nrfx_timer_init+0x294>)
    a666:	69f8      	ldr	r0, [r7, #28]
    a668:	f7ff f9be 	bl	99e8 <nrfx_error_string_get>
    a66c:	4603      	mov	r3, r0
    a66e:	461a      	mov	r2, r3
    a670:	8abb      	ldrh	r3, [r7, #20]
    a672:	4621      	mov	r1, r4
    a674:	480b      	ldr	r0, [pc, #44]	; (a6a4 <nrfx_timer_init+0x298>)
    a676:	f007 f800 	bl	1167a <log_2>
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    a67a:	69fb      	ldr	r3, [r7, #28]
}
    a67c:	4618      	mov	r0, r3
    a67e:	372c      	adds	r7, #44	; 0x2c
    a680:	46bd      	mov	sp, r7
    a682:	bd90      	pop	{r4, r7, pc}
    a684:	20000cc4 	.word	0x20000cc4
    a688:	0001af30 	.word	0x0001af30
    a68c:	0001af70 	.word	0x0001af70
    a690:	0001af7c 	.word	0x0001af7c
    a694:	0001af9c 	.word	0x0001af9c
    a698:	0bad0005 	.word	0x0bad0005
    a69c:	20000cc0 	.word	0x20000cc0
    a6a0:	0001cdec 	.word	0x0001cdec
    a6a4:	0001afb0 	.word	0x0001afb0
    a6a8:	5000f000 	.word	0x5000f000
    a6ac:	50010000 	.word	0x50010000
    a6b0:	50011000 	.word	0x50011000
    a6b4:	0001afd0 	.word	0x0001afd0
    a6b8:	0bad0000 	.word	0x0bad0000

0000a6bc <nrfx_timer_uninit>:

void nrfx_timer_uninit(nrfx_timer_t const * p_instance)
{
    a6bc:	b580      	push	{r7, lr}
    a6be:	b084      	sub	sp, #16
    a6c0:	af00      	add	r7, sp, #0
    a6c2:	6078      	str	r0, [r7, #4]
    NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
    a6c4:	687b      	ldr	r3, [r7, #4]
    a6c6:	681b      	ldr	r3, [r3, #0]
    a6c8:	4618      	mov	r0, r3
    a6ca:	f00c f9f2 	bl	16ab2 <nrfx_get_irq_number>
    a6ce:	4603      	mov	r3, r0
    a6d0:	4618      	mov	r0, r3
    a6d2:	f008 fb61 	bl	12d98 <arch_irq_disable>

    #define DISABLE_ALL UINT32_MAX
    nrf_timer_shorts_disable(p_instance->p_reg, DISABLE_ALL);
    a6d6:	687b      	ldr	r3, [r7, #4]
    a6d8:	681b      	ldr	r3, [r3, #0]
    a6da:	f04f 31ff 	mov.w	r1, #4294967295
    a6de:	4618      	mov	r0, r3
    a6e0:	f00c fa23 	bl	16b2a <nrf_timer_shorts_disable>
    nrf_timer_int_disable(p_instance->p_reg, DISABLE_ALL);
    a6e4:	687b      	ldr	r3, [r7, #4]
    a6e6:	681b      	ldr	r3, [r3, #0]
    a6e8:	f04f 31ff 	mov.w	r1, #4294967295
    a6ec:	4618      	mov	r0, r3
    a6ee:	f00c fa2f 	bl	16b50 <nrf_timer_int_disable>
    #undef DISABLE_ALL

    nrfx_timer_disable(p_instance);
    a6f2:	6878      	ldr	r0, [r7, #4]
    a6f4:	f000 f8bc 	bl	a870 <nrfx_timer_disable>

    m_cb[p_instance->instance_id].state = NRFX_DRV_STATE_UNINITIALIZED;
    a6f8:	687b      	ldr	r3, [r7, #4]
    a6fa:	791b      	ldrb	r3, [r3, #4]
    a6fc:	4619      	mov	r1, r3
    a6fe:	4a20      	ldr	r2, [pc, #128]	; (a780 <nrfx_timer_uninit+0xc4>)
    a700:	460b      	mov	r3, r1
    a702:	005b      	lsls	r3, r3, #1
    a704:	440b      	add	r3, r1
    a706:	009b      	lsls	r3, r3, #2
    a708:	4413      	add	r3, r2
    a70a:	3308      	adds	r3, #8
    a70c:	2200      	movs	r2, #0
    a70e:	701a      	strb	r2, [r3, #0]
    NRFX_LOG_INFO("Uninitialized instance: %d.", p_instance->instance_id);
    a710:	2300      	movs	r3, #0
    a712:	2b02      	cmp	r3, #2
    a714:	d930      	bls.n	a778 <nrfx_timer_uninit+0xbc>
    a716:	f00c fa9a 	bl	16c4e <_is_user_context>
    a71a:	4603      	mov	r3, r0
    a71c:	73fb      	strb	r3, [r7, #15]
    a71e:	7b3b      	ldrb	r3, [r7, #12]
    a720:	2203      	movs	r2, #3
    a722:	f362 0302 	bfi	r3, r2, #0, #3
    a726:	733b      	strb	r3, [r7, #12]
    a728:	7b3b      	ldrb	r3, [r7, #12]
    a72a:	f36f 03c5 	bfc	r3, #3, #3
    a72e:	733b      	strb	r3, [r7, #12]
    a730:	2300      	movs	r3, #0
    a732:	2b00      	cmp	r3, #0
    a734:	d009      	beq.n	a74a <nrfx_timer_uninit+0x8e>
    a736:	4b13      	ldr	r3, [pc, #76]	; (a784 <nrfx_timer_uninit+0xc8>)
    a738:	681b      	ldr	r3, [r3, #0]
    a73a:	4618      	mov	r0, r3
    a73c:	f7ff fe56 	bl	a3ec <log_const_source_id>
    a740:	4603      	mov	r3, r0
    a742:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a746:	b29a      	uxth	r2, r3
    a748:	e000      	b.n	a74c <nrfx_timer_uninit+0x90>
    a74a:	2200      	movs	r2, #0
    a74c:	89bb      	ldrh	r3, [r7, #12]
    a74e:	f362 138f 	bfi	r3, r2, #6, #10
    a752:	81bb      	strh	r3, [r7, #12]
    a754:	7bfb      	ldrb	r3, [r7, #15]
    a756:	2b00      	cmp	r3, #0
    a758:	d007      	beq.n	a76a <nrfx_timer_uninit+0xae>
    a75a:	687b      	ldr	r3, [r7, #4]
    a75c:	791b      	ldrb	r3, [r3, #4]
    a75e:	461a      	mov	r2, r3
    a760:	4909      	ldr	r1, [pc, #36]	; (a788 <nrfx_timer_uninit+0xcc>)
    a762:	89b8      	ldrh	r0, [r7, #12]
    a764:	f7f8 f8c4 	bl	28f0 <log_from_user>
}
    a768:	e006      	b.n	a778 <nrfx_timer_uninit+0xbc>
    NRFX_LOG_INFO("Uninitialized instance: %d.", p_instance->instance_id);
    a76a:	687b      	ldr	r3, [r7, #4]
    a76c:	791b      	ldrb	r3, [r3, #4]
    a76e:	89ba      	ldrh	r2, [r7, #12]
    a770:	4619      	mov	r1, r3
    a772:	4805      	ldr	r0, [pc, #20]	; (a788 <nrfx_timer_uninit+0xcc>)
    a774:	f006 ff6a 	bl	1164c <log_1>
}
    a778:	bf00      	nop
    a77a:	3710      	adds	r7, #16
    a77c:	46bd      	mov	sp, r7
    a77e:	bd80      	pop	{r7, pc}
    a780:	20000cc4 	.word	0x20000cc4
    a784:	20000cc0 	.word	0x20000cc0
    a788:	0001b714 	.word	0x0001b714

0000a78c <nrfx_timer_enable>:

void nrfx_timer_enable(nrfx_timer_t const * p_instance)
{
    a78c:	b580      	push	{r7, lr}
    a78e:	b084      	sub	sp, #16
    a790:	af00      	add	r7, sp, #0
    a792:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(m_cb[p_instance->instance_id].state == NRFX_DRV_STATE_INITIALIZED);
    a794:	687b      	ldr	r3, [r7, #4]
    a796:	791b      	ldrb	r3, [r3, #4]
    a798:	4619      	mov	r1, r3
    a79a:	4a2f      	ldr	r2, [pc, #188]	; (a858 <nrfx_timer_enable+0xcc>)
    a79c:	460b      	mov	r3, r1
    a79e:	005b      	lsls	r3, r3, #1
    a7a0:	440b      	add	r3, r1
    a7a2:	009b      	lsls	r3, r3, #2
    a7a4:	4413      	add	r3, r2
    a7a6:	3308      	adds	r3, #8
    a7a8:	781b      	ldrb	r3, [r3, #0]
    a7aa:	2b01      	cmp	r3, #1
    a7ac:	d009      	beq.n	a7c2 <nrfx_timer_enable+0x36>
    a7ae:	238d      	movs	r3, #141	; 0x8d
    a7b0:	4a2a      	ldr	r2, [pc, #168]	; (a85c <nrfx_timer_enable+0xd0>)
    a7b2:	492b      	ldr	r1, [pc, #172]	; (a860 <nrfx_timer_enable+0xd4>)
    a7b4:	482b      	ldr	r0, [pc, #172]	; (a864 <nrfx_timer_enable+0xd8>)
    a7b6:	f005 fc57 	bl	10068 <printk>
    a7ba:	218d      	movs	r1, #141	; 0x8d
    a7bc:	4827      	ldr	r0, [pc, #156]	; (a85c <nrfx_timer_enable+0xd0>)
    a7be:	f006 fa9b 	bl	10cf8 <assert_post_action>
    nrf_timer_task_trigger(p_instance->p_reg, NRF_TIMER_TASK_START);
    a7c2:	687b      	ldr	r3, [r7, #4]
    a7c4:	681b      	ldr	r3, [r3, #0]
    a7c6:	2100      	movs	r1, #0
    a7c8:	4618      	mov	r0, r3
    a7ca:	f00c f989 	bl	16ae0 <nrf_timer_task_trigger>
    m_cb[p_instance->instance_id].state = NRFX_DRV_STATE_POWERED_ON;
    a7ce:	687b      	ldr	r3, [r7, #4]
    a7d0:	791b      	ldrb	r3, [r3, #4]
    a7d2:	4619      	mov	r1, r3
    a7d4:	4a20      	ldr	r2, [pc, #128]	; (a858 <nrfx_timer_enable+0xcc>)
    a7d6:	460b      	mov	r3, r1
    a7d8:	005b      	lsls	r3, r3, #1
    a7da:	440b      	add	r3, r1
    a7dc:	009b      	lsls	r3, r3, #2
    a7de:	4413      	add	r3, r2
    a7e0:	3308      	adds	r3, #8
    a7e2:	2202      	movs	r2, #2
    a7e4:	701a      	strb	r2, [r3, #0]
    NRFX_LOG_INFO("Enabled instance: %d.", p_instance->instance_id);
    a7e6:	2300      	movs	r3, #0
    a7e8:	2b02      	cmp	r3, #2
    a7ea:	d930      	bls.n	a84e <nrfx_timer_enable+0xc2>
    a7ec:	f00c fa2f 	bl	16c4e <_is_user_context>
    a7f0:	4603      	mov	r3, r0
    a7f2:	73fb      	strb	r3, [r7, #15]
    a7f4:	7b3b      	ldrb	r3, [r7, #12]
    a7f6:	2203      	movs	r2, #3
    a7f8:	f362 0302 	bfi	r3, r2, #0, #3
    a7fc:	733b      	strb	r3, [r7, #12]
    a7fe:	7b3b      	ldrb	r3, [r7, #12]
    a800:	f36f 03c5 	bfc	r3, #3, #3
    a804:	733b      	strb	r3, [r7, #12]
    a806:	2300      	movs	r3, #0
    a808:	2b00      	cmp	r3, #0
    a80a:	d009      	beq.n	a820 <nrfx_timer_enable+0x94>
    a80c:	4b16      	ldr	r3, [pc, #88]	; (a868 <nrfx_timer_enable+0xdc>)
    a80e:	681b      	ldr	r3, [r3, #0]
    a810:	4618      	mov	r0, r3
    a812:	f7ff fdeb 	bl	a3ec <log_const_source_id>
    a816:	4603      	mov	r3, r0
    a818:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a81c:	b29a      	uxth	r2, r3
    a81e:	e000      	b.n	a822 <nrfx_timer_enable+0x96>
    a820:	2200      	movs	r2, #0
    a822:	89bb      	ldrh	r3, [r7, #12]
    a824:	f362 138f 	bfi	r3, r2, #6, #10
    a828:	81bb      	strh	r3, [r7, #12]
    a82a:	7bfb      	ldrb	r3, [r7, #15]
    a82c:	2b00      	cmp	r3, #0
    a82e:	d007      	beq.n	a840 <nrfx_timer_enable+0xb4>
    a830:	687b      	ldr	r3, [r7, #4]
    a832:	791b      	ldrb	r3, [r3, #4]
    a834:	461a      	mov	r2, r3
    a836:	490d      	ldr	r1, [pc, #52]	; (a86c <nrfx_timer_enable+0xe0>)
    a838:	89b8      	ldrh	r0, [r7, #12]
    a83a:	f7f8 f859 	bl	28f0 <log_from_user>
}
    a83e:	e006      	b.n	a84e <nrfx_timer_enable+0xc2>
    NRFX_LOG_INFO("Enabled instance: %d.", p_instance->instance_id);
    a840:	687b      	ldr	r3, [r7, #4]
    a842:	791b      	ldrb	r3, [r3, #4]
    a844:	89ba      	ldrh	r2, [r7, #12]
    a846:	4619      	mov	r1, r3
    a848:	4808      	ldr	r0, [pc, #32]	; (a86c <nrfx_timer_enable+0xe0>)
    a84a:	f006 feff 	bl	1164c <log_1>
}
    a84e:	bf00      	nop
    a850:	3710      	adds	r7, #16
    a852:	46bd      	mov	sp, r7
    a854:	bd80      	pop	{r7, pc}
    a856:	bf00      	nop
    a858:	20000cc4 	.word	0x20000cc4
    a85c:	0001af30 	.word	0x0001af30
    a860:	0001b730 	.word	0x0001b730
    a864:	0001af7c 	.word	0x0001af7c
    a868:	20000cc0 	.word	0x20000cc0
    a86c:	0001b774 	.word	0x0001b774

0000a870 <nrfx_timer_disable>:

void nrfx_timer_disable(nrfx_timer_t const * p_instance)
{
    a870:	b580      	push	{r7, lr}
    a872:	b084      	sub	sp, #16
    a874:	af00      	add	r7, sp, #0
    a876:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED);
    a878:	687b      	ldr	r3, [r7, #4]
    a87a:	791b      	ldrb	r3, [r3, #4]
    a87c:	4619      	mov	r1, r3
    a87e:	4a2f      	ldr	r2, [pc, #188]	; (a93c <nrfx_timer_disable+0xcc>)
    a880:	460b      	mov	r3, r1
    a882:	005b      	lsls	r3, r3, #1
    a884:	440b      	add	r3, r1
    a886:	009b      	lsls	r3, r3, #2
    a888:	4413      	add	r3, r2
    a88a:	3308      	adds	r3, #8
    a88c:	781b      	ldrb	r3, [r3, #0]
    a88e:	2b00      	cmp	r3, #0
    a890:	d109      	bne.n	a8a6 <nrfx_timer_disable+0x36>
    a892:	2395      	movs	r3, #149	; 0x95
    a894:	4a2a      	ldr	r2, [pc, #168]	; (a940 <nrfx_timer_disable+0xd0>)
    a896:	492b      	ldr	r1, [pc, #172]	; (a944 <nrfx_timer_disable+0xd4>)
    a898:	482b      	ldr	r0, [pc, #172]	; (a948 <nrfx_timer_disable+0xd8>)
    a89a:	f005 fbe5 	bl	10068 <printk>
    a89e:	2195      	movs	r1, #149	; 0x95
    a8a0:	4827      	ldr	r0, [pc, #156]	; (a940 <nrfx_timer_disable+0xd0>)
    a8a2:	f006 fa29 	bl	10cf8 <assert_post_action>
    nrf_timer_task_trigger(p_instance->p_reg, NRF_TIMER_TASK_SHUTDOWN);
    a8a6:	687b      	ldr	r3, [r7, #4]
    a8a8:	681b      	ldr	r3, [r3, #0]
    a8aa:	2110      	movs	r1, #16
    a8ac:	4618      	mov	r0, r3
    a8ae:	f00c f917 	bl	16ae0 <nrf_timer_task_trigger>
    m_cb[p_instance->instance_id].state = NRFX_DRV_STATE_INITIALIZED;
    a8b2:	687b      	ldr	r3, [r7, #4]
    a8b4:	791b      	ldrb	r3, [r3, #4]
    a8b6:	4619      	mov	r1, r3
    a8b8:	4a20      	ldr	r2, [pc, #128]	; (a93c <nrfx_timer_disable+0xcc>)
    a8ba:	460b      	mov	r3, r1
    a8bc:	005b      	lsls	r3, r3, #1
    a8be:	440b      	add	r3, r1
    a8c0:	009b      	lsls	r3, r3, #2
    a8c2:	4413      	add	r3, r2
    a8c4:	3308      	adds	r3, #8
    a8c6:	2201      	movs	r2, #1
    a8c8:	701a      	strb	r2, [r3, #0]
    NRFX_LOG_INFO("Disabled instance: %d.", p_instance->instance_id);
    a8ca:	2300      	movs	r3, #0
    a8cc:	2b02      	cmp	r3, #2
    a8ce:	d930      	bls.n	a932 <nrfx_timer_disable+0xc2>
    a8d0:	f00c f9bd 	bl	16c4e <_is_user_context>
    a8d4:	4603      	mov	r3, r0
    a8d6:	73fb      	strb	r3, [r7, #15]
    a8d8:	7b3b      	ldrb	r3, [r7, #12]
    a8da:	2203      	movs	r2, #3
    a8dc:	f362 0302 	bfi	r3, r2, #0, #3
    a8e0:	733b      	strb	r3, [r7, #12]
    a8e2:	7b3b      	ldrb	r3, [r7, #12]
    a8e4:	f36f 03c5 	bfc	r3, #3, #3
    a8e8:	733b      	strb	r3, [r7, #12]
    a8ea:	2300      	movs	r3, #0
    a8ec:	2b00      	cmp	r3, #0
    a8ee:	d009      	beq.n	a904 <nrfx_timer_disable+0x94>
    a8f0:	4b16      	ldr	r3, [pc, #88]	; (a94c <nrfx_timer_disable+0xdc>)
    a8f2:	681b      	ldr	r3, [r3, #0]
    a8f4:	4618      	mov	r0, r3
    a8f6:	f7ff fd79 	bl	a3ec <log_const_source_id>
    a8fa:	4603      	mov	r3, r0
    a8fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a900:	b29a      	uxth	r2, r3
    a902:	e000      	b.n	a906 <nrfx_timer_disable+0x96>
    a904:	2200      	movs	r2, #0
    a906:	89bb      	ldrh	r3, [r7, #12]
    a908:	f362 138f 	bfi	r3, r2, #6, #10
    a90c:	81bb      	strh	r3, [r7, #12]
    a90e:	7bfb      	ldrb	r3, [r7, #15]
    a910:	2b00      	cmp	r3, #0
    a912:	d007      	beq.n	a924 <nrfx_timer_disable+0xb4>
    a914:	687b      	ldr	r3, [r7, #4]
    a916:	791b      	ldrb	r3, [r3, #4]
    a918:	461a      	mov	r2, r3
    a91a:	490d      	ldr	r1, [pc, #52]	; (a950 <nrfx_timer_disable+0xe0>)
    a91c:	89b8      	ldrh	r0, [r7, #12]
    a91e:	f7f7 ffe7 	bl	28f0 <log_from_user>
}
    a922:	e006      	b.n	a932 <nrfx_timer_disable+0xc2>
    NRFX_LOG_INFO("Disabled instance: %d.", p_instance->instance_id);
    a924:	687b      	ldr	r3, [r7, #4]
    a926:	791b      	ldrb	r3, [r3, #4]
    a928:	89ba      	ldrh	r2, [r7, #12]
    a92a:	4619      	mov	r1, r3
    a92c:	4808      	ldr	r0, [pc, #32]	; (a950 <nrfx_timer_disable+0xe0>)
    a92e:	f006 fe8d 	bl	1164c <log_1>
}
    a932:	bf00      	nop
    a934:	3710      	adds	r7, #16
    a936:	46bd      	mov	sp, r7
    a938:	bd80      	pop	{r7, pc}
    a93a:	bf00      	nop
    a93c:	20000cc4 	.word	0x20000cc4
    a940:	0001af30 	.word	0x0001af30
    a944:	0001b78c 	.word	0x0001b78c
    a948:	0001af7c 	.word	0x0001af7c
    a94c:	20000cc0 	.word	0x20000cc0
    a950:	0001b7d0 	.word	0x0001b7d0

0000a954 <nrfx_timer_clear>:
    nrf_timer_task_trigger(p_instance->p_reg, NRF_TIMER_TASK_STOP);
    NRFX_LOG_INFO("Paused instance: %d.", p_instance->instance_id);
}

void nrfx_timer_clear(nrfx_timer_t const * p_instance)
{
    a954:	b580      	push	{r7, lr}
    a956:	b082      	sub	sp, #8
    a958:	af00      	add	r7, sp, #0
    a95a:	6078      	str	r0, [r7, #4]
    NRFX_ASSERT(m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED);
    a95c:	687b      	ldr	r3, [r7, #4]
    a95e:	791b      	ldrb	r3, [r3, #4]
    a960:	4619      	mov	r1, r3
    a962:	4a0f      	ldr	r2, [pc, #60]	; (a9a0 <nrfx_timer_clear+0x4c>)
    a964:	460b      	mov	r3, r1
    a966:	005b      	lsls	r3, r3, #1
    a968:	440b      	add	r3, r1
    a96a:	009b      	lsls	r3, r3, #2
    a96c:	4413      	add	r3, r2
    a96e:	3308      	adds	r3, #8
    a970:	781b      	ldrb	r3, [r3, #0]
    a972:	2b00      	cmp	r3, #0
    a974:	d109      	bne.n	a98a <nrfx_timer_clear+0x36>
    a976:	23b1      	movs	r3, #177	; 0xb1
    a978:	4a0a      	ldr	r2, [pc, #40]	; (a9a4 <nrfx_timer_clear+0x50>)
    a97a:	490b      	ldr	r1, [pc, #44]	; (a9a8 <nrfx_timer_clear+0x54>)
    a97c:	480b      	ldr	r0, [pc, #44]	; (a9ac <nrfx_timer_clear+0x58>)
    a97e:	f005 fb73 	bl	10068 <printk>
    a982:	21b1      	movs	r1, #177	; 0xb1
    a984:	4807      	ldr	r0, [pc, #28]	; (a9a4 <nrfx_timer_clear+0x50>)
    a986:	f006 f9b7 	bl	10cf8 <assert_post_action>
    nrf_timer_task_trigger(p_instance->p_reg, NRF_TIMER_TASK_CLEAR);
    a98a:	687b      	ldr	r3, [r7, #4]
    a98c:	681b      	ldr	r3, [r3, #0]
    a98e:	210c      	movs	r1, #12
    a990:	4618      	mov	r0, r3
    a992:	f00c f8a5 	bl	16ae0 <nrf_timer_task_trigger>
}
    a996:	bf00      	nop
    a998:	3708      	adds	r7, #8
    a99a:	46bd      	mov	sp, r7
    a99c:	bd80      	pop	{r7, pc}
    a99e:	bf00      	nop
    a9a0:	20000cc4 	.word	0x20000cc4
    a9a4:	0001af30 	.word	0x0001af30
    a9a8:	0001b78c 	.word	0x0001b78c
    a9ac:	0001af7c 	.word	0x0001af7c

0000a9b0 <nrfx_timer_capture>:
    nrf_timer_task_trigger(p_instance->p_reg, NRF_TIMER_TASK_COUNT);
}

uint32_t nrfx_timer_capture(nrfx_timer_t const *   p_instance,
                            nrf_timer_cc_channel_t cc_channel)
{
    a9b0:	b590      	push	{r4, r7, lr}
    a9b2:	b083      	sub	sp, #12
    a9b4:	af00      	add	r7, sp, #0
    a9b6:	6078      	str	r0, [r7, #4]
    a9b8:	460b      	mov	r3, r1
    a9ba:	70fb      	strb	r3, [r7, #3]
    NRFX_ASSERT(m_cb[p_instance->instance_id].state != NRFX_DRV_STATE_UNINITIALIZED);
    a9bc:	687b      	ldr	r3, [r7, #4]
    a9be:	791b      	ldrb	r3, [r3, #4]
    a9c0:	4619      	mov	r1, r3
    a9c2:	4a1d      	ldr	r2, [pc, #116]	; (aa38 <nrfx_timer_capture+0x88>)
    a9c4:	460b      	mov	r3, r1
    a9c6:	005b      	lsls	r3, r3, #1
    a9c8:	440b      	add	r3, r1
    a9ca:	009b      	lsls	r3, r3, #2
    a9cc:	4413      	add	r3, r2
    a9ce:	3308      	adds	r3, #8
    a9d0:	781b      	ldrb	r3, [r3, #0]
    a9d2:	2b00      	cmp	r3, #0
    a9d4:	d109      	bne.n	a9ea <nrfx_timer_capture+0x3a>
    a9d6:	23c0      	movs	r3, #192	; 0xc0
    a9d8:	4a18      	ldr	r2, [pc, #96]	; (aa3c <nrfx_timer_capture+0x8c>)
    a9da:	4919      	ldr	r1, [pc, #100]	; (aa40 <nrfx_timer_capture+0x90>)
    a9dc:	4819      	ldr	r0, [pc, #100]	; (aa44 <nrfx_timer_capture+0x94>)
    a9de:	f005 fb43 	bl	10068 <printk>
    a9e2:	21c0      	movs	r1, #192	; 0xc0
    a9e4:	4815      	ldr	r0, [pc, #84]	; (aa3c <nrfx_timer_capture+0x8c>)
    a9e6:	f006 f987 	bl	10cf8 <assert_post_action>
    NRFX_ASSERT(cc_channel < p_instance->cc_channel_count);
    a9ea:	687b      	ldr	r3, [r7, #4]
    a9ec:	795b      	ldrb	r3, [r3, #5]
    a9ee:	78fa      	ldrb	r2, [r7, #3]
    a9f0:	429a      	cmp	r2, r3
    a9f2:	d309      	bcc.n	aa08 <nrfx_timer_capture+0x58>
    a9f4:	23c1      	movs	r3, #193	; 0xc1
    a9f6:	4a11      	ldr	r2, [pc, #68]	; (aa3c <nrfx_timer_capture+0x8c>)
    a9f8:	4913      	ldr	r1, [pc, #76]	; (aa48 <nrfx_timer_capture+0x98>)
    a9fa:	4812      	ldr	r0, [pc, #72]	; (aa44 <nrfx_timer_capture+0x94>)
    a9fc:	f005 fb34 	bl	10068 <printk>
    aa00:	21c1      	movs	r1, #193	; 0xc1
    aa02:	480e      	ldr	r0, [pc, #56]	; (aa3c <nrfx_timer_capture+0x8c>)
    aa04:	f006 f978 	bl	10cf8 <assert_post_action>

    nrf_timer_task_trigger(p_instance->p_reg,
    aa08:	687b      	ldr	r3, [r7, #4]
    aa0a:	681c      	ldr	r4, [r3, #0]
    aa0c:	78fb      	ldrb	r3, [r7, #3]
    aa0e:	4618      	mov	r0, r3
    aa10:	f00c f902 	bl	16c18 <nrf_timer_capture_task_get>
    aa14:	4603      	mov	r3, r0
    aa16:	4619      	mov	r1, r3
    aa18:	4620      	mov	r0, r4
    aa1a:	f00c f861 	bl	16ae0 <nrf_timer_task_trigger>
        nrf_timer_capture_task_get(cc_channel));
    return nrf_timer_cc_get(p_instance->p_reg, cc_channel);
    aa1e:	687b      	ldr	r3, [r7, #4]
    aa20:	681b      	ldr	r3, [r3, #0]
    aa22:	78fa      	ldrb	r2, [r7, #3]
    aa24:	4611      	mov	r1, r2
    aa26:	4618      	mov	r0, r3
    aa28:	f00c f8e5 	bl	16bf6 <nrf_timer_cc_get>
    aa2c:	4603      	mov	r3, r0
}
    aa2e:	4618      	mov	r0, r3
    aa30:	370c      	adds	r7, #12
    aa32:	46bd      	mov	sp, r7
    aa34:	bd90      	pop	{r4, r7, pc}
    aa36:	bf00      	nop
    aa38:	20000cc4 	.word	0x20000cc4
    aa3c:	0001af30 	.word	0x0001af30
    aa40:	0001b78c 	.word	0x0001b78c
    aa44:	0001af7c 	.word	0x0001af7c
    aa48:	0001b858 	.word	0x0001b858

0000aa4c <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    aa4c:	b580      	push	{r7, lr}
    aa4e:	b08a      	sub	sp, #40	; 0x28
    aa50:	af00      	add	r7, sp, #0
    aa52:	6078      	str	r0, [r7, #4]
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    aa54:	4a23      	ldr	r2, [pc, #140]	; (aae4 <z_sys_init_run_level+0x98>)
    aa56:	687b      	ldr	r3, [r7, #4]
    aa58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aa5c:	627b      	str	r3, [r7, #36]	; 0x24
    aa5e:	e034      	b.n	aaca <z_sys_init_run_level+0x7e>
		const struct device *dev = entry->dev;
    aa60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    aa62:	685b      	ldr	r3, [r3, #4]
    aa64:	623b      	str	r3, [r7, #32]

		if (dev != NULL) {
    aa66:	6a3b      	ldr	r3, [r7, #32]
    aa68:	2b00      	cmp	r3, #0
    aa6a:	d002      	beq.n	aa72 <z_sys_init_run_level+0x26>
			z_object_init(dev);
    aa6c:	6a38      	ldr	r0, [r7, #32]
    aa6e:	f00c f8f5 	bl	16c5c <z_object_init>
		}

		if ((entry->init(dev) != 0) && (dev != NULL)) {
    aa72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    aa74:	681b      	ldr	r3, [r3, #0]
    aa76:	6a38      	ldr	r0, [r7, #32]
    aa78:	4798      	blx	r3
    aa7a:	4603      	mov	r3, r0
    aa7c:	2b00      	cmp	r3, #0
    aa7e:	d021      	beq.n	aac4 <z_sys_init_run_level+0x78>
    aa80:	6a3b      	ldr	r3, [r7, #32]
    aa82:	2b00      	cmp	r3, #0
    aa84:	d01e      	beq.n	aac4 <z_sys_init_run_level+0x78>
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
    aa86:	4a18      	ldr	r2, [pc, #96]	; (aae8 <z_sys_init_run_level+0x9c>)
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
    aa88:	6a3b      	ldr	r3, [r7, #32]
    aa8a:	4918      	ldr	r1, [pc, #96]	; (aaec <z_sys_init_run_level+0xa0>)
    aa8c:	1a5b      	subs	r3, r3, r1
    aa8e:	111b      	asrs	r3, r3, #4
    aa90:	61fa      	str	r2, [r7, #28]
    aa92:	61bb      	str	r3, [r7, #24]
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    aa94:	69bb      	ldr	r3, [r7, #24]
    aa96:	095b      	lsrs	r3, r3, #5
    aa98:	009a      	lsls	r2, r3, #2
    aa9a:	69fb      	ldr	r3, [r7, #28]
    aa9c:	441a      	add	r2, r3
    aa9e:	69bb      	ldr	r3, [r7, #24]
    aaa0:	f003 031f 	and.w	r3, r3, #31
    aaa4:	617a      	str	r2, [r7, #20]
    aaa6:	613b      	str	r3, [r7, #16]
	uint32_t temp = *(volatile uint32_t *)addr;
    aaa8:	697b      	ldr	r3, [r7, #20]
    aaaa:	681b      	ldr	r3, [r3, #0]
    aaac:	60fb      	str	r3, [r7, #12]
	*(volatile uint32_t *)addr = temp | (1 << bit);
    aaae:	2201      	movs	r2, #1
    aab0:	693b      	ldr	r3, [r7, #16]
    aab2:	fa02 f303 	lsl.w	r3, r2, r3
    aab6:	4619      	mov	r1, r3
    aab8:	697b      	ldr	r3, [r7, #20]
    aaba:	68fa      	ldr	r2, [r7, #12]
    aabc:	430a      	orrs	r2, r1
    aabe:	601a      	str	r2, [r3, #0]
}
    aac0:	bf00      	nop
}
    aac2:	bf00      	nop
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    aac4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    aac6:	3308      	adds	r3, #8
    aac8:	627b      	str	r3, [r7, #36]	; 0x24
    aaca:	687b      	ldr	r3, [r7, #4]
    aacc:	3301      	adds	r3, #1
    aace:	4a05      	ldr	r2, [pc, #20]	; (aae4 <z_sys_init_run_level+0x98>)
    aad0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aad4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    aad6:	429a      	cmp	r2, r3
    aad8:	d3c2      	bcc.n	aa60 <z_sys_init_run_level+0x14>
		}
	}
}
    aada:	bf00      	nop
    aadc:	bf00      	nop
    aade:	3728      	adds	r7, #40	; 0x28
    aae0:	46bd      	mov	sp, r7
    aae2:	bd80      	pop	{r7, pc}
    aae4:	20000154 	.word	0x20000154
    aae8:	20000258 	.word	0x20000258
    aaec:	200001e8 	.word	0x200001e8

0000aaf0 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    aaf0:	b580      	push	{r7, lr}
    aaf2:	b084      	sub	sp, #16
    aaf4:	af00      	add	r7, sp, #0
    aaf6:	6078      	str	r0, [r7, #4]
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    aaf8:	4b1b      	ldr	r3, [pc, #108]	; (ab68 <z_impl_device_get_binding+0x78>)
    aafa:	60fb      	str	r3, [r7, #12]
    aafc:	e00f      	b.n	ab1e <z_impl_device_get_binding+0x2e>
		if (z_device_ready(dev) && (dev->name == name)) {
    aafe:	68f8      	ldr	r0, [r7, #12]
    ab00:	f000 f836 	bl	ab70 <z_device_ready>
    ab04:	4603      	mov	r3, r0
    ab06:	2b00      	cmp	r3, #0
    ab08:	d006      	beq.n	ab18 <z_impl_device_get_binding+0x28>
    ab0a:	68fb      	ldr	r3, [r7, #12]
    ab0c:	681b      	ldr	r3, [r3, #0]
    ab0e:	687a      	ldr	r2, [r7, #4]
    ab10:	429a      	cmp	r2, r3
    ab12:	d101      	bne.n	ab18 <z_impl_device_get_binding+0x28>
			return dev;
    ab14:	68fb      	ldr	r3, [r7, #12]
    ab16:	e022      	b.n	ab5e <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
    ab18:	68fb      	ldr	r3, [r7, #12]
    ab1a:	3310      	adds	r3, #16
    ab1c:	60fb      	str	r3, [r7, #12]
    ab1e:	68fb      	ldr	r3, [r7, #12]
    ab20:	4a12      	ldr	r2, [pc, #72]	; (ab6c <z_impl_device_get_binding+0x7c>)
    ab22:	4293      	cmp	r3, r2
    ab24:	d1eb      	bne.n	aafe <z_impl_device_get_binding+0xe>
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    ab26:	4b10      	ldr	r3, [pc, #64]	; (ab68 <z_impl_device_get_binding+0x78>)
    ab28:	60fb      	str	r3, [r7, #12]
    ab2a:	e013      	b.n	ab54 <z_impl_device_get_binding+0x64>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    ab2c:	68f8      	ldr	r0, [r7, #12]
    ab2e:	f000 f81f 	bl	ab70 <z_device_ready>
    ab32:	4603      	mov	r3, r0
    ab34:	2b00      	cmp	r3, #0
    ab36:	d00a      	beq.n	ab4e <z_impl_device_get_binding+0x5e>
    ab38:	68fb      	ldr	r3, [r7, #12]
    ab3a:	681b      	ldr	r3, [r3, #0]
    ab3c:	4619      	mov	r1, r3
    ab3e:	6878      	ldr	r0, [r7, #4]
    ab40:	f008 fad5 	bl	130ee <strcmp>
    ab44:	4603      	mov	r3, r0
    ab46:	2b00      	cmp	r3, #0
    ab48:	d101      	bne.n	ab4e <z_impl_device_get_binding+0x5e>
			return dev;
    ab4a:	68fb      	ldr	r3, [r7, #12]
    ab4c:	e007      	b.n	ab5e <z_impl_device_get_binding+0x6e>
	for (dev = __device_start; dev != __device_end; dev++) {
    ab4e:	68fb      	ldr	r3, [r7, #12]
    ab50:	3310      	adds	r3, #16
    ab52:	60fb      	str	r3, [r7, #12]
    ab54:	68fb      	ldr	r3, [r7, #12]
    ab56:	4a05      	ldr	r2, [pc, #20]	; (ab6c <z_impl_device_get_binding+0x7c>)
    ab58:	4293      	cmp	r3, r2
    ab5a:	d1e7      	bne.n	ab2c <z_impl_device_get_binding+0x3c>
		}
	}

	return NULL;
    ab5c:	2300      	movs	r3, #0
}
    ab5e:	4618      	mov	r0, r3
    ab60:	3710      	adds	r7, #16
    ab62:	46bd      	mov	sp, r7
    ab64:	bd80      	pop	{r7, pc}
    ab66:	bf00      	nop
    ab68:	200001e8 	.word	0x200001e8
    ab6c:	20000258 	.word	0x20000258

0000ab70 <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
    ab70:	b480      	push	{r7}
    ab72:	b089      	sub	sp, #36	; 0x24
    ab74:	af00      	add	r7, sp, #0
    ab76:	6078      	str	r0, [r7, #4]
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
    ab78:	4a12      	ldr	r2, [pc, #72]	; (abc4 <z_device_ready+0x54>)
					(dev - __device_start)));
    ab7a:	687b      	ldr	r3, [r7, #4]
    ab7c:	4912      	ldr	r1, [pc, #72]	; (abc8 <z_device_ready+0x58>)
    ab7e:	1a5b      	subs	r3, r3, r1
    ab80:	111b      	asrs	r3, r3, #4
    ab82:	61fa      	str	r2, [r7, #28]
    ab84:	61bb      	str	r3, [r7, #24]
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ab86:	69bb      	ldr	r3, [r7, #24]
    ab88:	095b      	lsrs	r3, r3, #5
    ab8a:	009a      	lsls	r2, r3, #2
    ab8c:	69fb      	ldr	r3, [r7, #28]
    ab8e:	441a      	add	r2, r3
    ab90:	69bb      	ldr	r3, [r7, #24]
    ab92:	f003 031f 	and.w	r3, r3, #31
    ab96:	617a      	str	r2, [r7, #20]
    ab98:	613b      	str	r3, [r7, #16]
	uint32_t temp = *(volatile uint32_t *)addr;
    ab9a:	697b      	ldr	r3, [r7, #20]
    ab9c:	681b      	ldr	r3, [r3, #0]
    ab9e:	60fb      	str	r3, [r7, #12]
	return temp & (1 << bit);
    aba0:	2201      	movs	r2, #1
    aba2:	693b      	ldr	r3, [r7, #16]
    aba4:	fa02 f303 	lsl.w	r3, r2, r3
    aba8:	461a      	mov	r2, r3
    abaa:	68fb      	ldr	r3, [r7, #12]
    abac:	4013      	ands	r3, r2
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    abae:	bf00      	nop
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
    abb0:	2b00      	cmp	r3, #0
    abb2:	bf0c      	ite	eq
    abb4:	2301      	moveq	r3, #1
    abb6:	2300      	movne	r3, #0
    abb8:	b2db      	uxtb	r3, r3
}
    abba:	4618      	mov	r0, r3
    abbc:	3724      	adds	r7, #36	; 0x24
    abbe:	46bd      	mov	sp, r7
    abc0:	bc80      	pop	{r7}
    abc2:	4770      	bx	lr
    abc4:	20000258 	.word	0x20000258
    abc8:	200001e8 	.word	0x200001e8

0000abcc <log_const_source_id>:
{
    abcc:	b480      	push	{r7}
    abce:	b083      	sub	sp, #12
    abd0:	af00      	add	r7, sp, #0
    abd2:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    abd4:	687b      	ldr	r3, [r7, #4]
    abd6:	4a04      	ldr	r2, [pc, #16]	; (abe8 <log_const_source_id+0x1c>)
    abd8:	1a9b      	subs	r3, r3, r2
    abda:	08db      	lsrs	r3, r3, #3
}
    abdc:	4618      	mov	r0, r3
    abde:	370c      	adds	r7, #12
    abe0:	46bd      	mov	sp, r7
    abe2:	bc80      	pop	{r7}
    abe4:	4770      	bx	lr
    abe6:	bf00      	nop
    abe8:	00018788 	.word	0x00018788

0000abec <thread_name_get>:
	CODE_UNREACHABLE;
}
/* LCOV_EXCL_STOP */

static const char *thread_name_get(struct k_thread *thread)
{
    abec:	b580      	push	{r7, lr}
    abee:	b084      	sub	sp, #16
    abf0:	af00      	add	r7, sp, #0
    abf2:	6078      	str	r0, [r7, #4]
	const char *thread_name = thread ? k_thread_name_get(thread) : NULL;
    abf4:	687b      	ldr	r3, [r7, #4]
    abf6:	2b00      	cmp	r3, #0
    abf8:	d004      	beq.n	ac04 <thread_name_get+0x18>
    abfa:	6878      	ldr	r0, [r7, #4]
    abfc:	f00d fa1e 	bl	1803c <k_thread_name_get>
    ac00:	4603      	mov	r3, r0
    ac02:	e000      	b.n	ac06 <thread_name_get+0x1a>
    ac04:	2300      	movs	r3, #0
    ac06:	60fb      	str	r3, [r7, #12]

	if (thread_name == NULL || thread_name[0] == '\0') {
    ac08:	68fb      	ldr	r3, [r7, #12]
    ac0a:	2b00      	cmp	r3, #0
    ac0c:	d003      	beq.n	ac16 <thread_name_get+0x2a>
    ac0e:	68fb      	ldr	r3, [r7, #12]
    ac10:	781b      	ldrb	r3, [r3, #0]
    ac12:	2b00      	cmp	r3, #0
    ac14:	d101      	bne.n	ac1a <thread_name_get+0x2e>
		thread_name = "unknown";
    ac16:	4b03      	ldr	r3, [pc, #12]	; (ac24 <thread_name_get+0x38>)
    ac18:	60fb      	str	r3, [r7, #12]
	}

	return thread_name;
    ac1a:	68fb      	ldr	r3, [r7, #12]
}
    ac1c:	4618      	mov	r0, r3
    ac1e:	3710      	adds	r7, #16
    ac20:	46bd      	mov	sp, r7
    ac22:	bd80      	pop	{r7, pc}
    ac24:	0001b910 	.word	0x0001b910

0000ac28 <reason_to_str>:

static const char *reason_to_str(unsigned int reason)
{
    ac28:	b480      	push	{r7}
    ac2a:	b083      	sub	sp, #12
    ac2c:	af00      	add	r7, sp, #0
    ac2e:	6078      	str	r0, [r7, #4]
    ac30:	687b      	ldr	r3, [r7, #4]
    ac32:	2b04      	cmp	r3, #4
    ac34:	d816      	bhi.n	ac64 <reason_to_str+0x3c>
    ac36:	a201      	add	r2, pc, #4	; (adr r2, ac3c <reason_to_str+0x14>)
    ac38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ac3c:	0000ac51 	.word	0x0000ac51
    ac40:	0000ac55 	.word	0x0000ac55
    ac44:	0000ac59 	.word	0x0000ac59
    ac48:	0000ac5d 	.word	0x0000ac5d
    ac4c:	0000ac61 	.word	0x0000ac61
	switch (reason) {
	case K_ERR_CPU_EXCEPTION:
		return "CPU exception";
    ac50:	4b07      	ldr	r3, [pc, #28]	; (ac70 <reason_to_str+0x48>)
    ac52:	e008      	b.n	ac66 <reason_to_str+0x3e>
	case K_ERR_SPURIOUS_IRQ:
		return "Unhandled interrupt";
    ac54:	4b07      	ldr	r3, [pc, #28]	; (ac74 <reason_to_str+0x4c>)
    ac56:	e006      	b.n	ac66 <reason_to_str+0x3e>
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
    ac58:	4b07      	ldr	r3, [pc, #28]	; (ac78 <reason_to_str+0x50>)
    ac5a:	e004      	b.n	ac66 <reason_to_str+0x3e>
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
    ac5c:	4b07      	ldr	r3, [pc, #28]	; (ac7c <reason_to_str+0x54>)
    ac5e:	e002      	b.n	ac66 <reason_to_str+0x3e>
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
    ac60:	4b07      	ldr	r3, [pc, #28]	; (ac80 <reason_to_str+0x58>)
    ac62:	e000      	b.n	ac66 <reason_to_str+0x3e>
	default:
		return "Unknown error";
    ac64:	4b07      	ldr	r3, [pc, #28]	; (ac84 <reason_to_str+0x5c>)
	}
}
    ac66:	4618      	mov	r0, r3
    ac68:	370c      	adds	r7, #12
    ac6a:	46bd      	mov	sp, r7
    ac6c:	bc80      	pop	{r7}
    ac6e:	4770      	bx	lr
    ac70:	0001b918 	.word	0x0001b918
    ac74:	0001b928 	.word	0x0001b928
    ac78:	0001b93c 	.word	0x0001b93c
    ac7c:	0001b94c 	.word	0x0001b94c
    ac80:	0001b958 	.word	0x0001b958
    ac84:	0001b968 	.word	0x0001b968

0000ac88 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    ac88:	b590      	push	{r4, r7, lr}
    ac8a:	b095      	sub	sp, #84	; 0x54
    ac8c:	af02      	add	r7, sp, #8
    ac8e:	6078      	str	r0, [r7, #4]
    ac90:	6039      	str	r1, [r7, #0]
	__asm__ volatile(
    ac92:	f04f 0320 	mov.w	r3, #32
    ac96:	f3ef 8211 	mrs	r2, BASEPRI
    ac9a:	f383 8811 	msr	BASEPRI, r3
    ac9e:	f3bf 8f6f 	isb	sy
    aca2:	637a      	str	r2, [r7, #52]	; 0x34
    aca4:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
    aca6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	/* We can't allow this code to be preempted, but don't need to
	 * synchronize between CPUs, so an arch-layer lock is
	 * appropriate.
	 */
	unsigned int key = arch_irq_lock();
    aca8:	63fb      	str	r3, [r7, #60]	; 0x3c
	struct k_thread *thread = k_current_get();
    acaa:	f00b ffe7 	bl	16c7c <k_current_get>
    acae:	6438      	str	r0, [r7, #64]	; 0x40

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    acb0:	2303      	movs	r3, #3
    acb2:	2b00      	cmp	r3, #0
    acb4:	d048      	beq.n	ad48 <z_fatal_error+0xc0>
    acb6:	f00b ffda 	bl	16c6e <_is_user_context>
    acba:	4603      	mov	r3, r0
    acbc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    acc0:	f897 3020 	ldrb.w	r3, [r7, #32]
    acc4:	2201      	movs	r2, #1
    acc6:	f362 0302 	bfi	r3, r2, #0, #3
    acca:	f887 3020 	strb.w	r3, [r7, #32]
    acce:	f897 3020 	ldrb.w	r3, [r7, #32]
    acd2:	f36f 03c5 	bfc	r3, #3, #3
    acd6:	f887 3020 	strb.w	r3, [r7, #32]
    acda:	2303      	movs	r3, #3
    acdc:	2b00      	cmp	r3, #0
    acde:	d009      	beq.n	acf4 <z_fatal_error+0x6c>
    ace0:	4b74      	ldr	r3, [pc, #464]	; (aeb4 <z_fatal_error+0x22c>)
    ace2:	681b      	ldr	r3, [r3, #0]
    ace4:	4618      	mov	r0, r3
    ace6:	f7ff ff71 	bl	abcc <log_const_source_id>
    acea:	4603      	mov	r3, r0
    acec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    acf0:	b29a      	uxth	r2, r3
    acf2:	e000      	b.n	acf6 <z_fatal_error+0x6e>
    acf4:	2200      	movs	r2, #0
    acf6:	8c3b      	ldrh	r3, [r7, #32]
    acf8:	f362 138f 	bfi	r3, r2, #6, #10
    acfc:	843b      	strh	r3, [r7, #32]
    acfe:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
    ad02:	2b00      	cmp	r3, #0
    ad04:	d00e      	beq.n	ad24 <z_fatal_error+0x9c>
    ad06:	6878      	ldr	r0, [r7, #4]
    ad08:	f7ff ff8e 	bl	ac28 <reason_to_str>
    ad0c:	4604      	mov	r4, r0
    ad0e:	f00b ffd2 	bl	16cb6 <get_cpu>
    ad12:	4603      	mov	r3, r0
    ad14:	9300      	str	r3, [sp, #0]
    ad16:	4623      	mov	r3, r4
    ad18:	687a      	ldr	r2, [r7, #4]
    ad1a:	4967      	ldr	r1, [pc, #412]	; (aeb8 <z_fatal_error+0x230>)
    ad1c:	8c38      	ldrh	r0, [r7, #32]
    ad1e:	f7f7 fde7 	bl	28f0 <log_from_user>
    ad22:	e011      	b.n	ad48 <z_fatal_error+0xc0>
    ad24:	6878      	ldr	r0, [r7, #4]
    ad26:	f7ff ff7f 	bl	ac28 <reason_to_str>
    ad2a:	4603      	mov	r3, r0
    ad2c:	461c      	mov	r4, r3
    ad2e:	f00b ffc2 	bl	16cb6 <get_cpu>
    ad32:	4603      	mov	r3, r0
    ad34:	461a      	mov	r2, r3
    ad36:	8c3b      	ldrh	r3, [r7, #32]
    ad38:	f8ad 3000 	strh.w	r3, [sp]
    ad3c:	4613      	mov	r3, r2
    ad3e:	4622      	mov	r2, r4
    ad40:	6879      	ldr	r1, [r7, #4]
    ad42:	485d      	ldr	r0, [pc, #372]	; (aeb8 <z_fatal_error+0x230>)
    ad44:	f006 fcb2 	bl	116ac <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    ad48:	683b      	ldr	r3, [r7, #0]
    ad4a:	2b00      	cmp	r3, #0
    ad4c:	d03c      	beq.n	adc8 <z_fatal_error+0x140>
    ad4e:	683b      	ldr	r3, [r7, #0]
    ad50:	62fb      	str	r3, [r7, #44]	; 0x2c
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    ad52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    ad54:	69db      	ldr	r3, [r3, #28]
    ad56:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ad5a:	2b00      	cmp	r3, #0
    ad5c:	bf14      	ite	ne
    ad5e:	2301      	movne	r3, #1
    ad60:	2300      	moveq	r3, #0
    ad62:	b2db      	uxtb	r3, r3
    ad64:	2b00      	cmp	r3, #0
    ad66:	d02f      	beq.n	adc8 <z_fatal_error+0x140>
		LOG_ERR("Fault during interrupt handling\n");
    ad68:	2303      	movs	r3, #3
    ad6a:	2b00      	cmp	r3, #0
    ad6c:	d02c      	beq.n	adc8 <z_fatal_error+0x140>
    ad6e:	f00b ff7e 	bl	16c6e <_is_user_context>
    ad72:	4603      	mov	r3, r0
    ad74:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
    ad78:	7b3b      	ldrb	r3, [r7, #12]
    ad7a:	2201      	movs	r2, #1
    ad7c:	f362 0302 	bfi	r3, r2, #0, #3
    ad80:	733b      	strb	r3, [r7, #12]
    ad82:	7b3b      	ldrb	r3, [r7, #12]
    ad84:	f36f 03c5 	bfc	r3, #3, #3
    ad88:	733b      	strb	r3, [r7, #12]
    ad8a:	2303      	movs	r3, #3
    ad8c:	2b00      	cmp	r3, #0
    ad8e:	d009      	beq.n	ada4 <z_fatal_error+0x11c>
    ad90:	4b48      	ldr	r3, [pc, #288]	; (aeb4 <z_fatal_error+0x22c>)
    ad92:	681b      	ldr	r3, [r3, #0]
    ad94:	4618      	mov	r0, r3
    ad96:	f7ff ff19 	bl	abcc <log_const_source_id>
    ad9a:	4603      	mov	r3, r0
    ad9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    ada0:	b29a      	uxth	r2, r3
    ada2:	e000      	b.n	ada6 <z_fatal_error+0x11e>
    ada4:	2200      	movs	r2, #0
    ada6:	89bb      	ldrh	r3, [r7, #12]
    ada8:	f362 138f 	bfi	r3, r2, #6, #10
    adac:	81bb      	strh	r3, [r7, #12]
    adae:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
    adb2:	2b00      	cmp	r3, #0
    adb4:	d004      	beq.n	adc0 <z_fatal_error+0x138>
    adb6:	4941      	ldr	r1, [pc, #260]	; (aebc <z_fatal_error+0x234>)
    adb8:	89b8      	ldrh	r0, [r7, #12]
    adba:	f7f7 fd99 	bl	28f0 <log_from_user>
    adbe:	e003      	b.n	adc8 <z_fatal_error+0x140>
    adc0:	89b9      	ldrh	r1, [r7, #12]
    adc2:	483e      	ldr	r0, [pc, #248]	; (aebc <z_fatal_error+0x234>)
    adc4:	f006 fc2d 	bl	11622 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    adc8:	2303      	movs	r3, #3
    adca:	2b00      	cmp	r3, #0
    adcc:	d040      	beq.n	ae50 <z_fatal_error+0x1c8>
    adce:	f00b ff4e 	bl	16c6e <_is_user_context>
    add2:	4603      	mov	r3, r0
    add4:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
    add8:	7a3b      	ldrb	r3, [r7, #8]
    adda:	2201      	movs	r2, #1
    addc:	f362 0302 	bfi	r3, r2, #0, #3
    ade0:	723b      	strb	r3, [r7, #8]
    ade2:	7a3b      	ldrb	r3, [r7, #8]
    ade4:	f36f 03c5 	bfc	r3, #3, #3
    ade8:	723b      	strb	r3, [r7, #8]
    adea:	2303      	movs	r3, #3
    adec:	2b00      	cmp	r3, #0
    adee:	d009      	beq.n	ae04 <z_fatal_error+0x17c>
    adf0:	4b30      	ldr	r3, [pc, #192]	; (aeb4 <z_fatal_error+0x22c>)
    adf2:	681b      	ldr	r3, [r3, #0]
    adf4:	4618      	mov	r0, r3
    adf6:	f7ff fee9 	bl	abcc <log_const_source_id>
    adfa:	4603      	mov	r3, r0
    adfc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    ae00:	b29a      	uxth	r2, r3
    ae02:	e000      	b.n	ae06 <z_fatal_error+0x17e>
    ae04:	2200      	movs	r2, #0
    ae06:	893b      	ldrh	r3, [r7, #8]
    ae08:	f362 138f 	bfi	r3, r2, #6, #10
    ae0c:	813b      	strh	r3, [r7, #8]
    ae0e:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
    ae12:	2b00      	cmp	r3, #0
    ae14:	d00d      	beq.n	ae32 <z_fatal_error+0x1aa>
    ae16:	6c38      	ldr	r0, [r7, #64]	; 0x40
    ae18:	f7ff fee8 	bl	abec <thread_name_get>
    ae1c:	4603      	mov	r3, r0
    ae1e:	4618      	mov	r0, r3
    ae20:	f7f7 fcec 	bl	27fc <log_strdup>
    ae24:	4603      	mov	r3, r0
    ae26:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    ae28:	4925      	ldr	r1, [pc, #148]	; (aec0 <z_fatal_error+0x238>)
    ae2a:	8938      	ldrh	r0, [r7, #8]
    ae2c:	f7f7 fd60 	bl	28f0 <log_from_user>
    ae30:	e00e      	b.n	ae50 <z_fatal_error+0x1c8>
    ae32:	6c3c      	ldr	r4, [r7, #64]	; 0x40
    ae34:	6c38      	ldr	r0, [r7, #64]	; 0x40
    ae36:	f7ff fed9 	bl	abec <thread_name_get>
    ae3a:	4603      	mov	r3, r0
    ae3c:	4618      	mov	r0, r3
    ae3e:	f7f7 fcdd 	bl	27fc <log_strdup>
    ae42:	4603      	mov	r3, r0
    ae44:	461a      	mov	r2, r3
    ae46:	893b      	ldrh	r3, [r7, #8]
    ae48:	4621      	mov	r1, r4
    ae4a:	481d      	ldr	r0, [pc, #116]	; (aec0 <z_fatal_error+0x238>)
    ae4c:	f006 fc15 	bl	1167a <log_2>
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);
    ae50:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    ae52:	6839      	ldr	r1, [r7, #0]
    ae54:	6878      	ldr	r0, [r7, #4]
    ae56:	f00b ff23 	bl	16ca0 <z_coredump>

	k_sys_fatal_error_handler(reason, esf);
    ae5a:	6839      	ldr	r1, [r7, #0]
    ae5c:	6878      	ldr	r0, [r7, #4]
    ae5e:	f7fe fb8f 	bl	9580 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
    ae62:	687b      	ldr	r3, [r7, #4]
    ae64:	2b04      	cmp	r3, #4
    ae66:	d10c      	bne.n	ae82 <z_fatal_error+0x1fa>
    ae68:	238e      	movs	r3, #142	; 0x8e
    ae6a:	4a16      	ldr	r2, [pc, #88]	; (aec4 <z_fatal_error+0x23c>)
    ae6c:	4916      	ldr	r1, [pc, #88]	; (aec8 <z_fatal_error+0x240>)
    ae6e:	4817      	ldr	r0, [pc, #92]	; (aecc <z_fatal_error+0x244>)
    ae70:	f005 f8fa 	bl	10068 <printk>
    ae74:	4816      	ldr	r0, [pc, #88]	; (aed0 <z_fatal_error+0x248>)
    ae76:	f005 f8f7 	bl	10068 <printk>
    ae7a:	218e      	movs	r1, #142	; 0x8e
    ae7c:	4811      	ldr	r0, [pc, #68]	; (aec4 <z_fatal_error+0x23c>)
    ae7e:	f005 ff3b 	bl	10cf8 <assert_post_action>
			 "Attempted to recover from a kernel panic condition");
		/* FIXME: #17656 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    ae82:	683b      	ldr	r3, [r7, #0]
    ae84:	2b00      	cmp	r3, #0
    ae86:	d006      	beq.n	ae96 <z_fatal_error+0x20e>
    ae88:	683b      	ldr	r3, [r7, #0]
    ae8a:	62bb      	str	r3, [r7, #40]	; 0x28
    ae8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    ae8e:	69db      	ldr	r3, [r3, #28]
    ae90:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ae94:	2b00      	cmp	r3, #0
    ae96:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    ae98:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    ae9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    ae9c:	f383 8811 	msr	BASEPRI, r3
    aea0:	f3bf 8f6f 	isb	sy
}
    aea4:	bf00      	nop
		}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
    aea6:	6c38      	ldr	r0, [r7, #64]	; 0x40
    aea8:	f00b feef 	bl	16c8a <k_thread_abort>
}
    aeac:	374c      	adds	r7, #76	; 0x4c
    aeae:	46bd      	mov	sp, r7
    aeb0:	bd90      	pop	{r4, r7, pc}
    aeb2:	bf00      	nop
    aeb4:	20000168 	.word	0x20000168
    aeb8:	0001b978 	.word	0x0001b978
    aebc:	0001b9a0 	.word	0x0001b9a0
    aec0:	0001b9c4 	.word	0x0001b9c4
    aec4:	0001b9dc 	.word	0x0001b9dc
    aec8:	0001ba00 	.word	0x0001ba00
    aecc:	0001ba20 	.word	0x0001ba20
    aed0:	0001ba40 	.word	0x0001ba40

0000aed4 <log_const_source_id>:
{
    aed4:	b480      	push	{r7}
    aed6:	b083      	sub	sp, #12
    aed8:	af00      	add	r7, sp, #0
    aeda:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    aedc:	687b      	ldr	r3, [r7, #4]
    aede:	4a04      	ldr	r2, [pc, #16]	; (aef0 <log_const_source_id+0x1c>)
    aee0:	1a9b      	subs	r3, r3, r2
    aee2:	08db      	lsrs	r3, r3, #3
}
    aee4:	4618      	mov	r0, r3
    aee6:	370c      	adds	r7, #12
    aee8:	46bd      	mov	sp, r7
    aeea:	bc80      	pop	{r7}
    aeec:	4770      	bx	lr
    aeee:	bf00      	nop
    aef0:	00018788 	.word	0x00018788

0000aef4 <set_kernel_idle_time_in_ticks>:
 *
 * @return N/A
 */
#if !SMP_FALLBACK
static void set_kernel_idle_time_in_ticks(int32_t ticks)
{
    aef4:	b480      	push	{r7}
    aef6:	b083      	sub	sp, #12
    aef8:	af00      	add	r7, sp, #0
    aefa:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_SYS_POWER_MANAGEMENT
	_kernel.idle = ticks;
    aefc:	4a03      	ldr	r2, [pc, #12]	; (af0c <set_kernel_idle_time_in_ticks+0x18>)
    aefe:	687b      	ldr	r3, [r7, #4]
    af00:	6253      	str	r3, [r2, #36]	; 0x24
#endif
}
    af02:	bf00      	nop
    af04:	370c      	adds	r7, #12
    af06:	46bd      	mov	sp, r7
    af08:	bc80      	pop	{r7}
    af0a:	4770      	bx	lr
    af0c:	20000cd8 	.word	0x20000cd8

0000af10 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
    af10:	b580      	push	{r7, lr}
    af12:	b092      	sub	sp, #72	; 0x48
    af14:	af02      	add	r7, sp, #8
    af16:	60f8      	str	r0, [r7, #12]
    af18:	60b9      	str	r1, [r7, #8]
    af1a:	607a      	str	r2, [r7, #4]
	struct _cpu *cpu = p1;
    af1c:	68fb      	ldr	r3, [r7, #12]
    af1e:	63fb      	str	r3, [r7, #60]	; 0x3c
	__asm__ volatile(
    af20:	f04f 0320 	mov.w	r3, #32
    af24:	f3ef 8211 	mrs	r2, BASEPRI
    af28:	f383 8811 	msr	BASEPRI, r3
    af2c:	f3bf 8f6f 	isb	sy
    af30:	62fa      	str	r2, [r7, #44]	; 0x2c
    af32:	62bb      	str	r3, [r7, #40]	; 0x28
	return key;
    af34:	6afb      	ldr	r3, [r7, #44]	; 0x2c

	while (true) {
		/* Lock interrupts to atomically check if to_abort is non-NULL,
		 * and if so clear it
		 */
		int key = arch_irq_lock();
    af36:	63bb      	str	r3, [r7, #56]	; 0x38
		struct k_thread *to_abort = cpu->pending_abort;
    af38:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    af3a:	691b      	ldr	r3, [r3, #16]
    af3c:	637b      	str	r3, [r7, #52]	; 0x34

		if (to_abort) {
    af3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    af40:	2b00      	cmp	r3, #0
    af42:	d04f      	beq.n	afe4 <idle+0xd4>
			cpu->pending_abort = NULL;
    af44:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    af46:	2200      	movs	r2, #0
    af48:	611a      	str	r2, [r3, #16]
			arch_irq_unlock(key);
    af4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    af4c:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    af4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    af50:	f383 8811 	msr	BASEPRI, r3
    af54:	f3bf 8f6f 	isb	sy
}
    af58:	bf00      	nop
			 * variable. If we get preempted here and another
			 * thread aborts, cpu->pending abort will get set
			 * again and we'll handle it when the loop iteration
			 * is continued below.
			 */
			LOG_DBG("idle %p aborting thread %p",
    af5a:	2303      	movs	r3, #3
    af5c:	2b03      	cmp	r3, #3
    af5e:	d93b      	bls.n	afd8 <idle+0xc8>
    af60:	f00b feb0 	bl	16cc4 <_is_user_context>
    af64:	4603      	mov	r3, r0
    af66:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    af6a:	7d3b      	ldrb	r3, [r7, #20]
    af6c:	2204      	movs	r2, #4
    af6e:	f362 0302 	bfi	r3, r2, #0, #3
    af72:	753b      	strb	r3, [r7, #20]
    af74:	7d3b      	ldrb	r3, [r7, #20]
    af76:	f36f 03c5 	bfc	r3, #3, #3
    af7a:	753b      	strb	r3, [r7, #20]
    af7c:	2303      	movs	r3, #3
    af7e:	2b00      	cmp	r3, #0
    af80:	d009      	beq.n	af96 <idle+0x86>
    af82:	4b23      	ldr	r3, [pc, #140]	; (b010 <idle+0x100>)
    af84:	681b      	ldr	r3, [r3, #0]
    af86:	4618      	mov	r0, r3
    af88:	f7ff ffa4 	bl	aed4 <log_const_source_id>
    af8c:	4603      	mov	r3, r0
    af8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    af92:	b29a      	uxth	r2, r3
    af94:	e000      	b.n	af98 <idle+0x88>
    af96:	2200      	movs	r2, #0
    af98:	8abb      	ldrh	r3, [r7, #20]
    af9a:	f362 138f 	bfi	r3, r2, #6, #10
    af9e:	82bb      	strh	r3, [r7, #20]
    afa0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    afa4:	2b00      	cmp	r3, #0
    afa6:	d00a      	beq.n	afbe <idle+0xae>
    afa8:	4b1a      	ldr	r3, [pc, #104]	; (b014 <idle+0x104>)
    afaa:	689a      	ldr	r2, [r3, #8]
    afac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    afae:	9300      	str	r3, [sp, #0]
    afb0:	4613      	mov	r3, r2
    afb2:	4a19      	ldr	r2, [pc, #100]	; (b018 <idle+0x108>)
    afb4:	4919      	ldr	r1, [pc, #100]	; (b01c <idle+0x10c>)
    afb6:	8ab8      	ldrh	r0, [r7, #20]
    afb8:	f7f7 fc9a 	bl	28f0 <log_from_user>
    afbc:	e00c      	b.n	afd8 <idle+0xc8>
    afbe:	4916      	ldr	r1, [pc, #88]	; (b018 <idle+0x108>)
    afc0:	4b14      	ldr	r3, [pc, #80]	; (b014 <idle+0x104>)
    afc2:	689b      	ldr	r3, [r3, #8]
    afc4:	4618      	mov	r0, r3
    afc6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    afc8:	8abb      	ldrh	r3, [r7, #20]
    afca:	f8ad 3000 	strh.w	r3, [sp]
    afce:	4613      	mov	r3, r2
    afd0:	4602      	mov	r2, r0
    afd2:	4812      	ldr	r0, [pc, #72]	; (b01c <idle+0x10c>)
    afd4:	f006 fb6a 	bl	116ac <log_3>
				_current, to_abort);

			z_thread_single_abort(to_abort);
    afd8:	6b78      	ldr	r0, [r7, #52]	; 0x34
    afda:	f001 ff4f 	bl	ce7c <z_thread_single_abort>
			 * here, the idle thread preempted everything else
			 * in order to abort the thread, and we now need to
			 * figure out what to do next, it's not necessarily
			 * the case that there are no other runnable threads.
			 */
			z_reschedule_unlocked();
    afde:	f00b fe7e 	bl	16cde <z_reschedule_unlocked>
			continue;
    afe2:	e013      	b.n	b00c <idle+0xfc>
		}
		arch_irq_unlock(key);
    afe4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    afe6:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    afe8:	69bb      	ldr	r3, [r7, #24]
    afea:	f383 8811 	msr	BASEPRI, r3
    afee:	f3bf 8f6f 	isb	sy
}
    aff2:	bf00      	nop
	__asm__ volatile(
    aff4:	f04f 0320 	mov.w	r3, #32
    aff8:	f3ef 8211 	mrs	r2, BASEPRI
    affc:	f383 8811 	msr	BASEPRI, r3
    b000:	f3bf 8f6f 	isb	sy
    b004:	623a      	str	r2, [r7, #32]
    b006:	61fb      	str	r3, [r7, #28]
#if SMP_FALLBACK
		k_busy_wait(100);
		k_yield();
#else
		(void)arch_irq_lock();
		sys_power_save_idle();
    b008:	f00b fe7e 	bl	16d08 <sys_power_save_idle>
	while (true) {
    b00c:	e788      	b.n	af20 <idle+0x10>
    b00e:	bf00      	nop
    b010:	2000016c 	.word	0x2000016c
    b014:	20000cd8 	.word	0x20000cd8
    b018:	0001ce00 	.word	0x0001ce00
    b01c:	0001ba78 	.word	0x0001ba78

0000b020 <__NVIC_SetPriority>:
{
    b020:	b480      	push	{r7}
    b022:	b083      	sub	sp, #12
    b024:	af00      	add	r7, sp, #0
    b026:	4603      	mov	r3, r0
    b028:	6039      	str	r1, [r7, #0]
    b02a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    b02c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    b030:	2b00      	cmp	r3, #0
    b032:	db0a      	blt.n	b04a <__NVIC_SetPriority+0x2a>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    b034:	683b      	ldr	r3, [r7, #0]
    b036:	b2da      	uxtb	r2, r3
    b038:	490c      	ldr	r1, [pc, #48]	; (b06c <__NVIC_SetPriority+0x4c>)
    b03a:	f997 3007 	ldrsb.w	r3, [r7, #7]
    b03e:	0152      	lsls	r2, r2, #5
    b040:	b2d2      	uxtb	r2, r2
    b042:	440b      	add	r3, r1
    b044:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
    b048:	e00a      	b.n	b060 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    b04a:	683b      	ldr	r3, [r7, #0]
    b04c:	b2da      	uxtb	r2, r3
    b04e:	4908      	ldr	r1, [pc, #32]	; (b070 <__NVIC_SetPriority+0x50>)
    b050:	79fb      	ldrb	r3, [r7, #7]
    b052:	f003 030f 	and.w	r3, r3, #15
    b056:	3b04      	subs	r3, #4
    b058:	0152      	lsls	r2, r2, #5
    b05a:	b2d2      	uxtb	r2, r2
    b05c:	440b      	add	r3, r1
    b05e:	761a      	strb	r2, [r3, #24]
}
    b060:	bf00      	nop
    b062:	370c      	adds	r7, #12
    b064:	46bd      	mov	sp, r7
    b066:	bc80      	pop	{r7}
    b068:	4770      	bx	lr
    b06a:	bf00      	nop
    b06c:	e000e100 	.word	0xe000e100
    b070:	e000ed00 	.word	0xe000ed00

0000b074 <z_dummy_thread_init>:
 * use it to properly store state, which will just be discarded.
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
    b074:	b480      	push	{r7}
    b076:	b083      	sub	sp, #12
    b078:	af00      	add	r7, sp, #0
    b07a:	6078      	str	r0, [r7, #4]
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    b07c:	687b      	ldr	r3, [r7, #4]
    b07e:	2201      	movs	r2, #1
    b080:	735a      	strb	r2, [r3, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    b082:	687b      	ldr	r3, [r7, #4]
    b084:	2201      	movs	r2, #1
    b086:	731a      	strb	r2, [r3, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    b088:	687b      	ldr	r3, [r7, #4]
    b08a:	2200      	movs	r2, #0
    b08c:	671a      	str	r2, [r3, #112]	; 0x70
	dummy_thread->stack_info.size = 0U;
    b08e:	687b      	ldr	r3, [r7, #4]
    b090:	2200      	movs	r2, #0
    b092:	675a      	str	r2, [r3, #116]	; 0x74
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    b094:	4a03      	ldr	r2, [pc, #12]	; (b0a4 <z_dummy_thread_init+0x30>)
    b096:	687b      	ldr	r3, [r7, #4]
    b098:	6093      	str	r3, [r2, #8]
}
    b09a:	bf00      	nop
    b09c:	370c      	adds	r7, #12
    b09e:	46bd      	mov	sp, r7
    b0a0:	bc80      	pop	{r7}
    b0a2:	4770      	bx	lr
    b0a4:	20000cd8 	.word	0x20000cd8

0000b0a8 <z_bss_zero>:
 * This routine clears the BSS region, so all bytes are 0.
 *
 * @return N/A
 */
void z_bss_zero(void)
{
    b0a8:	b580      	push	{r7, lr}
    b0aa:	af00      	add	r7, sp, #0
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    b0ac:	4a04      	ldr	r2, [pc, #16]	; (b0c0 <z_bss_zero+0x18>)
    b0ae:	4b05      	ldr	r3, [pc, #20]	; (b0c4 <z_bss_zero+0x1c>)
    b0b0:	1ad3      	subs	r3, r2, r3
    b0b2:	461a      	mov	r2, r3
    b0b4:	2100      	movs	r1, #0
    b0b6:	4803      	ldr	r0, [pc, #12]	; (b0c4 <z_bss_zero+0x1c>)
    b0b8:	f008 f88f 	bl	131da <memset>
#endif	/* CONFIG_CODE_DATA_RELOCATION */
#ifdef CONFIG_COVERAGE_GCOV
	(void)memset(&__gcov_bss_start, 0,
		 ((uint32_t) &__gcov_bss_end - (uint32_t) &__gcov_bss_start));
#endif
}
    b0bc:	bf00      	nop
    b0be:	bd80      	pop	{r7, pc}
    b0c0:	20000d48 	.word	0x20000d48
    b0c4:	200002c0 	.word	0x200002c0

0000b0c8 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    b0c8:	b580      	push	{r7, lr}
    b0ca:	af00      	add	r7, sp, #0
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    b0cc:	4a07      	ldr	r2, [pc, #28]	; (b0ec <z_data_copy+0x24>)
    b0ce:	4b08      	ldr	r3, [pc, #32]	; (b0f0 <z_data_copy+0x28>)
    b0d0:	1ad3      	subs	r3, r2, r3
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    b0d2:	461a      	mov	r2, r3
    b0d4:	4907      	ldr	r1, [pc, #28]	; (b0f4 <z_data_copy+0x2c>)
    b0d6:	4806      	ldr	r0, [pc, #24]	; (b0f0 <z_data_copy+0x28>)
    b0d8:	f008 f82a 	bl	13130 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    b0dc:	4b06      	ldr	r3, [pc, #24]	; (b0f8 <z_data_copy+0x30>)
    b0de:	461a      	mov	r2, r3
    b0e0:	4906      	ldr	r1, [pc, #24]	; (b0fc <z_data_copy+0x34>)
    b0e2:	4807      	ldr	r0, [pc, #28]	; (b100 <z_data_copy+0x38>)
    b0e4:	f008 f824 	bl	13130 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    b0e8:	bf00      	nop
    b0ea:	bd80      	pop	{r7, pc}
    b0ec:	200002bc 	.word	0x200002bc
    b0f0:	20000000 	.word	0x20000000
    b0f4:	0001cf34 	.word	0x0001cf34
    b0f8:	00000000 	.word	0x00000000
    b0fc:	0001cf34 	.word	0x0001cf34
    b100:	20000000 	.word	0x20000000

0000b104 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    b104:	b580      	push	{r7, lr}
    b106:	b084      	sub	sp, #16
    b108:	af00      	add	r7, sp, #0
    b10a:	60f8      	str	r0, [r7, #12]
    b10c:	60b9      	str	r1, [r7, #8]
    b10e:	607a      	str	r2, [r7, #4]
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
    b110:	4b13      	ldr	r3, [pc, #76]	; (b160 <bg_thread_main+0x5c>)
    b112:	2201      	movs	r2, #1
    b114:	701a      	strb	r2, [r3, #0]

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    b116:	2002      	movs	r0, #2
    b118:	f7ff fc98 	bl	aa4c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
    b11c:	4b11      	ldr	r3, [pc, #68]	; (b164 <bg_thread_main+0x60>)
    b11e:	681b      	ldr	r3, [r3, #0]
    b120:	2b00      	cmp	r3, #0
    b122:	d005      	beq.n	b130 <bg_thread_main+0x2c>
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
    b124:	4810      	ldr	r0, [pc, #64]	; (b168 <bg_thread_main+0x64>)
    b126:	f004 ff9f 	bl	10068 <printk>
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
    b12a:	2000      	movs	r0, #0
    b12c:	f00b fe28 	bl	16d80 <k_busy_wait>
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    b130:	4a0e      	ldr	r2, [pc, #56]	; (b16c <bg_thread_main+0x68>)
    b132:	490f      	ldr	r1, [pc, #60]	; (b170 <bg_thread_main+0x6c>)
    b134:	480f      	ldr	r0, [pc, #60]	; (b174 <bg_thread_main+0x70>)
    b136:	f004 ff97 	bl	10068 <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    b13a:	2003      	movs	r0, #3
    b13c:	f7ff fc86 	bl	aa4c <z_sys_init_run_level>

	z_init_static_threads();
    b140:	f003 fbf0 	bl	e924 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    b144:	f7f5 f9ea 	bl	51c <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    b148:	4b0b      	ldr	r3, [pc, #44]	; (b178 <bg_thread_main+0x74>)
    b14a:	7b1b      	ldrb	r3, [r3, #12]
    b14c:	f023 0301 	bic.w	r3, r3, #1
    b150:	b2da      	uxtb	r2, r3
    b152:	4b09      	ldr	r3, [pc, #36]	; (b178 <bg_thread_main+0x74>)
    b154:	731a      	strb	r2, [r3, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    b156:	bf00      	nop
    b158:	3710      	adds	r7, #16
    b15a:	46bd      	mov	sp, r7
    b15c:	bd80      	pop	{r7, pc}
    b15e:	bf00      	nop
    b160:	20000d45 	.word	0x20000d45
    b164:	0001ce08 	.word	0x0001ce08
    b168:	0001ba9c 	.word	0x0001ba9c
    b16c:	0001bad8 	.word	0x0001bad8
    b170:	0001badc 	.word	0x0001badc
    b174:	0001bafc 	.word	0x0001bafc
    b178:	20000528 	.word	0x20000528

0000b17c <init_idle_thread>:

/* LCOV_EXCL_STOP */

#if defined(CONFIG_MULTITHREADING)
static void init_idle_thread(int i)
{
    b17c:	b580      	push	{r7, lr}
    b17e:	b08c      	sub	sp, #48	; 0x30
    b180:	af06      	add	r7, sp, #24
    b182:	6078      	str	r0, [r7, #4]
	struct k_thread *thread = &z_idle_threads[i];
    b184:	687a      	ldr	r2, [r7, #4]
    b186:	4613      	mov	r3, r2
    b188:	011b      	lsls	r3, r3, #4
    b18a:	4413      	add	r3, r2
    b18c:	00db      	lsls	r3, r3, #3
    b18e:	4a16      	ldr	r2, [pc, #88]	; (b1e8 <init_idle_thread+0x6c>)
    b190:	4413      	add	r3, r2
    b192:	617b      	str	r3, [r7, #20]
	k_thread_stack_t *stack = z_idle_stacks[i];
    b194:	687a      	ldr	r2, [r7, #4]
    b196:	4613      	mov	r3, r2
    b198:	009b      	lsls	r3, r3, #2
    b19a:	4413      	add	r3, r2
    b19c:	019b      	lsls	r3, r3, #6
    b19e:	4a13      	ldr	r2, [pc, #76]	; (b1ec <init_idle_thread+0x70>)
    b1a0:	4413      	add	r3, r2
    b1a2:	613b      	str	r3, [r7, #16]
#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
    b1a4:	2300      	movs	r3, #0
    b1a6:	60fb      	str	r3, [r7, #12]
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    b1a8:	687a      	ldr	r2, [r7, #4]
    b1aa:	4613      	mov	r3, r2
    b1ac:	00db      	lsls	r3, r3, #3
    b1ae:	1a9b      	subs	r3, r3, r2
    b1b0:	009b      	lsls	r3, r3, #2
    b1b2:	4a0f      	ldr	r2, [pc, #60]	; (b1f0 <init_idle_thread+0x74>)
    b1b4:	4413      	add	r3, r2
	z_setup_new_thread(thread, stack,
    b1b6:	68fa      	ldr	r2, [r7, #12]
    b1b8:	9205      	str	r2, [sp, #20]
    b1ba:	2201      	movs	r2, #1
    b1bc:	9204      	str	r2, [sp, #16]
    b1be:	220f      	movs	r2, #15
    b1c0:	9203      	str	r2, [sp, #12]
    b1c2:	2200      	movs	r2, #0
    b1c4:	9202      	str	r2, [sp, #8]
    b1c6:	2200      	movs	r2, #0
    b1c8:	9201      	str	r2, [sp, #4]
    b1ca:	9300      	str	r3, [sp, #0]
    b1cc:	4b09      	ldr	r3, [pc, #36]	; (b1f4 <init_idle_thread+0x78>)
    b1ce:	f44f 72a0 	mov.w	r2, #320	; 0x140
    b1d2:	6939      	ldr	r1, [r7, #16]
    b1d4:	6978      	ldr	r0, [r7, #20]
    b1d6:	f003 fac7 	bl	e768 <z_setup_new_thread>
			  NULL, NULL, K_LOWEST_THREAD_PRIO, K_ESSENTIAL,
			  tname);
	z_mark_thread_as_started(thread);
    b1da:	6978      	ldr	r0, [r7, #20]
    b1dc:	f00b fddb 	bl	16d96 <z_mark_thread_as_started>

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    b1e0:	bf00      	nop
    b1e2:	3718      	adds	r7, #24
    b1e4:	46bd      	mov	sp, r7
    b1e6:	bd80      	pop	{r7, pc}
    b1e8:	200005b0 	.word	0x200005b0
    b1ec:	20001d48 	.word	0x20001d48
    b1f0:	20000cd8 	.word	0x20000cd8
    b1f4:	0000af11 	.word	0x0000af11

0000b1f8 <prepare_multithreading>:
 *
 * @return initial stack pointer for the main thread
 */
#ifdef CONFIG_MULTITHREADING
static char *prepare_multithreading(void)
{
    b1f8:	b580      	push	{r7, lr}
    b1fa:	b088      	sub	sp, #32
    b1fc:	af06      	add	r7, sp, #24
	char *stack_ptr;

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    b1fe:	f002 fe21 	bl	de44 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    b202:	4b30      	ldr	r3, [pc, #192]	; (b2c4 <prepare_multithreading+0xcc>)
    b204:	4a30      	ldr	r2, [pc, #192]	; (b2c8 <prepare_multithreading+0xd0>)
    b206:	629a      	str	r2, [r3, #40]	; 0x28
#endif
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    b208:	4b30      	ldr	r3, [pc, #192]	; (b2cc <prepare_multithreading+0xd4>)
    b20a:	9305      	str	r3, [sp, #20]
    b20c:	2301      	movs	r3, #1
    b20e:	9304      	str	r3, [sp, #16]
    b210:	2300      	movs	r3, #0
    b212:	9303      	str	r3, [sp, #12]
    b214:	2300      	movs	r3, #0
    b216:	9302      	str	r3, [sp, #8]
    b218:	2300      	movs	r3, #0
    b21a:	9301      	str	r3, [sp, #4]
    b21c:	2300      	movs	r3, #0
    b21e:	9300      	str	r3, [sp, #0]
    b220:	4b2b      	ldr	r3, [pc, #172]	; (b2d0 <prepare_multithreading+0xd8>)
    b222:	f44f 6280 	mov.w	r2, #1024	; 0x400
    b226:	492b      	ldr	r1, [pc, #172]	; (b2d4 <prepare_multithreading+0xdc>)
    b228:	4827      	ldr	r0, [pc, #156]	; (b2c8 <prepare_multithreading+0xd0>)
    b22a:	f003 fa9d 	bl	e768 <z_setup_new_thread>
    b22e:	6038      	str	r0, [r7, #0]
				       CONFIG_MAIN_STACK_SIZE, bg_thread_main,
				       NULL, NULL, NULL,
				       CONFIG_MAIN_THREAD_PRIORITY,
				       K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
    b230:	4825      	ldr	r0, [pc, #148]	; (b2c8 <prepare_multithreading+0xd0>)
    b232:	f00b fdb0 	bl	16d96 <z_mark_thread_as_started>
	z_ready_thread(&z_main_thread);
    b236:	4824      	ldr	r0, [pc, #144]	; (b2c8 <prepare_multithreading+0xd0>)
    b238:	f001 fc86 	bl	cb48 <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    b23c:	2300      	movs	r3, #0
    b23e:	607b      	str	r3, [r7, #4]
    b240:	e034      	b.n	b2ac <prepare_multithreading+0xb4>
		init_idle_thread(i);
    b242:	6878      	ldr	r0, [r7, #4]
    b244:	f7ff ff9a 	bl	b17c <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    b248:	687a      	ldr	r2, [r7, #4]
    b24a:	4613      	mov	r3, r2
    b24c:	011b      	lsls	r3, r3, #4
    b24e:	4413      	add	r3, r2
    b250:	00db      	lsls	r3, r3, #3
    b252:	4a21      	ldr	r2, [pc, #132]	; (b2d8 <prepare_multithreading+0xe0>)
    b254:	1899      	adds	r1, r3, r2
    b256:	481b      	ldr	r0, [pc, #108]	; (b2c4 <prepare_multithreading+0xcc>)
    b258:	687a      	ldr	r2, [r7, #4]
    b25a:	4613      	mov	r3, r2
    b25c:	00db      	lsls	r3, r3, #3
    b25e:	1a9b      	subs	r3, r3, r2
    b260:	009b      	lsls	r3, r3, #2
    b262:	4403      	add	r3, r0
    b264:	330c      	adds	r3, #12
    b266:	6019      	str	r1, [r3, #0]
		_kernel.cpus[i].id = i;
    b268:	687b      	ldr	r3, [r7, #4]
    b26a:	b2d8      	uxtb	r0, r3
    b26c:	4915      	ldr	r1, [pc, #84]	; (b2c4 <prepare_multithreading+0xcc>)
    b26e:	687a      	ldr	r2, [r7, #4]
    b270:	4613      	mov	r3, r2
    b272:	00db      	lsls	r3, r3, #3
    b274:	1a9b      	subs	r3, r3, r2
    b276:	009b      	lsls	r3, r3, #2
    b278:	440b      	add	r3, r1
    b27a:	3318      	adds	r3, #24
    b27c:	4602      	mov	r2, r0
    b27e:	701a      	strb	r2, [r3, #0]
		_kernel.cpus[i].irq_stack =
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
    b280:	687b      	ldr	r3, [r7, #4]
    b282:	02db      	lsls	r3, r3, #11
    b284:	4a15      	ldr	r2, [pc, #84]	; (b2dc <prepare_multithreading+0xe4>)
    b286:	4413      	add	r3, r2
    b288:	4618      	mov	r0, r3
    b28a:	f00b fd6f 	bl	16d6c <Z_KERNEL_STACK_BUFFER>
    b28e:	4603      	mov	r3, r0
    b290:	f503 6100 	add.w	r1, r3, #2048	; 0x800
		_kernel.cpus[i].irq_stack =
    b294:	480b      	ldr	r0, [pc, #44]	; (b2c4 <prepare_multithreading+0xcc>)
    b296:	687a      	ldr	r2, [r7, #4]
    b298:	4613      	mov	r3, r2
    b29a:	00db      	lsls	r3, r3, #3
    b29c:	1a9b      	subs	r3, r3, r2
    b29e:	009b      	lsls	r3, r3, #2
    b2a0:	4403      	add	r3, r0
    b2a2:	3304      	adds	r3, #4
    b2a4:	6019      	str	r1, [r3, #0]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    b2a6:	687b      	ldr	r3, [r7, #4]
    b2a8:	3301      	adds	r3, #1
    b2aa:	607b      	str	r3, [r7, #4]
    b2ac:	687b      	ldr	r3, [r7, #4]
    b2ae:	2b00      	cmp	r3, #0
    b2b0:	ddc7      	ble.n	b242 <prepare_multithreading+0x4a>
			 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]));
	}

	initialize_timeouts();
    b2b2:	480b      	ldr	r0, [pc, #44]	; (b2e0 <prepare_multithreading+0xe8>)
    b2b4:	f00b fd4b 	bl	16d4e <sys_dlist_init>

	return stack_ptr;
    b2b8:	683b      	ldr	r3, [r7, #0]
}
    b2ba:	4618      	mov	r0, r3
    b2bc:	3708      	adds	r7, #8
    b2be:	46bd      	mov	sp, r7
    b2c0:	bd80      	pop	{r7, pc}
    b2c2:	bf00      	nop
    b2c4:	20000cd8 	.word	0x20000cd8
    b2c8:	20000528 	.word	0x20000528
    b2cc:	0001bb24 	.word	0x0001bb24
    b2d0:	0000b105 	.word	0x0000b105
    b2d4:	20001948 	.word	0x20001948
    b2d8:	200005b0 	.word	0x200005b0
    b2dc:	20001148 	.word	0x20001148
    b2e0:	20000cf4 	.word	0x20000cf4

0000b2e4 <switch_to_main_thread>:

static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    b2e4:	b580      	push	{r7, lr}
    b2e6:	b082      	sub	sp, #8
    b2e8:	af00      	add	r7, sp, #0
    b2ea:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    b2ec:	4a02      	ldr	r2, [pc, #8]	; (b2f8 <switch_to_main_thread+0x14>)
    b2ee:	6879      	ldr	r1, [r7, #4]
    b2f0:	4802      	ldr	r0, [pc, #8]	; (b2fc <switch_to_main_thread+0x18>)
    b2f2:	f7f9 fc69 	bl	4bc8 <arch_switch_to_main_thread>
    b2f6:	bf00      	nop
    b2f8:	0000b105 	.word	0x0000b105
    b2fc:	20000528 	.word	0x20000528

0000b300 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    b300:	b580      	push	{r7, lr}
    b302:	b0a6      	sub	sp, #152	; 0x98
    b304:	af00      	add	r7, sp, #0
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();
    b306:	f00b fd56 	bl	16db6 <gcov_static_init>

	LOG_CORE_INIT();
    b30a:	f7f7 f8a1 	bl	2450 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
    b30e:	482c      	ldr	r0, [pc, #176]	; (b3c0 <z_cstart+0xc0>)
    b310:	f00b fd2c 	bl	16d6c <Z_KERNEL_STACK_BUFFER>
    b314:	4603      	mov	r3, r0
	uint32_t msp =
    b316:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    b31a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    b31e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
    b322:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    b326:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    b32a:	f383 8808 	msr	MSP, r3
}
    b32e:	bf00      	nop
			   K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[0]);

	__set_MSP(msp);
#if defined(CONFIG_BUILTIN_STACK_GUARD)
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
	__set_MSPLIM((uint32_t)z_interrupt_stacks[0]);
    b330:	4b23      	ldr	r3, [pc, #140]	; (b3c0 <z_cstart+0xc0>)
    b332:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
    b336:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    b33a:	f383 880a 	msr	MSPLIM, r3
}
    b33e:	bf00      	nop
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
#endif
#endif /* CONFIG_STACK_ALIGN_DOUBLE_WORD */
}
    b340:	bf00      	nop
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_exc_setup(void)
{
	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
    b342:	21ff      	movs	r1, #255	; 0xff
    b344:	f06f 0001 	mvn.w	r0, #1
    b348:	f7ff fe6a 	bl	b020 <__NVIC_SetPriority>

#ifdef CONFIG_CPU_CORTEX_M_HAS_BASEPRI
	/* Note: SVCall IRQ priority level is left to default (0)
	 * for Cortex-M variants without BASEPRI (e.g. ARMv6-M).
	 */
	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
    b34c:	2100      	movs	r1, #0
    b34e:	f06f 0004 	mvn.w	r0, #4
    b352:	f7ff fe65 	bl	b020 <__NVIC_SetPriority>
#endif

#ifdef CONFIG_CPU_CORTEX_M_HAS_PROGRAMMABLE_FAULT_PRIOS
	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
    b356:	2100      	movs	r1, #0
    b358:	f06f 000b 	mvn.w	r0, #11
    b35c:	f7ff fe60 	bl	b020 <__NVIC_SetPriority>
	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
    b360:	2100      	movs	r1, #0
    b362:	f06f 000a 	mvn.w	r0, #10
    b366:	f7ff fe5b 	bl	b020 <__NVIC_SetPriority>
	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
    b36a:	2100      	movs	r1, #0
    b36c:	f06f 0009 	mvn.w	r0, #9
    b370:	f7ff fe56 	bl	b020 <__NVIC_SetPriority>
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    b374:	4b13      	ldr	r3, [pc, #76]	; (b3c4 <z_cstart+0xc4>)
    b376:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    b378:	4a12      	ldr	r2, [pc, #72]	; (b3c4 <z_cstart+0xc4>)
    b37a:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    b37e:	6253      	str	r3, [r2, #36]	; 0x24
	/* Note: Fault conditions that would generate a SecureFault
	 * in a PE with the Main Extension instead generate a
	 * SecureHardFault in a PE without the Main Extension.
	 */
#endif /* ARM_SECURE_FIRMWARE && !ARM_SECURE_BUSFAULT_HARDFAULT_NMI */
}
    b380:	bf00      	nop

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    b382:	f7fa fe61 	bl	6048 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    b386:	f7f9 fc43 	bl	4c10 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    b38a:	4b0e      	ldr	r3, [pc, #56]	; (b3c4 <z_cstart+0xc4>)
    b38c:	f04f 32ff 	mov.w	r2, #4294967295
    b390:	629a      	str	r2, [r3, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    b392:	4b0c      	ldr	r3, [pc, #48]	; (b3c4 <z_cstart+0xc4>)
    b394:	f04f 32ff 	mov.w	r2, #4294967295
    b398:	62da      	str	r2, [r3, #44]	; 0x2c
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    b39a:	bf00      	nop
	z_arm_clear_faults();
}
    b39c:	bf00      	nop
	/* Note: The z_ready_thread() call in prepare_multithreading() requires
	 * a dummy thread even if CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN=y
	 */
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
    b39e:	463b      	mov	r3, r7
    b3a0:	4618      	mov	r0, r3
    b3a2:	f7ff fe67 	bl	b074 <z_dummy_thread_init>
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    b3a6:	2000      	movs	r0, #0
    b3a8:	f7ff fb50 	bl	aa4c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    b3ac:	2001      	movs	r0, #1
    b3ae:	f7ff fb4d 	bl	aa4c <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    b3b2:	f7ff ff21 	bl	b1f8 <prepare_multithreading>
    b3b6:	4603      	mov	r3, r0
    b3b8:	4618      	mov	r0, r3
    b3ba:	f7ff ff93 	bl	b2e4 <switch_to_main_thread>
    b3be:	bf00      	nop
    b3c0:	20001148 	.word	0x20001148
    b3c4:	e000ed00 	.word	0xe000ed00

0000b3c8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
    b3c8:	b580      	push	{r7, lr}
    b3ca:	b084      	sub	sp, #16
    b3cc:	af00      	add	r7, sp, #0
    b3ce:	6078      	str	r0, [r7, #4]
	int rc = 0;
    b3d0:	2300      	movs	r3, #0
    b3d2:	60fb      	str	r3, [r7, #12]
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    b3d4:	4b18      	ldr	r3, [pc, #96]	; (b438 <init_mem_slab_module+0x70>)
    b3d6:	60bb      	str	r3, [r7, #8]
    b3d8:	e00c      	b.n	b3f4 <init_mem_slab_module+0x2c>
		rc = create_free_list(slab);
    b3da:	68b8      	ldr	r0, [r7, #8]
    b3dc:	f00b fd15 	bl	16e0a <create_free_list>
    b3e0:	60f8      	str	r0, [r7, #12]
		if (rc < 0) {
    b3e2:	68fb      	ldr	r3, [r7, #12]
    b3e4:	2b00      	cmp	r3, #0
    b3e6:	db20      	blt.n	b42a <init_mem_slab_module+0x62>
			goto out;
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
    b3e8:	68b8      	ldr	r0, [r7, #8]
    b3ea:	f00b fcf9 	bl	16de0 <z_object_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    b3ee:	68bb      	ldr	r3, [r7, #8]
    b3f0:	331c      	adds	r3, #28
    b3f2:	60bb      	str	r3, [r7, #8]
    b3f4:	68bb      	ldr	r3, [r7, #8]
    b3f6:	4a11      	ldr	r2, [pc, #68]	; (b43c <init_mem_slab_module+0x74>)
    b3f8:	4293      	cmp	r3, r2
    b3fa:	d90c      	bls.n	b416 <init_mem_slab_module+0x4e>
    b3fc:	2342      	movs	r3, #66	; 0x42
    b3fe:	4a10      	ldr	r2, [pc, #64]	; (b440 <init_mem_slab_module+0x78>)
    b400:	4910      	ldr	r1, [pc, #64]	; (b444 <init_mem_slab_module+0x7c>)
    b402:	4811      	ldr	r0, [pc, #68]	; (b448 <init_mem_slab_module+0x80>)
    b404:	f004 fe30 	bl	10068 <printk>
    b408:	4810      	ldr	r0, [pc, #64]	; (b44c <init_mem_slab_module+0x84>)
    b40a:	f004 fe2d 	bl	10068 <printk>
    b40e:	2142      	movs	r1, #66	; 0x42
    b410:	480b      	ldr	r0, [pc, #44]	; (b440 <init_mem_slab_module+0x78>)
    b412:	f005 fc71 	bl	10cf8 <assert_post_action>
    b416:	68bb      	ldr	r3, [r7, #8]
    b418:	4a08      	ldr	r2, [pc, #32]	; (b43c <init_mem_slab_module+0x74>)
    b41a:	4293      	cmp	r3, r2
    b41c:	bf34      	ite	cc
    b41e:	2301      	movcc	r3, #1
    b420:	2300      	movcs	r3, #0
    b422:	b2db      	uxtb	r3, r3
    b424:	2b00      	cmp	r3, #0
    b426:	d1d8      	bne.n	b3da <init_mem_slab_module+0x12>
	}

out:
    b428:	e000      	b.n	b42c <init_mem_slab_module+0x64>
			goto out;
    b42a:	bf00      	nop
	return rc;
    b42c:	68fb      	ldr	r3, [r7, #12]
}
    b42e:	4618      	mov	r0, r3
    b430:	3710      	adds	r7, #16
    b432:	46bd      	mov	sp, r7
    b434:	bd80      	pop	{r7, pc}
    b436:	bf00      	nop
    b438:	2000025c 	.word	0x2000025c
    b43c:	2000025c 	.word	0x2000025c
    b440:	0001bb2c 	.word	0x0001bb2c
    b444:	0001bb54 	.word	0x0001bb54
    b448:	0001bb74 	.word	0x0001bb74
    b44c:	0001bb94 	.word	0x0001bb94

0000b450 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    b450:	b580      	push	{r7, lr}
    b452:	b090      	sub	sp, #64	; 0x40
    b454:	af02      	add	r7, sp, #8
    b456:	60f8      	str	r0, [r7, #12]
    b458:	60b9      	str	r1, [r7, #8]
    b45a:	e9c7 2300 	strd	r2, r3, [r7]
    b45e:	4b47      	ldr	r3, [pc, #284]	; (b57c <k_mem_slab_alloc+0x12c>)
    b460:	633b      	str	r3, [r7, #48]	; 0x30
    b462:	f04f 0320 	mov.w	r3, #32
    b466:	f3ef 8211 	mrs	r2, BASEPRI
    b46a:	f383 8811 	msr	BASEPRI, r3
    b46e:	f3bf 8f6f 	isb	sy
    b472:	62fa      	str	r2, [r7, #44]	; 0x2c
    b474:	62bb      	str	r3, [r7, #40]	; 0x28
	return key;
    b476:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	k.key = arch_irq_lock();
    b478:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    b47a:	6b38      	ldr	r0, [r7, #48]	; 0x30
    b47c:	f003 faec 	bl	ea58 <z_spin_lock_valid>
    b480:	4603      	mov	r3, r0
    b482:	f083 0301 	eor.w	r3, r3, #1
    b486:	b2db      	uxtb	r3, r3
    b488:	2b00      	cmp	r3, #0
    b48a:	d00d      	beq.n	b4a8 <k_mem_slab_alloc+0x58>
    b48c:	2378      	movs	r3, #120	; 0x78
    b48e:	4a3c      	ldr	r2, [pc, #240]	; (b580 <k_mem_slab_alloc+0x130>)
    b490:	493c      	ldr	r1, [pc, #240]	; (b584 <k_mem_slab_alloc+0x134>)
    b492:	483d      	ldr	r0, [pc, #244]	; (b588 <k_mem_slab_alloc+0x138>)
    b494:	f004 fde8 	bl	10068 <printk>
    b498:	6b39      	ldr	r1, [r7, #48]	; 0x30
    b49a:	483c      	ldr	r0, [pc, #240]	; (b58c <k_mem_slab_alloc+0x13c>)
    b49c:	f004 fde4 	bl	10068 <printk>
    b4a0:	2178      	movs	r1, #120	; 0x78
    b4a2:	4837      	ldr	r0, [pc, #220]	; (b580 <k_mem_slab_alloc+0x130>)
    b4a4:	f005 fc28 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    b4a8:	6b38      	ldr	r0, [r7, #48]	; 0x30
    b4aa:	f003 fb0d 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    b4ae:	697b      	ldr	r3, [r7, #20]
    b4b0:	61fb      	str	r3, [r7, #28]
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    b4b2:	68fb      	ldr	r3, [r7, #12]
    b4b4:	695b      	ldr	r3, [r3, #20]
    b4b6:	2b00      	cmp	r3, #0
    b4b8:	d010      	beq.n	b4dc <k_mem_slab_alloc+0x8c>
		/* take a free block */
		*mem = slab->free_list;
    b4ba:	68fb      	ldr	r3, [r7, #12]
    b4bc:	695a      	ldr	r2, [r3, #20]
    b4be:	68bb      	ldr	r3, [r7, #8]
    b4c0:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)(slab->free_list);
    b4c2:	68fb      	ldr	r3, [r7, #12]
    b4c4:	695b      	ldr	r3, [r3, #20]
    b4c6:	681a      	ldr	r2, [r3, #0]
    b4c8:	68fb      	ldr	r3, [r7, #12]
    b4ca:	615a      	str	r2, [r3, #20]
		slab->num_used++;
    b4cc:	68fb      	ldr	r3, [r7, #12]
    b4ce:	699b      	ldr	r3, [r3, #24]
    b4d0:	1c5a      	adds	r2, r3, #1
    b4d2:	68fb      	ldr	r3, [r7, #12]
    b4d4:	619a      	str	r2, [r3, #24]
		result = 0;
    b4d6:	2300      	movs	r3, #0
    b4d8:	637b      	str	r3, [r7, #52]	; 0x34
    b4da:	e025      	b.n	b528 <k_mem_slab_alloc+0xd8>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    b4dc:	e9d7 2300 	ldrd	r2, r3, [r7]
    b4e0:	f04f 0000 	mov.w	r0, #0
    b4e4:	f04f 0100 	mov.w	r1, #0
    b4e8:	428b      	cmp	r3, r1
    b4ea:	bf08      	it	eq
    b4ec:	4282      	cmpeq	r2, r0
    b4ee:	d106      	bne.n	b4fe <k_mem_slab_alloc+0xae>
		/* don't wait for a free block to become available */
		*mem = NULL;
    b4f0:	68bb      	ldr	r3, [r7, #8]
    b4f2:	2200      	movs	r2, #0
    b4f4:	601a      	str	r2, [r3, #0]
		result = -ENOMEM;
    b4f6:	f06f 030b 	mvn.w	r3, #11
    b4fa:	637b      	str	r3, [r7, #52]	; 0x34
    b4fc:	e014      	b.n	b528 <k_mem_slab_alloc+0xd8>
	} else {
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    b4fe:	68f9      	ldr	r1, [r7, #12]
    b500:	e9d7 2300 	ldrd	r2, r3, [r7]
    b504:	e9cd 2300 	strd	r2, r3, [sp]
    b508:	460a      	mov	r2, r1
    b50a:	69f9      	ldr	r1, [r7, #28]
    b50c:	481b      	ldr	r0, [pc, #108]	; (b57c <k_mem_slab_alloc+0x12c>)
    b50e:	f002 f957 	bl	d7c0 <z_pend_curr>
    b512:	6378      	str	r0, [r7, #52]	; 0x34
		if (result == 0) {
    b514:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b516:	2b00      	cmp	r3, #0
    b518:	d104      	bne.n	b524 <k_mem_slab_alloc+0xd4>
			*mem = _current->base.swap_data;
    b51a:	4b1d      	ldr	r3, [pc, #116]	; (b590 <k_mem_slab_alloc+0x140>)
    b51c:	689b      	ldr	r3, [r3, #8]
    b51e:	695a      	ldr	r2, [r3, #20]
    b520:	68bb      	ldr	r3, [r7, #8]
    b522:	601a      	str	r2, [r3, #0]
		}
		return result;
    b524:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b526:	e024      	b.n	b572 <k_mem_slab_alloc+0x122>
    b528:	4b14      	ldr	r3, [pc, #80]	; (b57c <k_mem_slab_alloc+0x12c>)
    b52a:	627b      	str	r3, [r7, #36]	; 0x24
    b52c:	69fb      	ldr	r3, [r7, #28]
    b52e:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    b530:	6a78      	ldr	r0, [r7, #36]	; 0x24
    b532:	f003 faad 	bl	ea90 <z_spin_unlock_valid>
    b536:	4603      	mov	r3, r0
    b538:	f083 0301 	eor.w	r3, r3, #1
    b53c:	b2db      	uxtb	r3, r3
    b53e:	2b00      	cmp	r3, #0
    b540:	d00d      	beq.n	b55e <k_mem_slab_alloc+0x10e>
    b542:	23a3      	movs	r3, #163	; 0xa3
    b544:	4a0e      	ldr	r2, [pc, #56]	; (b580 <k_mem_slab_alloc+0x130>)
    b546:	4913      	ldr	r1, [pc, #76]	; (b594 <k_mem_slab_alloc+0x144>)
    b548:	480f      	ldr	r0, [pc, #60]	; (b588 <k_mem_slab_alloc+0x138>)
    b54a:	f004 fd8d 	bl	10068 <printk>
    b54e:	6a79      	ldr	r1, [r7, #36]	; 0x24
    b550:	4811      	ldr	r0, [pc, #68]	; (b598 <k_mem_slab_alloc+0x148>)
    b552:	f004 fd89 	bl	10068 <printk>
    b556:	21a3      	movs	r1, #163	; 0xa3
    b558:	4809      	ldr	r0, [pc, #36]	; (b580 <k_mem_slab_alloc+0x130>)
    b55a:	f005 fbcd 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    b55e:	69bb      	ldr	r3, [r7, #24]
    b560:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    b562:	6a3b      	ldr	r3, [r7, #32]
    b564:	f383 8811 	msr	BASEPRI, r3
    b568:	f3bf 8f6f 	isb	sy
}
    b56c:	bf00      	nop
}
    b56e:	bf00      	nop
	}

	k_spin_unlock(&lock, key);

	return result;
    b570:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
    b572:	4618      	mov	r0, r3
    b574:	3738      	adds	r7, #56	; 0x38
    b576:	46bd      	mov	sp, r7
    b578:	bd80      	pop	{r7, pc}
    b57a:	bf00      	nop
    b57c:	20000cd0 	.word	0x20000cd0
    b580:	0001bbb4 	.word	0x0001bbb4
    b584:	0001bbdc 	.word	0x0001bbdc
    b588:	0001bb74 	.word	0x0001bb74
    b58c:	0001bbf4 	.word	0x0001bbf4
    b590:	20000cd8 	.word	0x20000cd8
    b594:	0001bc0c 	.word	0x0001bc0c
    b598:	0001bc24 	.word	0x0001bc24

0000b59c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    b59c:	b580      	push	{r7, lr}
    b59e:	b090      	sub	sp, #64	; 0x40
    b5a0:	af00      	add	r7, sp, #0
    b5a2:	6078      	str	r0, [r7, #4]
    b5a4:	6039      	str	r1, [r7, #0]
    b5a6:	4b42      	ldr	r3, [pc, #264]	; (b6b0 <k_mem_slab_free+0x114>)
    b5a8:	63bb      	str	r3, [r7, #56]	; 0x38
	__asm__ volatile(
    b5aa:	f04f 0320 	mov.w	r3, #32
    b5ae:	f3ef 8211 	mrs	r2, BASEPRI
    b5b2:	f383 8811 	msr	BASEPRI, r3
    b5b6:	f3bf 8f6f 	isb	sy
    b5ba:	637a      	str	r2, [r7, #52]	; 0x34
    b5bc:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
    b5be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	k.key = arch_irq_lock();
    b5c0:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    b5c2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    b5c4:	f003 fa48 	bl	ea58 <z_spin_lock_valid>
    b5c8:	4603      	mov	r3, r0
    b5ca:	f083 0301 	eor.w	r3, r3, #1
    b5ce:	b2db      	uxtb	r3, r3
    b5d0:	2b00      	cmp	r3, #0
    b5d2:	d00d      	beq.n	b5f0 <k_mem_slab_free+0x54>
    b5d4:	2378      	movs	r3, #120	; 0x78
    b5d6:	4a37      	ldr	r2, [pc, #220]	; (b6b4 <k_mem_slab_free+0x118>)
    b5d8:	4937      	ldr	r1, [pc, #220]	; (b6b8 <k_mem_slab_free+0x11c>)
    b5da:	4838      	ldr	r0, [pc, #224]	; (b6bc <k_mem_slab_free+0x120>)
    b5dc:	f004 fd44 	bl	10068 <printk>
    b5e0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    b5e2:	4837      	ldr	r0, [pc, #220]	; (b6c0 <k_mem_slab_free+0x124>)
    b5e4:	f004 fd40 	bl	10068 <printk>
    b5e8:	2178      	movs	r1, #120	; 0x78
    b5ea:	4832      	ldr	r0, [pc, #200]	; (b6b4 <k_mem_slab_free+0x118>)
    b5ec:	f005 fb84 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    b5f0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    b5f2:	f003 fa69 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    b5f6:	68bb      	ldr	r3, [r7, #8]
    b5f8:	613b      	str	r3, [r7, #16]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    b5fa:	687b      	ldr	r3, [r7, #4]
    b5fc:	4618      	mov	r0, r3
    b5fe:	f00c faec 	bl	17bda <z_unpend_first_thread>
    b602:	63f8      	str	r0, [r7, #60]	; 0x3c

	if (pending_thread != NULL) {
    b604:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    b606:	2b00      	cmp	r3, #0
    b608:	d01b      	beq.n	b642 <k_mem_slab_free+0xa6>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    b60a:	683b      	ldr	r3, [r7, #0]
    b60c:	681b      	ldr	r3, [r3, #0]
    b60e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    b610:	62fa      	str	r2, [r7, #44]	; 0x2c
    b612:	2200      	movs	r2, #0
    b614:	62ba      	str	r2, [r7, #40]	; 0x28
    b616:	627b      	str	r3, [r7, #36]	; 0x24
    b618:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b61a:	623b      	str	r3, [r7, #32]
    b61c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    b61e:	61fb      	str	r3, [r7, #28]

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    b620:	6a3b      	ldr	r3, [r7, #32]
    b622:	69fa      	ldr	r2, [r7, #28]
    b624:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    b628:	bf00      	nop
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    b62a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b62c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    b62e:	615a      	str	r2, [r3, #20]
}
    b630:	bf00      	nop
		z_ready_thread(pending_thread);
    b632:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    b634:	f001 fa88 	bl	cb48 <z_ready_thread>
		z_reschedule(&lock, key);
    b638:	6939      	ldr	r1, [r7, #16]
    b63a:	481d      	ldr	r0, [pc, #116]	; (b6b0 <k_mem_slab_free+0x114>)
    b63c:	f002 f9fe 	bl	da3c <z_reschedule>
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    b640:	e031      	b.n	b6a6 <k_mem_slab_free+0x10a>
		**(char ***)mem = slab->free_list;
    b642:	683b      	ldr	r3, [r7, #0]
    b644:	681b      	ldr	r3, [r3, #0]
    b646:	687a      	ldr	r2, [r7, #4]
    b648:	6952      	ldr	r2, [r2, #20]
    b64a:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    b64c:	683b      	ldr	r3, [r7, #0]
    b64e:	681a      	ldr	r2, [r3, #0]
    b650:	687b      	ldr	r3, [r7, #4]
    b652:	615a      	str	r2, [r3, #20]
		slab->num_used--;
    b654:	687b      	ldr	r3, [r7, #4]
    b656:	699b      	ldr	r3, [r3, #24]
    b658:	1e5a      	subs	r2, r3, #1
    b65a:	687b      	ldr	r3, [r7, #4]
    b65c:	619a      	str	r2, [r3, #24]
    b65e:	4b14      	ldr	r3, [pc, #80]	; (b6b0 <k_mem_slab_free+0x114>)
    b660:	61bb      	str	r3, [r7, #24]
    b662:	693b      	ldr	r3, [r7, #16]
    b664:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    b666:	69b8      	ldr	r0, [r7, #24]
    b668:	f003 fa12 	bl	ea90 <z_spin_unlock_valid>
    b66c:	4603      	mov	r3, r0
    b66e:	f083 0301 	eor.w	r3, r3, #1
    b672:	b2db      	uxtb	r3, r3
    b674:	2b00      	cmp	r3, #0
    b676:	d00d      	beq.n	b694 <k_mem_slab_free+0xf8>
    b678:	23a3      	movs	r3, #163	; 0xa3
    b67a:	4a0e      	ldr	r2, [pc, #56]	; (b6b4 <k_mem_slab_free+0x118>)
    b67c:	4911      	ldr	r1, [pc, #68]	; (b6c4 <k_mem_slab_free+0x128>)
    b67e:	480f      	ldr	r0, [pc, #60]	; (b6bc <k_mem_slab_free+0x120>)
    b680:	f004 fcf2 	bl	10068 <printk>
    b684:	69b9      	ldr	r1, [r7, #24]
    b686:	4810      	ldr	r0, [pc, #64]	; (b6c8 <k_mem_slab_free+0x12c>)
    b688:	f004 fcee 	bl	10068 <printk>
    b68c:	21a3      	movs	r1, #163	; 0xa3
    b68e:	4809      	ldr	r0, [pc, #36]	; (b6b4 <k_mem_slab_free+0x118>)
    b690:	f005 fb32 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    b694:	68fb      	ldr	r3, [r7, #12]
    b696:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    b698:	697b      	ldr	r3, [r7, #20]
    b69a:	f383 8811 	msr	BASEPRI, r3
    b69e:	f3bf 8f6f 	isb	sy
}
    b6a2:	bf00      	nop
}
    b6a4:	bf00      	nop
}
    b6a6:	bf00      	nop
    b6a8:	3740      	adds	r7, #64	; 0x40
    b6aa:	46bd      	mov	sp, r7
    b6ac:	bd80      	pop	{r7, pc}
    b6ae:	bf00      	nop
    b6b0:	20000cd0 	.word	0x20000cd0
    b6b4:	0001bbb4 	.word	0x0001bbb4
    b6b8:	0001bbdc 	.word	0x0001bbdc
    b6bc:	0001bb74 	.word	0x0001bb74
    b6c0:	0001bbf4 	.word	0x0001bbf4
    b6c4:	0001bc0c 	.word	0x0001bc0c
    b6c8:	0001bc24 	.word	0x0001bc24

0000b6cc <z_sched_lock>:
		z_ready_thread(thread);
	}
}

static inline void z_sched_lock(void)
{
    b6cc:	b580      	push	{r7, lr}
    b6ce:	b082      	sub	sp, #8
    b6d0:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    b6d2:	f3ef 8305 	mrs	r3, IPSR
    b6d6:	607b      	str	r3, [r7, #4]
  return(result);
    b6d8:	687b      	ldr	r3, [r7, #4]
	return (__get_IPSR()) ? (true) : (false);
    b6da:	2b00      	cmp	r3, #0
    b6dc:	bf14      	ite	ne
    b6de:	2301      	movne	r3, #1
    b6e0:	2300      	moveq	r3, #0
    b6e2:	b2db      	uxtb	r3, r3
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
    b6e4:	2b00      	cmp	r3, #0
    b6e6:	d00e      	beq.n	b706 <z_sched_lock+0x3a>
    b6e8:	f44f 7389 	mov.w	r3, #274	; 0x112
    b6ec:	4a15      	ldr	r2, [pc, #84]	; (b744 <z_sched_lock+0x78>)
    b6ee:	4916      	ldr	r1, [pc, #88]	; (b748 <z_sched_lock+0x7c>)
    b6f0:	4816      	ldr	r0, [pc, #88]	; (b74c <z_sched_lock+0x80>)
    b6f2:	f004 fcb9 	bl	10068 <printk>
    b6f6:	4816      	ldr	r0, [pc, #88]	; (b750 <z_sched_lock+0x84>)
    b6f8:	f004 fcb6 	bl	10068 <printk>
    b6fc:	f44f 7189 	mov.w	r1, #274	; 0x112
    b700:	4810      	ldr	r0, [pc, #64]	; (b744 <z_sched_lock+0x78>)
    b702:	f005 faf9 	bl	10cf8 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
    b706:	4b13      	ldr	r3, [pc, #76]	; (b754 <z_sched_lock+0x88>)
    b708:	689b      	ldr	r3, [r3, #8]
    b70a:	7bdb      	ldrb	r3, [r3, #15]
    b70c:	2b01      	cmp	r3, #1
    b70e:	d10e      	bne.n	b72e <z_sched_lock+0x62>
    b710:	f240 1313 	movw	r3, #275	; 0x113
    b714:	4a0b      	ldr	r2, [pc, #44]	; (b744 <z_sched_lock+0x78>)
    b716:	4910      	ldr	r1, [pc, #64]	; (b758 <z_sched_lock+0x8c>)
    b718:	480c      	ldr	r0, [pc, #48]	; (b74c <z_sched_lock+0x80>)
    b71a:	f004 fca5 	bl	10068 <printk>
    b71e:	480c      	ldr	r0, [pc, #48]	; (b750 <z_sched_lock+0x84>)
    b720:	f004 fca2 	bl	10068 <printk>
    b724:	f240 1113 	movw	r1, #275	; 0x113
    b728:	4806      	ldr	r0, [pc, #24]	; (b744 <z_sched_lock+0x78>)
    b72a:	f005 fae5 	bl	10cf8 <assert_post_action>

	--_current->base.sched_locked;
    b72e:	4b09      	ldr	r3, [pc, #36]	; (b754 <z_sched_lock+0x88>)
    b730:	689b      	ldr	r3, [r3, #8]
    b732:	7bda      	ldrb	r2, [r3, #15]
    b734:	3a01      	subs	r2, #1
    b736:	b2d2      	uxtb	r2, r2
    b738:	73da      	strb	r2, [r3, #15]

	compiler_barrier();

#endif
}
    b73a:	bf00      	nop
    b73c:	3708      	adds	r7, #8
    b73e:	46bd      	mov	sp, r7
    b740:	bd80      	pop	{r7, pc}
    b742:	bf00      	nop
    b744:	0001bc3c 	.word	0x0001bc3c
    b748:	0001bc68 	.word	0x0001bc68
    b74c:	0001bc7c 	.word	0x0001bc7c
    b750:	0001bc9c 	.word	0x0001bc9c
    b754:	20000cd8 	.word	0x20000cd8
    b758:	0001bca0 	.word	0x0001bca0

0000b75c <log_const_source_id>:
{
    b75c:	b480      	push	{r7}
    b75e:	b083      	sub	sp, #12
    b760:	af00      	add	r7, sp, #0
    b762:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    b764:	687b      	ldr	r3, [r7, #4]
    b766:	4a04      	ldr	r2, [pc, #16]	; (b778 <log_const_source_id+0x1c>)
    b768:	1a9b      	subs	r3, r3, r2
    b76a:	08db      	lsrs	r3, r3, #3
}
    b76c:	4618      	mov	r0, r3
    b76e:	370c      	adds	r7, #12
    b770:	46bd      	mov	sp, r7
    b772:	bc80      	pop	{r7}
    b774:	4770      	bx	lr
    b776:	bf00      	nop
    b778:	00018788 	.word	0x00018788

0000b77c <adjust_owner_prio>:

	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
    b77c:	b590      	push	{r4, r7, lr}
    b77e:	b091      	sub	sp, #68	; 0x44
    b780:	af04      	add	r7, sp, #16
    b782:	6078      	str	r0, [r7, #4]
    b784:	6039      	str	r1, [r7, #0]
	if (mutex->owner->base.prio != new_prio) {
    b786:	687b      	ldr	r3, [r7, #4]
    b788:	689b      	ldr	r3, [r3, #8]
    b78a:	f993 300e 	ldrsb.w	r3, [r3, #14]
    b78e:	461a      	mov	r2, r3
    b790:	683b      	ldr	r3, [r7, #0]
    b792:	4293      	cmp	r3, r2
    b794:	d06d      	beq.n	b872 <adjust_owner_prio+0xf6>

		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
    b796:	2303      	movs	r3, #3
    b798:	2b03      	cmp	r3, #3
    b79a:	d962      	bls.n	b862 <adjust_owner_prio+0xe6>
    b79c:	f00b fbd4 	bl	16f48 <_is_user_context>
    b7a0:	4603      	mov	r3, r0
    b7a2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    b7a6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    b7aa:	2204      	movs	r2, #4
    b7ac:	f362 0302 	bfi	r3, r2, #0, #3
    b7b0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    b7b4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    b7b8:	f36f 03c5 	bfc	r3, #3, #3
    b7bc:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    b7c0:	2303      	movs	r3, #3
    b7c2:	2b00      	cmp	r3, #0
    b7c4:	d009      	beq.n	b7da <adjust_owner_prio+0x5e>
    b7c6:	4b2d      	ldr	r3, [pc, #180]	; (b87c <adjust_owner_prio+0x100>)
    b7c8:	681b      	ldr	r3, [r3, #0]
    b7ca:	4618      	mov	r0, r3
    b7cc:	f7ff ffc6 	bl	b75c <log_const_source_id>
    b7d0:	4603      	mov	r3, r0
    b7d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    b7d6:	b29a      	uxth	r2, r3
    b7d8:	e000      	b.n	b7dc <adjust_owner_prio+0x60>
    b7da:	2200      	movs	r2, #0
    b7dc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    b7de:	f362 138f 	bfi	r3, r2, #6, #10
    b7e2:	85bb      	strh	r3, [r7, #44]	; 0x2c
    b7e4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    b7e8:	2b00      	cmp	r3, #0
    b7ea:	d01b      	beq.n	b824 <adjust_owner_prio+0xa8>
    b7ec:	687b      	ldr	r3, [r7, #4]
    b7ee:	689c      	ldr	r4, [r3, #8]
    b7f0:	687b      	ldr	r3, [r7, #4]
    b7f2:	689b      	ldr	r3, [r3, #8]
    b7f4:	4618      	mov	r0, r3
    b7f6:	f00b fbfc 	bl	16ff2 <z_is_thread_ready>
    b7fa:	4603      	mov	r3, r0
    b7fc:	2b00      	cmp	r3, #0
    b7fe:	d001      	beq.n	b804 <adjust_owner_prio+0x88>
    b800:	2379      	movs	r3, #121	; 0x79
    b802:	e000      	b.n	b806 <adjust_owner_prio+0x8a>
    b804:	236e      	movs	r3, #110	; 0x6e
    b806:	687a      	ldr	r2, [r7, #4]
    b808:	6892      	ldr	r2, [r2, #8]
    b80a:	f992 200e 	ldrsb.w	r2, [r2, #14]
    b80e:	9202      	str	r2, [sp, #8]
    b810:	683a      	ldr	r2, [r7, #0]
    b812:	9201      	str	r2, [sp, #4]
    b814:	9300      	str	r3, [sp, #0]
    b816:	4623      	mov	r3, r4
    b818:	4a19      	ldr	r2, [pc, #100]	; (b880 <adjust_owner_prio+0x104>)
    b81a:	491a      	ldr	r1, [pc, #104]	; (b884 <adjust_owner_prio+0x108>)
    b81c:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
    b81e:	f7f7 f867 	bl	28f0 <log_from_user>
    b822:	e01e      	b.n	b862 <adjust_owner_prio+0xe6>
    b824:	4b16      	ldr	r3, [pc, #88]	; (b880 <adjust_owner_prio+0x104>)
    b826:	61bb      	str	r3, [r7, #24]
    b828:	687b      	ldr	r3, [r7, #4]
    b82a:	689b      	ldr	r3, [r3, #8]
    b82c:	61fb      	str	r3, [r7, #28]
    b82e:	687b      	ldr	r3, [r7, #4]
    b830:	689b      	ldr	r3, [r3, #8]
    b832:	4618      	mov	r0, r3
    b834:	f00b fbdd 	bl	16ff2 <z_is_thread_ready>
    b838:	4603      	mov	r3, r0
    b83a:	2b00      	cmp	r3, #0
    b83c:	d001      	beq.n	b842 <adjust_owner_prio+0xc6>
    b83e:	2379      	movs	r3, #121	; 0x79
    b840:	e000      	b.n	b844 <adjust_owner_prio+0xc8>
    b842:	236e      	movs	r3, #110	; 0x6e
    b844:	623b      	str	r3, [r7, #32]
    b846:	683b      	ldr	r3, [r7, #0]
    b848:	627b      	str	r3, [r7, #36]	; 0x24
    b84a:	687b      	ldr	r3, [r7, #4]
    b84c:	689b      	ldr	r3, [r3, #8]
    b84e:	f993 300e 	ldrsb.w	r3, [r3, #14]
    b852:	62bb      	str	r3, [r7, #40]	; 0x28
    b854:	f107 0118 	add.w	r1, r7, #24
    b858:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    b85a:	2205      	movs	r2, #5
    b85c:	4809      	ldr	r0, [pc, #36]	; (b884 <adjust_owner_prio+0x108>)
    b85e:	f005 ff3f 	bl	116e0 <log_n>
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    b862:	687b      	ldr	r3, [r7, #4]
    b864:	689b      	ldr	r3, [r3, #8]
    b866:	6839      	ldr	r1, [r7, #0]
    b868:	4618      	mov	r0, r3
    b86a:	f001 ffed 	bl	d848 <z_set_prio>
    b86e:	4603      	mov	r3, r0
    b870:	e000      	b.n	b874 <adjust_owner_prio+0xf8>
	}
	return false;
    b872:	2300      	movs	r3, #0
}
    b874:	4618      	mov	r0, r3
    b876:	3734      	adds	r7, #52	; 0x34
    b878:	46bd      	mov	sp, r7
    b87a:	bd90      	pop	{r4, r7, pc}
    b87c:	20000170 	.word	0x20000170
    b880:	0001ce0c 	.word	0x0001ce0c
    b884:	0001bcd0 	.word	0x0001bcd0

0000b888 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    b888:	b580      	push	{r7, lr}
    b88a:	b0b6      	sub	sp, #216	; 0xd8
    b88c:	af04      	add	r7, sp, #16
    b88e:	60f8      	str	r0, [r7, #12]
    b890:	e9c7 2300 	strd	r2, r3, [r7]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;
    b894:	2300      	movs	r3, #0
    b896:	f887 30bf 	strb.w	r3, [r7, #191]	; 0xbf
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    b89a:	f3ef 8305 	mrs	r3, IPSR
    b89e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  return(result);
    b8a2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
    b8a6:	2b00      	cmp	r3, #0
    b8a8:	bf14      	ite	ne
    b8aa:	2301      	movne	r3, #1
    b8ac:	2300      	moveq	r3, #0
    b8ae:	b2db      	uxtb	r3, r3

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
    b8b0:	2b00      	cmp	r3, #0
    b8b2:	d00c      	beq.n	b8ce <z_impl_k_mutex_lock+0x46>
    b8b4:	237d      	movs	r3, #125	; 0x7d
    b8b6:	4ab1      	ldr	r2, [pc, #708]	; (bb7c <z_impl_k_mutex_lock+0x2f4>)
    b8b8:	49b1      	ldr	r1, [pc, #708]	; (bb80 <z_impl_k_mutex_lock+0x2f8>)
    b8ba:	48b2      	ldr	r0, [pc, #712]	; (bb84 <z_impl_k_mutex_lock+0x2fc>)
    b8bc:	f004 fbd4 	bl	10068 <printk>
    b8c0:	48b1      	ldr	r0, [pc, #708]	; (bb88 <z_impl_k_mutex_lock+0x300>)
    b8c2:	f004 fbd1 	bl	10068 <printk>
    b8c6:	217d      	movs	r1, #125	; 0x7d
    b8c8:	48ac      	ldr	r0, [pc, #688]	; (bb7c <z_impl_k_mutex_lock+0x2f4>)
    b8ca:	f005 fa15 	bl	10cf8 <assert_post_action>
    b8ce:	4baf      	ldr	r3, [pc, #700]	; (bb8c <z_impl_k_mutex_lock+0x304>)
    b8d0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	__asm__ volatile(
    b8d4:	f04f 0320 	mov.w	r3, #32
    b8d8:	f3ef 8211 	mrs	r2, BASEPRI
    b8dc:	f383 8811 	msr	BASEPRI, r3
    b8e0:	f3bf 8f6f 	isb	sy
    b8e4:	f8c7 20a0 	str.w	r2, [r7, #160]	; 0xa0
    b8e8:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	return key;
    b8ec:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
	k.key = arch_irq_lock();
    b8f0:	667b      	str	r3, [r7, #100]	; 0x64
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    b8f2:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
    b8f6:	f003 f8af 	bl	ea58 <z_spin_lock_valid>
    b8fa:	4603      	mov	r3, r0
    b8fc:	f083 0301 	eor.w	r3, r3, #1
    b900:	b2db      	uxtb	r3, r3
    b902:	2b00      	cmp	r3, #0
    b904:	d00e      	beq.n	b924 <z_impl_k_mutex_lock+0x9c>
    b906:	2378      	movs	r3, #120	; 0x78
    b908:	4aa1      	ldr	r2, [pc, #644]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    b90a:	49a2      	ldr	r1, [pc, #648]	; (bb94 <z_impl_k_mutex_lock+0x30c>)
    b90c:	489d      	ldr	r0, [pc, #628]	; (bb84 <z_impl_k_mutex_lock+0x2fc>)
    b90e:	f004 fbab 	bl	10068 <printk>
    b912:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
    b916:	48a0      	ldr	r0, [pc, #640]	; (bb98 <z_impl_k_mutex_lock+0x310>)
    b918:	f004 fba6 	bl	10068 <printk>
    b91c:	2178      	movs	r1, #120	; 0x78
    b91e:	489c      	ldr	r0, [pc, #624]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    b920:	f005 f9ea 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    b924:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
    b928:	f003 f8ce 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    b92c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    b92e:	677b      	str	r3, [r7, #116]	; 0x74

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    b930:	68fb      	ldr	r3, [r7, #12]
    b932:	68db      	ldr	r3, [r3, #12]
    b934:	2b00      	cmp	r3, #0
    b936:	bf0c      	ite	eq
    b938:	2301      	moveq	r3, #1
    b93a:	2300      	movne	r3, #0
    b93c:	b2db      	uxtb	r3, r3
    b93e:	2b00      	cmp	r3, #0
    b940:	d10b      	bne.n	b95a <z_impl_k_mutex_lock+0xd2>
    b942:	68fb      	ldr	r3, [r7, #12]
    b944:	689a      	ldr	r2, [r3, #8]
    b946:	4b95      	ldr	r3, [pc, #596]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    b948:	689b      	ldr	r3, [r3, #8]
    b94a:	429a      	cmp	r2, r3
    b94c:	bf0c      	ite	eq
    b94e:	2301      	moveq	r3, #1
    b950:	2300      	movne	r3, #0
    b952:	b2db      	uxtb	r3, r3
    b954:	2b00      	cmp	r3, #0
    b956:	f000 8095 	beq.w	ba84 <z_impl_k_mutex_lock+0x1fc>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    b95a:	68fb      	ldr	r3, [r7, #12]
    b95c:	68db      	ldr	r3, [r3, #12]
					_current->base.prio :
    b95e:	2b00      	cmp	r3, #0
    b960:	d104      	bne.n	b96c <z_impl_k_mutex_lock+0xe4>
    b962:	4b8e      	ldr	r3, [pc, #568]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    b964:	689b      	ldr	r3, [r3, #8]
    b966:	f993 300e 	ldrsb.w	r3, [r3, #14]
    b96a:	e001      	b.n	b970 <z_impl_k_mutex_lock+0xe8>
    b96c:	68fb      	ldr	r3, [r7, #12]
    b96e:	691b      	ldr	r3, [r3, #16]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    b970:	68fa      	ldr	r2, [r7, #12]
    b972:	6113      	str	r3, [r2, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    b974:	68fb      	ldr	r3, [r7, #12]
    b976:	68db      	ldr	r3, [r3, #12]
    b978:	1c5a      	adds	r2, r3, #1
    b97a:	68fb      	ldr	r3, [r7, #12]
    b97c:	60da      	str	r2, [r3, #12]
		mutex->owner = _current;
    b97e:	4b87      	ldr	r3, [pc, #540]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    b980:	689a      	ldr	r2, [r3, #8]
    b982:	68fb      	ldr	r3, [r7, #12]
    b984:	609a      	str	r2, [r3, #8]

		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
    b986:	2303      	movs	r3, #3
    b988:	2b03      	cmp	r3, #3
    b98a:	d950      	bls.n	ba2e <z_impl_k_mutex_lock+0x1a6>
    b98c:	f00b fadc 	bl	16f48 <_is_user_context>
    b990:	4603      	mov	r3, r0
    b992:	f887 30ae 	strb.w	r3, [r7, #174]	; 0xae
    b996:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
    b99a:	2204      	movs	r2, #4
    b99c:	f362 0302 	bfi	r3, r2, #0, #3
    b9a0:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
    b9a4:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
    b9a8:	f36f 03c5 	bfc	r3, #3, #3
    b9ac:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
    b9b0:	2303      	movs	r3, #3
    b9b2:	2b00      	cmp	r3, #0
    b9b4:	d009      	beq.n	b9ca <z_impl_k_mutex_lock+0x142>
    b9b6:	4b7a      	ldr	r3, [pc, #488]	; (bba0 <z_impl_k_mutex_lock+0x318>)
    b9b8:	681b      	ldr	r3, [r3, #0]
    b9ba:	4618      	mov	r0, r3
    b9bc:	f7ff fece 	bl	b75c <log_const_source_id>
    b9c0:	4603      	mov	r3, r0
    b9c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    b9c6:	b29a      	uxth	r2, r3
    b9c8:	e000      	b.n	b9cc <z_impl_k_mutex_lock+0x144>
    b9ca:	2200      	movs	r2, #0
    b9cc:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
    b9d0:	f362 138f 	bfi	r3, r2, #6, #10
    b9d4:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    b9d8:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
    b9dc:	2b00      	cmp	r3, #0
    b9de:	d011      	beq.n	ba04 <z_impl_k_mutex_lock+0x17c>
    b9e0:	4b6e      	ldr	r3, [pc, #440]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    b9e2:	6899      	ldr	r1, [r3, #8]
    b9e4:	68fb      	ldr	r3, [r7, #12]
    b9e6:	68db      	ldr	r3, [r3, #12]
    b9e8:	68fa      	ldr	r2, [r7, #12]
    b9ea:	6912      	ldr	r2, [r2, #16]
    b9ec:	9202      	str	r2, [sp, #8]
    b9ee:	9301      	str	r3, [sp, #4]
    b9f0:	68fb      	ldr	r3, [r7, #12]
    b9f2:	9300      	str	r3, [sp, #0]
    b9f4:	460b      	mov	r3, r1
    b9f6:	4a6b      	ldr	r2, [pc, #428]	; (bba4 <z_impl_k_mutex_lock+0x31c>)
    b9f8:	496b      	ldr	r1, [pc, #428]	; (bba8 <z_impl_k_mutex_lock+0x320>)
    b9fa:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
    b9fe:	f7f6 ff77 	bl	28f0 <log_from_user>
    ba02:	e014      	b.n	ba2e <z_impl_k_mutex_lock+0x1a6>
    ba04:	4b67      	ldr	r3, [pc, #412]	; (bba4 <z_impl_k_mutex_lock+0x31c>)
    ba06:	64fb      	str	r3, [r7, #76]	; 0x4c
    ba08:	4b64      	ldr	r3, [pc, #400]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    ba0a:	689b      	ldr	r3, [r3, #8]
    ba0c:	653b      	str	r3, [r7, #80]	; 0x50
    ba0e:	68fb      	ldr	r3, [r7, #12]
    ba10:	657b      	str	r3, [r7, #84]	; 0x54
    ba12:	68fb      	ldr	r3, [r7, #12]
    ba14:	68db      	ldr	r3, [r3, #12]
    ba16:	65bb      	str	r3, [r7, #88]	; 0x58
    ba18:	68fb      	ldr	r3, [r7, #12]
    ba1a:	691b      	ldr	r3, [r3, #16]
    ba1c:	65fb      	str	r3, [r7, #92]	; 0x5c
    ba1e:	f107 014c 	add.w	r1, r7, #76	; 0x4c
    ba22:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
    ba26:	2205      	movs	r2, #5
    ba28:	485f      	ldr	r0, [pc, #380]	; (bba8 <z_impl_k_mutex_lock+0x320>)
    ba2a:	f005 fe59 	bl	116e0 <log_n>
    ba2e:	4b57      	ldr	r3, [pc, #348]	; (bb8c <z_impl_k_mutex_lock+0x304>)
    ba30:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    ba34:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    ba36:	66bb      	str	r3, [r7, #104]	; 0x68
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    ba38:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
    ba3c:	f003 f828 	bl	ea90 <z_spin_unlock_valid>
    ba40:	4603      	mov	r3, r0
    ba42:	f083 0301 	eor.w	r3, r3, #1
    ba46:	b2db      	uxtb	r3, r3
    ba48:	2b00      	cmp	r3, #0
    ba4a:	d00e      	beq.n	ba6a <z_impl_k_mutex_lock+0x1e2>
    ba4c:	23a3      	movs	r3, #163	; 0xa3
    ba4e:	4a50      	ldr	r2, [pc, #320]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    ba50:	4956      	ldr	r1, [pc, #344]	; (bbac <z_impl_k_mutex_lock+0x324>)
    ba52:	484c      	ldr	r0, [pc, #304]	; (bb84 <z_impl_k_mutex_lock+0x2fc>)
    ba54:	f004 fb08 	bl	10068 <printk>
    ba58:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
    ba5c:	4854      	ldr	r0, [pc, #336]	; (bbb0 <z_impl_k_mutex_lock+0x328>)
    ba5e:	f004 fb03 	bl	10068 <printk>
    ba62:	21a3      	movs	r1, #163	; 0xa3
    ba64:	484a      	ldr	r0, [pc, #296]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    ba66:	f005 f947 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    ba6a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    ba6c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
	__asm__ volatile(
    ba70:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
    ba74:	f383 8811 	msr	BASEPRI, r3
    ba78:	f3bf 8f6f 	isb	sy
}
    ba7c:	bf00      	nop
}
    ba7e:	bf00      	nop
			mutex->owner_orig_prio);

		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
    ba80:	2300      	movs	r3, #0
    ba82:	e279      	b.n	bf78 <z_impl_k_mutex_lock+0x6f0>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    ba84:	e9d7 2300 	ldrd	r2, r3, [r7]
    ba88:	f04f 0000 	mov.w	r0, #0
    ba8c:	f04f 0100 	mov.w	r1, #0
    ba90:	428b      	cmp	r3, r1
    ba92:	bf06      	itte	eq
    ba94:	4282      	cmpeq	r2, r0
    ba96:	2301      	moveq	r3, #1
    ba98:	2300      	movne	r3, #0
    ba9a:	b2db      	uxtb	r3, r3
    ba9c:	2b00      	cmp	r3, #0
    ba9e:	d02b      	beq.n	baf8 <z_impl_k_mutex_lock+0x270>
    baa0:	4b3a      	ldr	r3, [pc, #232]	; (bb8c <z_impl_k_mutex_lock+0x304>)
    baa2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    baa6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    baa8:	63bb      	str	r3, [r7, #56]	; 0x38
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    baaa:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
    baae:	f002 ffef 	bl	ea90 <z_spin_unlock_valid>
    bab2:	4603      	mov	r3, r0
    bab4:	f083 0301 	eor.w	r3, r3, #1
    bab8:	b2db      	uxtb	r3, r3
    baba:	2b00      	cmp	r3, #0
    babc:	d00e      	beq.n	badc <z_impl_k_mutex_lock+0x254>
    babe:	23a3      	movs	r3, #163	; 0xa3
    bac0:	4a33      	ldr	r2, [pc, #204]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    bac2:	493a      	ldr	r1, [pc, #232]	; (bbac <z_impl_k_mutex_lock+0x324>)
    bac4:	482f      	ldr	r0, [pc, #188]	; (bb84 <z_impl_k_mutex_lock+0x2fc>)
    bac6:	f004 facf 	bl	10068 <printk>
    baca:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
    bace:	4838      	ldr	r0, [pc, #224]	; (bbb0 <z_impl_k_mutex_lock+0x328>)
    bad0:	f004 faca 	bl	10068 <printk>
    bad4:	21a3      	movs	r1, #163	; 0xa3
    bad6:	482e      	ldr	r0, [pc, #184]	; (bb90 <z_impl_k_mutex_lock+0x308>)
    bad8:	f005 f90e 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    badc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    bade:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	__asm__ volatile(
    bae2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    bae6:	f383 8811 	msr	BASEPRI, r3
    baea:	f3bf 8f6f 	isb	sy
}
    baee:	bf00      	nop
}
    baf0:	bf00      	nop
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
    baf2:	f06f 030f 	mvn.w	r3, #15
    baf6:	e23f      	b.n	bf78 <z_impl_k_mutex_lock+0x6f0>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
    baf8:	4b28      	ldr	r3, [pc, #160]	; (bb9c <z_impl_k_mutex_lock+0x314>)
    bafa:	689b      	ldr	r3, [r3, #8]
    bafc:	f993 300e 	ldrsb.w	r3, [r3, #14]
    bb00:	461a      	mov	r2, r3
					    mutex->owner->base.prio);
    bb02:	68fb      	ldr	r3, [r7, #12]
    bb04:	689b      	ldr	r3, [r3, #8]
    bb06:	f993 300e 	ldrsb.w	r3, [r3, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    bb0a:	4619      	mov	r1, r3
    bb0c:	4610      	mov	r0, r2
    bb0e:	f00b fafc 	bl	1710a <new_prio_for_inheritance>
    bb12:	f8c7 00c0 	str.w	r0, [r7, #192]	; 0xc0

	LOG_DBG("adjusting prio up on mutex %p", mutex);
    bb16:	2303      	movs	r3, #3
    bb18:	2b03      	cmp	r3, #3
    bb1a:	d953      	bls.n	bbc4 <z_impl_k_mutex_lock+0x33c>
    bb1c:	f00b fa14 	bl	16f48 <_is_user_context>
    bb20:	4603      	mov	r3, r0
    bb22:	f887 30c7 	strb.w	r3, [r7, #199]	; 0xc7
    bb26:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    bb2a:	2204      	movs	r2, #4
    bb2c:	f362 0302 	bfi	r3, r2, #0, #3
    bb30:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    bb34:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    bb38:	f36f 03c5 	bfc	r3, #3, #3
    bb3c:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    bb40:	2303      	movs	r3, #3
    bb42:	2b00      	cmp	r3, #0
    bb44:	d009      	beq.n	bb5a <z_impl_k_mutex_lock+0x2d2>
    bb46:	4b16      	ldr	r3, [pc, #88]	; (bba0 <z_impl_k_mutex_lock+0x318>)
    bb48:	681b      	ldr	r3, [r3, #0]
    bb4a:	4618      	mov	r0, r3
    bb4c:	f7ff fe06 	bl	b75c <log_const_source_id>
    bb50:	4603      	mov	r3, r0
    bb52:	f3c3 0309 	ubfx	r3, r3, #0, #10
    bb56:	b29a      	uxth	r2, r3
    bb58:	e000      	b.n	bb5c <z_impl_k_mutex_lock+0x2d4>
    bb5a:	2200      	movs	r2, #0
    bb5c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    bb5e:	f362 138f 	bfi	r3, r2, #6, #10
    bb62:	86bb      	strh	r3, [r7, #52]	; 0x34
    bb64:	f897 30c7 	ldrb.w	r3, [r7, #199]	; 0xc7
    bb68:	2b00      	cmp	r3, #0
    bb6a:	d025      	beq.n	bbb8 <z_impl_k_mutex_lock+0x330>
    bb6c:	68fb      	ldr	r3, [r7, #12]
    bb6e:	4a0d      	ldr	r2, [pc, #52]	; (bba4 <z_impl_k_mutex_lock+0x31c>)
    bb70:	4910      	ldr	r1, [pc, #64]	; (bbb4 <z_impl_k_mutex_lock+0x32c>)
    bb72:	8eb8      	ldrh	r0, [r7, #52]	; 0x34
    bb74:	f7f6 febc 	bl	28f0 <log_from_user>
    bb78:	e024      	b.n	bbc4 <z_impl_k_mutex_lock+0x33c>
    bb7a:	bf00      	nop
    bb7c:	0001bd08 	.word	0x0001bd08
    bb80:	0001bc68 	.word	0x0001bc68
    bb84:	0001bc7c 	.word	0x0001bc7c
    bb88:	0001bd2c 	.word	0x0001bd2c
    bb8c:	20000cd4 	.word	0x20000cd4
    bb90:	0001bd54 	.word	0x0001bd54
    bb94:	0001bd7c 	.word	0x0001bd7c
    bb98:	0001bd94 	.word	0x0001bd94
    bb9c:	20000cd8 	.word	0x20000cd8
    bba0:	20000170 	.word	0x20000170
    bba4:	0001ce20 	.word	0x0001ce20
    bba8:	0001bdac 	.word	0x0001bdac
    bbac:	0001bddc 	.word	0x0001bddc
    bbb0:	0001bdf4 	.word	0x0001bdf4
    bbb4:	0001be0c 	.word	0x0001be0c
    bbb8:	49bc      	ldr	r1, [pc, #752]	; (beac <z_impl_k_mutex_lock+0x624>)
    bbba:	68fa      	ldr	r2, [r7, #12]
    bbbc:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    bbbe:	48bc      	ldr	r0, [pc, #752]	; (beb0 <z_impl_k_mutex_lock+0x628>)
    bbc0:	f005 fd5b 	bl	1167a <log_2>

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    bbc4:	68fb      	ldr	r3, [r7, #12]
    bbc6:	689b      	ldr	r3, [r3, #8]
    bbc8:	f993 300e 	ldrsb.w	r3, [r3, #14]
    bbcc:	4619      	mov	r1, r3
    bbce:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
    bbd2:	f00b fa5d 	bl	17090 <z_is_prio_higher>
    bbd6:	4603      	mov	r3, r0
    bbd8:	2b00      	cmp	r3, #0
    bbda:	d007      	beq.n	bbec <z_impl_k_mutex_lock+0x364>
		resched = adjust_owner_prio(mutex, new_prio);
    bbdc:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
    bbe0:	68f8      	ldr	r0, [r7, #12]
    bbe2:	f7ff fdcb 	bl	b77c <adjust_owner_prio>
    bbe6:	4603      	mov	r3, r0
    bbe8:	f887 30bf 	strb.w	r3, [r7, #191]	; 0xbf
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    bbec:	68f9      	ldr	r1, [r7, #12]
    bbee:	e9d7 2300 	ldrd	r2, r3, [r7]
    bbf2:	e9cd 2300 	strd	r2, r3, [sp]
    bbf6:	460a      	mov	r2, r1
    bbf8:	6f79      	ldr	r1, [r7, #116]	; 0x74
    bbfa:	48ae      	ldr	r0, [pc, #696]	; (beb4 <z_impl_k_mutex_lock+0x62c>)
    bbfc:	f001 fde0 	bl	d7c0 <z_pend_curr>
    bc00:	f8c7 00b8 	str.w	r0, [r7, #184]	; 0xb8

	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
    bc04:	2303      	movs	r3, #3
    bc06:	2b03      	cmp	r3, #3
    bc08:	d93d      	bls.n	bc86 <z_impl_k_mutex_lock+0x3fe>
    bc0a:	f00b f99d 	bl	16f48 <_is_user_context>
    bc0e:	4603      	mov	r3, r0
    bc10:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
    bc14:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    bc18:	2204      	movs	r2, #4
    bc1a:	f362 0302 	bfi	r3, r2, #0, #3
    bc1e:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    bc22:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    bc26:	f36f 03c5 	bfc	r3, #3, #3
    bc2a:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    bc2e:	2303      	movs	r3, #3
    bc30:	2b00      	cmp	r3, #0
    bc32:	d009      	beq.n	bc48 <z_impl_k_mutex_lock+0x3c0>
    bc34:	4ba0      	ldr	r3, [pc, #640]	; (beb8 <z_impl_k_mutex_lock+0x630>)
    bc36:	681b      	ldr	r3, [r3, #0]
    bc38:	4618      	mov	r0, r3
    bc3a:	f7ff fd8f 	bl	b75c <log_const_source_id>
    bc3e:	4603      	mov	r3, r0
    bc40:	f3c3 0309 	ubfx	r3, r3, #0, #10
    bc44:	b29a      	uxth	r2, r3
    bc46:	e000      	b.n	bc4a <z_impl_k_mutex_lock+0x3c2>
    bc48:	2200      	movs	r2, #0
    bc4a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    bc4c:	f362 138f 	bfi	r3, r2, #6, #10
    bc50:	863b      	strh	r3, [r7, #48]	; 0x30
    bc52:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
    bc56:	2b00      	cmp	r3, #0
    bc58:	d009      	beq.n	bc6e <z_impl_k_mutex_lock+0x3e6>
    bc5a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    bc5e:	9300      	str	r3, [sp, #0]
    bc60:	68fb      	ldr	r3, [r7, #12]
    bc62:	4a92      	ldr	r2, [pc, #584]	; (beac <z_impl_k_mutex_lock+0x624>)
    bc64:	4995      	ldr	r1, [pc, #596]	; (bebc <z_impl_k_mutex_lock+0x634>)
    bc66:	8e38      	ldrh	r0, [r7, #48]	; 0x30
    bc68:	f7f6 fe42 	bl	28f0 <log_from_user>
    bc6c:	e00b      	b.n	bc86 <z_impl_k_mutex_lock+0x3fe>
    bc6e:	488f      	ldr	r0, [pc, #572]	; (beac <z_impl_k_mutex_lock+0x624>)
    bc70:	68fa      	ldr	r2, [r7, #12]
    bc72:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    bc76:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    bc78:	f8ad 3000 	strh.w	r3, [sp]
    bc7c:	460b      	mov	r3, r1
    bc7e:	4601      	mov	r1, r0
    bc80:	488e      	ldr	r0, [pc, #568]	; (bebc <z_impl_k_mutex_lock+0x634>)
    bc82:	f005 fd13 	bl	116ac <log_3>

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
    bc86:	2303      	movs	r3, #3
    bc88:	2b03      	cmp	r3, #3
    bc8a:	d950      	bls.n	bd2e <z_impl_k_mutex_lock+0x4a6>
    bc8c:	f00b f95c 	bl	16f48 <_is_user_context>
    bc90:	4603      	mov	r3, r0
    bc92:	f887 30b6 	strb.w	r3, [r7, #182]	; 0xb6
    bc96:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    bc9a:	2204      	movs	r2, #4
    bc9c:	f362 0302 	bfi	r3, r2, #0, #3
    bca0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    bca4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    bca8:	f36f 03c5 	bfc	r3, #3, #3
    bcac:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    bcb0:	2303      	movs	r3, #3
    bcb2:	2b00      	cmp	r3, #0
    bcb4:	d009      	beq.n	bcca <z_impl_k_mutex_lock+0x442>
    bcb6:	4b80      	ldr	r3, [pc, #512]	; (beb8 <z_impl_k_mutex_lock+0x630>)
    bcb8:	681b      	ldr	r3, [r3, #0]
    bcba:	4618      	mov	r0, r3
    bcbc:	f7ff fd4e 	bl	b75c <log_const_source_id>
    bcc0:	4603      	mov	r3, r0
    bcc2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    bcc6:	b29a      	uxth	r2, r3
    bcc8:	e000      	b.n	bccc <z_impl_k_mutex_lock+0x444>
    bcca:	2200      	movs	r2, #0
    bccc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    bcce:	f362 138f 	bfi	r3, r2, #6, #10
    bcd2:	85bb      	strh	r3, [r7, #44]	; 0x2c
    bcd4:	f897 30b6 	ldrb.w	r3, [r7, #182]	; 0xb6
    bcd8:	2b00      	cmp	r3, #0
    bcda:	d012      	beq.n	bd02 <z_impl_k_mutex_lock+0x47a>
    bcdc:	4b78      	ldr	r3, [pc, #480]	; (bec0 <z_impl_k_mutex_lock+0x638>)
    bcde:	689a      	ldr	r2, [r3, #8]
    bce0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    bce4:	2b00      	cmp	r3, #0
    bce6:	d001      	beq.n	bcec <z_impl_k_mutex_lock+0x464>
    bce8:	2379      	movs	r3, #121	; 0x79
    bcea:	e000      	b.n	bcee <z_impl_k_mutex_lock+0x466>
    bcec:	236e      	movs	r3, #110	; 0x6e
    bcee:	9301      	str	r3, [sp, #4]
    bcf0:	68fb      	ldr	r3, [r7, #12]
    bcf2:	9300      	str	r3, [sp, #0]
    bcf4:	4613      	mov	r3, r2
    bcf6:	4a6d      	ldr	r2, [pc, #436]	; (beac <z_impl_k_mutex_lock+0x624>)
    bcf8:	4972      	ldr	r1, [pc, #456]	; (bec4 <z_impl_k_mutex_lock+0x63c>)
    bcfa:	8db8      	ldrh	r0, [r7, #44]	; 0x2c
    bcfc:	f7f6 fdf8 	bl	28f0 <log_from_user>
    bd00:	e015      	b.n	bd2e <z_impl_k_mutex_lock+0x4a6>
    bd02:	4b6a      	ldr	r3, [pc, #424]	; (beac <z_impl_k_mutex_lock+0x624>)
    bd04:	61fb      	str	r3, [r7, #28]
    bd06:	4b6e      	ldr	r3, [pc, #440]	; (bec0 <z_impl_k_mutex_lock+0x638>)
    bd08:	689b      	ldr	r3, [r3, #8]
    bd0a:	623b      	str	r3, [r7, #32]
    bd0c:	68fb      	ldr	r3, [r7, #12]
    bd0e:	627b      	str	r3, [r7, #36]	; 0x24
    bd10:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    bd14:	2b00      	cmp	r3, #0
    bd16:	d001      	beq.n	bd1c <z_impl_k_mutex_lock+0x494>
    bd18:	2379      	movs	r3, #121	; 0x79
    bd1a:	e000      	b.n	bd1e <z_impl_k_mutex_lock+0x496>
    bd1c:	236e      	movs	r3, #110	; 0x6e
    bd1e:	62bb      	str	r3, [r7, #40]	; 0x28
    bd20:	f107 011c 	add.w	r1, r7, #28
    bd24:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    bd26:	2204      	movs	r2, #4
    bd28:	4866      	ldr	r0, [pc, #408]	; (bec4 <z_impl_k_mutex_lock+0x63c>)
    bd2a:	f005 fcd9 	bl	116e0 <log_n>
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
    bd2e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    bd32:	2b00      	cmp	r3, #0
    bd34:	d101      	bne.n	bd3a <z_impl_k_mutex_lock+0x4b2>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return 0;
    bd36:	2300      	movs	r3, #0
    bd38:	e11e      	b.n	bf78 <z_impl_k_mutex_lock+0x6f0>
	}

	/* timed out */

	LOG_DBG("%p timeout on mutex %p", _current, mutex);
    bd3a:	2303      	movs	r3, #3
    bd3c:	2b03      	cmp	r3, #3
    bd3e:	d93b      	bls.n	bdb8 <z_impl_k_mutex_lock+0x530>
    bd40:	f00b f902 	bl	16f48 <_is_user_context>
    bd44:	4603      	mov	r3, r0
    bd46:	f887 30b5 	strb.w	r3, [r7, #181]	; 0xb5
    bd4a:	7e3b      	ldrb	r3, [r7, #24]
    bd4c:	2204      	movs	r2, #4
    bd4e:	f362 0302 	bfi	r3, r2, #0, #3
    bd52:	763b      	strb	r3, [r7, #24]
    bd54:	7e3b      	ldrb	r3, [r7, #24]
    bd56:	f36f 03c5 	bfc	r3, #3, #3
    bd5a:	763b      	strb	r3, [r7, #24]
    bd5c:	2303      	movs	r3, #3
    bd5e:	2b00      	cmp	r3, #0
    bd60:	d009      	beq.n	bd76 <z_impl_k_mutex_lock+0x4ee>
    bd62:	4b55      	ldr	r3, [pc, #340]	; (beb8 <z_impl_k_mutex_lock+0x630>)
    bd64:	681b      	ldr	r3, [r3, #0]
    bd66:	4618      	mov	r0, r3
    bd68:	f7ff fcf8 	bl	b75c <log_const_source_id>
    bd6c:	4603      	mov	r3, r0
    bd6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    bd72:	b29a      	uxth	r2, r3
    bd74:	e000      	b.n	bd78 <z_impl_k_mutex_lock+0x4f0>
    bd76:	2200      	movs	r2, #0
    bd78:	8b3b      	ldrh	r3, [r7, #24]
    bd7a:	f362 138f 	bfi	r3, r2, #6, #10
    bd7e:	833b      	strh	r3, [r7, #24]
    bd80:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
    bd84:	2b00      	cmp	r3, #0
    bd86:	d00a      	beq.n	bd9e <z_impl_k_mutex_lock+0x516>
    bd88:	4b4d      	ldr	r3, [pc, #308]	; (bec0 <z_impl_k_mutex_lock+0x638>)
    bd8a:	689a      	ldr	r2, [r3, #8]
    bd8c:	68fb      	ldr	r3, [r7, #12]
    bd8e:	9300      	str	r3, [sp, #0]
    bd90:	4613      	mov	r3, r2
    bd92:	4a46      	ldr	r2, [pc, #280]	; (beac <z_impl_k_mutex_lock+0x624>)
    bd94:	494c      	ldr	r1, [pc, #304]	; (bec8 <z_impl_k_mutex_lock+0x640>)
    bd96:	8b38      	ldrh	r0, [r7, #24]
    bd98:	f7f6 fdaa 	bl	28f0 <log_from_user>
    bd9c:	e00c      	b.n	bdb8 <z_impl_k_mutex_lock+0x530>
    bd9e:	4943      	ldr	r1, [pc, #268]	; (beac <z_impl_k_mutex_lock+0x624>)
    bda0:	4b47      	ldr	r3, [pc, #284]	; (bec0 <z_impl_k_mutex_lock+0x638>)
    bda2:	689b      	ldr	r3, [r3, #8]
    bda4:	4618      	mov	r0, r3
    bda6:	68fa      	ldr	r2, [r7, #12]
    bda8:	8b3b      	ldrh	r3, [r7, #24]
    bdaa:	f8ad 3000 	strh.w	r3, [sp]
    bdae:	4613      	mov	r3, r2
    bdb0:	4602      	mov	r2, r0
    bdb2:	4845      	ldr	r0, [pc, #276]	; (bec8 <z_impl_k_mutex_lock+0x640>)
    bdb4:	f005 fc7a 	bl	116ac <log_3>
    bdb8:	4b3e      	ldr	r3, [pc, #248]	; (beb4 <z_impl_k_mutex_lock+0x62c>)
    bdba:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
	__asm__ volatile(
    bdbe:	f04f 0320 	mov.w	r3, #32
    bdc2:	f3ef 8211 	mrs	r2, BASEPRI
    bdc6:	f383 8811 	msr	BASEPRI, r3
    bdca:	f3bf 8f6f 	isb	sy
    bdce:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
    bdd2:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
	return key;
    bdd6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
	k.key = arch_irq_lock();
    bdda:	66fb      	str	r3, [r7, #108]	; 0x6c
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    bddc:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
    bde0:	f002 fe3a 	bl	ea58 <z_spin_lock_valid>
    bde4:	4603      	mov	r3, r0
    bde6:	f083 0301 	eor.w	r3, r3, #1
    bdea:	b2db      	uxtb	r3, r3
    bdec:	2b00      	cmp	r3, #0
    bdee:	d00e      	beq.n	be0e <z_impl_k_mutex_lock+0x586>
    bdf0:	2378      	movs	r3, #120	; 0x78
    bdf2:	4a36      	ldr	r2, [pc, #216]	; (becc <z_impl_k_mutex_lock+0x644>)
    bdf4:	4936      	ldr	r1, [pc, #216]	; (bed0 <z_impl_k_mutex_lock+0x648>)
    bdf6:	4837      	ldr	r0, [pc, #220]	; (bed4 <z_impl_k_mutex_lock+0x64c>)
    bdf8:	f004 f936 	bl	10068 <printk>
    bdfc:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
    be00:	4835      	ldr	r0, [pc, #212]	; (bed8 <z_impl_k_mutex_lock+0x650>)
    be02:	f004 f931 	bl	10068 <printk>
    be06:	2178      	movs	r1, #120	; 0x78
    be08:	4830      	ldr	r0, [pc, #192]	; (becc <z_impl_k_mutex_lock+0x644>)
    be0a:	f004 ff75 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    be0e:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
    be12:	f002 fe59 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    be16:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    be18:	677b      	str	r3, [r7, #116]	; 0x74

	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
    be1a:	68fb      	ldr	r3, [r7, #12]
    be1c:	4618      	mov	r0, r3
    be1e:	f00b f951 	bl	170c4 <z_waitq_head>
    be22:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    be26:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
    be2a:	2b00      	cmp	r3, #0
    be2c:	d00c      	beq.n	be48 <z_impl_k_mutex_lock+0x5c0>
    be2e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
    be32:	f993 300e 	ldrsb.w	r3, [r3, #14]
    be36:	461a      	mov	r2, r3
    be38:	68fb      	ldr	r3, [r7, #12]
    be3a:	691b      	ldr	r3, [r3, #16]
    be3c:	4619      	mov	r1, r3
    be3e:	4610      	mov	r0, r2
    be40:	f00b f963 	bl	1710a <new_prio_for_inheritance>
    be44:	4603      	mov	r3, r0
    be46:	e001      	b.n	be4c <z_impl_k_mutex_lock+0x5c4>
    be48:	68fb      	ldr	r3, [r7, #12]
    be4a:	691b      	ldr	r3, [r3, #16]
	new_prio = (waiter != NULL) ?
    be4c:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);
    be50:	2303      	movs	r3, #3
    be52:	2b03      	cmp	r3, #3
    be54:	d94a      	bls.n	beec <z_impl_k_mutex_lock+0x664>
    be56:	f00b f877 	bl	16f48 <_is_user_context>
    be5a:	4603      	mov	r3, r0
    be5c:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
    be60:	7d3b      	ldrb	r3, [r7, #20]
    be62:	2204      	movs	r2, #4
    be64:	f362 0302 	bfi	r3, r2, #0, #3
    be68:	753b      	strb	r3, [r7, #20]
    be6a:	7d3b      	ldrb	r3, [r7, #20]
    be6c:	f36f 03c5 	bfc	r3, #3, #3
    be70:	753b      	strb	r3, [r7, #20]
    be72:	2303      	movs	r3, #3
    be74:	2b00      	cmp	r3, #0
    be76:	d009      	beq.n	be8c <z_impl_k_mutex_lock+0x604>
    be78:	4b0f      	ldr	r3, [pc, #60]	; (beb8 <z_impl_k_mutex_lock+0x630>)
    be7a:	681b      	ldr	r3, [r3, #0]
    be7c:	4618      	mov	r0, r3
    be7e:	f7ff fc6d 	bl	b75c <log_const_source_id>
    be82:	4603      	mov	r3, r0
    be84:	f3c3 0309 	ubfx	r3, r3, #0, #10
    be88:	b29a      	uxth	r2, r3
    be8a:	e000      	b.n	be8e <z_impl_k_mutex_lock+0x606>
    be8c:	2200      	movs	r2, #0
    be8e:	8abb      	ldrh	r3, [r7, #20]
    be90:	f362 138f 	bfi	r3, r2, #6, #10
    be94:	82bb      	strh	r3, [r7, #20]
    be96:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
    be9a:	2b00      	cmp	r3, #0
    be9c:	d020      	beq.n	bee0 <z_impl_k_mutex_lock+0x658>
    be9e:	68fb      	ldr	r3, [r7, #12]
    bea0:	4a02      	ldr	r2, [pc, #8]	; (beac <z_impl_k_mutex_lock+0x624>)
    bea2:	490e      	ldr	r1, [pc, #56]	; (bedc <z_impl_k_mutex_lock+0x654>)
    bea4:	8ab8      	ldrh	r0, [r7, #20]
    bea6:	f7f6 fd23 	bl	28f0 <log_from_user>
    beaa:	e01f      	b.n	beec <z_impl_k_mutex_lock+0x664>
    beac:	0001ce20 	.word	0x0001ce20
    beb0:	0001be0c 	.word	0x0001be0c
    beb4:	20000cd4 	.word	0x20000cd4
    beb8:	20000170 	.word	0x20000170
    bebc:	0001be30 	.word	0x0001be30
    bec0:	20000cd8 	.word	0x20000cd8
    bec4:	0001be54 	.word	0x0001be54
    bec8:	0001be74 	.word	0x0001be74
    becc:	0001bd54 	.word	0x0001bd54
    bed0:	0001bd7c 	.word	0x0001bd7c
    bed4:	0001bc7c 	.word	0x0001bc7c
    bed8:	0001bd94 	.word	0x0001bd94
    bedc:	0001be90 	.word	0x0001be90
    bee0:	4927      	ldr	r1, [pc, #156]	; (bf80 <z_impl_k_mutex_lock+0x6f8>)
    bee2:	68fa      	ldr	r2, [r7, #12]
    bee4:	8abb      	ldrh	r3, [r7, #20]
    bee6:	4827      	ldr	r0, [pc, #156]	; (bf84 <z_impl_k_mutex_lock+0x6fc>)
    bee8:	f005 fbc7 	bl	1167a <log_2>

	resched = adjust_owner_prio(mutex, new_prio) || resched;
    beec:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
    bef0:	68f8      	ldr	r0, [r7, #12]
    bef2:	f7ff fc43 	bl	b77c <adjust_owner_prio>
    bef6:	4603      	mov	r3, r0
    bef8:	2b00      	cmp	r3, #0
    befa:	d103      	bne.n	bf04 <z_impl_k_mutex_lock+0x67c>
    befc:	f897 30bf 	ldrb.w	r3, [r7, #191]	; 0xbf
    bf00:	2b00      	cmp	r3, #0
    bf02:	d001      	beq.n	bf08 <z_impl_k_mutex_lock+0x680>
    bf04:	2301      	movs	r3, #1
    bf06:	e000      	b.n	bf0a <z_impl_k_mutex_lock+0x682>
    bf08:	2300      	movs	r3, #0
    bf0a:	f887 30bf 	strb.w	r3, [r7, #191]	; 0xbf
    bf0e:	f897 30bf 	ldrb.w	r3, [r7, #191]	; 0xbf
    bf12:	f003 0301 	and.w	r3, r3, #1
    bf16:	f887 30bf 	strb.w	r3, [r7, #191]	; 0xbf

	if (resched) {
    bf1a:	f897 30bf 	ldrb.w	r3, [r7, #191]	; 0xbf
    bf1e:	2b00      	cmp	r3, #0
    bf20:	d004      	beq.n	bf2c <z_impl_k_mutex_lock+0x6a4>
		z_reschedule(&lock, key);
    bf22:	6f79      	ldr	r1, [r7, #116]	; 0x74
    bf24:	4818      	ldr	r0, [pc, #96]	; (bf88 <z_impl_k_mutex_lock+0x700>)
    bf26:	f001 fd89 	bl	da3c <z_reschedule>
    bf2a:	e023      	b.n	bf74 <z_impl_k_mutex_lock+0x6ec>
    bf2c:	4b16      	ldr	r3, [pc, #88]	; (bf88 <z_impl_k_mutex_lock+0x700>)
    bf2e:	67fb      	str	r3, [r7, #124]	; 0x7c
    bf30:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    bf32:	673b      	str	r3, [r7, #112]	; 0x70
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    bf34:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
    bf36:	f002 fdab 	bl	ea90 <z_spin_unlock_valid>
    bf3a:	4603      	mov	r3, r0
    bf3c:	f083 0301 	eor.w	r3, r3, #1
    bf40:	b2db      	uxtb	r3, r3
    bf42:	2b00      	cmp	r3, #0
    bf44:	d00d      	beq.n	bf62 <z_impl_k_mutex_lock+0x6da>
    bf46:	23a3      	movs	r3, #163	; 0xa3
    bf48:	4a10      	ldr	r2, [pc, #64]	; (bf8c <z_impl_k_mutex_lock+0x704>)
    bf4a:	4911      	ldr	r1, [pc, #68]	; (bf90 <z_impl_k_mutex_lock+0x708>)
    bf4c:	4811      	ldr	r0, [pc, #68]	; (bf94 <z_impl_k_mutex_lock+0x70c>)
    bf4e:	f004 f88b 	bl	10068 <printk>
    bf52:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
    bf54:	4810      	ldr	r0, [pc, #64]	; (bf98 <z_impl_k_mutex_lock+0x710>)
    bf56:	f004 f887 	bl	10068 <printk>
    bf5a:	21a3      	movs	r1, #163	; 0xa3
    bf5c:	480b      	ldr	r0, [pc, #44]	; (bf8c <z_impl_k_mutex_lock+0x704>)
    bf5e:	f004 fecb 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    bf62:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    bf64:	67bb      	str	r3, [r7, #120]	; 0x78
	__asm__ volatile(
    bf66:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    bf68:	f383 8811 	msr	BASEPRI, r3
    bf6c:	f3bf 8f6f 	isb	sy
}
    bf70:	bf00      	nop
}
    bf72:	bf00      	nop
	} else {
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
    bf74:	f06f 030a 	mvn.w	r3, #10
}
    bf78:	4618      	mov	r0, r3
    bf7a:	37c8      	adds	r7, #200	; 0xc8
    bf7c:	46bd      	mov	sp, r7
    bf7e:	bd80      	pop	{r7, pc}
    bf80:	0001ce20 	.word	0x0001ce20
    bf84:	0001be90 	.word	0x0001be90
    bf88:	20000cd4 	.word	0x20000cd4
    bf8c:	0001bd54 	.word	0x0001bd54
    bf90:	0001bddc 	.word	0x0001bddc
    bf94:	0001bc7c 	.word	0x0001bc7c
    bf98:	0001bdf4 	.word	0x0001bdf4

0000bf9c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    bf9c:	b580      	push	{r7, lr}
    bf9e:	b098      	sub	sp, #96	; 0x60
    bfa0:	af02      	add	r7, sp, #8
    bfa2:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    bfa4:	f3ef 8305 	mrs	r3, IPSR
    bfa8:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
    bfaa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    bfac:	2b00      	cmp	r3, #0
    bfae:	bf14      	ite	ne
    bfb0:	2301      	movne	r3, #1
    bfb2:	2300      	moveq	r3, #0
    bfb4:	b2db      	uxtb	r3, r3
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
    bfb6:	2b00      	cmp	r3, #0
    bfb8:	d00c      	beq.n	bfd4 <z_impl_k_mutex_unlock+0x38>
    bfba:	23d8      	movs	r3, #216	; 0xd8
    bfbc:	4aa0      	ldr	r2, [pc, #640]	; (c240 <z_impl_k_mutex_unlock+0x2a4>)
    bfbe:	49a1      	ldr	r1, [pc, #644]	; (c244 <z_impl_k_mutex_unlock+0x2a8>)
    bfc0:	48a1      	ldr	r0, [pc, #644]	; (c248 <z_impl_k_mutex_unlock+0x2ac>)
    bfc2:	f004 f851 	bl	10068 <printk>
    bfc6:	48a1      	ldr	r0, [pc, #644]	; (c24c <z_impl_k_mutex_unlock+0x2b0>)
    bfc8:	f004 f84e 	bl	10068 <printk>
    bfcc:	21d8      	movs	r1, #216	; 0xd8
    bfce:	489c      	ldr	r0, [pc, #624]	; (c240 <z_impl_k_mutex_unlock+0x2a4>)
    bfd0:	f004 fe92 	bl	10cf8 <assert_post_action>

	CHECKIF(mutex->owner == NULL) {
    bfd4:	687b      	ldr	r3, [r7, #4]
    bfd6:	689b      	ldr	r3, [r3, #8]
    bfd8:	2b00      	cmp	r3, #0
    bfda:	d102      	bne.n	bfe2 <z_impl_k_mutex_unlock+0x46>
		return -EINVAL;
    bfdc:	f06f 0315 	mvn.w	r3, #21
    bfe0:	e12a      	b.n	c238 <z_impl_k_mutex_unlock+0x29c>
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    bfe2:	687b      	ldr	r3, [r7, #4]
    bfe4:	689a      	ldr	r2, [r3, #8]
    bfe6:	4b9a      	ldr	r3, [pc, #616]	; (c250 <z_impl_k_mutex_unlock+0x2b4>)
    bfe8:	689b      	ldr	r3, [r3, #8]
    bfea:	429a      	cmp	r2, r3
    bfec:	d002      	beq.n	bff4 <z_impl_k_mutex_unlock+0x58>
		return -EPERM;
    bfee:	f04f 33ff 	mov.w	r3, #4294967295
    bff2:	e121      	b.n	c238 <z_impl_k_mutex_unlock+0x29c>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
    bff4:	687b      	ldr	r3, [r7, #4]
    bff6:	68db      	ldr	r3, [r3, #12]
    bff8:	2b00      	cmp	r3, #0
    bffa:	d109      	bne.n	c010 <z_impl_k_mutex_unlock+0x74>
    bffc:	23ea      	movs	r3, #234	; 0xea
    bffe:	4a90      	ldr	r2, [pc, #576]	; (c240 <z_impl_k_mutex_unlock+0x2a4>)
    c000:	4994      	ldr	r1, [pc, #592]	; (c254 <z_impl_k_mutex_unlock+0x2b8>)
    c002:	4891      	ldr	r0, [pc, #580]	; (c248 <z_impl_k_mutex_unlock+0x2ac>)
    c004:	f004 f830 	bl	10068 <printk>
    c008:	21ea      	movs	r1, #234	; 0xea
    c00a:	488d      	ldr	r0, [pc, #564]	; (c240 <z_impl_k_mutex_unlock+0x2a4>)
    c00c:	f004 fe74 	bl	10cf8 <assert_post_action>

	sys_trace_mutex_unlock(mutex);
	z_sched_lock();
    c010:	f7ff fb5c 	bl	b6cc <z_sched_lock>

	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
    c014:	2303      	movs	r3, #3
    c016:	2b03      	cmp	r3, #3
    c018:	d939      	bls.n	c08e <z_impl_k_mutex_unlock+0xf2>
    c01a:	f00a ff95 	bl	16f48 <_is_user_context>
    c01e:	4603      	mov	r3, r0
    c020:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    c024:	7f3b      	ldrb	r3, [r7, #28]
    c026:	2204      	movs	r2, #4
    c028:	f362 0302 	bfi	r3, r2, #0, #3
    c02c:	773b      	strb	r3, [r7, #28]
    c02e:	7f3b      	ldrb	r3, [r7, #28]
    c030:	f36f 03c5 	bfc	r3, #3, #3
    c034:	773b      	strb	r3, [r7, #28]
    c036:	2303      	movs	r3, #3
    c038:	2b00      	cmp	r3, #0
    c03a:	d009      	beq.n	c050 <z_impl_k_mutex_unlock+0xb4>
    c03c:	4b86      	ldr	r3, [pc, #536]	; (c258 <z_impl_k_mutex_unlock+0x2bc>)
    c03e:	681b      	ldr	r3, [r3, #0]
    c040:	4618      	mov	r0, r3
    c042:	f7ff fb8b 	bl	b75c <log_const_source_id>
    c046:	4603      	mov	r3, r0
    c048:	f3c3 0309 	ubfx	r3, r3, #0, #10
    c04c:	b29a      	uxth	r2, r3
    c04e:	e000      	b.n	c052 <z_impl_k_mutex_unlock+0xb6>
    c050:	2200      	movs	r2, #0
    c052:	8bbb      	ldrh	r3, [r7, #28]
    c054:	f362 138f 	bfi	r3, r2, #6, #10
    c058:	83bb      	strh	r3, [r7, #28]
    c05a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
    c05e:	2b00      	cmp	r3, #0
    c060:	d009      	beq.n	c076 <z_impl_k_mutex_unlock+0xda>
    c062:	687b      	ldr	r3, [r7, #4]
    c064:	68db      	ldr	r3, [r3, #12]
    c066:	9300      	str	r3, [sp, #0]
    c068:	687b      	ldr	r3, [r7, #4]
    c06a:	4a7c      	ldr	r2, [pc, #496]	; (c25c <z_impl_k_mutex_unlock+0x2c0>)
    c06c:	497c      	ldr	r1, [pc, #496]	; (c260 <z_impl_k_mutex_unlock+0x2c4>)
    c06e:	8bb8      	ldrh	r0, [r7, #28]
    c070:	f7f6 fc3e 	bl	28f0 <log_from_user>
    c074:	e00b      	b.n	c08e <z_impl_k_mutex_unlock+0xf2>
    c076:	4879      	ldr	r0, [pc, #484]	; (c25c <z_impl_k_mutex_unlock+0x2c0>)
    c078:	687a      	ldr	r2, [r7, #4]
    c07a:	687b      	ldr	r3, [r7, #4]
    c07c:	68d9      	ldr	r1, [r3, #12]
    c07e:	8bbb      	ldrh	r3, [r7, #28]
    c080:	f8ad 3000 	strh.w	r3, [sp]
    c084:	460b      	mov	r3, r1
    c086:	4601      	mov	r1, r0
    c088:	4875      	ldr	r0, [pc, #468]	; (c260 <z_impl_k_mutex_unlock+0x2c4>)
    c08a:	f005 fb0f 	bl	116ac <log_3>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
    c08e:	687b      	ldr	r3, [r7, #4]
    c090:	68db      	ldr	r3, [r3, #12]
    c092:	2b01      	cmp	r3, #1
    c094:	d005      	beq.n	c0a2 <z_impl_k_mutex_unlock+0x106>
		mutex->lock_count--;
    c096:	687b      	ldr	r3, [r7, #4]
    c098:	68db      	ldr	r3, [r3, #12]
    c09a:	1e5a      	subs	r2, r3, #1
    c09c:	687b      	ldr	r3, [r7, #4]
    c09e:	60da      	str	r2, [r3, #12]
		goto k_mutex_unlock_return;
    c0a0:	e0c7      	b.n	c232 <z_impl_k_mutex_unlock+0x296>
    c0a2:	4b70      	ldr	r3, [pc, #448]	; (c264 <z_impl_k_mutex_unlock+0x2c8>)
    c0a4:	647b      	str	r3, [r7, #68]	; 0x44
	__asm__ volatile(
    c0a6:	f04f 0320 	mov.w	r3, #32
    c0aa:	f3ef 8211 	mrs	r2, BASEPRI
    c0ae:	f383 8811 	msr	BASEPRI, r3
    c0b2:	f3bf 8f6f 	isb	sy
    c0b6:	643a      	str	r2, [r7, #64]	; 0x40
    c0b8:	63fb      	str	r3, [r7, #60]	; 0x3c
	return key;
    c0ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
	k.key = arch_irq_lock();
    c0bc:	623b      	str	r3, [r7, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    c0be:	6c78      	ldr	r0, [r7, #68]	; 0x44
    c0c0:	f002 fcca 	bl	ea58 <z_spin_lock_valid>
    c0c4:	4603      	mov	r3, r0
    c0c6:	f083 0301 	eor.w	r3, r3, #1
    c0ca:	b2db      	uxtb	r3, r3
    c0cc:	2b00      	cmp	r3, #0
    c0ce:	d00d      	beq.n	c0ec <z_impl_k_mutex_unlock+0x150>
    c0d0:	2378      	movs	r3, #120	; 0x78
    c0d2:	4a65      	ldr	r2, [pc, #404]	; (c268 <z_impl_k_mutex_unlock+0x2cc>)
    c0d4:	4965      	ldr	r1, [pc, #404]	; (c26c <z_impl_k_mutex_unlock+0x2d0>)
    c0d6:	485c      	ldr	r0, [pc, #368]	; (c248 <z_impl_k_mutex_unlock+0x2ac>)
    c0d8:	f003 ffc6 	bl	10068 <printk>
    c0dc:	6c79      	ldr	r1, [r7, #68]	; 0x44
    c0de:	4864      	ldr	r0, [pc, #400]	; (c270 <z_impl_k_mutex_unlock+0x2d4>)
    c0e0:	f003 ffc2 	bl	10068 <printk>
    c0e4:	2178      	movs	r1, #120	; 0x78
    c0e6:	4860      	ldr	r0, [pc, #384]	; (c268 <z_impl_k_mutex_unlock+0x2cc>)
    c0e8:	f004 fe06 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    c0ec:	6c78      	ldr	r0, [r7, #68]	; 0x44
    c0ee:	f002 fceb 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    c0f2:	6a3b      	ldr	r3, [r7, #32]
    c0f4:	62bb      	str	r3, [r7, #40]	; 0x28
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    c0f6:	687b      	ldr	r3, [r7, #4]
    c0f8:	691b      	ldr	r3, [r3, #16]
    c0fa:	4619      	mov	r1, r3
    c0fc:	6878      	ldr	r0, [r7, #4]
    c0fe:	f7ff fb3d 	bl	b77c <adjust_owner_prio>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    c102:	687b      	ldr	r3, [r7, #4]
    c104:	4618      	mov	r0, r3
    c106:	f00b fd68 	bl	17bda <z_unpend_first_thread>
    c10a:	6538      	str	r0, [r7, #80]	; 0x50

	mutex->owner = new_owner;
    c10c:	687b      	ldr	r3, [r7, #4]
    c10e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    c110:	609a      	str	r2, [r3, #8]

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
    c112:	2303      	movs	r3, #3
    c114:	2b03      	cmp	r3, #3
    c116:	d94b      	bls.n	c1b0 <z_impl_k_mutex_unlock+0x214>
    c118:	f00a ff16 	bl	16f48 <_is_user_context>
    c11c:	4603      	mov	r3, r0
    c11e:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
    c122:	7e3b      	ldrb	r3, [r7, #24]
    c124:	2204      	movs	r2, #4
    c126:	f362 0302 	bfi	r3, r2, #0, #3
    c12a:	763b      	strb	r3, [r7, #24]
    c12c:	7e3b      	ldrb	r3, [r7, #24]
    c12e:	f36f 03c5 	bfc	r3, #3, #3
    c132:	763b      	strb	r3, [r7, #24]
    c134:	2303      	movs	r3, #3
    c136:	2b00      	cmp	r3, #0
    c138:	d009      	beq.n	c14e <z_impl_k_mutex_unlock+0x1b2>
    c13a:	4b47      	ldr	r3, [pc, #284]	; (c258 <z_impl_k_mutex_unlock+0x2bc>)
    c13c:	681b      	ldr	r3, [r3, #0]
    c13e:	4618      	mov	r0, r3
    c140:	f7ff fb0c 	bl	b75c <log_const_source_id>
    c144:	4603      	mov	r3, r0
    c146:	f3c3 0309 	ubfx	r3, r3, #0, #10
    c14a:	b29a      	uxth	r2, r3
    c14c:	e000      	b.n	c150 <z_impl_k_mutex_unlock+0x1b4>
    c14e:	2200      	movs	r2, #0
    c150:	8b3b      	ldrh	r3, [r7, #24]
    c152:	f362 138f 	bfi	r3, r2, #6, #10
    c156:	833b      	strh	r3, [r7, #24]
    c158:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
    c15c:	2b00      	cmp	r3, #0
    c15e:	d011      	beq.n	c184 <z_impl_k_mutex_unlock+0x1e8>
    c160:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c162:	2b00      	cmp	r3, #0
    c164:	d003      	beq.n	c16e <z_impl_k_mutex_unlock+0x1d2>
    c166:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c168:	f993 300e 	ldrsb.w	r3, [r3, #14]
    c16c:	e000      	b.n	c170 <z_impl_k_mutex_unlock+0x1d4>
    c16e:	4b41      	ldr	r3, [pc, #260]	; (c274 <z_impl_k_mutex_unlock+0x2d8>)
    c170:	9301      	str	r3, [sp, #4]
    c172:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c174:	9300      	str	r3, [sp, #0]
    c176:	687b      	ldr	r3, [r7, #4]
    c178:	4a38      	ldr	r2, [pc, #224]	; (c25c <z_impl_k_mutex_unlock+0x2c0>)
    c17a:	493f      	ldr	r1, [pc, #252]	; (c278 <z_impl_k_mutex_unlock+0x2dc>)
    c17c:	8b38      	ldrh	r0, [r7, #24]
    c17e:	f7f6 fbb7 	bl	28f0 <log_from_user>
    c182:	e015      	b.n	c1b0 <z_impl_k_mutex_unlock+0x214>
    c184:	4b35      	ldr	r3, [pc, #212]	; (c25c <z_impl_k_mutex_unlock+0x2c0>)
    c186:	60bb      	str	r3, [r7, #8]
    c188:	687b      	ldr	r3, [r7, #4]
    c18a:	60fb      	str	r3, [r7, #12]
    c18c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c18e:	613b      	str	r3, [r7, #16]
    c190:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c192:	2b00      	cmp	r3, #0
    c194:	d003      	beq.n	c19e <z_impl_k_mutex_unlock+0x202>
    c196:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c198:	f993 300e 	ldrsb.w	r3, [r3, #14]
    c19c:	e000      	b.n	c1a0 <z_impl_k_mutex_unlock+0x204>
    c19e:	4b35      	ldr	r3, [pc, #212]	; (c274 <z_impl_k_mutex_unlock+0x2d8>)
    c1a0:	617b      	str	r3, [r7, #20]
    c1a2:	f107 0108 	add.w	r1, r7, #8
    c1a6:	8b3b      	ldrh	r3, [r7, #24]
    c1a8:	2204      	movs	r2, #4
    c1aa:	4833      	ldr	r0, [pc, #204]	; (c278 <z_impl_k_mutex_unlock+0x2dc>)
    c1ac:	f005 fa98 	bl	116e0 <log_n>
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
    c1b0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c1b2:	2b00      	cmp	r3, #0
    c1b4:	d016      	beq.n	c1e4 <z_impl_k_mutex_unlock+0x248>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
    c1b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c1b8:	f993 300e 	ldrsb.w	r3, [r3, #14]
    c1bc:	461a      	mov	r2, r3
    c1be:	687b      	ldr	r3, [r7, #4]
    c1c0:	611a      	str	r2, [r3, #16]
    c1c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    c1c4:	63bb      	str	r3, [r7, #56]	; 0x38
    c1c6:	2300      	movs	r3, #0
    c1c8:	637b      	str	r3, [r7, #52]	; 0x34
	thread->arch.swap_return_value = value;
    c1ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    c1cc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    c1ce:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    c1d2:	bf00      	nop
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
    c1d4:	6d38      	ldr	r0, [r7, #80]	; 0x50
    c1d6:	f000 fcb7 	bl	cb48 <z_ready_thread>
		z_reschedule(&lock, key);
    c1da:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    c1dc:	4821      	ldr	r0, [pc, #132]	; (c264 <z_impl_k_mutex_unlock+0x2c8>)
    c1de:	f001 fc2d 	bl	da3c <z_reschedule>
    c1e2:	e026      	b.n	c232 <z_impl_k_mutex_unlock+0x296>
	} else {
		mutex->lock_count = 0U;
    c1e4:	687b      	ldr	r3, [r7, #4]
    c1e6:	2200      	movs	r2, #0
    c1e8:	60da      	str	r2, [r3, #12]
    c1ea:	4b1e      	ldr	r3, [pc, #120]	; (c264 <z_impl_k_mutex_unlock+0x2c8>)
    c1ec:	633b      	str	r3, [r7, #48]	; 0x30
    c1ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
    c1f0:	627b      	str	r3, [r7, #36]	; 0x24
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c1f2:	6b38      	ldr	r0, [r7, #48]	; 0x30
    c1f4:	f002 fc4c 	bl	ea90 <z_spin_unlock_valid>
    c1f8:	4603      	mov	r3, r0
    c1fa:	f083 0301 	eor.w	r3, r3, #1
    c1fe:	b2db      	uxtb	r3, r3
    c200:	2b00      	cmp	r3, #0
    c202:	d00d      	beq.n	c220 <z_impl_k_mutex_unlock+0x284>
    c204:	23a3      	movs	r3, #163	; 0xa3
    c206:	4a18      	ldr	r2, [pc, #96]	; (c268 <z_impl_k_mutex_unlock+0x2cc>)
    c208:	491c      	ldr	r1, [pc, #112]	; (c27c <z_impl_k_mutex_unlock+0x2e0>)
    c20a:	480f      	ldr	r0, [pc, #60]	; (c248 <z_impl_k_mutex_unlock+0x2ac>)
    c20c:	f003 ff2c 	bl	10068 <printk>
    c210:	6b39      	ldr	r1, [r7, #48]	; 0x30
    c212:	481b      	ldr	r0, [pc, #108]	; (c280 <z_impl_k_mutex_unlock+0x2e4>)
    c214:	f003 ff28 	bl	10068 <printk>
    c218:	21a3      	movs	r1, #163	; 0xa3
    c21a:	4813      	ldr	r0, [pc, #76]	; (c268 <z_impl_k_mutex_unlock+0x2cc>)
    c21c:	f004 fd6c 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c220:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c222:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    c224:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    c226:	f383 8811 	msr	BASEPRI, r3
    c22a:	f3bf 8f6f 	isb	sy
}
    c22e:	bf00      	nop
}
    c230:	bf00      	nop
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
    c232:	f001 fcd5 	bl	dbe0 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
    c236:	2300      	movs	r3, #0
}
    c238:	4618      	mov	r0, r3
    c23a:	3758      	adds	r7, #88	; 0x58
    c23c:	46bd      	mov	sp, r7
    c23e:	bd80      	pop	{r7, pc}
    c240:	0001bd08 	.word	0x0001bd08
    c244:	0001bc68 	.word	0x0001bc68
    c248:	0001bc7c 	.word	0x0001bc7c
    c24c:	0001bd2c 	.word	0x0001bd2c
    c250:	20000cd8 	.word	0x20000cd8
    c254:	0001beb4 	.word	0x0001beb4
    c258:	20000170 	.word	0x20000170
    c25c:	0001ce34 	.word	0x0001ce34
    c260:	0001becc 	.word	0x0001becc
    c264:	20000cd4 	.word	0x20000cd4
    c268:	0001bd54 	.word	0x0001bd54
    c26c:	0001bd7c 	.word	0x0001bd7c
    c270:	0001bd94 	.word	0x0001bd94
    c274:	fffffc18 	.word	0xfffffc18
    c278:	0001bee8 	.word	0x0001bee8
    c27c:	0001bddc 	.word	0x0001bddc
    c280:	0001bdf4 	.word	0x0001bdf4

0000c284 <z_add_thread_timeout>:
}

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, k_timeout_t ticks)
{
    c284:	b580      	push	{r7, lr}
    c286:	b084      	sub	sp, #16
    c288:	af00      	add	r7, sp, #0
    c28a:	60f8      	str	r0, [r7, #12]
    c28c:	e9c7 2300 	strd	r2, r3, [r7]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    c290:	68fb      	ldr	r3, [r7, #12]
    c292:	f103 0018 	add.w	r0, r3, #24
    c296:	e9d7 2300 	ldrd	r2, r3, [r7]
    c29a:	4903      	ldr	r1, [pc, #12]	; (c2a8 <z_add_thread_timeout+0x24>)
    c29c:	f002 fd46 	bl	ed2c <z_add_timeout>
}
    c2a0:	bf00      	nop
    c2a2:	3710      	adds	r7, #16
    c2a4:	46bd      	mov	sp, r7
    c2a6:	bd80      	pop	{r7, pc}
    c2a8:	0000d6c1 	.word	0x0000d6c1

0000c2ac <z_is_idle_thread_object>:
{
    c2ac:	b480      	push	{r7}
    c2ae:	b083      	sub	sp, #12
    c2b0:	af00      	add	r7, sp, #0
    c2b2:	6078      	str	r0, [r7, #4]
	return thread == &z_idle_threads[0];
    c2b4:	687b      	ldr	r3, [r7, #4]
    c2b6:	4a05      	ldr	r2, [pc, #20]	; (c2cc <z_is_idle_thread_object+0x20>)
    c2b8:	4293      	cmp	r3, r2
    c2ba:	bf0c      	ite	eq
    c2bc:	2301      	moveq	r3, #1
    c2be:	2300      	movne	r3, #0
    c2c0:	b2db      	uxtb	r3, r3
}
    c2c2:	4618      	mov	r0, r3
    c2c4:	370c      	adds	r7, #12
    c2c6:	46bd      	mov	sp, r7
    c2c8:	bc80      	pop	{r7}
    c2ca:	4770      	bx	lr
    c2cc:	200005b0 	.word	0x200005b0

0000c2d0 <z_sched_lock>:
{
    c2d0:	b580      	push	{r7, lr}
    c2d2:	b082      	sub	sp, #8
    c2d4:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    c2d6:	f3ef 8305 	mrs	r3, IPSR
    c2da:	607b      	str	r3, [r7, #4]
  return(result);
    c2dc:	687b      	ldr	r3, [r7, #4]
    c2de:	2b00      	cmp	r3, #0
    c2e0:	bf14      	ite	ne
    c2e2:	2301      	movne	r3, #1
    c2e4:	2300      	moveq	r3, #0
    c2e6:	b2db      	uxtb	r3, r3
	__ASSERT(!arch_is_in_isr(), "");
    c2e8:	2b00      	cmp	r3, #0
    c2ea:	d00e      	beq.n	c30a <z_sched_lock+0x3a>
    c2ec:	f44f 7389 	mov.w	r3, #274	; 0x112
    c2f0:	4a15      	ldr	r2, [pc, #84]	; (c348 <z_sched_lock+0x78>)
    c2f2:	4916      	ldr	r1, [pc, #88]	; (c34c <z_sched_lock+0x7c>)
    c2f4:	4816      	ldr	r0, [pc, #88]	; (c350 <z_sched_lock+0x80>)
    c2f6:	f003 feb7 	bl	10068 <printk>
    c2fa:	4816      	ldr	r0, [pc, #88]	; (c354 <z_sched_lock+0x84>)
    c2fc:	f003 feb4 	bl	10068 <printk>
    c300:	f44f 7189 	mov.w	r1, #274	; 0x112
    c304:	4810      	ldr	r0, [pc, #64]	; (c348 <z_sched_lock+0x78>)
    c306:	f004 fcf7 	bl	10cf8 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
    c30a:	4b13      	ldr	r3, [pc, #76]	; (c358 <z_sched_lock+0x88>)
    c30c:	689b      	ldr	r3, [r3, #8]
    c30e:	7bdb      	ldrb	r3, [r3, #15]
    c310:	2b01      	cmp	r3, #1
    c312:	d10e      	bne.n	c332 <z_sched_lock+0x62>
    c314:	f240 1313 	movw	r3, #275	; 0x113
    c318:	4a0b      	ldr	r2, [pc, #44]	; (c348 <z_sched_lock+0x78>)
    c31a:	4910      	ldr	r1, [pc, #64]	; (c35c <z_sched_lock+0x8c>)
    c31c:	480c      	ldr	r0, [pc, #48]	; (c350 <z_sched_lock+0x80>)
    c31e:	f003 fea3 	bl	10068 <printk>
    c322:	480c      	ldr	r0, [pc, #48]	; (c354 <z_sched_lock+0x84>)
    c324:	f003 fea0 	bl	10068 <printk>
    c328:	f240 1113 	movw	r1, #275	; 0x113
    c32c:	4806      	ldr	r0, [pc, #24]	; (c348 <z_sched_lock+0x78>)
    c32e:	f004 fce3 	bl	10cf8 <assert_post_action>
	--_current->base.sched_locked;
    c332:	4b09      	ldr	r3, [pc, #36]	; (c358 <z_sched_lock+0x88>)
    c334:	689b      	ldr	r3, [r3, #8]
    c336:	7bda      	ldrb	r2, [r3, #15]
    c338:	3a01      	subs	r2, #1
    c33a:	b2d2      	uxtb	r2, r2
    c33c:	73da      	strb	r2, [r3, #15]
}
    c33e:	bf00      	nop
    c340:	3708      	adds	r7, #8
    c342:	46bd      	mov	sp, r7
    c344:	bd80      	pop	{r7, pc}
    c346:	bf00      	nop
    c348:	0001bf14 	.word	0x0001bf14
    c34c:	0001bf40 	.word	0x0001bf40
    c350:	0001bf54 	.word	0x0001bf54
    c354:	0001bf74 	.word	0x0001bf74
    c358:	20000cd8 	.word	0x20000cd8
    c35c:	0001bf78 	.word	0x0001bf78

0000c360 <z_unpend1_no_timeout>:
	return 0;
#endif
}

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
    c360:	b580      	push	{r7, lr}
    c362:	b09a      	sub	sp, #104	; 0x68
    c364:	af00      	add	r7, sp, #0
    c366:	6078      	str	r0, [r7, #4]
    c368:	687b      	ldr	r3, [r7, #4]
    c36a:	663b      	str	r3, [r7, #96]	; 0x60
    c36c:	2300      	movs	r3, #0
    c36e:	65fb      	str	r3, [r7, #92]	; 0x5c
ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;
    c370:	2300      	movs	r3, #0
    c372:	65bb      	str	r3, [r7, #88]	; 0x58

	LOCKED(&sched_spinlock) {
    c374:	2300      	movs	r3, #0
    c376:	61bb      	str	r3, [r7, #24]
    c378:	4b5f      	ldr	r3, [pc, #380]	; (c4f8 <z_unpend1_no_timeout+0x198>)
    c37a:	657b      	str	r3, [r7, #84]	; 0x54
	__asm__ volatile(
    c37c:	f04f 0320 	mov.w	r3, #32
    c380:	f3ef 8211 	mrs	r2, BASEPRI
    c384:	f383 8811 	msr	BASEPRI, r3
    c388:	f3bf 8f6f 	isb	sy
    c38c:	653a      	str	r2, [r7, #80]	; 0x50
    c38e:	64fb      	str	r3, [r7, #76]	; 0x4c
	return key;
    c390:	6d3b      	ldr	r3, [r7, #80]	; 0x50
	k.key = arch_irq_lock();
    c392:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    c394:	6d78      	ldr	r0, [r7, #84]	; 0x54
    c396:	f002 fb5f 	bl	ea58 <z_spin_lock_valid>
    c39a:	4603      	mov	r3, r0
    c39c:	f083 0301 	eor.w	r3, r3, #1
    c3a0:	b2db      	uxtb	r3, r3
    c3a2:	2b00      	cmp	r3, #0
    c3a4:	d00d      	beq.n	c3c2 <z_unpend1_no_timeout+0x62>
    c3a6:	2378      	movs	r3, #120	; 0x78
    c3a8:	4a54      	ldr	r2, [pc, #336]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c3aa:	4955      	ldr	r1, [pc, #340]	; (c500 <z_unpend1_no_timeout+0x1a0>)
    c3ac:	4855      	ldr	r0, [pc, #340]	; (c504 <z_unpend1_no_timeout+0x1a4>)
    c3ae:	f003 fe5b 	bl	10068 <printk>
    c3b2:	6d79      	ldr	r1, [r7, #84]	; 0x54
    c3b4:	4854      	ldr	r0, [pc, #336]	; (c508 <z_unpend1_no_timeout+0x1a8>)
    c3b6:	f003 fe57 	bl	10068 <printk>
    c3ba:	2178      	movs	r1, #120	; 0x78
    c3bc:	484f      	ldr	r0, [pc, #316]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c3be:	f004 fc9b 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    c3c2:	6d78      	ldr	r0, [r7, #84]	; 0x54
    c3c4:	f002 fb80 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    c3c8:	68fb      	ldr	r3, [r7, #12]
    c3ca:	617b      	str	r3, [r7, #20]
    c3cc:	e02a      	b.n	c424 <z_unpend1_no_timeout+0xc4>
		ret = _priq_wait_best(&wait_q->waitq);
    c3ce:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    c3d0:	4618      	mov	r0, r3
    c3d2:	f00b fc53 	bl	17c7c <z_priq_dumb_best>
    c3d6:	65b8      	str	r0, [r7, #88]	; 0x58
    c3d8:	4b47      	ldr	r3, [pc, #284]	; (c4f8 <z_unpend1_no_timeout+0x198>)
    c3da:	64bb      	str	r3, [r7, #72]	; 0x48
    c3dc:	697b      	ldr	r3, [r7, #20]
    c3de:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c3e0:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    c3e2:	f002 fb55 	bl	ea90 <z_spin_unlock_valid>
    c3e6:	4603      	mov	r3, r0
    c3e8:	f083 0301 	eor.w	r3, r3, #1
    c3ec:	b2db      	uxtb	r3, r3
    c3ee:	2b00      	cmp	r3, #0
    c3f0:	d00d      	beq.n	c40e <z_unpend1_no_timeout+0xae>
    c3f2:	23a3      	movs	r3, #163	; 0xa3
    c3f4:	4a41      	ldr	r2, [pc, #260]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c3f6:	4945      	ldr	r1, [pc, #276]	; (c50c <z_unpend1_no_timeout+0x1ac>)
    c3f8:	4842      	ldr	r0, [pc, #264]	; (c504 <z_unpend1_no_timeout+0x1a4>)
    c3fa:	f003 fe35 	bl	10068 <printk>
    c3fe:	6cb9      	ldr	r1, [r7, #72]	; 0x48
    c400:	4843      	ldr	r0, [pc, #268]	; (c510 <z_unpend1_no_timeout+0x1b0>)
    c402:	f003 fe31 	bl	10068 <printk>
    c406:	21a3      	movs	r1, #163	; 0xa3
    c408:	483c      	ldr	r0, [pc, #240]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c40a:	f004 fc75 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c40e:	693b      	ldr	r3, [r7, #16]
    c410:	647b      	str	r3, [r7, #68]	; 0x44
	__asm__ volatile(
    c412:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    c414:	f383 8811 	msr	BASEPRI, r3
    c418:	f3bf 8f6f 	isb	sy
}
    c41c:	bf00      	nop
}
    c41e:	bf00      	nop
	LOCKED(&sched_spinlock) {
    c420:	2301      	movs	r3, #1
    c422:	61bb      	str	r3, [r7, #24]
    c424:	69bb      	ldr	r3, [r7, #24]
    c426:	2b00      	cmp	r3, #0
    c428:	d0d1      	beq.n	c3ce <z_unpend1_no_timeout+0x6e>
	}

	return ret;
    c42a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
    c42c:	667b      	str	r3, [r7, #100]	; 0x64

	if (thread != NULL) {
    c42e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    c430:	2b00      	cmp	r3, #0
    c432:	d05b      	beq.n	c4ec <z_unpend1_no_timeout+0x18c>
    c434:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    c436:	643b      	str	r3, [r7, #64]	; 0x40
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
	LOCKED(&sched_spinlock) {
    c438:	2300      	movs	r3, #0
    c43a:	62bb      	str	r3, [r7, #40]	; 0x28
    c43c:	4b2e      	ldr	r3, [pc, #184]	; (c4f8 <z_unpend1_no_timeout+0x198>)
    c43e:	63fb      	str	r3, [r7, #60]	; 0x3c
	__asm__ volatile(
    c440:	f04f 0320 	mov.w	r3, #32
    c444:	f3ef 8211 	mrs	r2, BASEPRI
    c448:	f383 8811 	msr	BASEPRI, r3
    c44c:	f3bf 8f6f 	isb	sy
    c450:	63ba      	str	r2, [r7, #56]	; 0x38
    c452:	637b      	str	r3, [r7, #52]	; 0x34
	return key;
    c454:	6bbb      	ldr	r3, [r7, #56]	; 0x38
	k.key = arch_irq_lock();
    c456:	61fb      	str	r3, [r7, #28]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    c458:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    c45a:	f002 fafd 	bl	ea58 <z_spin_lock_valid>
    c45e:	4603      	mov	r3, r0
    c460:	f083 0301 	eor.w	r3, r3, #1
    c464:	b2db      	uxtb	r3, r3
    c466:	2b00      	cmp	r3, #0
    c468:	d00d      	beq.n	c486 <z_unpend1_no_timeout+0x126>
    c46a:	2378      	movs	r3, #120	; 0x78
    c46c:	4a23      	ldr	r2, [pc, #140]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c46e:	4924      	ldr	r1, [pc, #144]	; (c500 <z_unpend1_no_timeout+0x1a0>)
    c470:	4824      	ldr	r0, [pc, #144]	; (c504 <z_unpend1_no_timeout+0x1a4>)
    c472:	f003 fdf9 	bl	10068 <printk>
    c476:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    c478:	4823      	ldr	r0, [pc, #140]	; (c508 <z_unpend1_no_timeout+0x1a8>)
    c47a:	f003 fdf5 	bl	10068 <printk>
    c47e:	2178      	movs	r1, #120	; 0x78
    c480:	481e      	ldr	r0, [pc, #120]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c482:	f004 fc39 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    c486:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    c488:	f002 fb1e 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    c48c:	69fb      	ldr	r3, [r7, #28]
    c48e:	627b      	str	r3, [r7, #36]	; 0x24
    c490:	e028      	b.n	c4e4 <z_unpend1_no_timeout+0x184>
		unpend_thread_no_timeout(thread);
    c492:	6c38      	ldr	r0, [r7, #64]	; 0x40
    c494:	f00b fb8b 	bl	17bae <unpend_thread_no_timeout>
    c498:	4b17      	ldr	r3, [pc, #92]	; (c4f8 <z_unpend1_no_timeout+0x198>)
    c49a:	633b      	str	r3, [r7, #48]	; 0x30
    c49c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c49e:	623b      	str	r3, [r7, #32]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c4a0:	6b38      	ldr	r0, [r7, #48]	; 0x30
    c4a2:	f002 faf5 	bl	ea90 <z_spin_unlock_valid>
    c4a6:	4603      	mov	r3, r0
    c4a8:	f083 0301 	eor.w	r3, r3, #1
    c4ac:	b2db      	uxtb	r3, r3
    c4ae:	2b00      	cmp	r3, #0
    c4b0:	d00d      	beq.n	c4ce <z_unpend1_no_timeout+0x16e>
    c4b2:	23a3      	movs	r3, #163	; 0xa3
    c4b4:	4a11      	ldr	r2, [pc, #68]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c4b6:	4915      	ldr	r1, [pc, #84]	; (c50c <z_unpend1_no_timeout+0x1ac>)
    c4b8:	4812      	ldr	r0, [pc, #72]	; (c504 <z_unpend1_no_timeout+0x1a4>)
    c4ba:	f003 fdd5 	bl	10068 <printk>
    c4be:	6b39      	ldr	r1, [r7, #48]	; 0x30
    c4c0:	4813      	ldr	r0, [pc, #76]	; (c510 <z_unpend1_no_timeout+0x1b0>)
    c4c2:	f003 fdd1 	bl	10068 <printk>
    c4c6:	21a3      	movs	r1, #163	; 0xa3
    c4c8:	480c      	ldr	r0, [pc, #48]	; (c4fc <z_unpend1_no_timeout+0x19c>)
    c4ca:	f004 fc15 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c4ce:	6a3b      	ldr	r3, [r7, #32]
    c4d0:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    c4d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    c4d4:	f383 8811 	msr	BASEPRI, r3
    c4d8:	f3bf 8f6f 	isb	sy
}
    c4dc:	bf00      	nop
}
    c4de:	bf00      	nop
	LOCKED(&sched_spinlock) {
    c4e0:	2301      	movs	r3, #1
    c4e2:	62bb      	str	r3, [r7, #40]	; 0x28
    c4e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    c4e6:	2b00      	cmp	r3, #0
    c4e8:	d0d3      	beq.n	c492 <z_unpend1_no_timeout+0x132>
	}
}
    c4ea:	bf00      	nop
		z_unpend_thread_no_timeout(thread);
	}

	return thread;
    c4ec:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
    c4ee:	4618      	mov	r0, r3
    c4f0:	3768      	adds	r7, #104	; 0x68
    c4f2:	46bd      	mov	sp, r7
    c4f4:	bd80      	pop	{r7, pc}
    c4f6:	bf00      	nop
    c4f8:	20000d0c 	.word	0x20000d0c
    c4fc:	0001bfa8 	.word	0x0001bfa8
    c500:	0001bfd0 	.word	0x0001bfd0
    c504:	0001bf54 	.word	0x0001bf54
    c508:	0001bfe8 	.word	0x0001bfe8
    c50c:	0001c000 	.word	0x0001c000
    c510:	0001c018 	.word	0x0001c018

0000c514 <log_const_source_id>:
{
    c514:	b480      	push	{r7}
    c516:	b083      	sub	sp, #12
    c518:	af00      	add	r7, sp, #0
    c51a:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    c51c:	687b      	ldr	r3, [r7, #4]
    c51e:	4a04      	ldr	r2, [pc, #16]	; (c530 <log_const_source_id+0x1c>)
    c520:	1a9b      	subs	r3, r3, r2
    c522:	08db      	lsrs	r3, r3, #3
}
    c524:	4618      	mov	r0, r3
    c526:	370c      	adds	r7, #12
    c528:	46bd      	mov	sp, r7
    c52a:	bc80      	pop	{r7}
    c52c:	4770      	bx	lr
    c52e:	bf00      	nop
    c530:	00018788 	.word	0x00018788

0000c534 <move_thread_to_end_of_prio_q>:
{
    c534:	b580      	push	{r7, lr}
    c536:	b086      	sub	sp, #24
    c538:	af00      	add	r7, sp, #0
    c53a:	6078      	str	r0, [r7, #4]
	if (z_is_thread_queued(thread)) {
    c53c:	6878      	ldr	r0, [r7, #4]
    c53e:	f00b f9fc 	bl	1793a <z_is_thread_queued>
    c542:	4603      	mov	r3, r0
    c544:	2b00      	cmp	r3, #0
    c546:	d003      	beq.n	c550 <move_thread_to_end_of_prio_q+0x1c>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    c548:	6879      	ldr	r1, [r7, #4]
    c54a:	4832      	ldr	r0, [pc, #200]	; (c614 <move_thread_to_end_of_prio_q+0xe0>)
    c54c:	f001 fc40 	bl	ddd0 <z_priq_dumb_remove>
    c550:	4b30      	ldr	r3, [pc, #192]	; (c614 <move_thread_to_end_of_prio_q+0xe0>)
    c552:	617b      	str	r3, [r7, #20]
    c554:	687b      	ldr	r3, [r7, #4]
    c556:	613b      	str	r3, [r7, #16]

ALWAYS_INLINE void z_priq_dumb_add(sys_dlist_t *pq, struct k_thread *thread)
{
	struct k_thread *t;

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    c558:	6938      	ldr	r0, [r7, #16]
    c55a:	f7ff fea7 	bl	c2ac <z_is_idle_thread_object>
    c55e:	4603      	mov	r3, r0
    c560:	2b00      	cmp	r3, #0
    c562:	d00b      	beq.n	c57c <move_thread_to_end_of_prio_q+0x48>
    c564:	f240 33c7 	movw	r3, #967	; 0x3c7
    c568:	4a2b      	ldr	r2, [pc, #172]	; (c618 <move_thread_to_end_of_prio_q+0xe4>)
    c56a:	492c      	ldr	r1, [pc, #176]	; (c61c <move_thread_to_end_of_prio_q+0xe8>)
    c56c:	482c      	ldr	r0, [pc, #176]	; (c620 <move_thread_to_end_of_prio_q+0xec>)
    c56e:	f003 fd7b 	bl	10068 <printk>
    c572:	f240 31c7 	movw	r1, #967	; 0x3c7
    c576:	4828      	ldr	r0, [pc, #160]	; (c618 <move_thread_to_end_of_prio_q+0xe4>)
    c578:	f004 fbbe 	bl	10cf8 <assert_post_action>

	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c57c:	6978      	ldr	r0, [r7, #20]
    c57e:	f00a fe3c 	bl	171fa <sys_dlist_peek_head>
    c582:	4603      	mov	r3, r0
    c584:	2b00      	cmp	r3, #0
    c586:	d004      	beq.n	c592 <move_thread_to_end_of_prio_q+0x5e>
    c588:	6978      	ldr	r0, [r7, #20]
    c58a:	f00a fe36 	bl	171fa <sys_dlist_peek_head>
    c58e:	4603      	mov	r3, r0
    c590:	e000      	b.n	c594 <move_thread_to_end_of_prio_q+0x60>
    c592:	2300      	movs	r3, #0
    c594:	60fb      	str	r3, [r7, #12]
    c596:	e023      	b.n	c5e0 <move_thread_to_end_of_prio_q+0xac>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    c598:	68f9      	ldr	r1, [r7, #12]
    c59a:	6938      	ldr	r0, [r7, #16]
    c59c:	f00b fad0 	bl	17b40 <z_is_t1_higher_prio_than_t2>
    c5a0:	4603      	mov	r3, r0
    c5a2:	2b00      	cmp	r3, #0
    c5a4:	d006      	beq.n	c5b4 <move_thread_to_end_of_prio_q+0x80>
			sys_dlist_insert(&t->base.qnode_dlist,
    c5a6:	68fb      	ldr	r3, [r7, #12]
    c5a8:	693a      	ldr	r2, [r7, #16]
    c5aa:	4611      	mov	r1, r2
    c5ac:	4618      	mov	r0, r3
    c5ae:	f00a fe74 	bl	1729a <sys_dlist_insert>
					 &thread->base.qnode_dlist);
			return;
    c5b2:	e01d      	b.n	c5f0 <move_thread_to_end_of_prio_q+0xbc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c5b4:	68fb      	ldr	r3, [r7, #12]
    c5b6:	2b00      	cmp	r3, #0
    c5b8:	d010      	beq.n	c5dc <move_thread_to_end_of_prio_q+0xa8>
    c5ba:	68fb      	ldr	r3, [r7, #12]
    c5bc:	4619      	mov	r1, r3
    c5be:	6978      	ldr	r0, [r7, #20]
    c5c0:	f00a fe40 	bl	17244 <sys_dlist_peek_next>
    c5c4:	4603      	mov	r3, r0
    c5c6:	2b00      	cmp	r3, #0
    c5c8:	d006      	beq.n	c5d8 <move_thread_to_end_of_prio_q+0xa4>
    c5ca:	68fb      	ldr	r3, [r7, #12]
    c5cc:	4619      	mov	r1, r3
    c5ce:	6978      	ldr	r0, [r7, #20]
    c5d0:	f00a fe38 	bl	17244 <sys_dlist_peek_next>
    c5d4:	4603      	mov	r3, r0
    c5d6:	e002      	b.n	c5de <move_thread_to_end_of_prio_q+0xaa>
    c5d8:	2300      	movs	r3, #0
    c5da:	e000      	b.n	c5de <move_thread_to_end_of_prio_q+0xaa>
    c5dc:	2300      	movs	r3, #0
    c5de:	60fb      	str	r3, [r7, #12]
    c5e0:	68fb      	ldr	r3, [r7, #12]
    c5e2:	2b00      	cmp	r3, #0
    c5e4:	d1d8      	bne.n	c598 <move_thread_to_end_of_prio_q+0x64>
		}
	}

	sys_dlist_append(pq, &thread->base.qnode_dlist);
    c5e6:	693b      	ldr	r3, [r7, #16]
    c5e8:	4619      	mov	r1, r3
    c5ea:	6978      	ldr	r0, [r7, #20]
    c5ec:	f00a fe3d 	bl	1726a <sys_dlist_append>
	z_mark_thread_as_queued(thread);
    c5f0:	6878      	ldr	r0, [r7, #4]
    c5f2:	f00b fa25 	bl	17a40 <z_mark_thread_as_queued>
	update_cache(thread == _current);
    c5f6:	4b0b      	ldr	r3, [pc, #44]	; (c624 <move_thread_to_end_of_prio_q+0xf0>)
    c5f8:	689b      	ldr	r3, [r3, #8]
    c5fa:	687a      	ldr	r2, [r7, #4]
    c5fc:	429a      	cmp	r2, r3
    c5fe:	bf0c      	ite	eq
    c600:	2301      	moveq	r3, #1
    c602:	2300      	movne	r3, #0
    c604:	b2db      	uxtb	r3, r3
    c606:	4618      	mov	r0, r3
    c608:	f000 f9a0 	bl	c94c <update_cache>
}
    c60c:	bf00      	nop
    c60e:	3718      	adds	r7, #24
    c610:	46bd      	mov	sp, r7
    c612:	bd80      	pop	{r7, pc}
    c614:	20000d04 	.word	0x20000d04
    c618:	0001c030 	.word	0x0001c030
    c61c:	0001c054 	.word	0x0001c054
    c620:	0001bf54 	.word	0x0001bf54
    c624:	20000cd8 	.word	0x20000cd8

0000c628 <z_reset_time_slice>:
{
    c628:	b580      	push	{r7, lr}
    c62a:	af00      	add	r7, sp, #0
	if (slice_time != 0) {
    c62c:	4b0a      	ldr	r3, [pc, #40]	; (c658 <z_reset_time_slice+0x30>)
    c62e:	681b      	ldr	r3, [r3, #0]
    c630:	2b00      	cmp	r3, #0
    c632:	d00e      	beq.n	c652 <z_reset_time_slice+0x2a>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    c634:	f7f7 ffa0 	bl	4578 <z_clock_elapsed>
    c638:	4603      	mov	r3, r0
    c63a:	4a07      	ldr	r2, [pc, #28]	; (c658 <z_reset_time_slice+0x30>)
    c63c:	6812      	ldr	r2, [r2, #0]
    c63e:	4413      	add	r3, r2
    c640:	461a      	mov	r2, r3
    c642:	4b06      	ldr	r3, [pc, #24]	; (c65c <z_reset_time_slice+0x34>)
    c644:	615a      	str	r2, [r3, #20]
		z_set_timeout_expiry(slice_time, false);
    c646:	4b04      	ldr	r3, [pc, #16]	; (c658 <z_reset_time_slice+0x30>)
    c648:	681b      	ldr	r3, [r3, #0]
    c64a:	2100      	movs	r1, #0
    c64c:	4618      	mov	r0, r3
    c64e:	f002 fda1 	bl	f194 <z_set_timeout_expiry>
}
    c652:	bf00      	nop
    c654:	bd80      	pop	{r7, pc}
    c656:	bf00      	nop
    c658:	20000d10 	.word	0x20000d10
    c65c:	20000cd8 	.word	0x20000cd8

0000c660 <k_sched_time_slice_set>:
{
    c660:	b580      	push	{r7, lr}
    c662:	b08c      	sub	sp, #48	; 0x30
    c664:	af00      	add	r7, sp, #0
    c666:	6078      	str	r0, [r7, #4]
    c668:	6039      	str	r1, [r7, #0]
	LOCKED(&sched_spinlock) {
    c66a:	2300      	movs	r3, #0
    c66c:	61bb      	str	r3, [r7, #24]
    c66e:	4b34      	ldr	r3, [pc, #208]	; (c740 <k_sched_time_slice_set+0xe0>)
    c670:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    c672:	f04f 0320 	mov.w	r3, #32
    c676:	f3ef 8211 	mrs	r2, BASEPRI
    c67a:	f383 8811 	msr	BASEPRI, r3
    c67e:	f3bf 8f6f 	isb	sy
    c682:	62ba      	str	r2, [r7, #40]	; 0x28
    c684:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
    c686:	6abb      	ldr	r3, [r7, #40]	; 0x28
	k.key = arch_irq_lock();
    c688:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    c68a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    c68c:	f002 f9e4 	bl	ea58 <z_spin_lock_valid>
    c690:	4603      	mov	r3, r0
    c692:	f083 0301 	eor.w	r3, r3, #1
    c696:	b2db      	uxtb	r3, r3
    c698:	2b00      	cmp	r3, #0
    c69a:	d00d      	beq.n	c6b8 <k_sched_time_slice_set+0x58>
    c69c:	2378      	movs	r3, #120	; 0x78
    c69e:	4a29      	ldr	r2, [pc, #164]	; (c744 <k_sched_time_slice_set+0xe4>)
    c6a0:	4929      	ldr	r1, [pc, #164]	; (c748 <k_sched_time_slice_set+0xe8>)
    c6a2:	482a      	ldr	r0, [pc, #168]	; (c74c <k_sched_time_slice_set+0xec>)
    c6a4:	f003 fce0 	bl	10068 <printk>
    c6a8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    c6aa:	4829      	ldr	r0, [pc, #164]	; (c750 <k_sched_time_slice_set+0xf0>)
    c6ac:	f003 fcdc 	bl	10068 <printk>
    c6b0:	2178      	movs	r1, #120	; 0x78
    c6b2:	4824      	ldr	r0, [pc, #144]	; (c744 <k_sched_time_slice_set+0xe4>)
    c6b4:	f004 fb20 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    c6b8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    c6ba:	f002 fa05 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    c6be:	68fb      	ldr	r3, [r7, #12]
    c6c0:	617b      	str	r3, [r7, #20]
    c6c2:	e035      	b.n	c730 <k_sched_time_slice_set+0xd0>
		_current_cpu->slice_ticks = 0;
    c6c4:	4b23      	ldr	r3, [pc, #140]	; (c754 <k_sched_time_slice_set+0xf4>)
    c6c6:	2200      	movs	r2, #0
    c6c8:	615a      	str	r2, [r3, #20]
		slice_time = k_ms_to_ticks_ceil32(slice);
    c6ca:	687b      	ldr	r3, [r7, #4]
    c6cc:	4618      	mov	r0, r3
    c6ce:	f00a fe18 	bl	17302 <k_ms_to_ticks_ceil32>
    c6d2:	4603      	mov	r3, r0
    c6d4:	461a      	mov	r2, r3
    c6d6:	4b20      	ldr	r3, [pc, #128]	; (c758 <k_sched_time_slice_set+0xf8>)
    c6d8:	601a      	str	r2, [r3, #0]
		slice_max_prio = prio;
    c6da:	4a20      	ldr	r2, [pc, #128]	; (c75c <k_sched_time_slice_set+0xfc>)
    c6dc:	683b      	ldr	r3, [r7, #0]
    c6de:	6013      	str	r3, [r2, #0]
		z_reset_time_slice();
    c6e0:	f7ff ffa2 	bl	c628 <z_reset_time_slice>
    c6e4:	4b16      	ldr	r3, [pc, #88]	; (c740 <k_sched_time_slice_set+0xe0>)
    c6e6:	623b      	str	r3, [r7, #32]
    c6e8:	697b      	ldr	r3, [r7, #20]
    c6ea:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c6ec:	6a38      	ldr	r0, [r7, #32]
    c6ee:	f002 f9cf 	bl	ea90 <z_spin_unlock_valid>
    c6f2:	4603      	mov	r3, r0
    c6f4:	f083 0301 	eor.w	r3, r3, #1
    c6f8:	b2db      	uxtb	r3, r3
    c6fa:	2b00      	cmp	r3, #0
    c6fc:	d00d      	beq.n	c71a <k_sched_time_slice_set+0xba>
    c6fe:	23a3      	movs	r3, #163	; 0xa3
    c700:	4a10      	ldr	r2, [pc, #64]	; (c744 <k_sched_time_slice_set+0xe4>)
    c702:	4917      	ldr	r1, [pc, #92]	; (c760 <k_sched_time_slice_set+0x100>)
    c704:	4811      	ldr	r0, [pc, #68]	; (c74c <k_sched_time_slice_set+0xec>)
    c706:	f003 fcaf 	bl	10068 <printk>
    c70a:	6a39      	ldr	r1, [r7, #32]
    c70c:	4815      	ldr	r0, [pc, #84]	; (c764 <k_sched_time_slice_set+0x104>)
    c70e:	f003 fcab 	bl	10068 <printk>
    c712:	21a3      	movs	r1, #163	; 0xa3
    c714:	480b      	ldr	r0, [pc, #44]	; (c744 <k_sched_time_slice_set+0xe4>)
    c716:	f004 faef 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c71a:	693b      	ldr	r3, [r7, #16]
    c71c:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    c71e:	69fb      	ldr	r3, [r7, #28]
    c720:	f383 8811 	msr	BASEPRI, r3
    c724:	f3bf 8f6f 	isb	sy
}
    c728:	bf00      	nop
}
    c72a:	bf00      	nop
	LOCKED(&sched_spinlock) {
    c72c:	2301      	movs	r3, #1
    c72e:	61bb      	str	r3, [r7, #24]
    c730:	69bb      	ldr	r3, [r7, #24]
    c732:	2b00      	cmp	r3, #0
    c734:	d0c6      	beq.n	c6c4 <k_sched_time_slice_set+0x64>
}
    c736:	bf00      	nop
    c738:	bf00      	nop
    c73a:	3730      	adds	r7, #48	; 0x30
    c73c:	46bd      	mov	sp, r7
    c73e:	bd80      	pop	{r7, pc}
    c740:	20000d0c 	.word	0x20000d0c
    c744:	0001bfa8 	.word	0x0001bfa8
    c748:	0001bfd0 	.word	0x0001bfd0
    c74c:	0001bf54 	.word	0x0001bf54
    c750:	0001bfe8 	.word	0x0001bfe8
    c754:	20000cd8 	.word	0x20000cd8
    c758:	20000d10 	.word	0x20000d10
    c75c:	20000d14 	.word	0x20000d14
    c760:	0001c000 	.word	0x0001c000
    c764:	0001c018 	.word	0x0001c018

0000c768 <sliceable>:
{
    c768:	b580      	push	{r7, lr}
    c76a:	b082      	sub	sp, #8
    c76c:	af00      	add	r7, sp, #0
    c76e:	6078      	str	r0, [r7, #4]
	return is_preempt(thread)
    c770:	6878      	ldr	r0, [r7, #4]
    c772:	f00b f9cb 	bl	17b0c <is_preempt>
    c776:	4603      	mov	r3, r0
		&& !z_is_idle_thread_object(thread);
    c778:	2b00      	cmp	r3, #0
    c77a:	d023      	beq.n	c7c4 <sliceable+0x5c>
		&& !z_is_thread_prevented_from_running(thread)
    c77c:	6878      	ldr	r0, [r7, #4]
    c77e:	f00b f869 	bl	17854 <z_is_thread_prevented_from_running>
    c782:	4603      	mov	r3, r0
    c784:	f083 0301 	eor.w	r3, r3, #1
    c788:	b2db      	uxtb	r3, r3
    c78a:	2b00      	cmp	r3, #0
    c78c:	d01a      	beq.n	c7c4 <sliceable+0x5c>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    c78e:	687b      	ldr	r3, [r7, #4]
    c790:	f993 300e 	ldrsb.w	r3, [r3, #14]
    c794:	461a      	mov	r2, r3
    c796:	4b0e      	ldr	r3, [pc, #56]	; (c7d0 <sliceable+0x68>)
    c798:	681b      	ldr	r3, [r3, #0]
    c79a:	4619      	mov	r1, r3
    c79c:	4610      	mov	r0, r2
    c79e:	f00b f978 	bl	17a92 <z_is_prio_higher>
    c7a2:	4603      	mov	r3, r0
    c7a4:	f083 0301 	eor.w	r3, r3, #1
    c7a8:	b2db      	uxtb	r3, r3
    c7aa:	2b00      	cmp	r3, #0
    c7ac:	d00a      	beq.n	c7c4 <sliceable+0x5c>
		&& !z_is_idle_thread_object(thread);
    c7ae:	6878      	ldr	r0, [r7, #4]
    c7b0:	f7ff fd7c 	bl	c2ac <z_is_idle_thread_object>
    c7b4:	4603      	mov	r3, r0
    c7b6:	f083 0301 	eor.w	r3, r3, #1
    c7ba:	b2db      	uxtb	r3, r3
    c7bc:	2b00      	cmp	r3, #0
    c7be:	d001      	beq.n	c7c4 <sliceable+0x5c>
    c7c0:	2301      	movs	r3, #1
    c7c2:	e000      	b.n	c7c6 <sliceable+0x5e>
    c7c4:	2300      	movs	r3, #0
}
    c7c6:	4618      	mov	r0, r3
    c7c8:	3708      	adds	r7, #8
    c7ca:	46bd      	mov	sp, r7
    c7cc:	bd80      	pop	{r7, pc}
    c7ce:	bf00      	nop
    c7d0:	20000d14 	.word	0x20000d14

0000c7d4 <z_time_slice>:
{
    c7d4:	b580      	push	{r7, lr}
    c7d6:	b08e      	sub	sp, #56	; 0x38
    c7d8:	af00      	add	r7, sp, #0
    c7da:	6078      	str	r0, [r7, #4]
    c7dc:	4b51      	ldr	r3, [pc, #324]	; (c924 <z_time_slice+0x150>)
    c7de:	637b      	str	r3, [r7, #52]	; 0x34
	__asm__ volatile(
    c7e0:	f04f 0320 	mov.w	r3, #32
    c7e4:	f3ef 8211 	mrs	r2, BASEPRI
    c7e8:	f383 8811 	msr	BASEPRI, r3
    c7ec:	f3bf 8f6f 	isb	sy
    c7f0:	633a      	str	r2, [r7, #48]	; 0x30
    c7f2:	62fb      	str	r3, [r7, #44]	; 0x2c
	return key;
    c7f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	k.key = arch_irq_lock();
    c7f6:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    c7f8:	6b78      	ldr	r0, [r7, #52]	; 0x34
    c7fa:	f002 f92d 	bl	ea58 <z_spin_lock_valid>
    c7fe:	4603      	mov	r3, r0
    c800:	f083 0301 	eor.w	r3, r3, #1
    c804:	b2db      	uxtb	r3, r3
    c806:	2b00      	cmp	r3, #0
    c808:	d00d      	beq.n	c826 <z_time_slice+0x52>
    c80a:	2378      	movs	r3, #120	; 0x78
    c80c:	4a46      	ldr	r2, [pc, #280]	; (c928 <z_time_slice+0x154>)
    c80e:	4947      	ldr	r1, [pc, #284]	; (c92c <z_time_slice+0x158>)
    c810:	4847      	ldr	r0, [pc, #284]	; (c930 <z_time_slice+0x15c>)
    c812:	f003 fc29 	bl	10068 <printk>
    c816:	6b79      	ldr	r1, [r7, #52]	; 0x34
    c818:	4846      	ldr	r0, [pc, #280]	; (c934 <z_time_slice+0x160>)
    c81a:	f003 fc25 	bl	10068 <printk>
    c81e:	2178      	movs	r1, #120	; 0x78
    c820:	4841      	ldr	r0, [pc, #260]	; (c928 <z_time_slice+0x154>)
    c822:	f004 fa69 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    c826:	6b78      	ldr	r0, [r7, #52]	; 0x34
    c828:	f002 f94e 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    c82c:	68fb      	ldr	r3, [r7, #12]
    c82e:	61bb      	str	r3, [r7, #24]
	if (pending_current == _current) {
    c830:	4b41      	ldr	r3, [pc, #260]	; (c938 <z_time_slice+0x164>)
    c832:	689a      	ldr	r2, [r3, #8]
    c834:	4b41      	ldr	r3, [pc, #260]	; (c93c <z_time_slice+0x168>)
    c836:	681b      	ldr	r3, [r3, #0]
    c838:	429a      	cmp	r2, r3
    c83a:	d125      	bne.n	c888 <z_time_slice+0xb4>
		z_reset_time_slice();
    c83c:	f7ff fef4 	bl	c628 <z_reset_time_slice>
    c840:	4b38      	ldr	r3, [pc, #224]	; (c924 <z_time_slice+0x150>)
    c842:	62bb      	str	r3, [r7, #40]	; 0x28
    c844:	69bb      	ldr	r3, [r7, #24]
    c846:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c848:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    c84a:	f002 f921 	bl	ea90 <z_spin_unlock_valid>
    c84e:	4603      	mov	r3, r0
    c850:	f083 0301 	eor.w	r3, r3, #1
    c854:	b2db      	uxtb	r3, r3
    c856:	2b00      	cmp	r3, #0
    c858:	d00d      	beq.n	c876 <z_time_slice+0xa2>
    c85a:	23a3      	movs	r3, #163	; 0xa3
    c85c:	4a32      	ldr	r2, [pc, #200]	; (c928 <z_time_slice+0x154>)
    c85e:	4938      	ldr	r1, [pc, #224]	; (c940 <z_time_slice+0x16c>)
    c860:	4833      	ldr	r0, [pc, #204]	; (c930 <z_time_slice+0x15c>)
    c862:	f003 fc01 	bl	10068 <printk>
    c866:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    c868:	4836      	ldr	r0, [pc, #216]	; (c944 <z_time_slice+0x170>)
    c86a:	f003 fbfd 	bl	10068 <printk>
    c86e:	21a3      	movs	r1, #163	; 0xa3
    c870:	482d      	ldr	r0, [pc, #180]	; (c928 <z_time_slice+0x154>)
    c872:	f004 fa41 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c876:	693b      	ldr	r3, [r7, #16]
    c878:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    c87a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c87c:	f383 8811 	msr	BASEPRI, r3
    c880:	f3bf 8f6f 	isb	sy
}
    c884:	bf00      	nop
}
    c886:	e049      	b.n	c91c <z_time_slice+0x148>
	pending_current = NULL;
    c888:	4b2c      	ldr	r3, [pc, #176]	; (c93c <z_time_slice+0x168>)
    c88a:	2200      	movs	r2, #0
    c88c:	601a      	str	r2, [r3, #0]
	if (slice_time && sliceable(_current)) {
    c88e:	4b2e      	ldr	r3, [pc, #184]	; (c948 <z_time_slice+0x174>)
    c890:	681b      	ldr	r3, [r3, #0]
    c892:	2b00      	cmp	r3, #0
    c894:	d01b      	beq.n	c8ce <z_time_slice+0xfa>
    c896:	4b28      	ldr	r3, [pc, #160]	; (c938 <z_time_slice+0x164>)
    c898:	689b      	ldr	r3, [r3, #8]
    c89a:	4618      	mov	r0, r3
    c89c:	f7ff ff64 	bl	c768 <sliceable>
    c8a0:	4603      	mov	r3, r0
    c8a2:	2b00      	cmp	r3, #0
    c8a4:	d013      	beq.n	c8ce <z_time_slice+0xfa>
		if (ticks >= _current_cpu->slice_ticks) {
    c8a6:	4b24      	ldr	r3, [pc, #144]	; (c938 <z_time_slice+0x164>)
    c8a8:	695b      	ldr	r3, [r3, #20]
    c8aa:	687a      	ldr	r2, [r7, #4]
    c8ac:	429a      	cmp	r2, r3
    c8ae:	db07      	blt.n	c8c0 <z_time_slice+0xec>
			move_thread_to_end_of_prio_q(_current);
    c8b0:	4b21      	ldr	r3, [pc, #132]	; (c938 <z_time_slice+0x164>)
    c8b2:	689b      	ldr	r3, [r3, #8]
    c8b4:	4618      	mov	r0, r3
    c8b6:	f7ff fe3d 	bl	c534 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    c8ba:	f7ff feb5 	bl	c628 <z_reset_time_slice>
		if (ticks >= _current_cpu->slice_ticks) {
    c8be:	e009      	b.n	c8d4 <z_time_slice+0x100>
			_current_cpu->slice_ticks -= ticks;
    c8c0:	4b1d      	ldr	r3, [pc, #116]	; (c938 <z_time_slice+0x164>)
    c8c2:	695a      	ldr	r2, [r3, #20]
    c8c4:	687b      	ldr	r3, [r7, #4]
    c8c6:	1ad3      	subs	r3, r2, r3
    c8c8:	4a1b      	ldr	r2, [pc, #108]	; (c938 <z_time_slice+0x164>)
    c8ca:	6153      	str	r3, [r2, #20]
		if (ticks >= _current_cpu->slice_ticks) {
    c8cc:	e002      	b.n	c8d4 <z_time_slice+0x100>
		_current_cpu->slice_ticks = 0;
    c8ce:	4b1a      	ldr	r3, [pc, #104]	; (c938 <z_time_slice+0x164>)
    c8d0:	2200      	movs	r2, #0
    c8d2:	615a      	str	r2, [r3, #20]
    c8d4:	4b13      	ldr	r3, [pc, #76]	; (c924 <z_time_slice+0x150>)
    c8d6:	623b      	str	r3, [r7, #32]
    c8d8:	69bb      	ldr	r3, [r7, #24]
    c8da:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    c8dc:	6a38      	ldr	r0, [r7, #32]
    c8de:	f002 f8d7 	bl	ea90 <z_spin_unlock_valid>
    c8e2:	4603      	mov	r3, r0
    c8e4:	f083 0301 	eor.w	r3, r3, #1
    c8e8:	b2db      	uxtb	r3, r3
    c8ea:	2b00      	cmp	r3, #0
    c8ec:	d00d      	beq.n	c90a <z_time_slice+0x136>
    c8ee:	23a3      	movs	r3, #163	; 0xa3
    c8f0:	4a0d      	ldr	r2, [pc, #52]	; (c928 <z_time_slice+0x154>)
    c8f2:	4913      	ldr	r1, [pc, #76]	; (c940 <z_time_slice+0x16c>)
    c8f4:	480e      	ldr	r0, [pc, #56]	; (c930 <z_time_slice+0x15c>)
    c8f6:	f003 fbb7 	bl	10068 <printk>
    c8fa:	6a39      	ldr	r1, [r7, #32]
    c8fc:	4811      	ldr	r0, [pc, #68]	; (c944 <z_time_slice+0x170>)
    c8fe:	f003 fbb3 	bl	10068 <printk>
    c902:	21a3      	movs	r1, #163	; 0xa3
    c904:	4808      	ldr	r0, [pc, #32]	; (c928 <z_time_slice+0x154>)
    c906:	f004 f9f7 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    c90a:	697b      	ldr	r3, [r7, #20]
    c90c:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    c90e:	69fb      	ldr	r3, [r7, #28]
    c910:	f383 8811 	msr	BASEPRI, r3
    c914:	f3bf 8f6f 	isb	sy
}
    c918:	bf00      	nop
}
    c91a:	bf00      	nop
}
    c91c:	3738      	adds	r7, #56	; 0x38
    c91e:	46bd      	mov	sp, r7
    c920:	bd80      	pop	{r7, pc}
    c922:	bf00      	nop
    c924:	20000d0c 	.word	0x20000d0c
    c928:	0001bfa8 	.word	0x0001bfa8
    c92c:	0001bfd0 	.word	0x0001bfd0
    c930:	0001bf54 	.word	0x0001bf54
    c934:	0001bfe8 	.word	0x0001bfe8
    c938:	20000cd8 	.word	0x20000cd8
    c93c:	20000d18 	.word	0x20000d18
    c940:	0001c000 	.word	0x0001c000
    c944:	0001c018 	.word	0x0001c018
    c948:	20000d10 	.word	0x20000d10

0000c94c <update_cache>:
{
    c94c:	b580      	push	{r7, lr}
    c94e:	b086      	sub	sp, #24
    c950:	af00      	add	r7, sp, #0
    c952:	6078      	str	r0, [r7, #4]
	if (_current_cpu->pending_abort != NULL) {
    c954:	4b3b      	ldr	r3, [pc, #236]	; (ca44 <update_cache+0xf8>)
    c956:	691b      	ldr	r3, [r3, #16]
    c958:	2b00      	cmp	r3, #0
    c95a:	d002      	beq.n	c962 <update_cache+0x16>
		return _current_cpu->idle_thread;
    c95c:	4b39      	ldr	r3, [pc, #228]	; (ca44 <update_cache+0xf8>)
    c95e:	68db      	ldr	r3, [r3, #12]
    c960:	e01a      	b.n	c998 <update_cache+0x4c>
	thread = _priq_run_best(&_kernel.ready_q.runq);
    c962:	4839      	ldr	r0, [pc, #228]	; (ca48 <update_cache+0xfc>)
    c964:	f00b f98a 	bl	17c7c <z_priq_dumb_best>
    c968:	60b8      	str	r0, [r7, #8]
	if (_current->base.thread_state & _THREAD_ABORTING) {
    c96a:	4b36      	ldr	r3, [pc, #216]	; (ca44 <update_cache+0xf8>)
    c96c:	689b      	ldr	r3, [r3, #8]
    c96e:	7b5b      	ldrb	r3, [r3, #13]
    c970:	f003 0320 	and.w	r3, r3, #32
    c974:	2b00      	cmp	r3, #0
    c976:	d008      	beq.n	c98a <update_cache+0x3e>
		_current->base.thread_state |= _THREAD_DEAD;
    c978:	4b32      	ldr	r3, [pc, #200]	; (ca44 <update_cache+0xf8>)
    c97a:	689b      	ldr	r3, [r3, #8]
    c97c:	7b5a      	ldrb	r2, [r3, #13]
    c97e:	4b31      	ldr	r3, [pc, #196]	; (ca44 <update_cache+0xf8>)
    c980:	689b      	ldr	r3, [r3, #8]
    c982:	f042 0208 	orr.w	r2, r2, #8
    c986:	b2d2      	uxtb	r2, r2
    c988:	735a      	strb	r2, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
    c98a:	68bb      	ldr	r3, [r7, #8]
    c98c:	2b00      	cmp	r3, #0
    c98e:	d102      	bne.n	c996 <update_cache+0x4a>
    c990:	4b2c      	ldr	r3, [pc, #176]	; (ca44 <update_cache+0xf8>)
    c992:	68db      	ldr	r3, [r3, #12]
    c994:	e000      	b.n	c998 <update_cache+0x4c>
    c996:	68bb      	ldr	r3, [r7, #8]
	struct k_thread *thread = next_up();
    c998:	617b      	str	r3, [r7, #20]
    c99a:	697b      	ldr	r3, [r7, #20]
    c99c:	613b      	str	r3, [r7, #16]
    c99e:	687b      	ldr	r3, [r7, #4]
    c9a0:	60fb      	str	r3, [r7, #12]
	if (preempt_ok != 0) {
    c9a2:	68fb      	ldr	r3, [r7, #12]
    c9a4:	2b00      	cmp	r3, #0
    c9a6:	d001      	beq.n	c9ac <update_cache+0x60>
		return true;
    c9a8:	2301      	movs	r3, #1
    c9aa:	e033      	b.n	ca14 <update_cache+0xc8>
	__ASSERT(_current != NULL, "");
    c9ac:	4b25      	ldr	r3, [pc, #148]	; (ca44 <update_cache+0xf8>)
    c9ae:	689b      	ldr	r3, [r3, #8]
    c9b0:	2b00      	cmp	r3, #0
    c9b2:	d10c      	bne.n	c9ce <update_cache+0x82>
    c9b4:	2383      	movs	r3, #131	; 0x83
    c9b6:	4a25      	ldr	r2, [pc, #148]	; (ca4c <update_cache+0x100>)
    c9b8:	4925      	ldr	r1, [pc, #148]	; (ca50 <update_cache+0x104>)
    c9ba:	4826      	ldr	r0, [pc, #152]	; (ca54 <update_cache+0x108>)
    c9bc:	f003 fb54 	bl	10068 <printk>
    c9c0:	4825      	ldr	r0, [pc, #148]	; (ca58 <update_cache+0x10c>)
    c9c2:	f003 fb51 	bl	10068 <printk>
    c9c6:	2183      	movs	r1, #131	; 0x83
    c9c8:	4820      	ldr	r0, [pc, #128]	; (ca4c <update_cache+0x100>)
    c9ca:	f004 f995 	bl	10cf8 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
    c9ce:	4b1d      	ldr	r3, [pc, #116]	; (ca44 <update_cache+0xf8>)
    c9d0:	689b      	ldr	r3, [r3, #8]
    c9d2:	4618      	mov	r0, r3
    c9d4:	f00a ff3e 	bl	17854 <z_is_thread_prevented_from_running>
    c9d8:	4603      	mov	r3, r0
    c9da:	2b00      	cmp	r3, #0
    c9dc:	d001      	beq.n	c9e2 <update_cache+0x96>
		return true;
    c9de:	2301      	movs	r3, #1
    c9e0:	e018      	b.n	ca14 <update_cache+0xc8>
	    && z_is_thread_timeout_active(thread)) {
    c9e2:	6938      	ldr	r0, [r7, #16]
    c9e4:	f00a ff4a 	bl	1787c <z_is_thread_timeout_active>
    c9e8:	4603      	mov	r3, r0
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    c9ea:	2b00      	cmp	r3, #0
    c9ec:	d001      	beq.n	c9f2 <update_cache+0xa6>
		return true;
    c9ee:	2301      	movs	r3, #1
    c9f0:	e010      	b.n	ca14 <update_cache+0xc8>
	if (is_preempt(_current) || is_metairq(thread)) {
    c9f2:	4b14      	ldr	r3, [pc, #80]	; (ca44 <update_cache+0xf8>)
    c9f4:	689b      	ldr	r3, [r3, #8]
    c9f6:	4618      	mov	r0, r3
    c9f8:	f00b f888 	bl	17b0c <is_preempt>
    c9fc:	4603      	mov	r3, r0
    c9fe:	2b00      	cmp	r3, #0
    ca00:	d105      	bne.n	ca0e <update_cache+0xc2>
    ca02:	6938      	ldr	r0, [r7, #16]
    ca04:	f00b f892 	bl	17b2c <is_metairq>
    ca08:	4603      	mov	r3, r0
    ca0a:	2b00      	cmp	r3, #0
    ca0c:	d001      	beq.n	ca12 <update_cache+0xc6>
		return true;
    ca0e:	2301      	movs	r3, #1
    ca10:	e000      	b.n	ca14 <update_cache+0xc8>
	return false;
    ca12:	2300      	movs	r3, #0
	if (should_preempt(thread, preempt_ok)) {
    ca14:	2b00      	cmp	r3, #0
    ca16:	d00d      	beq.n	ca34 <update_cache+0xe8>
		if (thread != _current) {
    ca18:	4b0a      	ldr	r3, [pc, #40]	; (ca44 <update_cache+0xf8>)
    ca1a:	689b      	ldr	r3, [r3, #8]
    ca1c:	697a      	ldr	r2, [r7, #20]
    ca1e:	429a      	cmp	r2, r3
    ca20:	d001      	beq.n	ca26 <update_cache+0xda>
			z_reset_time_slice();
    ca22:	f7ff fe01 	bl	c628 <z_reset_time_slice>
		update_metairq_preempt(thread);
    ca26:	6978      	ldr	r0, [r7, #20]
    ca28:	f00b f89f 	bl	17b6a <update_metairq_preempt>
		_kernel.ready_q.cache = thread;
    ca2c:	4a05      	ldr	r2, [pc, #20]	; (ca44 <update_cache+0xf8>)
    ca2e:	697b      	ldr	r3, [r7, #20]
    ca30:	6293      	str	r3, [r2, #40]	; 0x28
}
    ca32:	e003      	b.n	ca3c <update_cache+0xf0>
		_kernel.ready_q.cache = _current;
    ca34:	4b03      	ldr	r3, [pc, #12]	; (ca44 <update_cache+0xf8>)
    ca36:	689b      	ldr	r3, [r3, #8]
    ca38:	4a02      	ldr	r2, [pc, #8]	; (ca44 <update_cache+0xf8>)
    ca3a:	6293      	str	r3, [r2, #40]	; 0x28
}
    ca3c:	bf00      	nop
    ca3e:	3718      	adds	r7, #24
    ca40:	46bd      	mov	sp, r7
    ca42:	bd80      	pop	{r7, pc}
    ca44:	20000cd8 	.word	0x20000cd8
    ca48:	20000d04 	.word	0x20000d04
    ca4c:	0001c030 	.word	0x0001c030
    ca50:	0001c078 	.word	0x0001c078
    ca54:	0001bf54 	.word	0x0001bf54
    ca58:	0001bf74 	.word	0x0001bf74

0000ca5c <ready_thread>:
{
    ca5c:	b580      	push	{r7, lr}
    ca5e:	b086      	sub	sp, #24
    ca60:	af00      	add	r7, sp, #0
    ca62:	6078      	str	r0, [r7, #4]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    ca64:	6878      	ldr	r0, [r7, #4]
    ca66:	f00a ff68 	bl	1793a <z_is_thread_queued>
    ca6a:	4603      	mov	r3, r0
    ca6c:	f083 0301 	eor.w	r3, r3, #1
    ca70:	b2db      	uxtb	r3, r3
    ca72:	2b00      	cmp	r3, #0
    ca74:	d05b      	beq.n	cb2e <ready_thread+0xd2>
    ca76:	6878      	ldr	r0, [r7, #4]
    ca78:	f00a ff19 	bl	178ae <z_is_thread_ready>
    ca7c:	4603      	mov	r3, r0
    ca7e:	2b00      	cmp	r3, #0
    ca80:	d055      	beq.n	cb2e <ready_thread+0xd2>
    ca82:	4b2d      	ldr	r3, [pc, #180]	; (cb38 <ready_thread+0xdc>)
    ca84:	617b      	str	r3, [r7, #20]
    ca86:	687b      	ldr	r3, [r7, #4]
    ca88:	613b      	str	r3, [r7, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    ca8a:	6938      	ldr	r0, [r7, #16]
    ca8c:	f7ff fc0e 	bl	c2ac <z_is_idle_thread_object>
    ca90:	4603      	mov	r3, r0
    ca92:	2b00      	cmp	r3, #0
    ca94:	d00b      	beq.n	caae <ready_thread+0x52>
    ca96:	f240 33c7 	movw	r3, #967	; 0x3c7
    ca9a:	4a28      	ldr	r2, [pc, #160]	; (cb3c <ready_thread+0xe0>)
    ca9c:	4928      	ldr	r1, [pc, #160]	; (cb40 <ready_thread+0xe4>)
    ca9e:	4829      	ldr	r0, [pc, #164]	; (cb44 <ready_thread+0xe8>)
    caa0:	f003 fae2 	bl	10068 <printk>
    caa4:	f240 31c7 	movw	r1, #967	; 0x3c7
    caa8:	4824      	ldr	r0, [pc, #144]	; (cb3c <ready_thread+0xe0>)
    caaa:	f004 f925 	bl	10cf8 <assert_post_action>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    caae:	6978      	ldr	r0, [r7, #20]
    cab0:	f00a fba3 	bl	171fa <sys_dlist_peek_head>
    cab4:	4603      	mov	r3, r0
    cab6:	2b00      	cmp	r3, #0
    cab8:	d004      	beq.n	cac4 <ready_thread+0x68>
    caba:	6978      	ldr	r0, [r7, #20]
    cabc:	f00a fb9d 	bl	171fa <sys_dlist_peek_head>
    cac0:	4603      	mov	r3, r0
    cac2:	e000      	b.n	cac6 <ready_thread+0x6a>
    cac4:	2300      	movs	r3, #0
    cac6:	60fb      	str	r3, [r7, #12]
    cac8:	e023      	b.n	cb12 <ready_thread+0xb6>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    caca:	68f9      	ldr	r1, [r7, #12]
    cacc:	6938      	ldr	r0, [r7, #16]
    cace:	f00b f837 	bl	17b40 <z_is_t1_higher_prio_than_t2>
    cad2:	4603      	mov	r3, r0
    cad4:	2b00      	cmp	r3, #0
    cad6:	d006      	beq.n	cae6 <ready_thread+0x8a>
			sys_dlist_insert(&t->base.qnode_dlist,
    cad8:	68fb      	ldr	r3, [r7, #12]
    cada:	693a      	ldr	r2, [r7, #16]
    cadc:	4611      	mov	r1, r2
    cade:	4618      	mov	r0, r3
    cae0:	f00a fbdb 	bl	1729a <sys_dlist_insert>
			return;
    cae4:	e01d      	b.n	cb22 <ready_thread+0xc6>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    cae6:	68fb      	ldr	r3, [r7, #12]
    cae8:	2b00      	cmp	r3, #0
    caea:	d010      	beq.n	cb0e <ready_thread+0xb2>
    caec:	68fb      	ldr	r3, [r7, #12]
    caee:	4619      	mov	r1, r3
    caf0:	6978      	ldr	r0, [r7, #20]
    caf2:	f00a fba7 	bl	17244 <sys_dlist_peek_next>
    caf6:	4603      	mov	r3, r0
    caf8:	2b00      	cmp	r3, #0
    cafa:	d006      	beq.n	cb0a <ready_thread+0xae>
    cafc:	68fb      	ldr	r3, [r7, #12]
    cafe:	4619      	mov	r1, r3
    cb00:	6978      	ldr	r0, [r7, #20]
    cb02:	f00a fb9f 	bl	17244 <sys_dlist_peek_next>
    cb06:	4603      	mov	r3, r0
    cb08:	e002      	b.n	cb10 <ready_thread+0xb4>
    cb0a:	2300      	movs	r3, #0
    cb0c:	e000      	b.n	cb10 <ready_thread+0xb4>
    cb0e:	2300      	movs	r3, #0
    cb10:	60fb      	str	r3, [r7, #12]
    cb12:	68fb      	ldr	r3, [r7, #12]
    cb14:	2b00      	cmp	r3, #0
    cb16:	d1d8      	bne.n	caca <ready_thread+0x6e>
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    cb18:	693b      	ldr	r3, [r7, #16]
    cb1a:	4619      	mov	r1, r3
    cb1c:	6978      	ldr	r0, [r7, #20]
    cb1e:	f00a fba4 	bl	1726a <sys_dlist_append>
		z_mark_thread_as_queued(thread);
    cb22:	6878      	ldr	r0, [r7, #4]
    cb24:	f00a ff8c 	bl	17a40 <z_mark_thread_as_queued>
		update_cache(0);
    cb28:	2000      	movs	r0, #0
    cb2a:	f7ff ff0f 	bl	c94c <update_cache>
}
    cb2e:	bf00      	nop
    cb30:	3718      	adds	r7, #24
    cb32:	46bd      	mov	sp, r7
    cb34:	bd80      	pop	{r7, pc}
    cb36:	bf00      	nop
    cb38:	20000d04 	.word	0x20000d04
    cb3c:	0001c030 	.word	0x0001c030
    cb40:	0001c054 	.word	0x0001c054
    cb44:	0001bf54 	.word	0x0001bf54

0000cb48 <z_ready_thread>:
{
    cb48:	b580      	push	{r7, lr}
    cb4a:	b08c      	sub	sp, #48	; 0x30
    cb4c:	af00      	add	r7, sp, #0
    cb4e:	6078      	str	r0, [r7, #4]
	LOCKED(&sched_spinlock) {
    cb50:	2300      	movs	r3, #0
    cb52:	61bb      	str	r3, [r7, #24]
    cb54:	4b2d      	ldr	r3, [pc, #180]	; (cc0c <z_ready_thread+0xc4>)
    cb56:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    cb58:	f04f 0320 	mov.w	r3, #32
    cb5c:	f3ef 8211 	mrs	r2, BASEPRI
    cb60:	f383 8811 	msr	BASEPRI, r3
    cb64:	f3bf 8f6f 	isb	sy
    cb68:	62ba      	str	r2, [r7, #40]	; 0x28
    cb6a:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
    cb6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
	k.key = arch_irq_lock();
    cb6e:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    cb70:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    cb72:	f001 ff71 	bl	ea58 <z_spin_lock_valid>
    cb76:	4603      	mov	r3, r0
    cb78:	f083 0301 	eor.w	r3, r3, #1
    cb7c:	b2db      	uxtb	r3, r3
    cb7e:	2b00      	cmp	r3, #0
    cb80:	d00d      	beq.n	cb9e <z_ready_thread+0x56>
    cb82:	2378      	movs	r3, #120	; 0x78
    cb84:	4a22      	ldr	r2, [pc, #136]	; (cc10 <z_ready_thread+0xc8>)
    cb86:	4923      	ldr	r1, [pc, #140]	; (cc14 <z_ready_thread+0xcc>)
    cb88:	4823      	ldr	r0, [pc, #140]	; (cc18 <z_ready_thread+0xd0>)
    cb8a:	f003 fa6d 	bl	10068 <printk>
    cb8e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    cb90:	4822      	ldr	r0, [pc, #136]	; (cc1c <z_ready_thread+0xd4>)
    cb92:	f003 fa69 	bl	10068 <printk>
    cb96:	2178      	movs	r1, #120	; 0x78
    cb98:	481d      	ldr	r0, [pc, #116]	; (cc10 <z_ready_thread+0xc8>)
    cb9a:	f004 f8ad 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    cb9e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    cba0:	f001 ff92 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    cba4:	68fb      	ldr	r3, [r7, #12]
    cba6:	617b      	str	r3, [r7, #20]
    cba8:	e028      	b.n	cbfc <z_ready_thread+0xb4>
		ready_thread(thread);
    cbaa:	6878      	ldr	r0, [r7, #4]
    cbac:	f7ff ff56 	bl	ca5c <ready_thread>
    cbb0:	4b16      	ldr	r3, [pc, #88]	; (cc0c <z_ready_thread+0xc4>)
    cbb2:	623b      	str	r3, [r7, #32]
    cbb4:	697b      	ldr	r3, [r7, #20]
    cbb6:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    cbb8:	6a38      	ldr	r0, [r7, #32]
    cbba:	f001 ff69 	bl	ea90 <z_spin_unlock_valid>
    cbbe:	4603      	mov	r3, r0
    cbc0:	f083 0301 	eor.w	r3, r3, #1
    cbc4:	b2db      	uxtb	r3, r3
    cbc6:	2b00      	cmp	r3, #0
    cbc8:	d00d      	beq.n	cbe6 <z_ready_thread+0x9e>
    cbca:	23a3      	movs	r3, #163	; 0xa3
    cbcc:	4a10      	ldr	r2, [pc, #64]	; (cc10 <z_ready_thread+0xc8>)
    cbce:	4914      	ldr	r1, [pc, #80]	; (cc20 <z_ready_thread+0xd8>)
    cbd0:	4811      	ldr	r0, [pc, #68]	; (cc18 <z_ready_thread+0xd0>)
    cbd2:	f003 fa49 	bl	10068 <printk>
    cbd6:	6a39      	ldr	r1, [r7, #32]
    cbd8:	4812      	ldr	r0, [pc, #72]	; (cc24 <z_ready_thread+0xdc>)
    cbda:	f003 fa45 	bl	10068 <printk>
    cbde:	21a3      	movs	r1, #163	; 0xa3
    cbe0:	480b      	ldr	r0, [pc, #44]	; (cc10 <z_ready_thread+0xc8>)
    cbe2:	f004 f889 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    cbe6:	693b      	ldr	r3, [r7, #16]
    cbe8:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    cbea:	69fb      	ldr	r3, [r7, #28]
    cbec:	f383 8811 	msr	BASEPRI, r3
    cbf0:	f3bf 8f6f 	isb	sy
}
    cbf4:	bf00      	nop
}
    cbf6:	bf00      	nop
	LOCKED(&sched_spinlock) {
    cbf8:	2301      	movs	r3, #1
    cbfa:	61bb      	str	r3, [r7, #24]
    cbfc:	69bb      	ldr	r3, [r7, #24]
    cbfe:	2b00      	cmp	r3, #0
    cc00:	d0d3      	beq.n	cbaa <z_ready_thread+0x62>
}
    cc02:	bf00      	nop
    cc04:	bf00      	nop
    cc06:	3730      	adds	r7, #48	; 0x30
    cc08:	46bd      	mov	sp, r7
    cc0a:	bd80      	pop	{r7, pc}
    cc0c:	20000d0c 	.word	0x20000d0c
    cc10:	0001bfa8 	.word	0x0001bfa8
    cc14:	0001bfd0 	.word	0x0001bfd0
    cc18:	0001bf54 	.word	0x0001bf54
    cc1c:	0001bfe8 	.word	0x0001bfe8
    cc20:	0001c000 	.word	0x0001c000
    cc24:	0001c018 	.word	0x0001c018

0000cc28 <z_sched_start>:
{
    cc28:	b580      	push	{r7, lr}
    cc2a:	b08a      	sub	sp, #40	; 0x28
    cc2c:	af00      	add	r7, sp, #0
    cc2e:	6078      	str	r0, [r7, #4]
    cc30:	4b30      	ldr	r3, [pc, #192]	; (ccf4 <z_sched_start+0xcc>)
    cc32:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    cc34:	f04f 0320 	mov.w	r3, #32
    cc38:	f3ef 8211 	mrs	r2, BASEPRI
    cc3c:	f383 8811 	msr	BASEPRI, r3
    cc40:	f3bf 8f6f 	isb	sy
    cc44:	623a      	str	r2, [r7, #32]
    cc46:	61fb      	str	r3, [r7, #28]
	return key;
    cc48:	6a3b      	ldr	r3, [r7, #32]
	k.key = arch_irq_lock();
    cc4a:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    cc4c:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cc4e:	f001 ff03 	bl	ea58 <z_spin_lock_valid>
    cc52:	4603      	mov	r3, r0
    cc54:	f083 0301 	eor.w	r3, r3, #1
    cc58:	b2db      	uxtb	r3, r3
    cc5a:	2b00      	cmp	r3, #0
    cc5c:	d00d      	beq.n	cc7a <z_sched_start+0x52>
    cc5e:	2378      	movs	r3, #120	; 0x78
    cc60:	4a25      	ldr	r2, [pc, #148]	; (ccf8 <z_sched_start+0xd0>)
    cc62:	4926      	ldr	r1, [pc, #152]	; (ccfc <z_sched_start+0xd4>)
    cc64:	4826      	ldr	r0, [pc, #152]	; (cd00 <z_sched_start+0xd8>)
    cc66:	f003 f9ff 	bl	10068 <printk>
    cc6a:	6a79      	ldr	r1, [r7, #36]	; 0x24
    cc6c:	4825      	ldr	r0, [pc, #148]	; (cd04 <z_sched_start+0xdc>)
    cc6e:	f003 f9fb 	bl	10068 <printk>
    cc72:	2178      	movs	r1, #120	; 0x78
    cc74:	4820      	ldr	r0, [pc, #128]	; (ccf8 <z_sched_start+0xd0>)
    cc76:	f004 f83f 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    cc7a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    cc7c:	f001 ff24 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    cc80:	68bb      	ldr	r3, [r7, #8]
    cc82:	613b      	str	r3, [r7, #16]
	if (z_has_thread_started(thread)) {
    cc84:	6878      	ldr	r0, [r7, #4]
    cc86:	f00a fe32 	bl	178ee <z_has_thread_started>
    cc8a:	4603      	mov	r3, r0
    cc8c:	2b00      	cmp	r3, #0
    cc8e:	d023      	beq.n	ccd8 <z_sched_start+0xb0>
    cc90:	4b18      	ldr	r3, [pc, #96]	; (ccf4 <z_sched_start+0xcc>)
    cc92:	61bb      	str	r3, [r7, #24]
    cc94:	693b      	ldr	r3, [r7, #16]
    cc96:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    cc98:	69b8      	ldr	r0, [r7, #24]
    cc9a:	f001 fef9 	bl	ea90 <z_spin_unlock_valid>
    cc9e:	4603      	mov	r3, r0
    cca0:	f083 0301 	eor.w	r3, r3, #1
    cca4:	b2db      	uxtb	r3, r3
    cca6:	2b00      	cmp	r3, #0
    cca8:	d00d      	beq.n	ccc6 <z_sched_start+0x9e>
    ccaa:	23a3      	movs	r3, #163	; 0xa3
    ccac:	4a12      	ldr	r2, [pc, #72]	; (ccf8 <z_sched_start+0xd0>)
    ccae:	4916      	ldr	r1, [pc, #88]	; (cd08 <z_sched_start+0xe0>)
    ccb0:	4813      	ldr	r0, [pc, #76]	; (cd00 <z_sched_start+0xd8>)
    ccb2:	f003 f9d9 	bl	10068 <printk>
    ccb6:	69b9      	ldr	r1, [r7, #24]
    ccb8:	4814      	ldr	r0, [pc, #80]	; (cd0c <z_sched_start+0xe4>)
    ccba:	f003 f9d5 	bl	10068 <printk>
    ccbe:	21a3      	movs	r1, #163	; 0xa3
    ccc0:	480d      	ldr	r0, [pc, #52]	; (ccf8 <z_sched_start+0xd0>)
    ccc2:	f004 f819 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    ccc6:	68fb      	ldr	r3, [r7, #12]
    ccc8:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    ccca:	697b      	ldr	r3, [r7, #20]
    cccc:	f383 8811 	msr	BASEPRI, r3
    ccd0:	f3bf 8f6f 	isb	sy
}
    ccd4:	bf00      	nop
}
    ccd6:	e009      	b.n	ccec <z_sched_start+0xc4>
	z_mark_thread_as_started(thread);
    ccd8:	6878      	ldr	r0, [r7, #4]
    ccda:	f00a fe5b 	bl	17994 <z_mark_thread_as_started>
	ready_thread(thread);
    ccde:	6878      	ldr	r0, [r7, #4]
    cce0:	f7ff febc 	bl	ca5c <ready_thread>
	z_reschedule(&sched_spinlock, key);
    cce4:	6939      	ldr	r1, [r7, #16]
    cce6:	4803      	ldr	r0, [pc, #12]	; (ccf4 <z_sched_start+0xcc>)
    cce8:	f000 fea8 	bl	da3c <z_reschedule>
}
    ccec:	3728      	adds	r7, #40	; 0x28
    ccee:	46bd      	mov	sp, r7
    ccf0:	bd80      	pop	{r7, pc}
    ccf2:	bf00      	nop
    ccf4:	20000d0c 	.word	0x20000d0c
    ccf8:	0001bfa8 	.word	0x0001bfa8
    ccfc:	0001bfd0 	.word	0x0001bfd0
    cd00:	0001bf54 	.word	0x0001bf54
    cd04:	0001bfe8 	.word	0x0001bfe8
    cd08:	0001c000 	.word	0x0001c000
    cd0c:	0001c018 	.word	0x0001c018

0000cd10 <z_impl_k_thread_suspend>:
{
    cd10:	b580      	push	{r7, lr}
    cd12:	b08c      	sub	sp, #48	; 0x30
    cd14:	af00      	add	r7, sp, #0
    cd16:	6078      	str	r0, [r7, #4]
	(void)z_abort_thread_timeout(thread);
    cd18:	6878      	ldr	r0, [r7, #4]
    cd1a:	f00a fd66 	bl	177ea <z_abort_thread_timeout>
	LOCKED(&sched_spinlock) {
    cd1e:	2300      	movs	r3, #0
    cd20:	61bb      	str	r3, [r7, #24]
    cd22:	4b3d      	ldr	r3, [pc, #244]	; (ce18 <z_impl_k_thread_suspend+0x108>)
    cd24:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    cd26:	f04f 0320 	mov.w	r3, #32
    cd2a:	f3ef 8211 	mrs	r2, BASEPRI
    cd2e:	f383 8811 	msr	BASEPRI, r3
    cd32:	f3bf 8f6f 	isb	sy
    cd36:	62ba      	str	r2, [r7, #40]	; 0x28
    cd38:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
    cd3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
	k.key = arch_irq_lock();
    cd3c:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    cd3e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    cd40:	f001 fe8a 	bl	ea58 <z_spin_lock_valid>
    cd44:	4603      	mov	r3, r0
    cd46:	f083 0301 	eor.w	r3, r3, #1
    cd4a:	b2db      	uxtb	r3, r3
    cd4c:	2b00      	cmp	r3, #0
    cd4e:	d00d      	beq.n	cd6c <z_impl_k_thread_suspend+0x5c>
    cd50:	2378      	movs	r3, #120	; 0x78
    cd52:	4a32      	ldr	r2, [pc, #200]	; (ce1c <z_impl_k_thread_suspend+0x10c>)
    cd54:	4932      	ldr	r1, [pc, #200]	; (ce20 <z_impl_k_thread_suspend+0x110>)
    cd56:	4833      	ldr	r0, [pc, #204]	; (ce24 <z_impl_k_thread_suspend+0x114>)
    cd58:	f003 f986 	bl	10068 <printk>
    cd5c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    cd5e:	4832      	ldr	r0, [pc, #200]	; (ce28 <z_impl_k_thread_suspend+0x118>)
    cd60:	f003 f982 	bl	10068 <printk>
    cd64:	2178      	movs	r1, #120	; 0x78
    cd66:	482d      	ldr	r0, [pc, #180]	; (ce1c <z_impl_k_thread_suspend+0x10c>)
    cd68:	f003 ffc6 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    cd6c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    cd6e:	f001 feab 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    cd72:	68fb      	ldr	r3, [r7, #12]
    cd74:	617b      	str	r3, [r7, #20]
    cd76:	e040      	b.n	cdfa <z_impl_k_thread_suspend+0xea>
		if (z_is_thread_queued(thread)) {
    cd78:	6878      	ldr	r0, [r7, #4]
    cd7a:	f00a fdde 	bl	1793a <z_is_thread_queued>
    cd7e:	4603      	mov	r3, r0
    cd80:	2b00      	cmp	r3, #0
    cd82:	d006      	beq.n	cd92 <z_impl_k_thread_suspend+0x82>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    cd84:	6879      	ldr	r1, [r7, #4]
    cd86:	4829      	ldr	r0, [pc, #164]	; (ce2c <z_impl_k_thread_suspend+0x11c>)
    cd88:	f001 f822 	bl	ddd0 <z_priq_dumb_remove>
			z_mark_thread_as_not_queued(thread);
    cd8c:	6878      	ldr	r0, [r7, #4]
    cd8e:	f00a fe63 	bl	17a58 <z_mark_thread_as_not_queued>
		z_mark_thread_as_suspended(thread);
    cd92:	6878      	ldr	r0, [r7, #4]
    cd94:	f00a fdde 	bl	17954 <z_mark_thread_as_suspended>
		update_cache(thread == _current);
    cd98:	4b25      	ldr	r3, [pc, #148]	; (ce30 <z_impl_k_thread_suspend+0x120>)
    cd9a:	689b      	ldr	r3, [r3, #8]
    cd9c:	687a      	ldr	r2, [r7, #4]
    cd9e:	429a      	cmp	r2, r3
    cda0:	bf0c      	ite	eq
    cda2:	2301      	moveq	r3, #1
    cda4:	2300      	movne	r3, #0
    cda6:	b2db      	uxtb	r3, r3
    cda8:	4618      	mov	r0, r3
    cdaa:	f7ff fdcf 	bl	c94c <update_cache>
    cdae:	4b1a      	ldr	r3, [pc, #104]	; (ce18 <z_impl_k_thread_suspend+0x108>)
    cdb0:	623b      	str	r3, [r7, #32]
    cdb2:	697b      	ldr	r3, [r7, #20]
    cdb4:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    cdb6:	6a38      	ldr	r0, [r7, #32]
    cdb8:	f001 fe6a 	bl	ea90 <z_spin_unlock_valid>
    cdbc:	4603      	mov	r3, r0
    cdbe:	f083 0301 	eor.w	r3, r3, #1
    cdc2:	b2db      	uxtb	r3, r3
    cdc4:	2b00      	cmp	r3, #0
    cdc6:	d00d      	beq.n	cde4 <z_impl_k_thread_suspend+0xd4>
    cdc8:	23a3      	movs	r3, #163	; 0xa3
    cdca:	4a14      	ldr	r2, [pc, #80]	; (ce1c <z_impl_k_thread_suspend+0x10c>)
    cdcc:	4919      	ldr	r1, [pc, #100]	; (ce34 <z_impl_k_thread_suspend+0x124>)
    cdce:	4815      	ldr	r0, [pc, #84]	; (ce24 <z_impl_k_thread_suspend+0x114>)
    cdd0:	f003 f94a 	bl	10068 <printk>
    cdd4:	6a39      	ldr	r1, [r7, #32]
    cdd6:	4818      	ldr	r0, [pc, #96]	; (ce38 <z_impl_k_thread_suspend+0x128>)
    cdd8:	f003 f946 	bl	10068 <printk>
    cddc:	21a3      	movs	r1, #163	; 0xa3
    cdde:	480f      	ldr	r0, [pc, #60]	; (ce1c <z_impl_k_thread_suspend+0x10c>)
    cde0:	f003 ff8a 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    cde4:	693b      	ldr	r3, [r7, #16]
    cde6:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    cde8:	69fb      	ldr	r3, [r7, #28]
    cdea:	f383 8811 	msr	BASEPRI, r3
    cdee:	f3bf 8f6f 	isb	sy
}
    cdf2:	bf00      	nop
}
    cdf4:	bf00      	nop
	LOCKED(&sched_spinlock) {
    cdf6:	2301      	movs	r3, #1
    cdf8:	61bb      	str	r3, [r7, #24]
    cdfa:	69bb      	ldr	r3, [r7, #24]
    cdfc:	2b00      	cmp	r3, #0
    cdfe:	d0bb      	beq.n	cd78 <z_impl_k_thread_suspend+0x68>
	if (thread == _current) {
    ce00:	4b0b      	ldr	r3, [pc, #44]	; (ce30 <z_impl_k_thread_suspend+0x120>)
    ce02:	689b      	ldr	r3, [r3, #8]
    ce04:	687a      	ldr	r2, [r7, #4]
    ce06:	429a      	cmp	r2, r3
    ce08:	d101      	bne.n	ce0e <z_impl_k_thread_suspend+0xfe>
		z_reschedule_unlocked();
    ce0a:	f00a fcfc 	bl	17806 <z_reschedule_unlocked>
}
    ce0e:	bf00      	nop
    ce10:	3730      	adds	r7, #48	; 0x30
    ce12:	46bd      	mov	sp, r7
    ce14:	bd80      	pop	{r7, pc}
    ce16:	bf00      	nop
    ce18:	20000d0c 	.word	0x20000d0c
    ce1c:	0001bfa8 	.word	0x0001bfa8
    ce20:	0001bfd0 	.word	0x0001bfd0
    ce24:	0001bf54 	.word	0x0001bf54
    ce28:	0001bfe8 	.word	0x0001bfe8
    ce2c:	20000d04 	.word	0x20000d04
    ce30:	20000cd8 	.word	0x20000cd8
    ce34:	0001c000 	.word	0x0001c000
    ce38:	0001c018 	.word	0x0001c018

0000ce3c <pended_on>:
{
    ce3c:	b580      	push	{r7, lr}
    ce3e:	b082      	sub	sp, #8
    ce40:	af00      	add	r7, sp, #0
    ce42:	6078      	str	r0, [r7, #4]
	__ASSERT_NO_MSG(thread->base.pended_on);
    ce44:	687b      	ldr	r3, [r7, #4]
    ce46:	689b      	ldr	r3, [r3, #8]
    ce48:	2b00      	cmp	r3, #0
    ce4a:	d10b      	bne.n	ce64 <pended_on+0x28>
    ce4c:	f44f 7301 	mov.w	r3, #516	; 0x204
    ce50:	4a07      	ldr	r2, [pc, #28]	; (ce70 <pended_on+0x34>)
    ce52:	4908      	ldr	r1, [pc, #32]	; (ce74 <pended_on+0x38>)
    ce54:	4808      	ldr	r0, [pc, #32]	; (ce78 <pended_on+0x3c>)
    ce56:	f003 f907 	bl	10068 <printk>
    ce5a:	f44f 7101 	mov.w	r1, #516	; 0x204
    ce5e:	4804      	ldr	r0, [pc, #16]	; (ce70 <pended_on+0x34>)
    ce60:	f003 ff4a 	bl	10cf8 <assert_post_action>
	return thread->base.pended_on;
    ce64:	687b      	ldr	r3, [r7, #4]
    ce66:	689b      	ldr	r3, [r3, #8]
}
    ce68:	4618      	mov	r0, r3
    ce6a:	3708      	adds	r7, #8
    ce6c:	46bd      	mov	sp, r7
    ce6e:	bd80      	pop	{r7, pc}
    ce70:	0001c030 	.word	0x0001c030
    ce74:	0001c0a0 	.word	0x0001c0a0
    ce78:	0001bf54 	.word	0x0001bf54

0000ce7c <z_thread_single_abort>:
{
    ce7c:	b580      	push	{r7, lr}
    ce7e:	b0a0      	sub	sp, #128	; 0x80
    ce80:	af00      	add	r7, sp, #0
    ce82:	6078      	str	r0, [r7, #4]
	void (*fn_abort)(struct k_thread *aborted) = NULL;
    ce84:	2300      	movs	r3, #0
    ce86:	67fb      	str	r3, [r7, #124]	; 0x7c
	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
    ce88:	687b      	ldr	r3, [r7, #4]
    ce8a:	7b1b      	ldrb	r3, [r3, #12]
    ce8c:	f003 0301 	and.w	r3, r3, #1
    ce90:	2b00      	cmp	r3, #0
    ce92:	d00e      	beq.n	ceb2 <z_thread_single_abort+0x36>
    ce94:	f240 230d 	movw	r3, #525	; 0x20d
    ce98:	4aa1      	ldr	r2, [pc, #644]	; (d120 <z_thread_single_abort+0x2a4>)
    ce9a:	49a2      	ldr	r1, [pc, #648]	; (d124 <z_thread_single_abort+0x2a8>)
    ce9c:	48a2      	ldr	r0, [pc, #648]	; (d128 <z_thread_single_abort+0x2ac>)
    ce9e:	f003 f8e3 	bl	10068 <printk>
    cea2:	48a2      	ldr	r0, [pc, #648]	; (d12c <z_thread_single_abort+0x2b0>)
    cea4:	f003 f8e0 	bl	10068 <printk>
    cea8:	f240 210d 	movw	r1, #525	; 0x20d
    ceac:	489c      	ldr	r0, [pc, #624]	; (d120 <z_thread_single_abort+0x2a4>)
    ceae:	f003 ff23 	bl	10cf8 <assert_post_action>
	__ASSERT(thread != _current || arch_is_in_isr(),
    ceb2:	4b9f      	ldr	r3, [pc, #636]	; (d130 <z_thread_single_abort+0x2b4>)
    ceb4:	689b      	ldr	r3, [r3, #8]
    ceb6:	687a      	ldr	r2, [r7, #4]
    ceb8:	429a      	cmp	r2, r3
    ceba:	d11c      	bne.n	cef6 <z_thread_single_abort+0x7a>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    cebc:	f3ef 8305 	mrs	r3, IPSR
    cec0:	66fb      	str	r3, [r7, #108]	; 0x6c
  return(result);
    cec2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    cec4:	2b00      	cmp	r3, #0
    cec6:	bf14      	ite	ne
    cec8:	2301      	movne	r3, #1
    ceca:	2300      	moveq	r3, #0
    cecc:	b2db      	uxtb	r3, r3
    cece:	f083 0301 	eor.w	r3, r3, #1
    ced2:	b2db      	uxtb	r3, r3
    ced4:	2b00      	cmp	r3, #0
    ced6:	d00e      	beq.n	cef6 <z_thread_single_abort+0x7a>
    ced8:	f240 230f 	movw	r3, #527	; 0x20f
    cedc:	4a90      	ldr	r2, [pc, #576]	; (d120 <z_thread_single_abort+0x2a4>)
    cede:	4995      	ldr	r1, [pc, #596]	; (d134 <z_thread_single_abort+0x2b8>)
    cee0:	4891      	ldr	r0, [pc, #580]	; (d128 <z_thread_single_abort+0x2ac>)
    cee2:	f003 f8c1 	bl	10068 <printk>
    cee6:	4894      	ldr	r0, [pc, #592]	; (d138 <z_thread_single_abort+0x2bc>)
    cee8:	f003 f8be 	bl	10068 <printk>
    ceec:	f240 210f 	movw	r1, #527	; 0x20f
    cef0:	488b      	ldr	r0, [pc, #556]	; (d120 <z_thread_single_abort+0x2a4>)
    cef2:	f003 ff01 	bl	10cf8 <assert_post_action>
    cef6:	4b91      	ldr	r3, [pc, #580]	; (d13c <z_thread_single_abort+0x2c0>)
    cef8:	66bb      	str	r3, [r7, #104]	; 0x68
	__asm__ volatile(
    cefa:	f04f 0320 	mov.w	r3, #32
    cefe:	f3ef 8211 	mrs	r2, BASEPRI
    cf02:	f383 8811 	msr	BASEPRI, r3
    cf06:	f3bf 8f6f 	isb	sy
    cf0a:	667a      	str	r2, [r7, #100]	; 0x64
    cf0c:	663b      	str	r3, [r7, #96]	; 0x60
	return key;
    cf0e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
	k.key = arch_irq_lock();
    cf10:	627b      	str	r3, [r7, #36]	; 0x24
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    cf12:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    cf14:	f001 fda0 	bl	ea58 <z_spin_lock_valid>
    cf18:	4603      	mov	r3, r0
    cf1a:	f083 0301 	eor.w	r3, r3, #1
    cf1e:	b2db      	uxtb	r3, r3
    cf20:	2b00      	cmp	r3, #0
    cf22:	d00d      	beq.n	cf40 <z_thread_single_abort+0xc4>
    cf24:	2378      	movs	r3, #120	; 0x78
    cf26:	4a86      	ldr	r2, [pc, #536]	; (d140 <z_thread_single_abort+0x2c4>)
    cf28:	4986      	ldr	r1, [pc, #536]	; (d144 <z_thread_single_abort+0x2c8>)
    cf2a:	487f      	ldr	r0, [pc, #508]	; (d128 <z_thread_single_abort+0x2ac>)
    cf2c:	f003 f89c 	bl	10068 <printk>
    cf30:	6eb9      	ldr	r1, [r7, #104]	; 0x68
    cf32:	4885      	ldr	r0, [pc, #532]	; (d148 <z_thread_single_abort+0x2cc>)
    cf34:	f003 f898 	bl	10068 <printk>
    cf38:	2178      	movs	r1, #120	; 0x78
    cf3a:	4881      	ldr	r0, [pc, #516]	; (d140 <z_thread_single_abort+0x2c4>)
    cf3c:	f003 fedc 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    cf40:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    cf42:	f001 fdc1 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    cf46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    cf48:	633b      	str	r3, [r7, #48]	; 0x30
	if ((thread->base.thread_state &
    cf4a:	687b      	ldr	r3, [r7, #4]
    cf4c:	7b5b      	ldrb	r3, [r3, #13]
    cf4e:	f003 0328 	and.w	r3, r3, #40	; 0x28
    cf52:	2b00      	cmp	r3, #0
    cf54:	d05b      	beq.n	d00e <z_thread_single_abort+0x192>
		LOG_DBG("Thread %p already dead or on the way out", thread);
    cf56:	2303      	movs	r3, #3
    cf58:	2b03      	cmp	r3, #3
    cf5a:	d934      	bls.n	cfc6 <z_thread_single_abort+0x14a>
    cf5c:	f00a f9ca 	bl	172f4 <_is_user_context>
    cf60:	4603      	mov	r3, r0
    cf62:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
    cf66:	f897 3020 	ldrb.w	r3, [r7, #32]
    cf6a:	2204      	movs	r2, #4
    cf6c:	f362 0302 	bfi	r3, r2, #0, #3
    cf70:	f887 3020 	strb.w	r3, [r7, #32]
    cf74:	f897 3020 	ldrb.w	r3, [r7, #32]
    cf78:	f36f 03c5 	bfc	r3, #3, #3
    cf7c:	f887 3020 	strb.w	r3, [r7, #32]
    cf80:	2303      	movs	r3, #3
    cf82:	2b00      	cmp	r3, #0
    cf84:	d009      	beq.n	cf9a <z_thread_single_abort+0x11e>
    cf86:	4b71      	ldr	r3, [pc, #452]	; (d14c <z_thread_single_abort+0x2d0>)
    cf88:	681b      	ldr	r3, [r3, #0]
    cf8a:	4618      	mov	r0, r3
    cf8c:	f7ff fac2 	bl	c514 <log_const_source_id>
    cf90:	4603      	mov	r3, r0
    cf92:	f3c3 0309 	ubfx	r3, r3, #0, #10
    cf96:	b29a      	uxth	r2, r3
    cf98:	e000      	b.n	cf9c <z_thread_single_abort+0x120>
    cf9a:	2200      	movs	r2, #0
    cf9c:	8c3b      	ldrh	r3, [r7, #32]
    cf9e:	f362 138f 	bfi	r3, r2, #6, #10
    cfa2:	843b      	strh	r3, [r7, #32]
    cfa4:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
    cfa8:	2b00      	cmp	r3, #0
    cfaa:	d006      	beq.n	cfba <z_thread_single_abort+0x13e>
    cfac:	687b      	ldr	r3, [r7, #4]
    cfae:	4a68      	ldr	r2, [pc, #416]	; (d150 <z_thread_single_abort+0x2d4>)
    cfb0:	4968      	ldr	r1, [pc, #416]	; (d154 <z_thread_single_abort+0x2d8>)
    cfb2:	8c38      	ldrh	r0, [r7, #32]
    cfb4:	f7f5 fc9c 	bl	28f0 <log_from_user>
    cfb8:	e005      	b.n	cfc6 <z_thread_single_abort+0x14a>
    cfba:	4965      	ldr	r1, [pc, #404]	; (d150 <z_thread_single_abort+0x2d4>)
    cfbc:	687a      	ldr	r2, [r7, #4]
    cfbe:	8c3b      	ldrh	r3, [r7, #32]
    cfc0:	4864      	ldr	r0, [pc, #400]	; (d154 <z_thread_single_abort+0x2d8>)
    cfc2:	f004 fb5a 	bl	1167a <log_2>
    cfc6:	4b5d      	ldr	r3, [pc, #372]	; (d13c <z_thread_single_abort+0x2c0>)
    cfc8:	65fb      	str	r3, [r7, #92]	; 0x5c
    cfca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    cfcc:	62bb      	str	r3, [r7, #40]	; 0x28
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    cfce:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    cfd0:	f001 fd5e 	bl	ea90 <z_spin_unlock_valid>
    cfd4:	4603      	mov	r3, r0
    cfd6:	f083 0301 	eor.w	r3, r3, #1
    cfda:	b2db      	uxtb	r3, r3
    cfdc:	2b00      	cmp	r3, #0
    cfde:	d00d      	beq.n	cffc <z_thread_single_abort+0x180>
    cfe0:	23a3      	movs	r3, #163	; 0xa3
    cfe2:	4a57      	ldr	r2, [pc, #348]	; (d140 <z_thread_single_abort+0x2c4>)
    cfe4:	495c      	ldr	r1, [pc, #368]	; (d158 <z_thread_single_abort+0x2dc>)
    cfe6:	4850      	ldr	r0, [pc, #320]	; (d128 <z_thread_single_abort+0x2ac>)
    cfe8:	f003 f83e 	bl	10068 <printk>
    cfec:	6df9      	ldr	r1, [r7, #92]	; 0x5c
    cfee:	485b      	ldr	r0, [pc, #364]	; (d15c <z_thread_single_abort+0x2e0>)
    cff0:	f003 f83a 	bl	10068 <printk>
    cff4:	21a3      	movs	r1, #163	; 0xa3
    cff6:	4852      	ldr	r0, [pc, #328]	; (d140 <z_thread_single_abort+0x2c4>)
    cff8:	f003 fe7e 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    cffc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    cffe:	65bb      	str	r3, [r7, #88]	; 0x58
	__asm__ volatile(
    d000:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    d002:	f383 8811 	msr	BASEPRI, r3
    d006:	f3bf 8f6f 	isb	sy
}
    d00a:	bf00      	nop
}
    d00c:	e154      	b.n	d2b8 <z_thread_single_abort+0x43c>
	thread->base.thread_state |= _THREAD_ABORTING;
    d00e:	687b      	ldr	r3, [r7, #4]
    d010:	7b5b      	ldrb	r3, [r3, #13]
    d012:	f043 0320 	orr.w	r3, r3, #32
    d016:	b2da      	uxtb	r2, r3
    d018:	687b      	ldr	r3, [r7, #4]
    d01a:	735a      	strb	r2, [r3, #13]
    d01c:	4b47      	ldr	r3, [pc, #284]	; (d13c <z_thread_single_abort+0x2c0>)
    d01e:	657b      	str	r3, [r7, #84]	; 0x54
    d020:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    d022:	62fb      	str	r3, [r7, #44]	; 0x2c
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d024:	6d78      	ldr	r0, [r7, #84]	; 0x54
    d026:	f001 fd33 	bl	ea90 <z_spin_unlock_valid>
    d02a:	4603      	mov	r3, r0
    d02c:	f083 0301 	eor.w	r3, r3, #1
    d030:	b2db      	uxtb	r3, r3
    d032:	2b00      	cmp	r3, #0
    d034:	d00d      	beq.n	d052 <z_thread_single_abort+0x1d6>
    d036:	23a3      	movs	r3, #163	; 0xa3
    d038:	4a41      	ldr	r2, [pc, #260]	; (d140 <z_thread_single_abort+0x2c4>)
    d03a:	4947      	ldr	r1, [pc, #284]	; (d158 <z_thread_single_abort+0x2dc>)
    d03c:	483a      	ldr	r0, [pc, #232]	; (d128 <z_thread_single_abort+0x2ac>)
    d03e:	f003 f813 	bl	10068 <printk>
    d042:	6d79      	ldr	r1, [r7, #84]	; 0x54
    d044:	4845      	ldr	r0, [pc, #276]	; (d15c <z_thread_single_abort+0x2e0>)
    d046:	f003 f80f 	bl	10068 <printk>
    d04a:	21a3      	movs	r1, #163	; 0xa3
    d04c:	483c      	ldr	r0, [pc, #240]	; (d140 <z_thread_single_abort+0x2c4>)
    d04e:	f003 fe53 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d054:	653b      	str	r3, [r7, #80]	; 0x50
	__asm__ volatile(
    d056:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    d058:	f383 8811 	msr	BASEPRI, r3
    d05c:	f3bf 8f6f 	isb	sy
}
    d060:	bf00      	nop
}
    d062:	bf00      	nop
	(void)z_abort_thread_timeout(thread);
    d064:	6878      	ldr	r0, [r7, #4]
    d066:	f00a fbc0 	bl	177ea <z_abort_thread_timeout>
	LOCKED(&sched_spinlock) {
    d06a:	2300      	movs	r3, #0
    d06c:	61fb      	str	r3, [r7, #28]
    d06e:	4b33      	ldr	r3, [pc, #204]	; (d13c <z_thread_single_abort+0x2c0>)
    d070:	64fb      	str	r3, [r7, #76]	; 0x4c
	__asm__ volatile(
    d072:	f04f 0320 	mov.w	r3, #32
    d076:	f3ef 8211 	mrs	r2, BASEPRI
    d07a:	f383 8811 	msr	BASEPRI, r3
    d07e:	f3bf 8f6f 	isb	sy
    d082:	64ba      	str	r2, [r7, #72]	; 0x48
    d084:	647b      	str	r3, [r7, #68]	; 0x44
	return key;
    d086:	6cbb      	ldr	r3, [r7, #72]	; 0x48
	k.key = arch_irq_lock();
    d088:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d08a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    d08c:	f001 fce4 	bl	ea58 <z_spin_lock_valid>
    d090:	4603      	mov	r3, r0
    d092:	f083 0301 	eor.w	r3, r3, #1
    d096:	b2db      	uxtb	r3, r3
    d098:	2b00      	cmp	r3, #0
    d09a:	d00d      	beq.n	d0b8 <z_thread_single_abort+0x23c>
    d09c:	2378      	movs	r3, #120	; 0x78
    d09e:	4a28      	ldr	r2, [pc, #160]	; (d140 <z_thread_single_abort+0x2c4>)
    d0a0:	4928      	ldr	r1, [pc, #160]	; (d144 <z_thread_single_abort+0x2c8>)
    d0a2:	4821      	ldr	r0, [pc, #132]	; (d128 <z_thread_single_abort+0x2ac>)
    d0a4:	f002 ffe0 	bl	10068 <printk>
    d0a8:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    d0aa:	4827      	ldr	r0, [pc, #156]	; (d148 <z_thread_single_abort+0x2cc>)
    d0ac:	f002 ffdc 	bl	10068 <printk>
    d0b0:	2178      	movs	r1, #120	; 0x78
    d0b2:	4823      	ldr	r0, [pc, #140]	; (d140 <z_thread_single_abort+0x2c4>)
    d0b4:	f003 fe20 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d0b8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    d0ba:	f001 fd05 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d0be:	693b      	ldr	r3, [r7, #16]
    d0c0:	61bb      	str	r3, [r7, #24]
    d0c2:	e0ef      	b.n	d2a4 <z_thread_single_abort+0x428>
		LOG_DBG("Cleanup aborting thread %p", thread);
    d0c4:	2303      	movs	r3, #3
    d0c6:	2b03      	cmp	r3, #3
    d0c8:	d952      	bls.n	d170 <z_thread_single_abort+0x2f4>
    d0ca:	f00a f913 	bl	172f4 <_is_user_context>
    d0ce:	4603      	mov	r3, r0
    d0d0:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
    d0d4:	7b3b      	ldrb	r3, [r7, #12]
    d0d6:	2204      	movs	r2, #4
    d0d8:	f362 0302 	bfi	r3, r2, #0, #3
    d0dc:	733b      	strb	r3, [r7, #12]
    d0de:	7b3b      	ldrb	r3, [r7, #12]
    d0e0:	f36f 03c5 	bfc	r3, #3, #3
    d0e4:	733b      	strb	r3, [r7, #12]
    d0e6:	2303      	movs	r3, #3
    d0e8:	2b00      	cmp	r3, #0
    d0ea:	d009      	beq.n	d100 <z_thread_single_abort+0x284>
    d0ec:	4b17      	ldr	r3, [pc, #92]	; (d14c <z_thread_single_abort+0x2d0>)
    d0ee:	681b      	ldr	r3, [r3, #0]
    d0f0:	4618      	mov	r0, r3
    d0f2:	f7ff fa0f 	bl	c514 <log_const_source_id>
    d0f6:	4603      	mov	r3, r0
    d0f8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    d0fc:	b29a      	uxth	r2, r3
    d0fe:	e000      	b.n	d102 <z_thread_single_abort+0x286>
    d100:	2200      	movs	r2, #0
    d102:	89bb      	ldrh	r3, [r7, #12]
    d104:	f362 138f 	bfi	r3, r2, #6, #10
    d108:	81bb      	strh	r3, [r7, #12]
    d10a:	f897 307b 	ldrb.w	r3, [r7, #123]	; 0x7b
    d10e:	2b00      	cmp	r3, #0
    d110:	d028      	beq.n	d164 <z_thread_single_abort+0x2e8>
    d112:	687b      	ldr	r3, [r7, #4]
    d114:	4a0e      	ldr	r2, [pc, #56]	; (d150 <z_thread_single_abort+0x2d4>)
    d116:	4912      	ldr	r1, [pc, #72]	; (d160 <z_thread_single_abort+0x2e4>)
    d118:	89b8      	ldrh	r0, [r7, #12]
    d11a:	f7f5 fbe9 	bl	28f0 <log_from_user>
    d11e:	e027      	b.n	d170 <z_thread_single_abort+0x2f4>
    d120:	0001c030 	.word	0x0001c030
    d124:	0001c0b8 	.word	0x0001c0b8
    d128:	0001bf54 	.word	0x0001bf54
    d12c:	0001c0e8 	.word	0x0001c0e8
    d130:	20000cd8 	.word	0x20000cd8
    d134:	0001c104 	.word	0x0001c104
    d138:	0001c13c 	.word	0x0001c13c
    d13c:	20000d0c 	.word	0x20000d0c
    d140:	0001bfa8 	.word	0x0001bfa8
    d144:	0001bfd0 	.word	0x0001bfd0
    d148:	0001bfe8 	.word	0x0001bfe8
    d14c:	20000174 	.word	0x20000174
    d150:	0001ce4c 	.word	0x0001ce4c
    d154:	0001c154 	.word	0x0001c154
    d158:	0001c000 	.word	0x0001c000
    d15c:	0001c018 	.word	0x0001c018
    d160:	0001c184 	.word	0x0001c184
    d164:	4956      	ldr	r1, [pc, #344]	; (d2c0 <z_thread_single_abort+0x444>)
    d166:	687a      	ldr	r2, [r7, #4]
    d168:	89bb      	ldrh	r3, [r7, #12]
    d16a:	4856      	ldr	r0, [pc, #344]	; (d2c4 <z_thread_single_abort+0x448>)
    d16c:	f004 fa85 	bl	1167a <log_2>
		if (z_is_thread_ready(thread)) {
    d170:	6878      	ldr	r0, [r7, #4]
    d172:	f00a fb9c 	bl	178ae <z_is_thread_ready>
    d176:	4603      	mov	r3, r0
    d178:	2b00      	cmp	r3, #0
    d17a:	d018      	beq.n	d1ae <z_thread_single_abort+0x332>
			if (z_is_thread_queued(thread)) {
    d17c:	6878      	ldr	r0, [r7, #4]
    d17e:	f00a fbdc 	bl	1793a <z_is_thread_queued>
    d182:	4603      	mov	r3, r0
    d184:	2b00      	cmp	r3, #0
    d186:	d006      	beq.n	d196 <z_thread_single_abort+0x31a>
				_priq_run_remove(&_kernel.ready_q.runq,
    d188:	6879      	ldr	r1, [r7, #4]
    d18a:	484f      	ldr	r0, [pc, #316]	; (d2c8 <z_thread_single_abort+0x44c>)
    d18c:	f000 fe20 	bl	ddd0 <z_priq_dumb_remove>
				z_mark_thread_as_not_queued(thread);
    d190:	6878      	ldr	r0, [r7, #4]
    d192:	f00a fc61 	bl	17a58 <z_mark_thread_as_not_queued>
			update_cache(thread == _current);
    d196:	4b4d      	ldr	r3, [pc, #308]	; (d2cc <z_thread_single_abort+0x450>)
    d198:	689b      	ldr	r3, [r3, #8]
    d19a:	687a      	ldr	r2, [r7, #4]
    d19c:	429a      	cmp	r2, r3
    d19e:	bf0c      	ite	eq
    d1a0:	2301      	moveq	r3, #1
    d1a2:	2300      	movne	r3, #0
    d1a4:	b2db      	uxtb	r3, r3
    d1a6:	4618      	mov	r0, r3
    d1a8:	f7ff fbd0 	bl	c94c <update_cache>
    d1ac:	e031      	b.n	d212 <z_thread_single_abort+0x396>
			if (z_is_thread_pending(thread)) {
    d1ae:	6878      	ldr	r0, [r7, #4]
    d1b0:	f00a fb3e 	bl	17830 <z_is_thread_pending>
    d1b4:	4603      	mov	r3, r0
    d1b6:	2b00      	cmp	r3, #0
    d1b8:	d02b      	beq.n	d212 <z_thread_single_abort+0x396>
				_priq_wait_remove(&pended_on(thread)->waitq,
    d1ba:	6878      	ldr	r0, [r7, #4]
    d1bc:	f7ff fe3e 	bl	ce3c <pended_on>
    d1c0:	4603      	mov	r3, r0
    d1c2:	6879      	ldr	r1, [r7, #4]
    d1c4:	4618      	mov	r0, r3
    d1c6:	f000 fe03 	bl	ddd0 <z_priq_dumb_remove>
				z_mark_thread_as_not_pending(thread);
    d1ca:	6878      	ldr	r0, [r7, #4]
    d1cc:	f00a fc02 	bl	179d4 <z_mark_thread_as_not_pending>
				thread->base.pended_on = NULL;
    d1d0:	687b      	ldr	r3, [r7, #4]
    d1d2:	2200      	movs	r2, #0
    d1d4:	609a      	str	r2, [r3, #8]
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
    d1d6:	e01c      	b.n	d212 <z_thread_single_abort+0x396>
			(void)z_abort_thread_timeout(waiter);
    d1d8:	6f78      	ldr	r0, [r7, #116]	; 0x74
    d1da:	f00a fb06 	bl	177ea <z_abort_thread_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
    d1de:	6f78      	ldr	r0, [r7, #116]	; 0x74
    d1e0:	f7ff fe2c 	bl	ce3c <pended_on>
    d1e4:	4603      	mov	r3, r0
    d1e6:	6f79      	ldr	r1, [r7, #116]	; 0x74
    d1e8:	4618      	mov	r0, r3
    d1ea:	f000 fdf1 	bl	ddd0 <z_priq_dumb_remove>
			z_mark_thread_as_not_pending(waiter);
    d1ee:	6f78      	ldr	r0, [r7, #116]	; 0x74
    d1f0:	f00a fbf0 	bl	179d4 <z_mark_thread_as_not_pending>
			waiter->base.pended_on = NULL;
    d1f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    d1f6:	2200      	movs	r2, #0
    d1f8:	609a      	str	r2, [r3, #8]
    d1fa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    d1fc:	643b      	str	r3, [r7, #64]	; 0x40
    d1fe:	2300      	movs	r3, #0
    d200:	63fb      	str	r3, [r7, #60]	; 0x3c
	thread->arch.swap_return_value = value;
    d202:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d204:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    d206:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    d20a:	bf00      	nop
			ready_thread(waiter);
    d20c:	6f78      	ldr	r0, [r7, #116]	; 0x74
    d20e:	f7ff fc25 	bl	ca5c <ready_thread>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
    d212:	687b      	ldr	r3, [r7, #4]
    d214:	3330      	adds	r3, #48	; 0x30
    d216:	4618      	mov	r0, r3
    d218:	f00a fc49 	bl	17aae <z_waitq_head>
    d21c:	6778      	str	r0, [r7, #116]	; 0x74
    d21e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    d220:	2b00      	cmp	r3, #0
    d222:	d1d9      	bne.n	d1d8 <z_thread_single_abort+0x35c>
		if (z_is_idle_thread_object(_current)) {
    d224:	4b29      	ldr	r3, [pc, #164]	; (d2cc <z_thread_single_abort+0x450>)
    d226:	689b      	ldr	r3, [r3, #8]
    d228:	4618      	mov	r0, r3
    d22a:	f7ff f83f 	bl	c2ac <z_is_idle_thread_object>
    d22e:	4603      	mov	r3, r0
    d230:	2b00      	cmp	r3, #0
    d232:	d002      	beq.n	d23a <z_thread_single_abort+0x3be>
			update_cache(1);
    d234:	2001      	movs	r0, #1
    d236:	f7ff fb89 	bl	c94c <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
    d23a:	687b      	ldr	r3, [r7, #4]
    d23c:	7b5b      	ldrb	r3, [r3, #13]
    d23e:	f043 0308 	orr.w	r3, r3, #8
    d242:	b2da      	uxtb	r2, r3
    d244:	687b      	ldr	r3, [r7, #4]
    d246:	735a      	strb	r2, [r3, #13]
		fn_abort = thread->fn_abort;
    d248:	687b      	ldr	r3, [r7, #4]
    d24a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    d24c:	67fb      	str	r3, [r7, #124]	; 0x7c
		atomic_clear(&thread->base.cookie);
    d24e:	687b      	ldr	r3, [r7, #4]
    d250:	3338      	adds	r3, #56	; 0x38
    d252:	4618      	mov	r0, r3
    d254:	f009 ff85 	bl	17162 <atomic_clear>
    d258:	4b1d      	ldr	r3, [pc, #116]	; (d2d0 <z_thread_single_abort+0x454>)
    d25a:	63bb      	str	r3, [r7, #56]	; 0x38
    d25c:	69bb      	ldr	r3, [r7, #24]
    d25e:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d260:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    d262:	f001 fc15 	bl	ea90 <z_spin_unlock_valid>
    d266:	4603      	mov	r3, r0
    d268:	f083 0301 	eor.w	r3, r3, #1
    d26c:	b2db      	uxtb	r3, r3
    d26e:	2b00      	cmp	r3, #0
    d270:	d00d      	beq.n	d28e <z_thread_single_abort+0x412>
    d272:	23a3      	movs	r3, #163	; 0xa3
    d274:	4a17      	ldr	r2, [pc, #92]	; (d2d4 <z_thread_single_abort+0x458>)
    d276:	4918      	ldr	r1, [pc, #96]	; (d2d8 <z_thread_single_abort+0x45c>)
    d278:	4818      	ldr	r0, [pc, #96]	; (d2dc <z_thread_single_abort+0x460>)
    d27a:	f002 fef5 	bl	10068 <printk>
    d27e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    d280:	4817      	ldr	r0, [pc, #92]	; (d2e0 <z_thread_single_abort+0x464>)
    d282:	f002 fef1 	bl	10068 <printk>
    d286:	21a3      	movs	r1, #163	; 0xa3
    d288:	4812      	ldr	r0, [pc, #72]	; (d2d4 <z_thread_single_abort+0x458>)
    d28a:	f003 fd35 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d28e:	697b      	ldr	r3, [r7, #20]
    d290:	637b      	str	r3, [r7, #52]	; 0x34
	__asm__ volatile(
    d292:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d294:	f383 8811 	msr	BASEPRI, r3
    d298:	f3bf 8f6f 	isb	sy
}
    d29c:	bf00      	nop
}
    d29e:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d2a0:	2301      	movs	r3, #1
    d2a2:	61fb      	str	r3, [r7, #28]
    d2a4:	69fb      	ldr	r3, [r7, #28]
    d2a6:	2b00      	cmp	r3, #0
    d2a8:	f43f af0c 	beq.w	d0c4 <z_thread_single_abort+0x248>
	if (fn_abort != NULL) {
    d2ac:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    d2ae:	2b00      	cmp	r3, #0
    d2b0:	d002      	beq.n	d2b8 <z_thread_single_abort+0x43c>
		fn_abort(thread);
    d2b2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    d2b4:	6878      	ldr	r0, [r7, #4]
    d2b6:	4798      	blx	r3
}
    d2b8:	3780      	adds	r7, #128	; 0x80
    d2ba:	46bd      	mov	sp, r7
    d2bc:	bd80      	pop	{r7, pc}
    d2be:	bf00      	nop
    d2c0:	0001ce4c 	.word	0x0001ce4c
    d2c4:	0001c184 	.word	0x0001c184
    d2c8:	20000d04 	.word	0x20000d04
    d2cc:	20000cd8 	.word	0x20000cd8
    d2d0:	20000d0c 	.word	0x20000d0c
    d2d4:	0001bfa8 	.word	0x0001bfa8
    d2d8:	0001c000 	.word	0x0001c000
    d2dc:	0001bf54 	.word	0x0001bf54
    d2e0:	0001c018 	.word	0x0001c018

0000d2e4 <unready_thread>:
{
    d2e4:	b580      	push	{r7, lr}
    d2e6:	b082      	sub	sp, #8
    d2e8:	af00      	add	r7, sp, #0
    d2ea:	6078      	str	r0, [r7, #4]
	if (z_is_thread_queued(thread)) {
    d2ec:	6878      	ldr	r0, [r7, #4]
    d2ee:	f00a fb24 	bl	1793a <z_is_thread_queued>
    d2f2:	4603      	mov	r3, r0
    d2f4:	2b00      	cmp	r3, #0
    d2f6:	d006      	beq.n	d306 <unready_thread+0x22>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    d2f8:	6879      	ldr	r1, [r7, #4]
    d2fa:	480a      	ldr	r0, [pc, #40]	; (d324 <unready_thread+0x40>)
    d2fc:	f000 fd68 	bl	ddd0 <z_priq_dumb_remove>
		z_mark_thread_as_not_queued(thread);
    d300:	6878      	ldr	r0, [r7, #4]
    d302:	f00a fba9 	bl	17a58 <z_mark_thread_as_not_queued>
	update_cache(thread == _current);
    d306:	4b08      	ldr	r3, [pc, #32]	; (d328 <unready_thread+0x44>)
    d308:	689b      	ldr	r3, [r3, #8]
    d30a:	687a      	ldr	r2, [r7, #4]
    d30c:	429a      	cmp	r2, r3
    d30e:	bf0c      	ite	eq
    d310:	2301      	moveq	r3, #1
    d312:	2300      	movne	r3, #0
    d314:	b2db      	uxtb	r3, r3
    d316:	4618      	mov	r0, r3
    d318:	f7ff fb18 	bl	c94c <update_cache>
}
    d31c:	bf00      	nop
    d31e:	3708      	adds	r7, #8
    d320:	46bd      	mov	sp, r7
    d322:	bd80      	pop	{r7, pc}
    d324:	20000d04 	.word	0x20000d04
    d328:	20000cd8 	.word	0x20000cd8

0000d32c <add_to_waitq_locked>:
{
    d32c:	b580      	push	{r7, lr}
    d32e:	b086      	sub	sp, #24
    d330:	af00      	add	r7, sp, #0
    d332:	6078      	str	r0, [r7, #4]
    d334:	6039      	str	r1, [r7, #0]
	unready_thread(thread);
    d336:	6878      	ldr	r0, [r7, #4]
    d338:	f7ff ffd4 	bl	d2e4 <unready_thread>
	z_mark_thread_as_pending(thread);
    d33c:	6878      	ldr	r0, [r7, #4]
    d33e:	f00a fb39 	bl	179b4 <z_mark_thread_as_pending>
	if (wait_q != NULL) {
    d342:	683b      	ldr	r3, [r7, #0]
    d344:	2b00      	cmp	r3, #0
    d346:	d053      	beq.n	d3f0 <add_to_waitq_locked+0xc4>
		thread->base.pended_on = wait_q;
    d348:	687b      	ldr	r3, [r7, #4]
    d34a:	683a      	ldr	r2, [r7, #0]
    d34c:	609a      	str	r2, [r3, #8]
		z_priq_wait_add(&wait_q->waitq, thread);
    d34e:	683b      	ldr	r3, [r7, #0]
    d350:	617b      	str	r3, [r7, #20]
    d352:	687b      	ldr	r3, [r7, #4]
    d354:	613b      	str	r3, [r7, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    d356:	6938      	ldr	r0, [r7, #16]
    d358:	f7fe ffa8 	bl	c2ac <z_is_idle_thread_object>
    d35c:	4603      	mov	r3, r0
    d35e:	2b00      	cmp	r3, #0
    d360:	d00b      	beq.n	d37a <add_to_waitq_locked+0x4e>
    d362:	f240 33c7 	movw	r3, #967	; 0x3c7
    d366:	4a24      	ldr	r2, [pc, #144]	; (d3f8 <add_to_waitq_locked+0xcc>)
    d368:	4924      	ldr	r1, [pc, #144]	; (d3fc <add_to_waitq_locked+0xd0>)
    d36a:	4825      	ldr	r0, [pc, #148]	; (d400 <add_to_waitq_locked+0xd4>)
    d36c:	f002 fe7c 	bl	10068 <printk>
    d370:	f240 31c7 	movw	r1, #967	; 0x3c7
    d374:	4820      	ldr	r0, [pc, #128]	; (d3f8 <add_to_waitq_locked+0xcc>)
    d376:	f003 fcbf 	bl	10cf8 <assert_post_action>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    d37a:	6978      	ldr	r0, [r7, #20]
    d37c:	f009 ff3d 	bl	171fa <sys_dlist_peek_head>
    d380:	4603      	mov	r3, r0
    d382:	2b00      	cmp	r3, #0
    d384:	d004      	beq.n	d390 <add_to_waitq_locked+0x64>
    d386:	6978      	ldr	r0, [r7, #20]
    d388:	f009 ff37 	bl	171fa <sys_dlist_peek_head>
    d38c:	4603      	mov	r3, r0
    d38e:	e000      	b.n	d392 <add_to_waitq_locked+0x66>
    d390:	2300      	movs	r3, #0
    d392:	60fb      	str	r3, [r7, #12]
    d394:	e024      	b.n	d3e0 <add_to_waitq_locked+0xb4>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    d396:	68f9      	ldr	r1, [r7, #12]
    d398:	6938      	ldr	r0, [r7, #16]
    d39a:	f00a fbd1 	bl	17b40 <z_is_t1_higher_prio_than_t2>
    d39e:	4603      	mov	r3, r0
    d3a0:	2b00      	cmp	r3, #0
    d3a2:	d007      	beq.n	d3b4 <add_to_waitq_locked+0x88>
			sys_dlist_insert(&t->base.qnode_dlist,
    d3a4:	68fb      	ldr	r3, [r7, #12]
    d3a6:	693a      	ldr	r2, [r7, #16]
    d3a8:	4611      	mov	r1, r2
    d3aa:	4618      	mov	r0, r3
    d3ac:	f009 ff75 	bl	1729a <sys_dlist_insert>
			return;
    d3b0:	bf00      	nop
}
    d3b2:	e01d      	b.n	d3f0 <add_to_waitq_locked+0xc4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    d3b4:	68fb      	ldr	r3, [r7, #12]
    d3b6:	2b00      	cmp	r3, #0
    d3b8:	d010      	beq.n	d3dc <add_to_waitq_locked+0xb0>
    d3ba:	68fb      	ldr	r3, [r7, #12]
    d3bc:	4619      	mov	r1, r3
    d3be:	6978      	ldr	r0, [r7, #20]
    d3c0:	f009 ff40 	bl	17244 <sys_dlist_peek_next>
    d3c4:	4603      	mov	r3, r0
    d3c6:	2b00      	cmp	r3, #0
    d3c8:	d006      	beq.n	d3d8 <add_to_waitq_locked+0xac>
    d3ca:	68fb      	ldr	r3, [r7, #12]
    d3cc:	4619      	mov	r1, r3
    d3ce:	6978      	ldr	r0, [r7, #20]
    d3d0:	f009 ff38 	bl	17244 <sys_dlist_peek_next>
    d3d4:	4603      	mov	r3, r0
    d3d6:	e002      	b.n	d3de <add_to_waitq_locked+0xb2>
    d3d8:	2300      	movs	r3, #0
    d3da:	e000      	b.n	d3de <add_to_waitq_locked+0xb2>
    d3dc:	2300      	movs	r3, #0
    d3de:	60fb      	str	r3, [r7, #12]
    d3e0:	68fb      	ldr	r3, [r7, #12]
    d3e2:	2b00      	cmp	r3, #0
    d3e4:	d1d7      	bne.n	d396 <add_to_waitq_locked+0x6a>
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    d3e6:	693b      	ldr	r3, [r7, #16]
    d3e8:	4619      	mov	r1, r3
    d3ea:	6978      	ldr	r0, [r7, #20]
    d3ec:	f009 ff3d 	bl	1726a <sys_dlist_append>
}
    d3f0:	bf00      	nop
    d3f2:	3718      	adds	r7, #24
    d3f4:	46bd      	mov	sp, r7
    d3f6:	bd80      	pop	{r7, pc}
    d3f8:	0001c030 	.word	0x0001c030
    d3fc:	0001c054 	.word	0x0001c054
    d400:	0001bf54 	.word	0x0001bf54

0000d404 <pend>:
{
    d404:	b580      	push	{r7, lr}
    d406:	b08e      	sub	sp, #56	; 0x38
    d408:	af00      	add	r7, sp, #0
    d40a:	60f8      	str	r0, [r7, #12]
    d40c:	60b9      	str	r1, [r7, #8]
    d40e:	e9c7 2300 	strd	r2, r3, [r7]
	LOCKED(&sched_spinlock) {
    d412:	2300      	movs	r3, #0
    d414:	623b      	str	r3, [r7, #32]
    d416:	4b30      	ldr	r3, [pc, #192]	; (d4d8 <pend+0xd4>)
    d418:	637b      	str	r3, [r7, #52]	; 0x34
	__asm__ volatile(
    d41a:	f04f 0320 	mov.w	r3, #32
    d41e:	f3ef 8211 	mrs	r2, BASEPRI
    d422:	f383 8811 	msr	BASEPRI, r3
    d426:	f3bf 8f6f 	isb	sy
    d42a:	633a      	str	r2, [r7, #48]	; 0x30
    d42c:	62fb      	str	r3, [r7, #44]	; 0x2c
	return key;
    d42e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	k.key = arch_irq_lock();
    d430:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d432:	6b78      	ldr	r0, [r7, #52]	; 0x34
    d434:	f001 fb10 	bl	ea58 <z_spin_lock_valid>
    d438:	4603      	mov	r3, r0
    d43a:	f083 0301 	eor.w	r3, r3, #1
    d43e:	b2db      	uxtb	r3, r3
    d440:	2b00      	cmp	r3, #0
    d442:	d00d      	beq.n	d460 <pend+0x5c>
    d444:	2378      	movs	r3, #120	; 0x78
    d446:	4a25      	ldr	r2, [pc, #148]	; (d4dc <pend+0xd8>)
    d448:	4925      	ldr	r1, [pc, #148]	; (d4e0 <pend+0xdc>)
    d44a:	4826      	ldr	r0, [pc, #152]	; (d4e4 <pend+0xe0>)
    d44c:	f002 fe0c 	bl	10068 <printk>
    d450:	6b79      	ldr	r1, [r7, #52]	; 0x34
    d452:	4825      	ldr	r0, [pc, #148]	; (d4e8 <pend+0xe4>)
    d454:	f002 fe08 	bl	10068 <printk>
    d458:	2178      	movs	r1, #120	; 0x78
    d45a:	4820      	ldr	r0, [pc, #128]	; (d4dc <pend+0xd8>)
    d45c:	f003 fc4c 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d460:	6b78      	ldr	r0, [r7, #52]	; 0x34
    d462:	f001 fb31 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d466:	697b      	ldr	r3, [r7, #20]
    d468:	61fb      	str	r3, [r7, #28]
    d46a:	e029      	b.n	d4c0 <pend+0xbc>
		add_to_waitq_locked(thread, wait_q);
    d46c:	68b9      	ldr	r1, [r7, #8]
    d46e:	68f8      	ldr	r0, [r7, #12]
    d470:	f7ff ff5c 	bl	d32c <add_to_waitq_locked>
    d474:	4b18      	ldr	r3, [pc, #96]	; (d4d8 <pend+0xd4>)
    d476:	62bb      	str	r3, [r7, #40]	; 0x28
    d478:	69fb      	ldr	r3, [r7, #28]
    d47a:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d47c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d47e:	f001 fb07 	bl	ea90 <z_spin_unlock_valid>
    d482:	4603      	mov	r3, r0
    d484:	f083 0301 	eor.w	r3, r3, #1
    d488:	b2db      	uxtb	r3, r3
    d48a:	2b00      	cmp	r3, #0
    d48c:	d00d      	beq.n	d4aa <pend+0xa6>
    d48e:	23a3      	movs	r3, #163	; 0xa3
    d490:	4a12      	ldr	r2, [pc, #72]	; (d4dc <pend+0xd8>)
    d492:	4916      	ldr	r1, [pc, #88]	; (d4ec <pend+0xe8>)
    d494:	4813      	ldr	r0, [pc, #76]	; (d4e4 <pend+0xe0>)
    d496:	f002 fde7 	bl	10068 <printk>
    d49a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    d49c:	4814      	ldr	r0, [pc, #80]	; (d4f0 <pend+0xec>)
    d49e:	f002 fde3 	bl	10068 <printk>
    d4a2:	21a3      	movs	r1, #163	; 0xa3
    d4a4:	480d      	ldr	r0, [pc, #52]	; (d4dc <pend+0xd8>)
    d4a6:	f003 fc27 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d4aa:	69bb      	ldr	r3, [r7, #24]
    d4ac:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    d4ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d4b0:	f383 8811 	msr	BASEPRI, r3
    d4b4:	f3bf 8f6f 	isb	sy
}
    d4b8:	bf00      	nop
}
    d4ba:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d4bc:	2301      	movs	r3, #1
    d4be:	623b      	str	r3, [r7, #32]
    d4c0:	6a3b      	ldr	r3, [r7, #32]
    d4c2:	2b00      	cmp	r3, #0
    d4c4:	d0d2      	beq.n	d46c <pend+0x68>
	add_thread_timeout(thread, timeout);
    d4c6:	e9d7 2300 	ldrd	r2, r3, [r7]
    d4ca:	68f8      	ldr	r0, [r7, #12]
    d4cc:	f00a fb56 	bl	17b7c <add_thread_timeout>
}
    d4d0:	bf00      	nop
    d4d2:	3738      	adds	r7, #56	; 0x38
    d4d4:	46bd      	mov	sp, r7
    d4d6:	bd80      	pop	{r7, pc}
    d4d8:	20000d0c 	.word	0x20000d0c
    d4dc:	0001bfa8 	.word	0x0001bfa8
    d4e0:	0001bfd0 	.word	0x0001bfd0
    d4e4:	0001bf54 	.word	0x0001bf54
    d4e8:	0001bfe8 	.word	0x0001bfe8
    d4ec:	0001c000 	.word	0x0001c000
    d4f0:	0001c018 	.word	0x0001c018

0000d4f4 <z_find_first_thread_to_unpend>:
{
    d4f4:	b580      	push	{r7, lr}
    d4f6:	b08c      	sub	sp, #48	; 0x30
    d4f8:	af00      	add	r7, sp, #0
    d4fa:	6078      	str	r0, [r7, #4]
    d4fc:	6039      	str	r1, [r7, #0]
	struct k_thread *ret = NULL;
    d4fe:	2300      	movs	r3, #0
    d500:	62fb      	str	r3, [r7, #44]	; 0x2c
	LOCKED(&sched_spinlock) {
    d502:	2300      	movs	r3, #0
    d504:	617b      	str	r3, [r7, #20]
    d506:	4b2f      	ldr	r3, [pc, #188]	; (d5c4 <z_find_first_thread_to_unpend+0xd0>)
    d508:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    d50a:	f04f 0320 	mov.w	r3, #32
    d50e:	f3ef 8211 	mrs	r2, BASEPRI
    d512:	f383 8811 	msr	BASEPRI, r3
    d516:	f3bf 8f6f 	isb	sy
    d51a:	627a      	str	r2, [r7, #36]	; 0x24
    d51c:	623b      	str	r3, [r7, #32]
	return key;
    d51e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
    d520:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d522:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d524:	f001 fa98 	bl	ea58 <z_spin_lock_valid>
    d528:	4603      	mov	r3, r0
    d52a:	f083 0301 	eor.w	r3, r3, #1
    d52e:	b2db      	uxtb	r3, r3
    d530:	2b00      	cmp	r3, #0
    d532:	d00d      	beq.n	d550 <z_find_first_thread_to_unpend+0x5c>
    d534:	2378      	movs	r3, #120	; 0x78
    d536:	4a24      	ldr	r2, [pc, #144]	; (d5c8 <z_find_first_thread_to_unpend+0xd4>)
    d538:	4924      	ldr	r1, [pc, #144]	; (d5cc <z_find_first_thread_to_unpend+0xd8>)
    d53a:	4825      	ldr	r0, [pc, #148]	; (d5d0 <z_find_first_thread_to_unpend+0xdc>)
    d53c:	f002 fd94 	bl	10068 <printk>
    d540:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    d542:	4824      	ldr	r0, [pc, #144]	; (d5d4 <z_find_first_thread_to_unpend+0xe0>)
    d544:	f002 fd90 	bl	10068 <printk>
    d548:	2178      	movs	r1, #120	; 0x78
    d54a:	481f      	ldr	r0, [pc, #124]	; (d5c8 <z_find_first_thread_to_unpend+0xd4>)
    d54c:	f003 fbd4 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d550:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d552:	f001 fab9 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d556:	68bb      	ldr	r3, [r7, #8]
    d558:	613b      	str	r3, [r7, #16]
    d55a:	e02a      	b.n	d5b2 <z_find_first_thread_to_unpend+0xbe>
		ret = _priq_wait_best(&wait_q->waitq);
    d55c:	687b      	ldr	r3, [r7, #4]
    d55e:	4618      	mov	r0, r3
    d560:	f00a fb8c 	bl	17c7c <z_priq_dumb_best>
    d564:	62f8      	str	r0, [r7, #44]	; 0x2c
    d566:	4b17      	ldr	r3, [pc, #92]	; (d5c4 <z_find_first_thread_to_unpend+0xd0>)
    d568:	61fb      	str	r3, [r7, #28]
    d56a:	693b      	ldr	r3, [r7, #16]
    d56c:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d56e:	69f8      	ldr	r0, [r7, #28]
    d570:	f001 fa8e 	bl	ea90 <z_spin_unlock_valid>
    d574:	4603      	mov	r3, r0
    d576:	f083 0301 	eor.w	r3, r3, #1
    d57a:	b2db      	uxtb	r3, r3
    d57c:	2b00      	cmp	r3, #0
    d57e:	d00d      	beq.n	d59c <z_find_first_thread_to_unpend+0xa8>
    d580:	23a3      	movs	r3, #163	; 0xa3
    d582:	4a11      	ldr	r2, [pc, #68]	; (d5c8 <z_find_first_thread_to_unpend+0xd4>)
    d584:	4914      	ldr	r1, [pc, #80]	; (d5d8 <z_find_first_thread_to_unpend+0xe4>)
    d586:	4812      	ldr	r0, [pc, #72]	; (d5d0 <z_find_first_thread_to_unpend+0xdc>)
    d588:	f002 fd6e 	bl	10068 <printk>
    d58c:	69f9      	ldr	r1, [r7, #28]
    d58e:	4813      	ldr	r0, [pc, #76]	; (d5dc <z_find_first_thread_to_unpend+0xe8>)
    d590:	f002 fd6a 	bl	10068 <printk>
    d594:	21a3      	movs	r1, #163	; 0xa3
    d596:	480c      	ldr	r0, [pc, #48]	; (d5c8 <z_find_first_thread_to_unpend+0xd4>)
    d598:	f003 fbae 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d59c:	68fb      	ldr	r3, [r7, #12]
    d59e:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    d5a0:	69bb      	ldr	r3, [r7, #24]
    d5a2:	f383 8811 	msr	BASEPRI, r3
    d5a6:	f3bf 8f6f 	isb	sy
}
    d5aa:	bf00      	nop
}
    d5ac:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d5ae:	2301      	movs	r3, #1
    d5b0:	617b      	str	r3, [r7, #20]
    d5b2:	697b      	ldr	r3, [r7, #20]
    d5b4:	2b00      	cmp	r3, #0
    d5b6:	d0d1      	beq.n	d55c <z_find_first_thread_to_unpend+0x68>
	return ret;
    d5b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
    d5ba:	4618      	mov	r0, r3
    d5bc:	3730      	adds	r7, #48	; 0x30
    d5be:	46bd      	mov	sp, r7
    d5c0:	bd80      	pop	{r7, pc}
    d5c2:	bf00      	nop
    d5c4:	20000d0c 	.word	0x20000d0c
    d5c8:	0001bfa8 	.word	0x0001bfa8
    d5cc:	0001bfd0 	.word	0x0001bfd0
    d5d0:	0001bf54 	.word	0x0001bf54
    d5d4:	0001bfe8 	.word	0x0001bfe8
    d5d8:	0001c000 	.word	0x0001c000
    d5dc:	0001c018 	.word	0x0001c018

0000d5e0 <z_unpend_thread_no_timeout>:
{
    d5e0:	b580      	push	{r7, lr}
    d5e2:	b08c      	sub	sp, #48	; 0x30
    d5e4:	af00      	add	r7, sp, #0
    d5e6:	6078      	str	r0, [r7, #4]
	LOCKED(&sched_spinlock) {
    d5e8:	2300      	movs	r3, #0
    d5ea:	61bb      	str	r3, [r7, #24]
    d5ec:	4b2d      	ldr	r3, [pc, #180]	; (d6a4 <z_unpend_thread_no_timeout+0xc4>)
    d5ee:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    d5f0:	f04f 0320 	mov.w	r3, #32
    d5f4:	f3ef 8211 	mrs	r2, BASEPRI
    d5f8:	f383 8811 	msr	BASEPRI, r3
    d5fc:	f3bf 8f6f 	isb	sy
    d600:	62ba      	str	r2, [r7, #40]	; 0x28
    d602:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
    d604:	6abb      	ldr	r3, [r7, #40]	; 0x28
	k.key = arch_irq_lock();
    d606:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d608:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d60a:	f001 fa25 	bl	ea58 <z_spin_lock_valid>
    d60e:	4603      	mov	r3, r0
    d610:	f083 0301 	eor.w	r3, r3, #1
    d614:	b2db      	uxtb	r3, r3
    d616:	2b00      	cmp	r3, #0
    d618:	d00d      	beq.n	d636 <z_unpend_thread_no_timeout+0x56>
    d61a:	2378      	movs	r3, #120	; 0x78
    d61c:	4a22      	ldr	r2, [pc, #136]	; (d6a8 <z_unpend_thread_no_timeout+0xc8>)
    d61e:	4923      	ldr	r1, [pc, #140]	; (d6ac <z_unpend_thread_no_timeout+0xcc>)
    d620:	4823      	ldr	r0, [pc, #140]	; (d6b0 <z_unpend_thread_no_timeout+0xd0>)
    d622:	f002 fd21 	bl	10068 <printk>
    d626:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    d628:	4822      	ldr	r0, [pc, #136]	; (d6b4 <z_unpend_thread_no_timeout+0xd4>)
    d62a:	f002 fd1d 	bl	10068 <printk>
    d62e:	2178      	movs	r1, #120	; 0x78
    d630:	481d      	ldr	r0, [pc, #116]	; (d6a8 <z_unpend_thread_no_timeout+0xc8>)
    d632:	f003 fb61 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d636:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d638:	f001 fa46 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d63c:	68fb      	ldr	r3, [r7, #12]
    d63e:	617b      	str	r3, [r7, #20]
    d640:	e028      	b.n	d694 <z_unpend_thread_no_timeout+0xb4>
		unpend_thread_no_timeout(thread);
    d642:	6878      	ldr	r0, [r7, #4]
    d644:	f00a fab3 	bl	17bae <unpend_thread_no_timeout>
    d648:	4b16      	ldr	r3, [pc, #88]	; (d6a4 <z_unpend_thread_no_timeout+0xc4>)
    d64a:	623b      	str	r3, [r7, #32]
    d64c:	697b      	ldr	r3, [r7, #20]
    d64e:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d650:	6a38      	ldr	r0, [r7, #32]
    d652:	f001 fa1d 	bl	ea90 <z_spin_unlock_valid>
    d656:	4603      	mov	r3, r0
    d658:	f083 0301 	eor.w	r3, r3, #1
    d65c:	b2db      	uxtb	r3, r3
    d65e:	2b00      	cmp	r3, #0
    d660:	d00d      	beq.n	d67e <z_unpend_thread_no_timeout+0x9e>
    d662:	23a3      	movs	r3, #163	; 0xa3
    d664:	4a10      	ldr	r2, [pc, #64]	; (d6a8 <z_unpend_thread_no_timeout+0xc8>)
    d666:	4914      	ldr	r1, [pc, #80]	; (d6b8 <z_unpend_thread_no_timeout+0xd8>)
    d668:	4811      	ldr	r0, [pc, #68]	; (d6b0 <z_unpend_thread_no_timeout+0xd0>)
    d66a:	f002 fcfd 	bl	10068 <printk>
    d66e:	6a39      	ldr	r1, [r7, #32]
    d670:	4812      	ldr	r0, [pc, #72]	; (d6bc <z_unpend_thread_no_timeout+0xdc>)
    d672:	f002 fcf9 	bl	10068 <printk>
    d676:	21a3      	movs	r1, #163	; 0xa3
    d678:	480b      	ldr	r0, [pc, #44]	; (d6a8 <z_unpend_thread_no_timeout+0xc8>)
    d67a:	f003 fb3d 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d67e:	693b      	ldr	r3, [r7, #16]
    d680:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    d682:	69fb      	ldr	r3, [r7, #28]
    d684:	f383 8811 	msr	BASEPRI, r3
    d688:	f3bf 8f6f 	isb	sy
}
    d68c:	bf00      	nop
}
    d68e:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d690:	2301      	movs	r3, #1
    d692:	61bb      	str	r3, [r7, #24]
    d694:	69bb      	ldr	r3, [r7, #24]
    d696:	2b00      	cmp	r3, #0
    d698:	d0d3      	beq.n	d642 <z_unpend_thread_no_timeout+0x62>
}
    d69a:	bf00      	nop
    d69c:	bf00      	nop
    d69e:	3730      	adds	r7, #48	; 0x30
    d6a0:	46bd      	mov	sp, r7
    d6a2:	bd80      	pop	{r7, pc}
    d6a4:	20000d0c 	.word	0x20000d0c
    d6a8:	0001bfa8 	.word	0x0001bfa8
    d6ac:	0001bfd0 	.word	0x0001bfd0
    d6b0:	0001bf54 	.word	0x0001bf54
    d6b4:	0001bfe8 	.word	0x0001bfe8
    d6b8:	0001c000 	.word	0x0001c000
    d6bc:	0001c018 	.word	0x0001c018

0000d6c0 <z_thread_timeout>:
{
    d6c0:	b580      	push	{r7, lr}
    d6c2:	b08c      	sub	sp, #48	; 0x30
    d6c4:	af00      	add	r7, sp, #0
    d6c6:	6078      	str	r0, [r7, #4]
	LOCKED(&sched_spinlock) {
    d6c8:	2300      	movs	r3, #0
    d6ca:	617b      	str	r3, [r7, #20]
    d6cc:	4b35      	ldr	r3, [pc, #212]	; (d7a4 <z_thread_timeout+0xe4>)
    d6ce:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    d6d0:	f04f 0320 	mov.w	r3, #32
    d6d4:	f3ef 8211 	mrs	r2, BASEPRI
    d6d8:	f383 8811 	msr	BASEPRI, r3
    d6dc:	f3bf 8f6f 	isb	sy
    d6e0:	627a      	str	r2, [r7, #36]	; 0x24
    d6e2:	623b      	str	r3, [r7, #32]
	return key;
    d6e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
    d6e6:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d6e8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d6ea:	f001 f9b5 	bl	ea58 <z_spin_lock_valid>
    d6ee:	4603      	mov	r3, r0
    d6f0:	f083 0301 	eor.w	r3, r3, #1
    d6f4:	b2db      	uxtb	r3, r3
    d6f6:	2b00      	cmp	r3, #0
    d6f8:	d00d      	beq.n	d716 <z_thread_timeout+0x56>
    d6fa:	2378      	movs	r3, #120	; 0x78
    d6fc:	4a2a      	ldr	r2, [pc, #168]	; (d7a8 <z_thread_timeout+0xe8>)
    d6fe:	492b      	ldr	r1, [pc, #172]	; (d7ac <z_thread_timeout+0xec>)
    d700:	482b      	ldr	r0, [pc, #172]	; (d7b0 <z_thread_timeout+0xf0>)
    d702:	f002 fcb1 	bl	10068 <printk>
    d706:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    d708:	482a      	ldr	r0, [pc, #168]	; (d7b4 <z_thread_timeout+0xf4>)
    d70a:	f002 fcad 	bl	10068 <printk>
    d70e:	2178      	movs	r1, #120	; 0x78
    d710:	4825      	ldr	r0, [pc, #148]	; (d7a8 <z_thread_timeout+0xe8>)
    d712:	f003 faf1 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d716:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d718:	f001 f9d6 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d71c:	68bb      	ldr	r3, [r7, #8]
    d71e:	613b      	str	r3, [r7, #16]
    d720:	e038      	b.n	d794 <z_thread_timeout+0xd4>
		struct k_thread *thread = CONTAINER_OF(timeout,
    d722:	687b      	ldr	r3, [r7, #4]
    d724:	3b18      	subs	r3, #24
    d726:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (thread->base.pended_on != NULL) {
    d728:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d72a:	689b      	ldr	r3, [r3, #8]
    d72c:	2b00      	cmp	r3, #0
    d72e:	d002      	beq.n	d736 <z_thread_timeout+0x76>
			unpend_thread_no_timeout(thread);
    d730:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d732:	f00a fa3c 	bl	17bae <unpend_thread_no_timeout>
		z_mark_thread_as_started(thread);
    d736:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d738:	f00a f92c 	bl	17994 <z_mark_thread_as_started>
		z_mark_thread_as_not_suspended(thread);
    d73c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d73e:	f00a f919 	bl	17974 <z_mark_thread_as_not_suspended>
		ready_thread(thread);
    d742:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d744:	f7ff f98a 	bl	ca5c <ready_thread>
    d748:	4b16      	ldr	r3, [pc, #88]	; (d7a4 <z_thread_timeout+0xe4>)
    d74a:	61fb      	str	r3, [r7, #28]
    d74c:	693b      	ldr	r3, [r7, #16]
    d74e:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d750:	69f8      	ldr	r0, [r7, #28]
    d752:	f001 f99d 	bl	ea90 <z_spin_unlock_valid>
    d756:	4603      	mov	r3, r0
    d758:	f083 0301 	eor.w	r3, r3, #1
    d75c:	b2db      	uxtb	r3, r3
    d75e:	2b00      	cmp	r3, #0
    d760:	d00d      	beq.n	d77e <z_thread_timeout+0xbe>
    d762:	23a3      	movs	r3, #163	; 0xa3
    d764:	4a10      	ldr	r2, [pc, #64]	; (d7a8 <z_thread_timeout+0xe8>)
    d766:	4914      	ldr	r1, [pc, #80]	; (d7b8 <z_thread_timeout+0xf8>)
    d768:	4811      	ldr	r0, [pc, #68]	; (d7b0 <z_thread_timeout+0xf0>)
    d76a:	f002 fc7d 	bl	10068 <printk>
    d76e:	69f9      	ldr	r1, [r7, #28]
    d770:	4812      	ldr	r0, [pc, #72]	; (d7bc <z_thread_timeout+0xfc>)
    d772:	f002 fc79 	bl	10068 <printk>
    d776:	21a3      	movs	r1, #163	; 0xa3
    d778:	480b      	ldr	r0, [pc, #44]	; (d7a8 <z_thread_timeout+0xe8>)
    d77a:	f003 fabd 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d77e:	68fb      	ldr	r3, [r7, #12]
    d780:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    d782:	69bb      	ldr	r3, [r7, #24]
    d784:	f383 8811 	msr	BASEPRI, r3
    d788:	f3bf 8f6f 	isb	sy
}
    d78c:	bf00      	nop
}
    d78e:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d790:	2301      	movs	r3, #1
    d792:	617b      	str	r3, [r7, #20]
    d794:	697b      	ldr	r3, [r7, #20]
    d796:	2b00      	cmp	r3, #0
    d798:	d0c3      	beq.n	d722 <z_thread_timeout+0x62>
}
    d79a:	bf00      	nop
    d79c:	bf00      	nop
    d79e:	3730      	adds	r7, #48	; 0x30
    d7a0:	46bd      	mov	sp, r7
    d7a2:	bd80      	pop	{r7, pc}
    d7a4:	20000d0c 	.word	0x20000d0c
    d7a8:	0001bfa8 	.word	0x0001bfa8
    d7ac:	0001bfd0 	.word	0x0001bfd0
    d7b0:	0001bf54 	.word	0x0001bf54
    d7b4:	0001bfe8 	.word	0x0001bfe8
    d7b8:	0001c000 	.word	0x0001c000
    d7bc:	0001c018 	.word	0x0001c018

0000d7c0 <z_pend_curr>:
{
    d7c0:	b580      	push	{r7, lr}
    d7c2:	b088      	sub	sp, #32
    d7c4:	af00      	add	r7, sp, #0
    d7c6:	60f8      	str	r0, [r7, #12]
    d7c8:	60b9      	str	r1, [r7, #8]
    d7ca:	607a      	str	r2, [r7, #4]
	pending_current = _current;
    d7cc:	4b18      	ldr	r3, [pc, #96]	; (d830 <z_pend_curr+0x70>)
    d7ce:	689b      	ldr	r3, [r3, #8]
    d7d0:	4a18      	ldr	r2, [pc, #96]	; (d834 <z_pend_curr+0x74>)
    d7d2:	6013      	str	r3, [r2, #0]
	pend(_current, wait_q, timeout);
    d7d4:	4b16      	ldr	r3, [pc, #88]	; (d830 <z_pend_curr+0x70>)
    d7d6:	6898      	ldr	r0, [r3, #8]
    d7d8:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
    d7dc:	6879      	ldr	r1, [r7, #4]
    d7de:	f7ff fe11 	bl	d404 <pend>
    d7e2:	68fb      	ldr	r3, [r7, #12]
    d7e4:	61fb      	str	r3, [r7, #28]
    d7e6:	68bb      	ldr	r3, [r7, #8]
    d7e8:	617b      	str	r3, [r7, #20]
    d7ea:	69fb      	ldr	r3, [r7, #28]
    d7ec:	61bb      	str	r3, [r7, #24]
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d7ee:	69b8      	ldr	r0, [r7, #24]
    d7f0:	f001 f94e 	bl	ea90 <z_spin_unlock_valid>
    d7f4:	4603      	mov	r3, r0
    d7f6:	f083 0301 	eor.w	r3, r3, #1
    d7fa:	b2db      	uxtb	r3, r3
    d7fc:	2b00      	cmp	r3, #0
    d7fe:	d00d      	beq.n	d81c <z_pend_curr+0x5c>
    d800:	23ba      	movs	r3, #186	; 0xba
    d802:	4a0d      	ldr	r2, [pc, #52]	; (d838 <z_pend_curr+0x78>)
    d804:	490d      	ldr	r1, [pc, #52]	; (d83c <z_pend_curr+0x7c>)
    d806:	480e      	ldr	r0, [pc, #56]	; (d840 <z_pend_curr+0x80>)
    d808:	f002 fc2e 	bl	10068 <printk>
    d80c:	69b9      	ldr	r1, [r7, #24]
    d80e:	480d      	ldr	r0, [pc, #52]	; (d844 <z_pend_curr+0x84>)
    d810:	f002 fc2a 	bl	10068 <printk>
    d814:	21ba      	movs	r1, #186	; 0xba
    d816:	4808      	ldr	r0, [pc, #32]	; (d838 <z_pend_curr+0x78>)
    d818:	f003 fa6e 	bl	10cf8 <assert_post_action>
#endif
#ifdef CONFIG_SMP
	atomic_clear(&l->locked);
#endif
}
    d81c:	bf00      	nop
	return z_swap_irqlock(key.key);
    d81e:	697b      	ldr	r3, [r7, #20]
    d820:	4618      	mov	r0, r3
    d822:	f00a f951 	bl	17ac8 <z_swap_irqlock>
    d826:	4603      	mov	r3, r0
}
    d828:	4618      	mov	r0, r3
    d82a:	3720      	adds	r7, #32
    d82c:	46bd      	mov	sp, r7
    d82e:	bd80      	pop	{r7, pc}
    d830:	20000cd8 	.word	0x20000cd8
    d834:	20000d18 	.word	0x20000d18
    d838:	0001bfa8 	.word	0x0001bfa8
    d83c:	0001c000 	.word	0x0001c000
    d840:	0001bf54 	.word	0x0001bf54
    d844:	0001c018 	.word	0x0001c018

0000d848 <z_set_prio>:
{
    d848:	b580      	push	{r7, lr}
    d84a:	b090      	sub	sp, #64	; 0x40
    d84c:	af00      	add	r7, sp, #0
    d84e:	6078      	str	r0, [r7, #4]
    d850:	6039      	str	r1, [r7, #0]
	bool need_sched = 0;
    d852:	2300      	movs	r3, #0
    d854:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	LOCKED(&sched_spinlock) {
    d858:	2300      	movs	r3, #0
    d85a:	61bb      	str	r3, [r7, #24]
    d85c:	4b62      	ldr	r3, [pc, #392]	; (d9e8 <z_set_prio+0x1a0>)
    d85e:	63bb      	str	r3, [r7, #56]	; 0x38
	__asm__ volatile(
    d860:	f04f 0320 	mov.w	r3, #32
    d864:	f3ef 8211 	mrs	r2, BASEPRI
    d868:	f383 8811 	msr	BASEPRI, r3
    d86c:	f3bf 8f6f 	isb	sy
    d870:	637a      	str	r2, [r7, #52]	; 0x34
    d872:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
    d874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	k.key = arch_irq_lock();
    d876:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    d878:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    d87a:	f001 f8ed 	bl	ea58 <z_spin_lock_valid>
    d87e:	4603      	mov	r3, r0
    d880:	f083 0301 	eor.w	r3, r3, #1
    d884:	b2db      	uxtb	r3, r3
    d886:	2b00      	cmp	r3, #0
    d888:	d00d      	beq.n	d8a6 <z_set_prio+0x5e>
    d88a:	2378      	movs	r3, #120	; 0x78
    d88c:	4a57      	ldr	r2, [pc, #348]	; (d9ec <z_set_prio+0x1a4>)
    d88e:	4958      	ldr	r1, [pc, #352]	; (d9f0 <z_set_prio+0x1a8>)
    d890:	4858      	ldr	r0, [pc, #352]	; (d9f4 <z_set_prio+0x1ac>)
    d892:	f002 fbe9 	bl	10068 <printk>
    d896:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    d898:	4857      	ldr	r0, [pc, #348]	; (d9f8 <z_set_prio+0x1b0>)
    d89a:	f002 fbe5 	bl	10068 <printk>
    d89e:	2178      	movs	r1, #120	; 0x78
    d8a0:	4852      	ldr	r0, [pc, #328]	; (d9ec <z_set_prio+0x1a4>)
    d8a2:	f003 fa29 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    d8a6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    d8a8:	f001 f90e 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    d8ac:	68fb      	ldr	r3, [r7, #12]
    d8ae:	617b      	str	r3, [r7, #20]
    d8b0:	e08f      	b.n	d9d2 <z_set_prio+0x18a>
		need_sched = z_is_thread_ready(thread);
    d8b2:	6878      	ldr	r0, [r7, #4]
    d8b4:	f009 fffb 	bl	178ae <z_is_thread_ready>
    d8b8:	4603      	mov	r3, r0
    d8ba:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
		if (need_sched) {
    d8be:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
    d8c2:	2b00      	cmp	r3, #0
    d8c4:	d05b      	beq.n	d97e <z_set_prio+0x136>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
    d8c6:	6879      	ldr	r1, [r7, #4]
    d8c8:	484c      	ldr	r0, [pc, #304]	; (d9fc <z_set_prio+0x1b4>)
    d8ca:	f000 fa81 	bl	ddd0 <z_priq_dumb_remove>
				thread->base.prio = prio;
    d8ce:	683b      	ldr	r3, [r7, #0]
    d8d0:	b25a      	sxtb	r2, r3
    d8d2:	687b      	ldr	r3, [r7, #4]
    d8d4:	739a      	strb	r2, [r3, #14]
    d8d6:	4b49      	ldr	r3, [pc, #292]	; (d9fc <z_set_prio+0x1b4>)
    d8d8:	62fb      	str	r3, [r7, #44]	; 0x2c
    d8da:	687b      	ldr	r3, [r7, #4]
    d8dc:	62bb      	str	r3, [r7, #40]	; 0x28
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    d8de:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d8e0:	f7fe fce4 	bl	c2ac <z_is_idle_thread_object>
    d8e4:	4603      	mov	r3, r0
    d8e6:	2b00      	cmp	r3, #0
    d8e8:	d00b      	beq.n	d902 <z_set_prio+0xba>
    d8ea:	f240 33c7 	movw	r3, #967	; 0x3c7
    d8ee:	4a44      	ldr	r2, [pc, #272]	; (da00 <z_set_prio+0x1b8>)
    d8f0:	4944      	ldr	r1, [pc, #272]	; (da04 <z_set_prio+0x1bc>)
    d8f2:	4840      	ldr	r0, [pc, #256]	; (d9f4 <z_set_prio+0x1ac>)
    d8f4:	f002 fbb8 	bl	10068 <printk>
    d8f8:	f240 31c7 	movw	r1, #967	; 0x3c7
    d8fc:	4840      	ldr	r0, [pc, #256]	; (da00 <z_set_prio+0x1b8>)
    d8fe:	f003 f9fb 	bl	10cf8 <assert_post_action>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    d902:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d904:	f009 fc79 	bl	171fa <sys_dlist_peek_head>
    d908:	4603      	mov	r3, r0
    d90a:	2b00      	cmp	r3, #0
    d90c:	d004      	beq.n	d918 <z_set_prio+0xd0>
    d90e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d910:	f009 fc73 	bl	171fa <sys_dlist_peek_head>
    d914:	4603      	mov	r3, r0
    d916:	e000      	b.n	d91a <z_set_prio+0xd2>
    d918:	2300      	movs	r3, #0
    d91a:	627b      	str	r3, [r7, #36]	; 0x24
    d91c:	e023      	b.n	d966 <z_set_prio+0x11e>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    d91e:	6a79      	ldr	r1, [r7, #36]	; 0x24
    d920:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    d922:	f00a f90d 	bl	17b40 <z_is_t1_higher_prio_than_t2>
    d926:	4603      	mov	r3, r0
    d928:	2b00      	cmp	r3, #0
    d92a:	d006      	beq.n	d93a <z_set_prio+0xf2>
			sys_dlist_insert(&t->base.qnode_dlist,
    d92c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d92e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    d930:	4611      	mov	r1, r2
    d932:	4618      	mov	r0, r3
    d934:	f009 fcb1 	bl	1729a <sys_dlist_insert>
			return;
    d938:	e01d      	b.n	d976 <z_set_prio+0x12e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    d93a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d93c:	2b00      	cmp	r3, #0
    d93e:	d010      	beq.n	d962 <z_set_prio+0x11a>
    d940:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d942:	4619      	mov	r1, r3
    d944:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d946:	f009 fc7d 	bl	17244 <sys_dlist_peek_next>
    d94a:	4603      	mov	r3, r0
    d94c:	2b00      	cmp	r3, #0
    d94e:	d006      	beq.n	d95e <z_set_prio+0x116>
    d950:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d952:	4619      	mov	r1, r3
    d954:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d956:	f009 fc75 	bl	17244 <sys_dlist_peek_next>
    d95a:	4603      	mov	r3, r0
    d95c:	e002      	b.n	d964 <z_set_prio+0x11c>
    d95e:	2300      	movs	r3, #0
    d960:	e000      	b.n	d964 <z_set_prio+0x11c>
    d962:	2300      	movs	r3, #0
    d964:	627b      	str	r3, [r7, #36]	; 0x24
    d966:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d968:	2b00      	cmp	r3, #0
    d96a:	d1d8      	bne.n	d91e <z_set_prio+0xd6>
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    d96c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d96e:	4619      	mov	r1, r3
    d970:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    d972:	f009 fc7a 	bl	1726a <sys_dlist_append>
			update_cache(1);
    d976:	2001      	movs	r0, #1
    d978:	f7fe ffe8 	bl	c94c <update_cache>
    d97c:	e003      	b.n	d986 <z_set_prio+0x13e>
			thread->base.prio = prio;
    d97e:	683b      	ldr	r3, [r7, #0]
    d980:	b25a      	sxtb	r2, r3
    d982:	687b      	ldr	r3, [r7, #4]
    d984:	739a      	strb	r2, [r3, #14]
    d986:	4b18      	ldr	r3, [pc, #96]	; (d9e8 <z_set_prio+0x1a0>)
    d988:	623b      	str	r3, [r7, #32]
    d98a:	697b      	ldr	r3, [r7, #20]
    d98c:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    d98e:	6a38      	ldr	r0, [r7, #32]
    d990:	f001 f87e 	bl	ea90 <z_spin_unlock_valid>
    d994:	4603      	mov	r3, r0
    d996:	f083 0301 	eor.w	r3, r3, #1
    d99a:	b2db      	uxtb	r3, r3
    d99c:	2b00      	cmp	r3, #0
    d99e:	d00d      	beq.n	d9bc <z_set_prio+0x174>
    d9a0:	23a3      	movs	r3, #163	; 0xa3
    d9a2:	4a12      	ldr	r2, [pc, #72]	; (d9ec <z_set_prio+0x1a4>)
    d9a4:	4918      	ldr	r1, [pc, #96]	; (da08 <z_set_prio+0x1c0>)
    d9a6:	4813      	ldr	r0, [pc, #76]	; (d9f4 <z_set_prio+0x1ac>)
    d9a8:	f002 fb5e 	bl	10068 <printk>
    d9ac:	6a39      	ldr	r1, [r7, #32]
    d9ae:	4817      	ldr	r0, [pc, #92]	; (da0c <z_set_prio+0x1c4>)
    d9b0:	f002 fb5a 	bl	10068 <printk>
    d9b4:	21a3      	movs	r1, #163	; 0xa3
    d9b6:	480d      	ldr	r0, [pc, #52]	; (d9ec <z_set_prio+0x1a4>)
    d9b8:	f003 f99e 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    d9bc:	693b      	ldr	r3, [r7, #16]
    d9be:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    d9c0:	69fb      	ldr	r3, [r7, #28]
    d9c2:	f383 8811 	msr	BASEPRI, r3
    d9c6:	f3bf 8f6f 	isb	sy
}
    d9ca:	bf00      	nop
}
    d9cc:	bf00      	nop
	LOCKED(&sched_spinlock) {
    d9ce:	2301      	movs	r3, #1
    d9d0:	61bb      	str	r3, [r7, #24]
    d9d2:	69bb      	ldr	r3, [r7, #24]
    d9d4:	2b00      	cmp	r3, #0
    d9d6:	f43f af6c 	beq.w	d8b2 <z_set_prio+0x6a>
	return need_sched;
    d9da:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
    d9de:	4618      	mov	r0, r3
    d9e0:	3740      	adds	r7, #64	; 0x40
    d9e2:	46bd      	mov	sp, r7
    d9e4:	bd80      	pop	{r7, pc}
    d9e6:	bf00      	nop
    d9e8:	20000d0c 	.word	0x20000d0c
    d9ec:	0001bfa8 	.word	0x0001bfa8
    d9f0:	0001bfd0 	.word	0x0001bfd0
    d9f4:	0001bf54 	.word	0x0001bf54
    d9f8:	0001bfe8 	.word	0x0001bfe8
    d9fc:	20000d04 	.word	0x20000d04
    da00:	0001c030 	.word	0x0001c030
    da04:	0001c054 	.word	0x0001c054
    da08:	0001c000 	.word	0x0001c000
    da0c:	0001c018 	.word	0x0001c018

0000da10 <need_swap>:
{
    da10:	b480      	push	{r7}
    da12:	b083      	sub	sp, #12
    da14:	af00      	add	r7, sp, #0
	return _kernel.ready_q.cache;
    da16:	4b08      	ldr	r3, [pc, #32]	; (da38 <need_swap+0x28>)
    da18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	new_thread = z_get_next_ready_thread();
    da1a:	607b      	str	r3, [r7, #4]
	return new_thread != _current;
    da1c:	4b06      	ldr	r3, [pc, #24]	; (da38 <need_swap+0x28>)
    da1e:	689b      	ldr	r3, [r3, #8]
    da20:	687a      	ldr	r2, [r7, #4]
    da22:	429a      	cmp	r2, r3
    da24:	bf14      	ite	ne
    da26:	2301      	movne	r3, #1
    da28:	2300      	moveq	r3, #0
    da2a:	b2db      	uxtb	r3, r3
}
    da2c:	4618      	mov	r0, r3
    da2e:	370c      	adds	r7, #12
    da30:	46bd      	mov	sp, r7
    da32:	bc80      	pop	{r7}
    da34:	4770      	bx	lr
    da36:	bf00      	nop
    da38:	20000cd8 	.word	0x20000cd8

0000da3c <z_reschedule>:
{
    da3c:	b580      	push	{r7, lr}
    da3e:	b088      	sub	sp, #32
    da40:	af00      	add	r7, sp, #0
    da42:	6078      	str	r0, [r7, #4]
    da44:	6039      	str	r1, [r7, #0]
	if (resched(key.key) && need_swap()) {
    da46:	683b      	ldr	r3, [r7, #0]
    da48:	4618      	mov	r0, r3
    da4a:	f00a f8d9 	bl	17c00 <resched>
    da4e:	4603      	mov	r3, r0
    da50:	2b00      	cmp	r3, #0
    da52:	d027      	beq.n	daa4 <z_reschedule+0x68>
    da54:	f7ff ffdc 	bl	da10 <need_swap>
    da58:	4603      	mov	r3, r0
    da5a:	2b00      	cmp	r3, #0
    da5c:	d022      	beq.n	daa4 <z_reschedule+0x68>
    da5e:	687b      	ldr	r3, [r7, #4]
    da60:	61fb      	str	r3, [r7, #28]
    da62:	683b      	ldr	r3, [r7, #0]
    da64:	60bb      	str	r3, [r7, #8]
    da66:	69fb      	ldr	r3, [r7, #28]
    da68:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    da6a:	69b8      	ldr	r0, [r7, #24]
    da6c:	f001 f810 	bl	ea90 <z_spin_unlock_valid>
    da70:	4603      	mov	r3, r0
    da72:	f083 0301 	eor.w	r3, r3, #1
    da76:	b2db      	uxtb	r3, r3
    da78:	2b00      	cmp	r3, #0
    da7a:	d00d      	beq.n	da98 <z_reschedule+0x5c>
    da7c:	23ba      	movs	r3, #186	; 0xba
    da7e:	4a1d      	ldr	r2, [pc, #116]	; (daf4 <z_reschedule+0xb8>)
    da80:	491d      	ldr	r1, [pc, #116]	; (daf8 <z_reschedule+0xbc>)
    da82:	481e      	ldr	r0, [pc, #120]	; (dafc <z_reschedule+0xc0>)
    da84:	f002 faf0 	bl	10068 <printk>
    da88:	69b9      	ldr	r1, [r7, #24]
    da8a:	481d      	ldr	r0, [pc, #116]	; (db00 <z_reschedule+0xc4>)
    da8c:	f002 faec 	bl	10068 <printk>
    da90:	21ba      	movs	r1, #186	; 0xba
    da92:	4818      	ldr	r0, [pc, #96]	; (daf4 <z_reschedule+0xb8>)
    da94:	f003 f930 	bl	10cf8 <assert_post_action>
}
    da98:	bf00      	nop
    da9a:	68bb      	ldr	r3, [r7, #8]
    da9c:	4618      	mov	r0, r3
    da9e:	f00a f813 	bl	17ac8 <z_swap_irqlock>
		z_swap(lock, key);
    daa2:	e023      	b.n	daec <z_reschedule+0xb0>
    daa4:	687b      	ldr	r3, [r7, #4]
    daa6:	617b      	str	r3, [r7, #20]
    daa8:	683b      	ldr	r3, [r7, #0]
    daaa:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    daac:	6978      	ldr	r0, [r7, #20]
    daae:	f000 ffef 	bl	ea90 <z_spin_unlock_valid>
    dab2:	4603      	mov	r3, r0
    dab4:	f083 0301 	eor.w	r3, r3, #1
    dab8:	b2db      	uxtb	r3, r3
    daba:	2b00      	cmp	r3, #0
    dabc:	d00d      	beq.n	dada <z_reschedule+0x9e>
    dabe:	23a3      	movs	r3, #163	; 0xa3
    dac0:	4a0c      	ldr	r2, [pc, #48]	; (daf4 <z_reschedule+0xb8>)
    dac2:	490d      	ldr	r1, [pc, #52]	; (daf8 <z_reschedule+0xbc>)
    dac4:	480d      	ldr	r0, [pc, #52]	; (dafc <z_reschedule+0xc0>)
    dac6:	f002 facf 	bl	10068 <printk>
    daca:	6979      	ldr	r1, [r7, #20]
    dacc:	480c      	ldr	r0, [pc, #48]	; (db00 <z_reschedule+0xc4>)
    dace:	f002 facb 	bl	10068 <printk>
    dad2:	21a3      	movs	r1, #163	; 0xa3
    dad4:	4807      	ldr	r0, [pc, #28]	; (daf4 <z_reschedule+0xb8>)
    dad6:	f003 f90f 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    dada:	68fb      	ldr	r3, [r7, #12]
    dadc:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
    dade:	693b      	ldr	r3, [r7, #16]
    dae0:	f383 8811 	msr	BASEPRI, r3
    dae4:	f3bf 8f6f 	isb	sy
}
    dae8:	bf00      	nop
}
    daea:	bf00      	nop
}
    daec:	bf00      	nop
    daee:	3720      	adds	r7, #32
    daf0:	46bd      	mov	sp, r7
    daf2:	bd80      	pop	{r7, pc}
    daf4:	0001bfa8 	.word	0x0001bfa8
    daf8:	0001c000 	.word	0x0001c000
    dafc:	0001bf54 	.word	0x0001bf54
    db00:	0001c018 	.word	0x0001c018

0000db04 <k_sched_lock>:
{
    db04:	b580      	push	{r7, lr}
    db06:	b08a      	sub	sp, #40	; 0x28
    db08:	af00      	add	r7, sp, #0
	LOCKED(&sched_spinlock) {
    db0a:	2300      	movs	r3, #0
    db0c:	613b      	str	r3, [r7, #16]
    db0e:	4b2d      	ldr	r3, [pc, #180]	; (dbc4 <k_sched_lock+0xc0>)
    db10:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    db12:	f04f 0320 	mov.w	r3, #32
    db16:	f3ef 8211 	mrs	r2, BASEPRI
    db1a:	f383 8811 	msr	BASEPRI, r3
    db1e:	f3bf 8f6f 	isb	sy
    db22:	623a      	str	r2, [r7, #32]
    db24:	61fb      	str	r3, [r7, #28]
	return key;
    db26:	6a3b      	ldr	r3, [r7, #32]
	k.key = arch_irq_lock();
    db28:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    db2a:	6a78      	ldr	r0, [r7, #36]	; 0x24
    db2c:	f000 ff94 	bl	ea58 <z_spin_lock_valid>
    db30:	4603      	mov	r3, r0
    db32:	f083 0301 	eor.w	r3, r3, #1
    db36:	b2db      	uxtb	r3, r3
    db38:	2b00      	cmp	r3, #0
    db3a:	d00d      	beq.n	db58 <k_sched_lock+0x54>
    db3c:	2378      	movs	r3, #120	; 0x78
    db3e:	4a22      	ldr	r2, [pc, #136]	; (dbc8 <k_sched_lock+0xc4>)
    db40:	4922      	ldr	r1, [pc, #136]	; (dbcc <k_sched_lock+0xc8>)
    db42:	4823      	ldr	r0, [pc, #140]	; (dbd0 <k_sched_lock+0xcc>)
    db44:	f002 fa90 	bl	10068 <printk>
    db48:	6a79      	ldr	r1, [r7, #36]	; 0x24
    db4a:	4822      	ldr	r0, [pc, #136]	; (dbd4 <k_sched_lock+0xd0>)
    db4c:	f002 fa8c 	bl	10068 <printk>
    db50:	2178      	movs	r1, #120	; 0x78
    db52:	481d      	ldr	r0, [pc, #116]	; (dbc8 <k_sched_lock+0xc4>)
    db54:	f003 f8d0 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    db58:	6a78      	ldr	r0, [r7, #36]	; 0x24
    db5a:	f000 ffb5 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    db5e:	687b      	ldr	r3, [r7, #4]
    db60:	60fb      	str	r3, [r7, #12]
    db62:	e027      	b.n	dbb4 <k_sched_lock+0xb0>
		z_sched_lock();
    db64:	f7fe fbb4 	bl	c2d0 <z_sched_lock>
    db68:	4b16      	ldr	r3, [pc, #88]	; (dbc4 <k_sched_lock+0xc0>)
    db6a:	61bb      	str	r3, [r7, #24]
    db6c:	68fb      	ldr	r3, [r7, #12]
    db6e:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    db70:	69b8      	ldr	r0, [r7, #24]
    db72:	f000 ff8d 	bl	ea90 <z_spin_unlock_valid>
    db76:	4603      	mov	r3, r0
    db78:	f083 0301 	eor.w	r3, r3, #1
    db7c:	b2db      	uxtb	r3, r3
    db7e:	2b00      	cmp	r3, #0
    db80:	d00d      	beq.n	db9e <k_sched_lock+0x9a>
    db82:	23a3      	movs	r3, #163	; 0xa3
    db84:	4a10      	ldr	r2, [pc, #64]	; (dbc8 <k_sched_lock+0xc4>)
    db86:	4914      	ldr	r1, [pc, #80]	; (dbd8 <k_sched_lock+0xd4>)
    db88:	4811      	ldr	r0, [pc, #68]	; (dbd0 <k_sched_lock+0xcc>)
    db8a:	f002 fa6d 	bl	10068 <printk>
    db8e:	69b9      	ldr	r1, [r7, #24]
    db90:	4812      	ldr	r0, [pc, #72]	; (dbdc <k_sched_lock+0xd8>)
    db92:	f002 fa69 	bl	10068 <printk>
    db96:	21a3      	movs	r1, #163	; 0xa3
    db98:	480b      	ldr	r0, [pc, #44]	; (dbc8 <k_sched_lock+0xc4>)
    db9a:	f003 f8ad 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    db9e:	68bb      	ldr	r3, [r7, #8]
    dba0:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    dba2:	697b      	ldr	r3, [r7, #20]
    dba4:	f383 8811 	msr	BASEPRI, r3
    dba8:	f3bf 8f6f 	isb	sy
}
    dbac:	bf00      	nop
}
    dbae:	bf00      	nop
	LOCKED(&sched_spinlock) {
    dbb0:	2301      	movs	r3, #1
    dbb2:	613b      	str	r3, [r7, #16]
    dbb4:	693b      	ldr	r3, [r7, #16]
    dbb6:	2b00      	cmp	r3, #0
    dbb8:	d0d4      	beq.n	db64 <k_sched_lock+0x60>
}
    dbba:	bf00      	nop
    dbbc:	bf00      	nop
    dbbe:	3728      	adds	r7, #40	; 0x28
    dbc0:	46bd      	mov	sp, r7
    dbc2:	bd80      	pop	{r7, pc}
    dbc4:	20000d0c 	.word	0x20000d0c
    dbc8:	0001bfa8 	.word	0x0001bfa8
    dbcc:	0001bfd0 	.word	0x0001bfd0
    dbd0:	0001bf54 	.word	0x0001bf54
    dbd4:	0001bfe8 	.word	0x0001bfe8
    dbd8:	0001c000 	.word	0x0001c000
    dbdc:	0001c018 	.word	0x0001c018

0000dbe0 <k_sched_unlock>:
{
    dbe0:	b580      	push	{r7, lr}
    dbe2:	b08e      	sub	sp, #56	; 0x38
    dbe4:	af02      	add	r7, sp, #8
	LOCKED(&sched_spinlock) {
    dbe6:	2300      	movs	r3, #0
    dbe8:	613b      	str	r3, [r7, #16]
    dbea:	4b6a      	ldr	r3, [pc, #424]	; (dd94 <k_sched_unlock+0x1b4>)
    dbec:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    dbee:	f04f 0320 	mov.w	r3, #32
    dbf2:	f3ef 8211 	mrs	r2, BASEPRI
    dbf6:	f383 8811 	msr	BASEPRI, r3
    dbfa:	f3bf 8f6f 	isb	sy
    dbfe:	627a      	str	r2, [r7, #36]	; 0x24
    dc00:	623b      	str	r3, [r7, #32]
	return key;
    dc02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
    dc04:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    dc06:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    dc08:	f000 ff26 	bl	ea58 <z_spin_lock_valid>
    dc0c:	4603      	mov	r3, r0
    dc0e:	f083 0301 	eor.w	r3, r3, #1
    dc12:	b2db      	uxtb	r3, r3
    dc14:	2b00      	cmp	r3, #0
    dc16:	d00d      	beq.n	dc34 <k_sched_unlock+0x54>
    dc18:	2378      	movs	r3, #120	; 0x78
    dc1a:	4a5f      	ldr	r2, [pc, #380]	; (dd98 <k_sched_unlock+0x1b8>)
    dc1c:	495f      	ldr	r1, [pc, #380]	; (dd9c <k_sched_unlock+0x1bc>)
    dc1e:	4860      	ldr	r0, [pc, #384]	; (dda0 <k_sched_unlock+0x1c0>)
    dc20:	f002 fa22 	bl	10068 <printk>
    dc24:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    dc26:	485f      	ldr	r0, [pc, #380]	; (dda4 <k_sched_unlock+0x1c4>)
    dc28:	f002 fa1e 	bl	10068 <printk>
    dc2c:	2178      	movs	r1, #120	; 0x78
    dc2e:	485a      	ldr	r0, [pc, #360]	; (dd98 <k_sched_unlock+0x1b8>)
    dc30:	f003 f862 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    dc34:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    dc36:	f000 ff47 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    dc3a:	687b      	ldr	r3, [r7, #4]
    dc3c:	60fb      	str	r3, [r7, #12]
    dc3e:	e05c      	b.n	dcfa <k_sched_unlock+0x11a>
		__ASSERT(_current->base.sched_locked != 0, "");
    dc40:	4b59      	ldr	r3, [pc, #356]	; (dda8 <k_sched_unlock+0x1c8>)
    dc42:	689b      	ldr	r3, [r3, #8]
    dc44:	7bdb      	ldrb	r3, [r3, #15]
    dc46:	2b00      	cmp	r3, #0
    dc48:	d10e      	bne.n	dc68 <k_sched_unlock+0x88>
    dc4a:	f240 3377 	movw	r3, #887	; 0x377
    dc4e:	4a57      	ldr	r2, [pc, #348]	; (ddac <k_sched_unlock+0x1cc>)
    dc50:	4957      	ldr	r1, [pc, #348]	; (ddb0 <k_sched_unlock+0x1d0>)
    dc52:	4853      	ldr	r0, [pc, #332]	; (dda0 <k_sched_unlock+0x1c0>)
    dc54:	f002 fa08 	bl	10068 <printk>
    dc58:	4856      	ldr	r0, [pc, #344]	; (ddb4 <k_sched_unlock+0x1d4>)
    dc5a:	f002 fa05 	bl	10068 <printk>
    dc5e:	f240 3177 	movw	r1, #887	; 0x377
    dc62:	4852      	ldr	r0, [pc, #328]	; (ddac <k_sched_unlock+0x1cc>)
    dc64:	f003 f848 	bl	10cf8 <assert_post_action>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    dc68:	f3ef 8305 	mrs	r3, IPSR
    dc6c:	61fb      	str	r3, [r7, #28]
  return(result);
    dc6e:	69fb      	ldr	r3, [r7, #28]
    dc70:	2b00      	cmp	r3, #0
    dc72:	bf14      	ite	ne
    dc74:	2301      	movne	r3, #1
    dc76:	2300      	moveq	r3, #0
    dc78:	b2db      	uxtb	r3, r3
		__ASSERT(!arch_is_in_isr(), "");
    dc7a:	2b00      	cmp	r3, #0
    dc7c:	d00e      	beq.n	dc9c <k_sched_unlock+0xbc>
    dc7e:	f44f 735e 	mov.w	r3, #888	; 0x378
    dc82:	4a4a      	ldr	r2, [pc, #296]	; (ddac <k_sched_unlock+0x1cc>)
    dc84:	494c      	ldr	r1, [pc, #304]	; (ddb8 <k_sched_unlock+0x1d8>)
    dc86:	4846      	ldr	r0, [pc, #280]	; (dda0 <k_sched_unlock+0x1c0>)
    dc88:	f002 f9ee 	bl	10068 <printk>
    dc8c:	4849      	ldr	r0, [pc, #292]	; (ddb4 <k_sched_unlock+0x1d4>)
    dc8e:	f002 f9eb 	bl	10068 <printk>
    dc92:	f44f 715e 	mov.w	r1, #888	; 0x378
    dc96:	4845      	ldr	r0, [pc, #276]	; (ddac <k_sched_unlock+0x1cc>)
    dc98:	f003 f82e 	bl	10cf8 <assert_post_action>
		++_current->base.sched_locked;
    dc9c:	4b42      	ldr	r3, [pc, #264]	; (dda8 <k_sched_unlock+0x1c8>)
    dc9e:	689b      	ldr	r3, [r3, #8]
    dca0:	7bda      	ldrb	r2, [r3, #15]
    dca2:	3201      	adds	r2, #1
    dca4:	b2d2      	uxtb	r2, r2
    dca6:	73da      	strb	r2, [r3, #15]
		update_cache(0);
    dca8:	2000      	movs	r0, #0
    dcaa:	f7fe fe4f 	bl	c94c <update_cache>
    dcae:	4b39      	ldr	r3, [pc, #228]	; (dd94 <k_sched_unlock+0x1b4>)
    dcb0:	61bb      	str	r3, [r7, #24]
    dcb2:	68fb      	ldr	r3, [r7, #12]
    dcb4:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    dcb6:	69b8      	ldr	r0, [r7, #24]
    dcb8:	f000 feea 	bl	ea90 <z_spin_unlock_valid>
    dcbc:	4603      	mov	r3, r0
    dcbe:	f083 0301 	eor.w	r3, r3, #1
    dcc2:	b2db      	uxtb	r3, r3
    dcc4:	2b00      	cmp	r3, #0
    dcc6:	d00d      	beq.n	dce4 <k_sched_unlock+0x104>
    dcc8:	23a3      	movs	r3, #163	; 0xa3
    dcca:	4a33      	ldr	r2, [pc, #204]	; (dd98 <k_sched_unlock+0x1b8>)
    dccc:	493b      	ldr	r1, [pc, #236]	; (ddbc <k_sched_unlock+0x1dc>)
    dcce:	4834      	ldr	r0, [pc, #208]	; (dda0 <k_sched_unlock+0x1c0>)
    dcd0:	f002 f9ca 	bl	10068 <printk>
    dcd4:	69b9      	ldr	r1, [r7, #24]
    dcd6:	483a      	ldr	r0, [pc, #232]	; (ddc0 <k_sched_unlock+0x1e0>)
    dcd8:	f002 f9c6 	bl	10068 <printk>
    dcdc:	21a3      	movs	r1, #163	; 0xa3
    dcde:	482e      	ldr	r0, [pc, #184]	; (dd98 <k_sched_unlock+0x1b8>)
    dce0:	f003 f80a 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    dce4:	68bb      	ldr	r3, [r7, #8]
    dce6:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    dce8:	697b      	ldr	r3, [r7, #20]
    dcea:	f383 8811 	msr	BASEPRI, r3
    dcee:	f3bf 8f6f 	isb	sy
}
    dcf2:	bf00      	nop
}
    dcf4:	bf00      	nop
	LOCKED(&sched_spinlock) {
    dcf6:	2301      	movs	r3, #1
    dcf8:	613b      	str	r3, [r7, #16]
    dcfa:	693b      	ldr	r3, [r7, #16]
    dcfc:	2b00      	cmp	r3, #0
    dcfe:	d09f      	beq.n	dc40 <k_sched_unlock+0x60>
	LOG_DBG("scheduler unlocked (%p:%d)",
    dd00:	2303      	movs	r3, #3
    dd02:	2b03      	cmp	r3, #3
    dd04:	d93f      	bls.n	dd86 <k_sched_unlock+0x1a6>
    dd06:	f009 faf5 	bl	172f4 <_is_user_context>
    dd0a:	4603      	mov	r3, r0
    dd0c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    dd10:	783b      	ldrb	r3, [r7, #0]
    dd12:	2204      	movs	r2, #4
    dd14:	f362 0302 	bfi	r3, r2, #0, #3
    dd18:	703b      	strb	r3, [r7, #0]
    dd1a:	783b      	ldrb	r3, [r7, #0]
    dd1c:	f36f 03c5 	bfc	r3, #3, #3
    dd20:	703b      	strb	r3, [r7, #0]
    dd22:	2303      	movs	r3, #3
    dd24:	2b00      	cmp	r3, #0
    dd26:	d009      	beq.n	dd3c <k_sched_unlock+0x15c>
    dd28:	4b26      	ldr	r3, [pc, #152]	; (ddc4 <k_sched_unlock+0x1e4>)
    dd2a:	681b      	ldr	r3, [r3, #0]
    dd2c:	4618      	mov	r0, r3
    dd2e:	f7fe fbf1 	bl	c514 <log_const_source_id>
    dd32:	4603      	mov	r3, r0
    dd34:	f3c3 0309 	ubfx	r3, r3, #0, #10
    dd38:	b29a      	uxth	r2, r3
    dd3a:	e000      	b.n	dd3e <k_sched_unlock+0x15e>
    dd3c:	2200      	movs	r2, #0
    dd3e:	883b      	ldrh	r3, [r7, #0]
    dd40:	f362 138f 	bfi	r3, r2, #6, #10
    dd44:	803b      	strh	r3, [r7, #0]
    dd46:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dd4a:	2b00      	cmp	r3, #0
    dd4c:	d00c      	beq.n	dd68 <k_sched_unlock+0x188>
    dd4e:	4b16      	ldr	r3, [pc, #88]	; (dda8 <k_sched_unlock+0x1c8>)
    dd50:	689a      	ldr	r2, [r3, #8]
    dd52:	4b15      	ldr	r3, [pc, #84]	; (dda8 <k_sched_unlock+0x1c8>)
    dd54:	689b      	ldr	r3, [r3, #8]
    dd56:	7bdb      	ldrb	r3, [r3, #15]
    dd58:	9300      	str	r3, [sp, #0]
    dd5a:	4613      	mov	r3, r2
    dd5c:	4a1a      	ldr	r2, [pc, #104]	; (ddc8 <k_sched_unlock+0x1e8>)
    dd5e:	491b      	ldr	r1, [pc, #108]	; (ddcc <k_sched_unlock+0x1ec>)
    dd60:	8838      	ldrh	r0, [r7, #0]
    dd62:	f7f4 fdc5 	bl	28f0 <log_from_user>
    dd66:	e00e      	b.n	dd86 <k_sched_unlock+0x1a6>
    dd68:	4917      	ldr	r1, [pc, #92]	; (ddc8 <k_sched_unlock+0x1e8>)
    dd6a:	4b0f      	ldr	r3, [pc, #60]	; (dda8 <k_sched_unlock+0x1c8>)
    dd6c:	689b      	ldr	r3, [r3, #8]
    dd6e:	461a      	mov	r2, r3
    dd70:	4b0d      	ldr	r3, [pc, #52]	; (dda8 <k_sched_unlock+0x1c8>)
    dd72:	689b      	ldr	r3, [r3, #8]
    dd74:	7bdb      	ldrb	r3, [r3, #15]
    dd76:	4618      	mov	r0, r3
    dd78:	883b      	ldrh	r3, [r7, #0]
    dd7a:	f8ad 3000 	strh.w	r3, [sp]
    dd7e:	4603      	mov	r3, r0
    dd80:	4812      	ldr	r0, [pc, #72]	; (ddcc <k_sched_unlock+0x1ec>)
    dd82:	f003 fc93 	bl	116ac <log_3>
	z_reschedule_unlocked();
    dd86:	f009 fd3e 	bl	17806 <z_reschedule_unlocked>
}
    dd8a:	bf00      	nop
    dd8c:	3730      	adds	r7, #48	; 0x30
    dd8e:	46bd      	mov	sp, r7
    dd90:	bd80      	pop	{r7, pc}
    dd92:	bf00      	nop
    dd94:	20000d0c 	.word	0x20000d0c
    dd98:	0001bfa8 	.word	0x0001bfa8
    dd9c:	0001bfd0 	.word	0x0001bfd0
    dda0:	0001bf54 	.word	0x0001bf54
    dda4:	0001bfe8 	.word	0x0001bfe8
    dda8:	20000cd8 	.word	0x20000cd8
    ddac:	0001c030 	.word	0x0001c030
    ddb0:	0001c1e4 	.word	0x0001c1e4
    ddb4:	0001bf74 	.word	0x0001bf74
    ddb8:	0001bf40 	.word	0x0001bf40
    ddbc:	0001c000 	.word	0x0001c000
    ddc0:	0001c018 	.word	0x0001c018
    ddc4:	20000174 	.word	0x20000174
    ddc8:	0001ce64 	.word	0x0001ce64
    ddcc:	0001c214 	.word	0x0001c214

0000ddd0 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    ddd0:	b580      	push	{r7, lr}
    ddd2:	b082      	sub	sp, #8
    ddd4:	af00      	add	r7, sp, #0
    ddd6:	6078      	str	r0, [r7, #4]
    ddd8:	6039      	str	r1, [r7, #0]
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    ddda:	687b      	ldr	r3, [r7, #4]
    dddc:	4a14      	ldr	r2, [pc, #80]	; (de30 <z_priq_dumb_remove+0x60>)
    ddde:	4293      	cmp	r3, r2
    dde0:	d10a      	bne.n	ddf8 <z_priq_dumb_remove+0x28>
    dde2:	4b14      	ldr	r3, [pc, #80]	; (de34 <z_priq_dumb_remove+0x64>)
    dde4:	689b      	ldr	r3, [r3, #8]
    dde6:	683a      	ldr	r2, [r7, #0]
    dde8:	429a      	cmp	r2, r3
    ddea:	d105      	bne.n	ddf8 <z_priq_dumb_remove+0x28>
	    z_is_thread_prevented_from_running(thread)) {
    ddec:	6838      	ldr	r0, [r7, #0]
    ddee:	f009 fd31 	bl	17854 <z_is_thread_prevented_from_running>
    ddf2:	4603      	mov	r3, r0
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    ddf4:	2b00      	cmp	r3, #0
    ddf6:	d116      	bne.n	de26 <z_priq_dumb_remove+0x56>
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    ddf8:	6838      	ldr	r0, [r7, #0]
    ddfa:	f7fe fa57 	bl	c2ac <z_is_idle_thread_object>
    ddfe:	4603      	mov	r3, r0
    de00:	2b00      	cmp	r3, #0
    de02:	d00b      	beq.n	de1c <z_priq_dumb_remove+0x4c>
    de04:	f240 33dd 	movw	r3, #989	; 0x3dd
    de08:	4a0b      	ldr	r2, [pc, #44]	; (de38 <z_priq_dumb_remove+0x68>)
    de0a:	490c      	ldr	r1, [pc, #48]	; (de3c <z_priq_dumb_remove+0x6c>)
    de0c:	480c      	ldr	r0, [pc, #48]	; (de40 <z_priq_dumb_remove+0x70>)
    de0e:	f002 f92b 	bl	10068 <printk>
    de12:	f240 31dd 	movw	r1, #989	; 0x3dd
    de16:	4808      	ldr	r0, [pc, #32]	; (de38 <z_priq_dumb_remove+0x68>)
    de18:	f002 ff6e 	bl	10cf8 <assert_post_action>

	sys_dlist_remove(&thread->base.qnode_dlist);
    de1c:	683b      	ldr	r3, [r7, #0]
    de1e:	4618      	mov	r0, r3
    de20:	f009 fa53 	bl	172ca <sys_dlist_remove>
    de24:	e000      	b.n	de28 <z_priq_dumb_remove+0x58>
		return;
    de26:	bf00      	nop
}
    de28:	3708      	adds	r7, #8
    de2a:	46bd      	mov	sp, r7
    de2c:	bd80      	pop	{r7, pc}
    de2e:	bf00      	nop
    de30:	20000d04 	.word	0x20000d04
    de34:	20000cd8 	.word	0x20000cd8
    de38:	0001c030 	.word	0x0001c030
    de3c:	0001c054 	.word	0x0001c054
    de40:	0001bf54 	.word	0x0001bf54

0000de44 <z_sched_init>:

	return need_sched;
}

void z_sched_init(void)
{
    de44:	b580      	push	{r7, lr}
    de46:	af00      	add	r7, sp, #0
#ifdef CONFIG_SCHED_DUMB
	sys_dlist_init(&_kernel.ready_q.runq);
    de48:	4804      	ldr	r0, [pc, #16]	; (de5c <z_sched_init+0x18>)
    de4a:	f009 f997 	bl	1717c <sys_dlist_init>
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    de4e:	2100      	movs	r1, #0
    de50:	2000      	movs	r0, #0
    de52:	f7fe fc05 	bl	c660 <k_sched_time_slice_set>
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
    de56:	bf00      	nop
    de58:	bd80      	pop	{r7, pc}
    de5a:	bf00      	nop
    de5c:	20000d04 	.word	0x20000d04

0000de60 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    de60:	b580      	push	{r7, lr}
    de62:	b08e      	sub	sp, #56	; 0x38
    de64:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    de66:	f3ef 8305 	mrs	r3, IPSR
    de6a:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
    de6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    de6e:	2b00      	cmp	r3, #0
    de70:	bf14      	ite	ne
    de72:	2301      	movne	r3, #1
    de74:	2300      	moveq	r3, #0
    de76:	b2db      	uxtb	r3, r3
	__ASSERT(!arch_is_in_isr(), "");
    de78:	2b00      	cmp	r3, #0
    de7a:	d00e      	beq.n	de9a <z_impl_k_yield+0x3a>
    de7c:	f240 43d2 	movw	r3, #1234	; 0x4d2
    de80:	4a6a      	ldr	r2, [pc, #424]	; (e02c <z_impl_k_yield+0x1cc>)
    de82:	496b      	ldr	r1, [pc, #428]	; (e030 <z_impl_k_yield+0x1d0>)
    de84:	486b      	ldr	r0, [pc, #428]	; (e034 <z_impl_k_yield+0x1d4>)
    de86:	f002 f8ef 	bl	10068 <printk>
    de8a:	486b      	ldr	r0, [pc, #428]	; (e038 <z_impl_k_yield+0x1d8>)
    de8c:	f002 f8ec 	bl	10068 <printk>
    de90:	f240 41d2 	movw	r1, #1234	; 0x4d2
    de94:	4865      	ldr	r0, [pc, #404]	; (e02c <z_impl_k_yield+0x1cc>)
    de96:	f002 ff2f 	bl	10cf8 <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
    de9a:	4b68      	ldr	r3, [pc, #416]	; (e03c <z_impl_k_yield+0x1dc>)
    de9c:	689b      	ldr	r3, [r3, #8]
    de9e:	4618      	mov	r0, r3
    dea0:	f7fe fa04 	bl	c2ac <z_is_idle_thread_object>
    dea4:	4603      	mov	r3, r0
    dea6:	f083 0301 	eor.w	r3, r3, #1
    deaa:	b2db      	uxtb	r3, r3
    deac:	2b00      	cmp	r3, #0
    deae:	f000 80b6 	beq.w	e01e <z_impl_k_yield+0x1be>
		LOCKED(&sched_spinlock) {
    deb2:	2300      	movs	r3, #0
    deb4:	613b      	str	r3, [r7, #16]
    deb6:	4b62      	ldr	r3, [pc, #392]	; (e040 <z_impl_k_yield+0x1e0>)
    deb8:	633b      	str	r3, [r7, #48]	; 0x30
	__asm__ volatile(
    deba:	f04f 0320 	mov.w	r3, #32
    debe:	f3ef 8211 	mrs	r2, BASEPRI
    dec2:	f383 8811 	msr	BASEPRI, r3
    dec6:	f3bf 8f6f 	isb	sy
    deca:	62fa      	str	r2, [r7, #44]	; 0x2c
    decc:	62bb      	str	r3, [r7, #40]	; 0x28
	return key;
    dece:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	k.key = arch_irq_lock();
    ded0:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    ded2:	6b38      	ldr	r0, [r7, #48]	; 0x30
    ded4:	f000 fdc0 	bl	ea58 <z_spin_lock_valid>
    ded8:	4603      	mov	r3, r0
    deda:	f083 0301 	eor.w	r3, r3, #1
    dede:	b2db      	uxtb	r3, r3
    dee0:	2b00      	cmp	r3, #0
    dee2:	d00d      	beq.n	df00 <z_impl_k_yield+0xa0>
    dee4:	2378      	movs	r3, #120	; 0x78
    dee6:	4a57      	ldr	r2, [pc, #348]	; (e044 <z_impl_k_yield+0x1e4>)
    dee8:	4957      	ldr	r1, [pc, #348]	; (e048 <z_impl_k_yield+0x1e8>)
    deea:	4852      	ldr	r0, [pc, #328]	; (e034 <z_impl_k_yield+0x1d4>)
    deec:	f002 f8bc 	bl	10068 <printk>
    def0:	6b39      	ldr	r1, [r7, #48]	; 0x30
    def2:	4856      	ldr	r0, [pc, #344]	; (e04c <z_impl_k_yield+0x1ec>)
    def4:	f002 f8b8 	bl	10068 <printk>
    def8:	2178      	movs	r1, #120	; 0x78
    defa:	4852      	ldr	r0, [pc, #328]	; (e044 <z_impl_k_yield+0x1e4>)
    defc:	f002 fefc 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    df00:	6b38      	ldr	r0, [r7, #48]	; 0x30
    df02:	f000 fde1 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    df06:	687b      	ldr	r3, [r7, #4]
    df08:	60fb      	str	r3, [r7, #12]
    df0a:	e084      	b.n	e016 <z_impl_k_yield+0x1b6>
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
    df0c:	4b4b      	ldr	r3, [pc, #300]	; (e03c <z_impl_k_yield+0x1dc>)
    df0e:	689b      	ldr	r3, [r3, #8]
    df10:	4619      	mov	r1, r3
    df12:	484f      	ldr	r0, [pc, #316]	; (e050 <z_impl_k_yield+0x1f0>)
    df14:	f7ff ff5c 	bl	ddd0 <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
    df18:	4b48      	ldr	r3, [pc, #288]	; (e03c <z_impl_k_yield+0x1dc>)
    df1a:	689b      	ldr	r3, [r3, #8]
    df1c:	4a4c      	ldr	r2, [pc, #304]	; (e050 <z_impl_k_yield+0x1f0>)
    df1e:	61fa      	str	r2, [r7, #28]
    df20:	61bb      	str	r3, [r7, #24]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    df22:	69b8      	ldr	r0, [r7, #24]
    df24:	f7fe f9c2 	bl	c2ac <z_is_idle_thread_object>
    df28:	4603      	mov	r3, r0
    df2a:	2b00      	cmp	r3, #0
    df2c:	d00b      	beq.n	df46 <z_impl_k_yield+0xe6>
    df2e:	f240 33c7 	movw	r3, #967	; 0x3c7
    df32:	4a3e      	ldr	r2, [pc, #248]	; (e02c <z_impl_k_yield+0x1cc>)
    df34:	4947      	ldr	r1, [pc, #284]	; (e054 <z_impl_k_yield+0x1f4>)
    df36:	483f      	ldr	r0, [pc, #252]	; (e034 <z_impl_k_yield+0x1d4>)
    df38:	f002 f896 	bl	10068 <printk>
    df3c:	f240 31c7 	movw	r1, #967	; 0x3c7
    df40:	483a      	ldr	r0, [pc, #232]	; (e02c <z_impl_k_yield+0x1cc>)
    df42:	f002 fed9 	bl	10cf8 <assert_post_action>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    df46:	69f8      	ldr	r0, [r7, #28]
    df48:	f009 f957 	bl	171fa <sys_dlist_peek_head>
    df4c:	4603      	mov	r3, r0
    df4e:	2b00      	cmp	r3, #0
    df50:	d004      	beq.n	df5c <z_impl_k_yield+0xfc>
    df52:	69f8      	ldr	r0, [r7, #28]
    df54:	f009 f951 	bl	171fa <sys_dlist_peek_head>
    df58:	4603      	mov	r3, r0
    df5a:	e000      	b.n	df5e <z_impl_k_yield+0xfe>
    df5c:	2300      	movs	r3, #0
    df5e:	617b      	str	r3, [r7, #20]
    df60:	e023      	b.n	dfaa <z_impl_k_yield+0x14a>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
    df62:	6979      	ldr	r1, [r7, #20]
    df64:	69b8      	ldr	r0, [r7, #24]
    df66:	f009 fdeb 	bl	17b40 <z_is_t1_higher_prio_than_t2>
    df6a:	4603      	mov	r3, r0
    df6c:	2b00      	cmp	r3, #0
    df6e:	d006      	beq.n	df7e <z_impl_k_yield+0x11e>
			sys_dlist_insert(&t->base.qnode_dlist,
    df70:	697b      	ldr	r3, [r7, #20]
    df72:	69ba      	ldr	r2, [r7, #24]
    df74:	4611      	mov	r1, r2
    df76:	4618      	mov	r0, r3
    df78:	f009 f98f 	bl	1729a <sys_dlist_insert>
			return;
    df7c:	e01d      	b.n	dfba <z_impl_k_yield+0x15a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    df7e:	697b      	ldr	r3, [r7, #20]
    df80:	2b00      	cmp	r3, #0
    df82:	d010      	beq.n	dfa6 <z_impl_k_yield+0x146>
    df84:	697b      	ldr	r3, [r7, #20]
    df86:	4619      	mov	r1, r3
    df88:	69f8      	ldr	r0, [r7, #28]
    df8a:	f009 f95b 	bl	17244 <sys_dlist_peek_next>
    df8e:	4603      	mov	r3, r0
    df90:	2b00      	cmp	r3, #0
    df92:	d006      	beq.n	dfa2 <z_impl_k_yield+0x142>
    df94:	697b      	ldr	r3, [r7, #20]
    df96:	4619      	mov	r1, r3
    df98:	69f8      	ldr	r0, [r7, #28]
    df9a:	f009 f953 	bl	17244 <sys_dlist_peek_next>
    df9e:	4603      	mov	r3, r0
    dfa0:	e002      	b.n	dfa8 <z_impl_k_yield+0x148>
    dfa2:	2300      	movs	r3, #0
    dfa4:	e000      	b.n	dfa8 <z_impl_k_yield+0x148>
    dfa6:	2300      	movs	r3, #0
    dfa8:	617b      	str	r3, [r7, #20]
    dfaa:	697b      	ldr	r3, [r7, #20]
    dfac:	2b00      	cmp	r3, #0
    dfae:	d1d8      	bne.n	df62 <z_impl_k_yield+0x102>
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    dfb0:	69bb      	ldr	r3, [r7, #24]
    dfb2:	4619      	mov	r1, r3
    dfb4:	69f8      	ldr	r0, [r7, #28]
    dfb6:	f009 f958 	bl	1726a <sys_dlist_append>
			z_mark_thread_as_queued(_current);
    dfba:	4b20      	ldr	r3, [pc, #128]	; (e03c <z_impl_k_yield+0x1dc>)
    dfbc:	689b      	ldr	r3, [r3, #8]
    dfbe:	4618      	mov	r0, r3
    dfc0:	f009 fd3e 	bl	17a40 <z_mark_thread_as_queued>
			update_cache(1);
    dfc4:	2001      	movs	r0, #1
    dfc6:	f7fe fcc1 	bl	c94c <update_cache>
    dfca:	4b1d      	ldr	r3, [pc, #116]	; (e040 <z_impl_k_yield+0x1e0>)
    dfcc:	627b      	str	r3, [r7, #36]	; 0x24
    dfce:	68fb      	ldr	r3, [r7, #12]
    dfd0:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    dfd2:	6a78      	ldr	r0, [r7, #36]	; 0x24
    dfd4:	f000 fd5c 	bl	ea90 <z_spin_unlock_valid>
    dfd8:	4603      	mov	r3, r0
    dfda:	f083 0301 	eor.w	r3, r3, #1
    dfde:	b2db      	uxtb	r3, r3
    dfe0:	2b00      	cmp	r3, #0
    dfe2:	d00d      	beq.n	e000 <z_impl_k_yield+0x1a0>
    dfe4:	23a3      	movs	r3, #163	; 0xa3
    dfe6:	4a17      	ldr	r2, [pc, #92]	; (e044 <z_impl_k_yield+0x1e4>)
    dfe8:	491b      	ldr	r1, [pc, #108]	; (e058 <z_impl_k_yield+0x1f8>)
    dfea:	4812      	ldr	r0, [pc, #72]	; (e034 <z_impl_k_yield+0x1d4>)
    dfec:	f002 f83c 	bl	10068 <printk>
    dff0:	6a79      	ldr	r1, [r7, #36]	; 0x24
    dff2:	481a      	ldr	r0, [pc, #104]	; (e05c <z_impl_k_yield+0x1fc>)
    dff4:	f002 f838 	bl	10068 <printk>
    dff8:	21a3      	movs	r1, #163	; 0xa3
    dffa:	4812      	ldr	r0, [pc, #72]	; (e044 <z_impl_k_yield+0x1e4>)
    dffc:	f002 fe7c 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    e000:	68bb      	ldr	r3, [r7, #8]
    e002:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    e004:	6a3b      	ldr	r3, [r7, #32]
    e006:	f383 8811 	msr	BASEPRI, r3
    e00a:	f3bf 8f6f 	isb	sy
}
    e00e:	bf00      	nop
}
    e010:	bf00      	nop
		LOCKED(&sched_spinlock) {
    e012:	2301      	movs	r3, #1
    e014:	613b      	str	r3, [r7, #16]
    e016:	693b      	ldr	r3, [r7, #16]
    e018:	2b00      	cmp	r3, #0
    e01a:	f43f af77 	beq.w	df0c <z_impl_k_yield+0xac>
		}
	}
	z_swap_unlocked();
    e01e:	f009 fd60 	bl	17ae2 <z_swap_unlocked>
}
    e022:	bf00      	nop
    e024:	3738      	adds	r7, #56	; 0x38
    e026:	46bd      	mov	sp, r7
    e028:	bd80      	pop	{r7, pc}
    e02a:	bf00      	nop
    e02c:	0001c030 	.word	0x0001c030
    e030:	0001bf40 	.word	0x0001bf40
    e034:	0001bf54 	.word	0x0001bf54
    e038:	0001bf74 	.word	0x0001bf74
    e03c:	20000cd8 	.word	0x20000cd8
    e040:	20000d0c 	.word	0x20000d0c
    e044:	0001bfa8 	.word	0x0001bfa8
    e048:	0001bfd0 	.word	0x0001bfd0
    e04c:	0001bfe8 	.word	0x0001bfe8
    e050:	20000d04 	.word	0x20000d04
    e054:	0001c054 	.word	0x0001c054
    e058:	0001c000 	.word	0x0001c000
    e05c:	0001c018 	.word	0x0001c018

0000e060 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(int32_t ticks)
{
    e060:	b580      	push	{r7, lr}
    e062:	b092      	sub	sp, #72	; 0x48
    e064:	af02      	add	r7, sp, #8
    e066:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e068:	f3ef 8305 	mrs	r3, IPSR
    e06c:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
    e06e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    e070:	2b00      	cmp	r3, #0
    e072:	bf14      	ite	ne
    e074:	2301      	movne	r3, #1
    e076:	2300      	moveq	r3, #0
    e078:	b2db      	uxtb	r3, r3
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
    e07a:	2b00      	cmp	r3, #0
    e07c:	d00e      	beq.n	e09c <z_tick_sleep+0x3c>
    e07e:	f44f 639e 	mov.w	r3, #1264	; 0x4f0
    e082:	4a74      	ldr	r2, [pc, #464]	; (e254 <z_tick_sleep+0x1f4>)
    e084:	4974      	ldr	r1, [pc, #464]	; (e258 <z_tick_sleep+0x1f8>)
    e086:	4875      	ldr	r0, [pc, #468]	; (e25c <z_tick_sleep+0x1fc>)
    e088:	f001 ffee 	bl	10068 <printk>
    e08c:	4874      	ldr	r0, [pc, #464]	; (e260 <z_tick_sleep+0x200>)
    e08e:	f001 ffeb 	bl	10068 <printk>
    e092:	f44f 619e 	mov.w	r1, #1264	; 0x4f0
    e096:	486f      	ldr	r0, [pc, #444]	; (e254 <z_tick_sleep+0x1f4>)
    e098:	f002 fe2e 	bl	10cf8 <assert_post_action>

	LOG_DBG("thread %p for %d ticks", _current, ticks);
    e09c:	2303      	movs	r3, #3
    e09e:	2b03      	cmp	r3, #3
    e0a0:	d93b      	bls.n	e11a <z_tick_sleep+0xba>
    e0a2:	f009 f927 	bl	172f4 <_is_user_context>
    e0a6:	4603      	mov	r3, r0
    e0a8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    e0ac:	7a3b      	ldrb	r3, [r7, #8]
    e0ae:	2204      	movs	r2, #4
    e0b0:	f362 0302 	bfi	r3, r2, #0, #3
    e0b4:	723b      	strb	r3, [r7, #8]
    e0b6:	7a3b      	ldrb	r3, [r7, #8]
    e0b8:	f36f 03c5 	bfc	r3, #3, #3
    e0bc:	723b      	strb	r3, [r7, #8]
    e0be:	2303      	movs	r3, #3
    e0c0:	2b00      	cmp	r3, #0
    e0c2:	d009      	beq.n	e0d8 <z_tick_sleep+0x78>
    e0c4:	4b67      	ldr	r3, [pc, #412]	; (e264 <z_tick_sleep+0x204>)
    e0c6:	681b      	ldr	r3, [r3, #0]
    e0c8:	4618      	mov	r0, r3
    e0ca:	f7fe fa23 	bl	c514 <log_const_source_id>
    e0ce:	4603      	mov	r3, r0
    e0d0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    e0d4:	b29a      	uxth	r2, r3
    e0d6:	e000      	b.n	e0da <z_tick_sleep+0x7a>
    e0d8:	2200      	movs	r2, #0
    e0da:	893b      	ldrh	r3, [r7, #8]
    e0dc:	f362 138f 	bfi	r3, r2, #6, #10
    e0e0:	813b      	strh	r3, [r7, #8]
    e0e2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
    e0e6:	2b00      	cmp	r3, #0
    e0e8:	d00a      	beq.n	e100 <z_tick_sleep+0xa0>
    e0ea:	4b5f      	ldr	r3, [pc, #380]	; (e268 <z_tick_sleep+0x208>)
    e0ec:	689a      	ldr	r2, [r3, #8]
    e0ee:	687b      	ldr	r3, [r7, #4]
    e0f0:	9300      	str	r3, [sp, #0]
    e0f2:	4613      	mov	r3, r2
    e0f4:	4a5d      	ldr	r2, [pc, #372]	; (e26c <z_tick_sleep+0x20c>)
    e0f6:	495e      	ldr	r1, [pc, #376]	; (e270 <z_tick_sleep+0x210>)
    e0f8:	8938      	ldrh	r0, [r7, #8]
    e0fa:	f7f4 fbf9 	bl	28f0 <log_from_user>
    e0fe:	e00c      	b.n	e11a <z_tick_sleep+0xba>
    e100:	495a      	ldr	r1, [pc, #360]	; (e26c <z_tick_sleep+0x20c>)
    e102:	4b59      	ldr	r3, [pc, #356]	; (e268 <z_tick_sleep+0x208>)
    e104:	689b      	ldr	r3, [r3, #8]
    e106:	4618      	mov	r0, r3
    e108:	687a      	ldr	r2, [r7, #4]
    e10a:	893b      	ldrh	r3, [r7, #8]
    e10c:	f8ad 3000 	strh.w	r3, [sp]
    e110:	4613      	mov	r3, r2
    e112:	4602      	mov	r2, r0
    e114:	4856      	ldr	r0, [pc, #344]	; (e270 <z_tick_sleep+0x210>)
    e116:	f003 fac9 	bl	116ac <log_3>

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    e11a:	687b      	ldr	r3, [r7, #4]
    e11c:	2b00      	cmp	r3, #0
    e11e:	d103      	bne.n	e128 <z_tick_sleep+0xc8>
		k_yield();
    e120:	f009 fb3a 	bl	17798 <k_yield>
		return 0;
    e124:	2300      	movs	r3, #0
    e126:	e090      	b.n	e24a <z_tick_sleep+0x1ea>
	}

	k_timeout_t timeout;

#ifndef CONFIG_LEGACY_TIMEOUT_API
	timeout = Z_TIMEOUT_TICKS(ticks);
    e128:	687b      	ldr	r3, [r7, #4]
    e12a:	461a      	mov	r2, r3
    e12c:	ea4f 73e2 	mov.w	r3, r2, asr #31
    e130:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
    e134:	f00a f8bd 	bl	182b2 <z_tick_get_32>
    e138:	4602      	mov	r2, r0
    e13a:	687b      	ldr	r3, [r7, #4]
    e13c:	4413      	add	r3, r2
    e13e:	63bb      	str	r3, [r7, #56]	; 0x38
    e140:	4b4c      	ldr	r3, [pc, #304]	; (e274 <z_tick_sleep+0x214>)
    e142:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    e144:	f04f 0320 	mov.w	r3, #32
    e148:	f3ef 8211 	mrs	r2, BASEPRI
    e14c:	f383 8811 	msr	BASEPRI, r3
    e150:	f3bf 8f6f 	isb	sy
    e154:	627a      	str	r2, [r7, #36]	; 0x24
    e156:	623b      	str	r3, [r7, #32]
	return key;
    e158:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
    e15a:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    e15c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e15e:	f000 fc7b 	bl	ea58 <z_spin_lock_valid>
    e162:	4603      	mov	r3, r0
    e164:	f083 0301 	eor.w	r3, r3, #1
    e168:	b2db      	uxtb	r3, r3
    e16a:	2b00      	cmp	r3, #0
    e16c:	d00d      	beq.n	e18a <z_tick_sleep+0x12a>
    e16e:	2378      	movs	r3, #120	; 0x78
    e170:	4a41      	ldr	r2, [pc, #260]	; (e278 <z_tick_sleep+0x218>)
    e172:	4942      	ldr	r1, [pc, #264]	; (e27c <z_tick_sleep+0x21c>)
    e174:	4839      	ldr	r0, [pc, #228]	; (e25c <z_tick_sleep+0x1fc>)
    e176:	f001 ff77 	bl	10068 <printk>
    e17a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    e17c:	4840      	ldr	r0, [pc, #256]	; (e280 <z_tick_sleep+0x220>)
    e17e:	f001 ff73 	bl	10068 <printk>
    e182:	2178      	movs	r1, #120	; 0x78
    e184:	483c      	ldr	r0, [pc, #240]	; (e278 <z_tick_sleep+0x218>)
    e186:	f002 fdb7 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    e18a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e18c:	f000 fc9c 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    e190:	693b      	ldr	r3, [r7, #16]
    e192:	617b      	str	r3, [r7, #20]

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    e194:	4b34      	ldr	r3, [pc, #208]	; (e268 <z_tick_sleep+0x208>)
    e196:	689b      	ldr	r3, [r3, #8]
    e198:	4a3a      	ldr	r2, [pc, #232]	; (e284 <z_tick_sleep+0x224>)
    e19a:	6013      	str	r3, [r2, #0]
#endif
	unready_thread(_current);
    e19c:	4b32      	ldr	r3, [pc, #200]	; (e268 <z_tick_sleep+0x208>)
    e19e:	689b      	ldr	r3, [r3, #8]
    e1a0:	4618      	mov	r0, r3
    e1a2:	f7ff f89f 	bl	d2e4 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    e1a6:	4b30      	ldr	r3, [pc, #192]	; (e268 <z_tick_sleep+0x208>)
    e1a8:	6899      	ldr	r1, [r3, #8]
    e1aa:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    e1ae:	4608      	mov	r0, r1
    e1b0:	f7fe f868 	bl	c284 <z_add_thread_timeout>
	z_mark_thread_as_suspended(_current);
    e1b4:	4b2c      	ldr	r3, [pc, #176]	; (e268 <z_tick_sleep+0x208>)
    e1b6:	689b      	ldr	r3, [r3, #8]
    e1b8:	4618      	mov	r0, r3
    e1ba:	f009 fbcb 	bl	17954 <z_mark_thread_as_suspended>
    e1be:	4b2d      	ldr	r3, [pc, #180]	; (e274 <z_tick_sleep+0x214>)
    e1c0:	633b      	str	r3, [r7, #48]	; 0x30
    e1c2:	697b      	ldr	r3, [r7, #20]
    e1c4:	60fb      	str	r3, [r7, #12]
    e1c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    e1c8:	62fb      	str	r3, [r7, #44]	; 0x2c
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    e1ca:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    e1cc:	f000 fc60 	bl	ea90 <z_spin_unlock_valid>
    e1d0:	4603      	mov	r3, r0
    e1d2:	f083 0301 	eor.w	r3, r3, #1
    e1d6:	b2db      	uxtb	r3, r3
    e1d8:	2b00      	cmp	r3, #0
    e1da:	d00d      	beq.n	e1f8 <z_tick_sleep+0x198>
    e1dc:	23ba      	movs	r3, #186	; 0xba
    e1de:	4a26      	ldr	r2, [pc, #152]	; (e278 <z_tick_sleep+0x218>)
    e1e0:	4929      	ldr	r1, [pc, #164]	; (e288 <z_tick_sleep+0x228>)
    e1e2:	481e      	ldr	r0, [pc, #120]	; (e25c <z_tick_sleep+0x1fc>)
    e1e4:	f001 ff40 	bl	10068 <printk>
    e1e8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    e1ea:	4828      	ldr	r0, [pc, #160]	; (e28c <z_tick_sleep+0x22c>)
    e1ec:	f001 ff3c 	bl	10068 <printk>
    e1f0:	21ba      	movs	r1, #186	; 0xba
    e1f2:	4821      	ldr	r0, [pc, #132]	; (e278 <z_tick_sleep+0x218>)
    e1f4:	f002 fd80 	bl	10cf8 <assert_post_action>
}
    e1f8:	bf00      	nop
    e1fa:	68fb      	ldr	r3, [r7, #12]
    e1fc:	4618      	mov	r0, r3
    e1fe:	f009 fc63 	bl	17ac8 <z_swap_irqlock>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
    e202:	4b19      	ldr	r3, [pc, #100]	; (e268 <z_tick_sleep+0x208>)
    e204:	689b      	ldr	r3, [r3, #8]
    e206:	2110      	movs	r1, #16
    e208:	4618      	mov	r0, r3
    e20a:	f009 fb82 	bl	17912 <z_is_thread_state_set>
    e20e:	4603      	mov	r3, r0
    e210:	2b00      	cmp	r3, #0
    e212:	d00e      	beq.n	e232 <z_tick_sleep+0x1d2>
    e214:	f44f 63a2 	mov.w	r3, #1296	; 0x510
    e218:	4a0e      	ldr	r2, [pc, #56]	; (e254 <z_tick_sleep+0x1f4>)
    e21a:	491d      	ldr	r1, [pc, #116]	; (e290 <z_tick_sleep+0x230>)
    e21c:	480f      	ldr	r0, [pc, #60]	; (e25c <z_tick_sleep+0x1fc>)
    e21e:	f001 ff23 	bl	10068 <printk>
    e222:	480f      	ldr	r0, [pc, #60]	; (e260 <z_tick_sleep+0x200>)
    e224:	f001 ff20 	bl	10068 <printk>
    e228:	f44f 61a2 	mov.w	r1, #1296	; 0x510
    e22c:	4809      	ldr	r0, [pc, #36]	; (e254 <z_tick_sleep+0x1f4>)
    e22e:	f002 fd63 	bl	10cf8 <assert_post_action>

	ticks = expected_wakeup_time - z_tick_get_32();
    e232:	f00a f83e 	bl	182b2 <z_tick_get_32>
    e236:	4602      	mov	r2, r0
    e238:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    e23a:	1a9b      	subs	r3, r3, r2
    e23c:	607b      	str	r3, [r7, #4]
	if (ticks > 0) {
    e23e:	687b      	ldr	r3, [r7, #4]
    e240:	2b00      	cmp	r3, #0
    e242:	dd01      	ble.n	e248 <z_tick_sleep+0x1e8>
		return ticks;
    e244:	687b      	ldr	r3, [r7, #4]
    e246:	e000      	b.n	e24a <z_tick_sleep+0x1ea>
	}
#endif

	return 0;
    e248:	2300      	movs	r3, #0
}
    e24a:	4618      	mov	r0, r3
    e24c:	3740      	adds	r7, #64	; 0x40
    e24e:	46bd      	mov	sp, r7
    e250:	bd80      	pop	{r7, pc}
    e252:	bf00      	nop
    e254:	0001c030 	.word	0x0001c030
    e258:	0001bf40 	.word	0x0001bf40
    e25c:	0001bf54 	.word	0x0001bf54
    e260:	0001bf74 	.word	0x0001bf74
    e264:	20000174 	.word	0x20000174
    e268:	20000cd8 	.word	0x20000cd8
    e26c:	0001ce74 	.word	0x0001ce74
    e270:	0001c2f0 	.word	0x0001c2f0
    e274:	20000d0c 	.word	0x20000d0c
    e278:	0001bfa8 	.word	0x0001bfa8
    e27c:	0001bfd0 	.word	0x0001bfd0
    e280:	0001bfe8 	.word	0x0001bfe8
    e284:	20000d18 	.word	0x20000d18
    e288:	0001c000 	.word	0x0001c000
    e28c:	0001c018 	.word	0x0001c018
    e290:	0001c30c 	.word	0x0001c30c

0000e294 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    e294:	b580      	push	{r7, lr}
    e296:	b086      	sub	sp, #24
    e298:	af00      	add	r7, sp, #0
    e29a:	e9c7 0100 	strd	r0, r1, [r7]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e29e:	f3ef 8305 	mrs	r3, IPSR
    e2a2:	60fb      	str	r3, [r7, #12]
  return(result);
    e2a4:	68fb      	ldr	r3, [r7, #12]
    e2a6:	2b00      	cmp	r3, #0
    e2a8:	bf14      	ite	ne
    e2aa:	2301      	movne	r3, #1
    e2ac:	2300      	moveq	r3, #0
    e2ae:	b2db      	uxtb	r3, r3
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
    e2b0:	2b00      	cmp	r3, #0
    e2b2:	d00e      	beq.n	e2d2 <z_impl_k_sleep+0x3e>
    e2b4:	f240 531f 	movw	r3, #1311	; 0x51f
    e2b8:	4a1c      	ldr	r2, [pc, #112]	; (e32c <z_impl_k_sleep+0x98>)
    e2ba:	491d      	ldr	r1, [pc, #116]	; (e330 <z_impl_k_sleep+0x9c>)
    e2bc:	481d      	ldr	r0, [pc, #116]	; (e334 <z_impl_k_sleep+0xa0>)
    e2be:	f001 fed3 	bl	10068 <printk>
    e2c2:	481d      	ldr	r0, [pc, #116]	; (e338 <z_impl_k_sleep+0xa4>)
    e2c4:	f001 fed0 	bl	10068 <printk>
    e2c8:	f240 511f 	movw	r1, #1311	; 0x51f
    e2cc:	4817      	ldr	r0, [pc, #92]	; (e32c <z_impl_k_sleep+0x98>)
    e2ce:	f002 fd13 	bl	10cf8 <assert_post_action>
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    e2d2:	e9d7 2300 	ldrd	r2, r3, [r7]
    e2d6:	f04f 30ff 	mov.w	r0, #4294967295
    e2da:	f04f 31ff 	mov.w	r1, #4294967295
    e2de:	428b      	cmp	r3, r1
    e2e0:	bf08      	it	eq
    e2e2:	4282      	cmpeq	r2, r0
    e2e4:	d107      	bne.n	e2f6 <z_impl_k_sleep+0x62>
		k_thread_suspend(_current);
    e2e6:	4b15      	ldr	r3, [pc, #84]	; (e33c <z_impl_k_sleep+0xa8>)
    e2e8:	689b      	ldr	r3, [r3, #8]
    e2ea:	4618      	mov	r0, r3
    e2ec:	f009 fa5a 	bl	177a4 <k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    e2f0:	f04f 33ff 	mov.w	r3, #4294967295
    e2f4:	e016      	b.n	e324 <z_impl_k_sleep+0x90>
	}

#ifdef CONFIG_LEGACY_TIMEOUT_API
	ticks = k_ms_to_ticks_ceil32(timeout);
#else
	ticks = timeout.ticks;
    e2f6:	e9d7 2300 	ldrd	r2, r3, [r7]
    e2fa:	e9c7 2304 	strd	r2, r3, [r7, #16]
#endif

	ticks = z_tick_sleep(ticks);
    e2fe:	693b      	ldr	r3, [r7, #16]
    e300:	4618      	mov	r0, r3
    e302:	f7ff fead 	bl	e060 <z_tick_sleep>
    e306:	4603      	mov	r3, r0
    e308:	461a      	mov	r2, r3
    e30a:	ea4f 73e2 	mov.w	r3, r2, asr #31
    e30e:	e9c7 2304 	strd	r2, r3, [r7, #16]
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
    e312:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    e316:	4610      	mov	r0, r2
    e318:	4619      	mov	r1, r3
    e31a:	f009 f918 	bl	1754e <k_ticks_to_ms_floor64>
    e31e:	4602      	mov	r2, r0
    e320:	460b      	mov	r3, r1
    e322:	4613      	mov	r3, r2
}
    e324:	4618      	mov	r0, r3
    e326:	3718      	adds	r7, #24
    e328:	46bd      	mov	sp, r7
    e32a:	bd80      	pop	{r7, pc}
    e32c:	0001c030 	.word	0x0001c030
    e330:	0001bf40 	.word	0x0001bf40
    e334:	0001bf54 	.word	0x0001bf54
    e338:	0001bf74 	.word	0x0001bf74
    e33c:	20000cd8 	.word	0x20000cd8

0000e340 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    e340:	b480      	push	{r7}
    e342:	b083      	sub	sp, #12
    e344:	af00      	add	r7, sp, #0
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    e346:	4b04      	ldr	r3, [pc, #16]	; (e358 <z_impl_k_current_get+0x18>)
    e348:	689b      	ldr	r3, [r3, #8]
    e34a:	607b      	str	r3, [r7, #4]

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    e34c:	687b      	ldr	r3, [r7, #4]
}
    e34e:	4618      	mov	r0, r3
    e350:	370c      	adds	r7, #12
    e352:	46bd      	mov	sp, r7
    e354:	bc80      	pop	{r7}
    e356:	4770      	bx	lr
    e358:	20000cd8 	.word	0x20000cd8

0000e35c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    e35c:	b580      	push	{r7, lr}
    e35e:	b08a      	sub	sp, #40	; 0x28
    e360:	af00      	add	r7, sp, #0
    e362:	6078      	str	r0, [r7, #4]
    e364:	4b2b      	ldr	r3, [pc, #172]	; (e414 <z_impl_k_sem_give+0xb8>)
    e366:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    e368:	f04f 0320 	mov.w	r3, #32
    e36c:	f3ef 8211 	mrs	r2, BASEPRI
    e370:	f383 8811 	msr	BASEPRI, r3
    e374:	f3bf 8f6f 	isb	sy
    e378:	61fa      	str	r2, [r7, #28]
    e37a:	61bb      	str	r3, [r7, #24]
	return key;
    e37c:	69fb      	ldr	r3, [r7, #28]
	k.key = arch_irq_lock();
    e37e:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    e380:	6a38      	ldr	r0, [r7, #32]
    e382:	f000 fb69 	bl	ea58 <z_spin_lock_valid>
    e386:	4603      	mov	r3, r0
    e388:	f083 0301 	eor.w	r3, r3, #1
    e38c:	b2db      	uxtb	r3, r3
    e38e:	2b00      	cmp	r3, #0
    e390:	d00d      	beq.n	e3ae <z_impl_k_sem_give+0x52>
    e392:	2378      	movs	r3, #120	; 0x78
    e394:	4a20      	ldr	r2, [pc, #128]	; (e418 <z_impl_k_sem_give+0xbc>)
    e396:	4921      	ldr	r1, [pc, #132]	; (e41c <z_impl_k_sem_give+0xc0>)
    e398:	4821      	ldr	r0, [pc, #132]	; (e420 <z_impl_k_sem_give+0xc4>)
    e39a:	f001 fe65 	bl	10068 <printk>
    e39e:	6a39      	ldr	r1, [r7, #32]
    e3a0:	4820      	ldr	r0, [pc, #128]	; (e424 <z_impl_k_sem_give+0xc8>)
    e3a2:	f001 fe61 	bl	10068 <printk>
    e3a6:	2178      	movs	r1, #120	; 0x78
    e3a8:	481b      	ldr	r0, [pc, #108]	; (e418 <z_impl_k_sem_give+0xbc>)
    e3aa:	f002 fca5 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    e3ae:	6a38      	ldr	r0, [r7, #32]
    e3b0:	f000 fb8a 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    e3b4:	68bb      	ldr	r3, [r7, #8]
    e3b6:	60fb      	str	r3, [r7, #12]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
    e3b8:	687b      	ldr	r3, [r7, #4]
    e3ba:	4618      	mov	r0, r3
    e3bc:	f009 fc0d 	bl	17bda <z_unpend_first_thread>
    e3c0:	6278      	str	r0, [r7, #36]	; 0x24

	if (thread != NULL) {
    e3c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e3c4:	2b00      	cmp	r3, #0
    e3c6:	d00c      	beq.n	e3e2 <z_impl_k_sem_give+0x86>
    e3c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e3ca:	617b      	str	r3, [r7, #20]
    e3cc:	2300      	movs	r3, #0
    e3ce:	613b      	str	r3, [r7, #16]
	thread->arch.swap_return_value = value;
    e3d0:	697b      	ldr	r3, [r7, #20]
    e3d2:	693a      	ldr	r2, [r7, #16]
    e3d4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    e3d8:	bf00      	nop
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    e3da:	6a78      	ldr	r0, [r7, #36]	; 0x24
    e3dc:	f7fe fbb4 	bl	cb48 <z_ready_thread>
    e3e0:	e010      	b.n	e404 <z_impl_k_sem_give+0xa8>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    e3e2:	687b      	ldr	r3, [r7, #4]
    e3e4:	689b      	ldr	r3, [r3, #8]
    e3e6:	687a      	ldr	r2, [r7, #4]
    e3e8:	6891      	ldr	r1, [r2, #8]
    e3ea:	687a      	ldr	r2, [r7, #4]
    e3ec:	68d2      	ldr	r2, [r2, #12]
    e3ee:	4291      	cmp	r1, r2
    e3f0:	d001      	beq.n	e3f6 <z_impl_k_sem_give+0x9a>
    e3f2:	2201      	movs	r2, #1
    e3f4:	e000      	b.n	e3f8 <z_impl_k_sem_give+0x9c>
    e3f6:	2200      	movs	r2, #0
    e3f8:	441a      	add	r2, r3
    e3fa:	687b      	ldr	r3, [r7, #4]
    e3fc:	609a      	str	r2, [r3, #8]
		handle_poll_events(sem);
    e3fe:	6878      	ldr	r0, [r7, #4]
    e400:	f009 fc50 	bl	17ca4 <handle_poll_events>
	}

	z_reschedule(&lock, key);
    e404:	68f9      	ldr	r1, [r7, #12]
    e406:	4803      	ldr	r0, [pc, #12]	; (e414 <z_impl_k_sem_give+0xb8>)
    e408:	f7ff fb18 	bl	da3c <z_reschedule>
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
    e40c:	bf00      	nop
    e40e:	3728      	adds	r7, #40	; 0x28
    e410:	46bd      	mov	sp, r7
    e412:	bd80      	pop	{r7, pc}
    e414:	20000d1c 	.word	0x20000d1c
    e418:	0001c39c 	.word	0x0001c39c
    e41c:	0001c3c4 	.word	0x0001c3c4
    e420:	0001c3dc 	.word	0x0001c3dc
    e424:	0001c3fc 	.word	0x0001c3fc

0000e428 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    e428:	b580      	push	{r7, lr}
    e42a:	b094      	sub	sp, #80	; 0x50
    e42c:	af02      	add	r7, sp, #8
    e42e:	60f8      	str	r0, [r7, #12]
    e430:	e9c7 2300 	strd	r2, r3, [r7]
	int ret = 0;
    e434:	2300      	movs	r3, #0
    e436:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e438:	f3ef 8305 	mrs	r3, IPSR
    e43c:	643b      	str	r3, [r7, #64]	; 0x40
  return(result);
    e43e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    e440:	2b00      	cmp	r3, #0
    e442:	bf14      	ite	ne
    e444:	2301      	movne	r3, #1
    e446:	2300      	moveq	r3, #0
    e448:	b2db      	uxtb	r3, r3

	__ASSERT(((arch_is_in_isr() == false) ||
    e44a:	2b00      	cmp	r3, #0
    e44c:	d016      	beq.n	e47c <z_impl_k_sem_take+0x54>
    e44e:	e9d7 2300 	ldrd	r2, r3, [r7]
    e452:	f04f 0000 	mov.w	r0, #0
    e456:	f04f 0100 	mov.w	r1, #0
    e45a:	428b      	cmp	r3, r1
    e45c:	bf08      	it	eq
    e45e:	4282      	cmpeq	r2, r0
    e460:	d00c      	beq.n	e47c <z_impl_k_sem_take+0x54>
    e462:	238c      	movs	r3, #140	; 0x8c
    e464:	4a56      	ldr	r2, [pc, #344]	; (e5c0 <z_impl_k_sem_take+0x198>)
    e466:	4957      	ldr	r1, [pc, #348]	; (e5c4 <z_impl_k_sem_take+0x19c>)
    e468:	4857      	ldr	r0, [pc, #348]	; (e5c8 <z_impl_k_sem_take+0x1a0>)
    e46a:	f001 fdfd 	bl	10068 <printk>
    e46e:	4857      	ldr	r0, [pc, #348]	; (e5cc <z_impl_k_sem_take+0x1a4>)
    e470:	f001 fdfa 	bl	10068 <printk>
    e474:	218c      	movs	r1, #140	; 0x8c
    e476:	4852      	ldr	r0, [pc, #328]	; (e5c0 <z_impl_k_sem_take+0x198>)
    e478:	f002 fc3e 	bl	10cf8 <assert_post_action>
    e47c:	4b54      	ldr	r3, [pc, #336]	; (e5d0 <z_impl_k_sem_take+0x1a8>)
    e47e:	63fb      	str	r3, [r7, #60]	; 0x3c
	__asm__ volatile(
    e480:	f04f 0320 	mov.w	r3, #32
    e484:	f3ef 8211 	mrs	r2, BASEPRI
    e488:	f383 8811 	msr	BASEPRI, r3
    e48c:	f3bf 8f6f 	isb	sy
    e490:	63ba      	str	r2, [r7, #56]	; 0x38
    e492:	637b      	str	r3, [r7, #52]	; 0x34
	return key;
    e494:	6bbb      	ldr	r3, [r7, #56]	; 0x38
	k.key = arch_irq_lock();
    e496:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    e498:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    e49a:	f000 fadd 	bl	ea58 <z_spin_lock_valid>
    e49e:	4603      	mov	r3, r0
    e4a0:	f083 0301 	eor.w	r3, r3, #1
    e4a4:	b2db      	uxtb	r3, r3
    e4a6:	2b00      	cmp	r3, #0
    e4a8:	d00d      	beq.n	e4c6 <z_impl_k_sem_take+0x9e>
    e4aa:	2378      	movs	r3, #120	; 0x78
    e4ac:	4a49      	ldr	r2, [pc, #292]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e4ae:	494a      	ldr	r1, [pc, #296]	; (e5d8 <z_impl_k_sem_take+0x1b0>)
    e4b0:	4845      	ldr	r0, [pc, #276]	; (e5c8 <z_impl_k_sem_take+0x1a0>)
    e4b2:	f001 fdd9 	bl	10068 <printk>
    e4b6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    e4b8:	4848      	ldr	r0, [pc, #288]	; (e5dc <z_impl_k_sem_take+0x1b4>)
    e4ba:	f001 fdd5 	bl	10068 <printk>
    e4be:	2178      	movs	r1, #120	; 0x78
    e4c0:	4844      	ldr	r0, [pc, #272]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e4c2:	f002 fc19 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    e4c6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    e4c8:	f000 fafe 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    e4cc:	69bb      	ldr	r3, [r7, #24]
    e4ce:	623b      	str	r3, [r7, #32]
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
    e4d0:	68fb      	ldr	r3, [r7, #12]
    e4d2:	689b      	ldr	r3, [r3, #8]
    e4d4:	2b00      	cmp	r3, #0
    e4d6:	bf14      	ite	ne
    e4d8:	2301      	movne	r3, #1
    e4da:	2300      	moveq	r3, #0
    e4dc:	b2db      	uxtb	r3, r3
    e4de:	2b00      	cmp	r3, #0
    e4e0:	d02b      	beq.n	e53a <z_impl_k_sem_take+0x112>
		sem->count--;
    e4e2:	68fb      	ldr	r3, [r7, #12]
    e4e4:	689b      	ldr	r3, [r3, #8]
    e4e6:	1e5a      	subs	r2, r3, #1
    e4e8:	68fb      	ldr	r3, [r7, #12]
    e4ea:	609a      	str	r2, [r3, #8]
    e4ec:	4b38      	ldr	r3, [pc, #224]	; (e5d0 <z_impl_k_sem_take+0x1a8>)
    e4ee:	633b      	str	r3, [r7, #48]	; 0x30
    e4f0:	6a3b      	ldr	r3, [r7, #32]
    e4f2:	61fb      	str	r3, [r7, #28]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    e4f4:	6b38      	ldr	r0, [r7, #48]	; 0x30
    e4f6:	f000 facb 	bl	ea90 <z_spin_unlock_valid>
    e4fa:	4603      	mov	r3, r0
    e4fc:	f083 0301 	eor.w	r3, r3, #1
    e500:	b2db      	uxtb	r3, r3
    e502:	2b00      	cmp	r3, #0
    e504:	d00d      	beq.n	e522 <z_impl_k_sem_take+0xfa>
    e506:	23a3      	movs	r3, #163	; 0xa3
    e508:	4a32      	ldr	r2, [pc, #200]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e50a:	4935      	ldr	r1, [pc, #212]	; (e5e0 <z_impl_k_sem_take+0x1b8>)
    e50c:	482e      	ldr	r0, [pc, #184]	; (e5c8 <z_impl_k_sem_take+0x1a0>)
    e50e:	f001 fdab 	bl	10068 <printk>
    e512:	6b39      	ldr	r1, [r7, #48]	; 0x30
    e514:	4833      	ldr	r0, [pc, #204]	; (e5e4 <z_impl_k_sem_take+0x1bc>)
    e516:	f001 fda7 	bl	10068 <printk>
    e51a:	21a3      	movs	r1, #163	; 0xa3
    e51c:	482d      	ldr	r0, [pc, #180]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e51e:	f002 fbeb 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    e522:	69fb      	ldr	r3, [r7, #28]
    e524:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    e526:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e528:	f383 8811 	msr	BASEPRI, r3
    e52c:	f3bf 8f6f 	isb	sy
}
    e530:	bf00      	nop
}
    e532:	bf00      	nop
		k_spin_unlock(&lock, key);
		ret = 0;
    e534:	2300      	movs	r3, #0
    e536:	647b      	str	r3, [r7, #68]	; 0x44
		goto out;
    e538:	e03c      	b.n	e5b4 <z_impl_k_sem_take+0x18c>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    e53a:	e9d7 2300 	ldrd	r2, r3, [r7]
    e53e:	f04f 0000 	mov.w	r0, #0
    e542:	f04f 0100 	mov.w	r1, #0
    e546:	428b      	cmp	r3, r1
    e548:	bf08      	it	eq
    e54a:	4282      	cmpeq	r2, r0
    e54c:	d127      	bne.n	e59e <z_impl_k_sem_take+0x176>
    e54e:	4b20      	ldr	r3, [pc, #128]	; (e5d0 <z_impl_k_sem_take+0x1a8>)
    e550:	62bb      	str	r3, [r7, #40]	; 0x28
    e552:	6a3b      	ldr	r3, [r7, #32]
    e554:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    e556:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e558:	f000 fa9a 	bl	ea90 <z_spin_unlock_valid>
    e55c:	4603      	mov	r3, r0
    e55e:	f083 0301 	eor.w	r3, r3, #1
    e562:	b2db      	uxtb	r3, r3
    e564:	2b00      	cmp	r3, #0
    e566:	d00d      	beq.n	e584 <z_impl_k_sem_take+0x15c>
    e568:	23a3      	movs	r3, #163	; 0xa3
    e56a:	4a1a      	ldr	r2, [pc, #104]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e56c:	491c      	ldr	r1, [pc, #112]	; (e5e0 <z_impl_k_sem_take+0x1b8>)
    e56e:	4816      	ldr	r0, [pc, #88]	; (e5c8 <z_impl_k_sem_take+0x1a0>)
    e570:	f001 fd7a 	bl	10068 <printk>
    e574:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    e576:	481b      	ldr	r0, [pc, #108]	; (e5e4 <z_impl_k_sem_take+0x1bc>)
    e578:	f001 fd76 	bl	10068 <printk>
    e57c:	21a3      	movs	r1, #163	; 0xa3
    e57e:	4815      	ldr	r0, [pc, #84]	; (e5d4 <z_impl_k_sem_take+0x1ac>)
    e580:	f002 fbba 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    e584:	697b      	ldr	r3, [r7, #20]
    e586:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    e588:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e58a:	f383 8811 	msr	BASEPRI, r3
    e58e:	f3bf 8f6f 	isb	sy
}
    e592:	bf00      	nop
}
    e594:	bf00      	nop
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
    e596:	f06f 030f 	mvn.w	r3, #15
    e59a:	647b      	str	r3, [r7, #68]	; 0x44
    e59c:	e00a      	b.n	e5b4 <z_impl_k_sem_take+0x18c>
		goto out;
	}

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    e59e:	68f9      	ldr	r1, [r7, #12]
    e5a0:	e9d7 2300 	ldrd	r2, r3, [r7]
    e5a4:	e9cd 2300 	strd	r2, r3, [sp]
    e5a8:	460a      	mov	r2, r1
    e5aa:	6a39      	ldr	r1, [r7, #32]
    e5ac:	4808      	ldr	r0, [pc, #32]	; (e5d0 <z_impl_k_sem_take+0x1a8>)
    e5ae:	f7ff f907 	bl	d7c0 <z_pend_curr>
    e5b2:	6478      	str	r0, [r7, #68]	; 0x44

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
    e5b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
    e5b6:	4618      	mov	r0, r3
    e5b8:	3748      	adds	r7, #72	; 0x48
    e5ba:	46bd      	mov	sp, r7
    e5bc:	bd80      	pop	{r7, pc}
    e5be:	bf00      	nop
    e5c0:	0001c414 	.word	0x0001c414
    e5c4:	0001c434 	.word	0x0001c434
    e5c8:	0001c3dc 	.word	0x0001c3dc
    e5cc:	0001c484 	.word	0x0001c484
    e5d0:	20000d1c 	.word	0x20000d1c
    e5d4:	0001c39c 	.word	0x0001c39c
    e5d8:	0001c3c4 	.word	0x0001c3c4
    e5dc:	0001c3fc 	.word	0x0001c3fc
    e5e0:	0001c488 	.word	0x0001c488
    e5e4:	0001c4a0 	.word	0x0001c4a0

0000e5e8 <z_add_thread_timeout>:
{
    e5e8:	b580      	push	{r7, lr}
    e5ea:	b084      	sub	sp, #16
    e5ec:	af00      	add	r7, sp, #0
    e5ee:	60f8      	str	r0, [r7, #12]
    e5f0:	e9c7 2300 	strd	r2, r3, [r7]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    e5f4:	68fb      	ldr	r3, [r7, #12]
    e5f6:	f103 0018 	add.w	r0, r3, #24
    e5fa:	e9d7 2300 	ldrd	r2, r3, [r7]
    e5fe:	4903      	ldr	r1, [pc, #12]	; (e60c <z_add_thread_timeout+0x24>)
    e600:	f000 fb94 	bl	ed2c <z_add_timeout>
}
    e604:	bf00      	nop
    e606:	3710      	adds	r7, #16
    e608:	46bd      	mov	sp, r7
    e60a:	bd80      	pop	{r7, pc}
    e60c:	0000d6c1 	.word	0x0000d6c1

0000e610 <z_is_idle_thread_entry>:
{
    e610:	b480      	push	{r7}
    e612:	b083      	sub	sp, #12
    e614:	af00      	add	r7, sp, #0
    e616:	6078      	str	r0, [r7, #4]
	return entry_point == idle;
    e618:	687b      	ldr	r3, [r7, #4]
    e61a:	4a05      	ldr	r2, [pc, #20]	; (e630 <z_is_idle_thread_entry+0x20>)
    e61c:	4293      	cmp	r3, r2
    e61e:	bf0c      	ite	eq
    e620:	2301      	moveq	r3, #1
    e622:	2300      	movne	r3, #0
    e624:	b2db      	uxtb	r3, r3
}
    e626:	4618      	mov	r0, r3
    e628:	370c      	adds	r7, #12
    e62a:	46bd      	mov	sp, r7
    e62c:	bc80      	pop	{r7}
    e62e:	4770      	bx	lr
    e630:	0000af11 	.word	0x0000af11

0000e634 <log_const_source_id>:
{
    e634:	b480      	push	{r7}
    e636:	b083      	sub	sp, #12
    e638:	af00      	add	r7, sp, #0
    e63a:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    e63c:	687b      	ldr	r3, [r7, #4]
    e63e:	4a04      	ldr	r2, [pc, #16]	; (e650 <log_const_source_id+0x1c>)
    e640:	1a9b      	subs	r3, r3, r2
    e642:	08db      	lsrs	r3, r3, #3
}
    e644:	4618      	mov	r0, r3
    e646:	370c      	adds	r7, #12
    e648:	46bd      	mov	sp, r7
    e64a:	bc80      	pop	{r7}
    e64c:	4770      	bx	lr
    e64e:	bf00      	nop
    e650:	00018788 	.word	0x00018788

0000e654 <setup_thread_stack>:
#endif /* CONFIG_STACK_GROWS_UP */
#endif /* CONFIG_STACK_POINTER_RANDOM */

static char *setup_thread_stack(struct k_thread *new_thread,
				k_thread_stack_t *stack, size_t stack_size)
{
    e654:	b580      	push	{r7, lr}
    e656:	b09e      	sub	sp, #120	; 0x78
    e658:	af06      	add	r7, sp, #24
    e65a:	60f8      	str	r0, [r7, #12]
    e65c:	60b9      	str	r1, [r7, #8]
    e65e:	607a      	str	r2, [r7, #4]
	size_t stack_obj_size, stack_buf_size;
	char *stack_ptr, *stack_buf_start;
	size_t delta = 0;
    e660:	2300      	movs	r3, #0
    e662:	65fb      	str	r3, [r7, #92]	; 0x5c
		stack_buf_size = stack_obj_size - K_THREAD_STACK_RESERVED;
	} else
#endif
	{
		/* Object cannot host a user mode thread */
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    e664:	687b      	ldr	r3, [r7, #4]
    e666:	3307      	adds	r3, #7
    e668:	f023 0307 	bic.w	r3, r3, #7
    e66c:	65bb      	str	r3, [r7, #88]	; 0x58
		stack_buf_start = Z_KERNEL_STACK_BUFFER(stack);
    e66e:	68b8      	ldr	r0, [r7, #8]
    e670:	f009 fc7e 	bl	17f70 <Z_KERNEL_STACK_BUFFER>
    e674:	6578      	str	r0, [r7, #84]	; 0x54
		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
    e676:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    e678:	653b      	str	r3, [r7, #80]	; 0x50
	}

	/* Initial stack pointer at the high end of the stack object, may
	 * be reduced later in this function by TLS or random offset
	 */
	stack_ptr = (char *)stack + stack_obj_size;
    e67a:	68ba      	ldr	r2, [r7, #8]
    e67c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    e67e:	4413      	add	r3, r2
    e680:	64fb      	str	r3, [r7, #76]	; 0x4c

	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
    e682:	2303      	movs	r3, #3
    e684:	2b03      	cmp	r3, #3
    e686:	d951      	bls.n	e72c <setup_thread_stack+0xd8>
    e688:	f009 fb46 	bl	17d18 <_is_user_context>
    e68c:	4603      	mov	r3, r0
    e68e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
    e692:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
    e696:	2204      	movs	r2, #4
    e698:	f362 0302 	bfi	r3, r2, #0, #3
    e69c:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
    e6a0:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
    e6a4:	f36f 03c5 	bfc	r3, #3, #3
    e6a8:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
    e6ac:	2303      	movs	r3, #3
    e6ae:	2b00      	cmp	r3, #0
    e6b0:	d009      	beq.n	e6c6 <setup_thread_stack+0x72>
    e6b2:	4b2a      	ldr	r3, [pc, #168]	; (e75c <setup_thread_stack+0x108>)
    e6b4:	681b      	ldr	r3, [r3, #0]
    e6b6:	4618      	mov	r0, r3
    e6b8:	f7ff ffbc 	bl	e634 <log_const_source_id>
    e6bc:	4603      	mov	r3, r0
    e6be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    e6c2:	b29a      	uxth	r2, r3
    e6c4:	e000      	b.n	e6c8 <setup_thread_stack+0x74>
    e6c6:	2200      	movs	r2, #0
    e6c8:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
    e6cc:	f362 138f 	bfi	r3, r2, #6, #10
    e6d0:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    e6d4:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
    e6d8:	2b00      	cmp	r3, #0
    e6da:	d011      	beq.n	e700 <setup_thread_stack+0xac>
    e6dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    e6de:	9304      	str	r3, [sp, #16]
    e6e0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    e6e2:	9303      	str	r3, [sp, #12]
    e6e4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    e6e6:	9302      	str	r3, [sp, #8]
    e6e8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    e6ea:	9301      	str	r3, [sp, #4]
    e6ec:	68fb      	ldr	r3, [r7, #12]
    e6ee:	9300      	str	r3, [sp, #0]
    e6f0:	68bb      	ldr	r3, [r7, #8]
    e6f2:	4a1b      	ldr	r2, [pc, #108]	; (e760 <setup_thread_stack+0x10c>)
    e6f4:	491b      	ldr	r1, [pc, #108]	; (e764 <setup_thread_stack+0x110>)
    e6f6:	f8b7 0048 	ldrh.w	r0, [r7, #72]	; 0x48
    e6fa:	f7f4 f8f9 	bl	28f0 <log_from_user>
    e6fe:	e015      	b.n	e72c <setup_thread_stack+0xd8>
    e700:	4b17      	ldr	r3, [pc, #92]	; (e760 <setup_thread_stack+0x10c>)
    e702:	62fb      	str	r3, [r7, #44]	; 0x2c
    e704:	68bb      	ldr	r3, [r7, #8]
    e706:	633b      	str	r3, [r7, #48]	; 0x30
    e708:	68fb      	ldr	r3, [r7, #12]
    e70a:	637b      	str	r3, [r7, #52]	; 0x34
    e70c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    e70e:	63bb      	str	r3, [r7, #56]	; 0x38
    e710:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    e712:	63fb      	str	r3, [r7, #60]	; 0x3c
    e714:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    e716:	643b      	str	r3, [r7, #64]	; 0x40
    e718:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    e71a:	647b      	str	r3, [r7, #68]	; 0x44
    e71c:	f107 012c 	add.w	r1, r7, #44	; 0x2c
    e720:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
    e724:	2207      	movs	r2, #7
    e726:	480f      	ldr	r0, [pc, #60]	; (e764 <setup_thread_stack+0x110>)
    e728:	f002 ffda 	bl	116e0 <log_n>
		(struct _thread_userspace_local_data *)(stack_ptr - delta);
#endif
#if CONFIG_STACK_POINTER_RANDOM
	delta += random_offset(stack_buf_size);
#endif
	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
    e72c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    e72e:	3307      	adds	r3, #7
    e730:	f023 0307 	bic.w	r3, r3, #7
    e734:	65fb      	str	r3, [r7, #92]	; 0x5c
	 * will need to appropriately update this.
	 *
	 * The bounds tracked here correspond to the area of the stack object
	 * that the thread can access, which includes TLS.
	 */
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    e736:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    e738:	68fb      	ldr	r3, [r7, #12]
    e73a:	671a      	str	r2, [r3, #112]	; 0x70
	new_thread->stack_info.size = stack_buf_size;
    e73c:	68fb      	ldr	r3, [r7, #12]
    e73e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    e740:	675a      	str	r2, [r3, #116]	; 0x74
	new_thread->stack_info.delta = delta;
    e742:	68fb      	ldr	r3, [r7, #12]
    e744:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
    e746:	679a      	str	r2, [r3, #120]	; 0x78
#endif
	stack_ptr -= delta;
    e748:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    e74a:	425b      	negs	r3, r3
    e74c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    e74e:	4413      	add	r3, r2
    e750:	64fb      	str	r3, [r7, #76]	; 0x4c

	return stack_ptr;
    e752:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
    e754:	4618      	mov	r0, r3
    e756:	3760      	adds	r7, #96	; 0x60
    e758:	46bd      	mov	sp, r7
    e75a:	bd80      	pop	{r7, pc}
    e75c:	20000178 	.word	0x20000178
    e760:	0001ce84 	.word	0x0001ce84
    e764:	0001c508 	.word	0x0001c508

0000e768 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    e768:	b580      	push	{r7, lr}
    e76a:	b08a      	sub	sp, #40	; 0x28
    e76c:	af04      	add	r7, sp, #16
    e76e:	60f8      	str	r0, [r7, #12]
    e770:	60b9      	str	r1, [r7, #8]
    e772:	607a      	str	r2, [r7, #4]
    e774:	603b      	str	r3, [r7, #0]
	char *stack_ptr;

#if __ASSERT_ON
	atomic_val_t old_val = atomic_set(&new_thread->base.cookie,
    e776:	68fb      	ldr	r3, [r7, #12]
    e778:	3338      	adds	r3, #56	; 0x38
    e77a:	493a      	ldr	r1, [pc, #232]	; (e864 <z_setup_new_thread+0xfc>)
    e77c:	4618      	mov	r0, r3
    e77e:	f009 fa9a 	bl	17cb6 <atomic_set>
    e782:	6178      	str	r0, [r7, #20]
					  THREAD_COOKIE);
	/* Must be garbage or 0, never already set. Cleared at the end of
	 * z_thread_single_abort()
	 */
	__ASSERT(old_val != THREAD_COOKIE,
    e784:	697b      	ldr	r3, [r7, #20]
    e786:	4a37      	ldr	r2, [pc, #220]	; (e864 <z_setup_new_thread+0xfc>)
    e788:	4293      	cmp	r3, r2
    e78a:	d10f      	bne.n	e7ac <z_setup_new_thread+0x44>
    e78c:	f240 2329 	movw	r3, #553	; 0x229
    e790:	4a35      	ldr	r2, [pc, #212]	; (e868 <z_setup_new_thread+0x100>)
    e792:	4936      	ldr	r1, [pc, #216]	; (e86c <z_setup_new_thread+0x104>)
    e794:	4836      	ldr	r0, [pc, #216]	; (e870 <z_setup_new_thread+0x108>)
    e796:	f001 fc67 	bl	10068 <printk>
    e79a:	68f9      	ldr	r1, [r7, #12]
    e79c:	4835      	ldr	r0, [pc, #212]	; (e874 <z_setup_new_thread+0x10c>)
    e79e:	f001 fc63 	bl	10068 <printk>
    e7a2:	f240 2129 	movw	r1, #553	; 0x229
    e7a6:	4830      	ldr	r0, [pc, #192]	; (e868 <z_setup_new_thread+0x100>)
    e7a8:	f002 faa6 	bl	10cf8 <assert_post_action>
		 "re-use of active thread object %p detected", new_thread);
#endif
	Z_ASSERT_VALID_PRIO(prio, entry);
    e7ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e7ae:	2b0f      	cmp	r3, #15
    e7b0:	d108      	bne.n	e7c4 <z_setup_new_thread+0x5c>
    e7b2:	6838      	ldr	r0, [r7, #0]
    e7b4:	f7ff ff2c 	bl	e610 <z_is_idle_thread_entry>
    e7b8:	4603      	mov	r3, r0
    e7ba:	f083 0301 	eor.w	r3, r3, #1
    e7be:	b2db      	uxtb	r3, r3
    e7c0:	2b00      	cmp	r3, #0
    e7c2:	d019      	beq.n	e7f8 <z_setup_new_thread+0x90>
    e7c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e7c6:	f113 0f10 	cmn.w	r3, #16
    e7ca:	db02      	blt.n	e7d2 <z_setup_new_thread+0x6a>
    e7cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e7ce:	2b0e      	cmp	r3, #14
    e7d0:	dd12      	ble.n	e7f8 <z_setup_new_thread+0x90>
    e7d2:	f44f 730b 	mov.w	r3, #556	; 0x22c
    e7d6:	4a24      	ldr	r2, [pc, #144]	; (e868 <z_setup_new_thread+0x100>)
    e7d8:	4927      	ldr	r1, [pc, #156]	; (e878 <z_setup_new_thread+0x110>)
    e7da:	4825      	ldr	r0, [pc, #148]	; (e870 <z_setup_new_thread+0x108>)
    e7dc:	f001 fc44 	bl	10068 <printk>
    e7e0:	f06f 030f 	mvn.w	r3, #15
    e7e4:	220e      	movs	r2, #14
    e7e6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    e7e8:	4824      	ldr	r0, [pc, #144]	; (e87c <z_setup_new_thread+0x114>)
    e7ea:	f001 fc3d 	bl	10068 <printk>
    e7ee:	f44f 710b 	mov.w	r1, #556	; 0x22c
    e7f2:	481d      	ldr	r0, [pc, #116]	; (e868 <z_setup_new_thread+0x100>)
    e7f4:	f002 fa80 	bl	10cf8 <assert_post_action>
	new_thread->syscall_frame = NULL;

	/* Any given thread has access to itself */
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->base.join_waiters);
    e7f8:	68fb      	ldr	r3, [r7, #12]
    e7fa:	3330      	adds	r3, #48	; 0x30
    e7fc:	4618      	mov	r0, r3
    e7fe:	f009 fbe5 	bl	17fcc <z_waitq_init>

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    e802:	68f8      	ldr	r0, [r7, #12]
    e804:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    e806:	2204      	movs	r2, #4
    e808:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    e80a:	f009 fc49 	bl	180a0 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    e80e:	687a      	ldr	r2, [r7, #4]
    e810:	68b9      	ldr	r1, [r7, #8]
    e812:	68f8      	ldr	r0, [r7, #12]
    e814:	f7ff ff1e 	bl	e654 <setup_thread_stack>
    e818:	6138      	str	r0, [r7, #16]
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    e81a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    e81c:	9302      	str	r3, [sp, #8]
    e81e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e820:	9301      	str	r3, [sp, #4]
    e822:	6a3b      	ldr	r3, [r7, #32]
    e824:	9300      	str	r3, [sp, #0]
    e826:	683b      	ldr	r3, [r7, #0]
    e828:	693a      	ldr	r2, [r7, #16]
    e82a:	68b9      	ldr	r1, [r7, #8]
    e82c:	68f8      	ldr	r0, [r7, #12]
    e82e:	f7f6 f999 	bl	4b64 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    e832:	68fb      	ldr	r3, [r7, #12]
    e834:	2200      	movs	r2, #0
    e836:	665a      	str	r2, [r3, #100]	; 0x64
	new_thread->fn_abort = NULL;
    e838:	68fb      	ldr	r3, [r7, #12]
    e83a:	2200      	movs	r2, #0
    e83c:	669a      	str	r2, [r3, #104]	; 0x68
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    e83e:	4b10      	ldr	r3, [pc, #64]	; (e880 <z_setup_new_thread+0x118>)
    e840:	689b      	ldr	r3, [r3, #8]
    e842:	2b00      	cmp	r3, #0
    e844:	d104      	bne.n	e850 <z_setup_new_thread+0xe8>
		new_thread->resource_pool = NULL;
    e846:	68fb      	ldr	r3, [r7, #12]
    e848:	2200      	movs	r2, #0
    e84a:	67da      	str	r2, [r3, #124]	; 0x7c
		return stack_ptr;
    e84c:	693b      	ldr	r3, [r7, #16]
    e84e:	e005      	b.n	e85c <z_setup_new_thread+0xf4>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    e850:	4b0b      	ldr	r3, [pc, #44]	; (e880 <z_setup_new_thread+0x118>)
    e852:	689b      	ldr	r3, [r3, #8]
    e854:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    e856:	68fb      	ldr	r3, [r7, #12]
    e858:	67da      	str	r2, [r3, #124]	; 0x7c

#ifdef CONFIG_THREAD_RUNTIME_STATS
	memset(&new_thread->rt_stats, 0, sizeof(new_thread->rt_stats));
#endif

	return stack_ptr;
    e85a:	693b      	ldr	r3, [r7, #16]
}
    e85c:	4618      	mov	r0, r3
    e85e:	3718      	adds	r7, #24
    e860:	46bd      	mov	sp, r7
    e862:	bd80      	pop	{r7, pc}
    e864:	1337c0d3 	.word	0x1337c0d3
    e868:	0001c55c 	.word	0x0001c55c
    e86c:	0001c580 	.word	0x0001c580
    e870:	0001c598 	.word	0x0001c598
    e874:	0001c5b8 	.word	0x0001c5b8
    e878:	0001c5e8 	.word	0x0001c5e8
    e87c:	0001c668 	.word	0x0001c668
    e880:	20000cd8 	.word	0x20000cd8

0000e884 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, uint32_t options, k_timeout_t delay)
{
    e884:	b580      	push	{r7, lr}
    e886:	b08c      	sub	sp, #48	; 0x30
    e888:	af06      	add	r7, sp, #24
    e88a:	60f8      	str	r0, [r7, #12]
    e88c:	60b9      	str	r1, [r7, #8]
    e88e:	607a      	str	r2, [r7, #4]
    e890:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e892:	f3ef 8305 	mrs	r3, IPSR
    e896:	617b      	str	r3, [r7, #20]
  return(result);
    e898:	697b      	ldr	r3, [r7, #20]
    e89a:	2b00      	cmp	r3, #0
    e89c:	bf14      	ite	ne
    e89e:	2301      	movne	r3, #1
    e8a0:	2300      	moveq	r3, #0
    e8a2:	b2db      	uxtb	r3, r3
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
    e8a4:	2b00      	cmp	r3, #0
    e8a6:	d00e      	beq.n	e8c6 <z_impl_k_thread_create+0x42>
    e8a8:	f240 2395 	movw	r3, #661	; 0x295
    e8ac:	4a19      	ldr	r2, [pc, #100]	; (e914 <z_impl_k_thread_create+0x90>)
    e8ae:	491a      	ldr	r1, [pc, #104]	; (e918 <z_impl_k_thread_create+0x94>)
    e8b0:	481a      	ldr	r0, [pc, #104]	; (e91c <z_impl_k_thread_create+0x98>)
    e8b2:	f001 fbd9 	bl	10068 <printk>
    e8b6:	481a      	ldr	r0, [pc, #104]	; (e920 <z_impl_k_thread_create+0x9c>)
    e8b8:	f001 fbd6 	bl	10068 <printk>
    e8bc:	f240 2195 	movw	r1, #661	; 0x295
    e8c0:	4814      	ldr	r0, [pc, #80]	; (e914 <z_impl_k_thread_create+0x90>)
    e8c2:	f002 fa19 	bl	10cf8 <assert_post_action>
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e8c6:	2300      	movs	r3, #0
    e8c8:	9305      	str	r3, [sp, #20]
    e8ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    e8cc:	9304      	str	r3, [sp, #16]
    e8ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    e8d0:	9303      	str	r3, [sp, #12]
    e8d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    e8d4:	9302      	str	r3, [sp, #8]
    e8d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e8d8:	9301      	str	r3, [sp, #4]
    e8da:	6a3b      	ldr	r3, [r7, #32]
    e8dc:	9300      	str	r3, [sp, #0]
    e8de:	683b      	ldr	r3, [r7, #0]
    e8e0:	687a      	ldr	r2, [r7, #4]
    e8e2:	68b9      	ldr	r1, [r7, #8]
    e8e4:	68f8      	ldr	r0, [r7, #12]
    e8e6:	f7ff ff3f 	bl	e768 <z_setup_new_thread>
			  prio, options, NULL);

	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    e8ea:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    e8ee:	f04f 30ff 	mov.w	r0, #4294967295
    e8f2:	f04f 31ff 	mov.w	r1, #4294967295
    e8f6:	428b      	cmp	r3, r1
    e8f8:	bf08      	it	eq
    e8fa:	4282      	cmpeq	r2, r0
    e8fc:	d004      	beq.n	e908 <z_impl_k_thread_create+0x84>
		schedule_new_thread(new_thread, delay);
    e8fe:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    e902:	68f8      	ldr	r0, [r7, #12]
    e904:	f009 fbaf 	bl	18066 <schedule_new_thread>
	}

	return new_thread;
    e908:	68fb      	ldr	r3, [r7, #12]
}
    e90a:	4618      	mov	r0, r3
    e90c:	3718      	adds	r7, #24
    e90e:	46bd      	mov	sp, r7
    e910:	bd80      	pop	{r7, pc}
    e912:	bf00      	nop
    e914:	0001c55c 	.word	0x0001c55c
    e918:	0001c69c 	.word	0x0001c69c
    e91c:	0001c598 	.word	0x0001c598
    e920:	0001c6b0 	.word	0x0001c6b0

0000e924 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    e924:	b5f0      	push	{r4, r5, r6, r7, lr}
    e926:	b08d      	sub	sp, #52	; 0x34
    e928:	af06      	add	r7, sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
    e92a:	4b45      	ldr	r3, [pc, #276]	; (ea40 <z_init_static_threads+0x11c>)
    e92c:	617b      	str	r3, [r7, #20]
    e92e:	e029      	b.n	e984 <z_init_static_threads+0x60>
		z_setup_new_thread(
    e930:	697b      	ldr	r3, [r7, #20]
    e932:	681e      	ldr	r6, [r3, #0]
    e934:	697b      	ldr	r3, [r7, #20]
    e936:	685b      	ldr	r3, [r3, #4]
    e938:	60fb      	str	r3, [r7, #12]
    e93a:	697b      	ldr	r3, [r7, #20]
    e93c:	689a      	ldr	r2, [r3, #8]
    e93e:	60ba      	str	r2, [r7, #8]
    e940:	697b      	ldr	r3, [r7, #20]
    e942:	68d8      	ldr	r0, [r3, #12]
    e944:	6078      	str	r0, [r7, #4]
    e946:	697b      	ldr	r3, [r7, #20]
    e948:	691b      	ldr	r3, [r3, #16]
    e94a:	697a      	ldr	r2, [r7, #20]
    e94c:	6952      	ldr	r2, [r2, #20]
    e94e:	6979      	ldr	r1, [r7, #20]
    e950:	6989      	ldr	r1, [r1, #24]
    e952:	6978      	ldr	r0, [r7, #20]
    e954:	69c0      	ldr	r0, [r0, #28]
    e956:	697c      	ldr	r4, [r7, #20]
    e958:	6a24      	ldr	r4, [r4, #32]
    e95a:	697d      	ldr	r5, [r7, #20]
    e95c:	6aed      	ldr	r5, [r5, #44]	; 0x2c
    e95e:	9505      	str	r5, [sp, #20]
    e960:	9404      	str	r4, [sp, #16]
    e962:	9003      	str	r0, [sp, #12]
    e964:	9102      	str	r1, [sp, #8]
    e966:	9201      	str	r2, [sp, #4]
    e968:	9300      	str	r3, [sp, #0]
    e96a:	687b      	ldr	r3, [r7, #4]
    e96c:	68ba      	ldr	r2, [r7, #8]
    e96e:	68f9      	ldr	r1, [r7, #12]
    e970:	4630      	mov	r0, r6
    e972:	f7ff fef9 	bl	e768 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    e976:	697b      	ldr	r3, [r7, #20]
    e978:	681b      	ldr	r3, [r3, #0]
    e97a:	697a      	ldr	r2, [r7, #20]
    e97c:	665a      	str	r2, [r3, #100]	; 0x64
	_FOREACH_STATIC_THREAD(thread_data) {
    e97e:	697b      	ldr	r3, [r7, #20]
    e980:	3330      	adds	r3, #48	; 0x30
    e982:	617b      	str	r3, [r7, #20]
    e984:	697b      	ldr	r3, [r7, #20]
    e986:	4a2f      	ldr	r2, [pc, #188]	; (ea44 <z_init_static_threads+0x120>)
    e988:	4293      	cmp	r3, r2
    e98a:	d90e      	bls.n	e9aa <z_init_static_threads+0x86>
    e98c:	f240 3303 	movw	r3, #771	; 0x303
    e990:	4a2d      	ldr	r2, [pc, #180]	; (ea48 <z_init_static_threads+0x124>)
    e992:	492e      	ldr	r1, [pc, #184]	; (ea4c <z_init_static_threads+0x128>)
    e994:	482e      	ldr	r0, [pc, #184]	; (ea50 <z_init_static_threads+0x12c>)
    e996:	f001 fb67 	bl	10068 <printk>
    e99a:	482e      	ldr	r0, [pc, #184]	; (ea54 <z_init_static_threads+0x130>)
    e99c:	f001 fb64 	bl	10068 <printk>
    e9a0:	f240 3103 	movw	r1, #771	; 0x303
    e9a4:	4828      	ldr	r0, [pc, #160]	; (ea48 <z_init_static_threads+0x124>)
    e9a6:	f002 f9a7 	bl	10cf8 <assert_post_action>
    e9aa:	697b      	ldr	r3, [r7, #20]
    e9ac:	4a25      	ldr	r2, [pc, #148]	; (ea44 <z_init_static_threads+0x120>)
    e9ae:	4293      	cmp	r3, r2
    e9b0:	bf34      	ite	cc
    e9b2:	2301      	movcc	r3, #1
    e9b4:	2300      	movcs	r3, #0
    e9b6:	b2db      	uxtb	r3, r3
    e9b8:	2b00      	cmp	r3, #0
    e9ba:	d1b9      	bne.n	e930 <z_init_static_threads+0xc>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    e9bc:	f7ff f8a2 	bl	db04 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    e9c0:	4b1f      	ldr	r3, [pc, #124]	; (ea40 <z_init_static_threads+0x11c>)
    e9c2:	613b      	str	r3, [r7, #16]
    e9c4:	e019      	b.n	e9fa <z_init_static_threads+0xd6>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    e9c6:	693b      	ldr	r3, [r7, #16]
    e9c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    e9ca:	f1b3 3fff 	cmp.w	r3, #4294967295
    e9ce:	d011      	beq.n	e9f4 <z_init_static_threads+0xd0>
			schedule_new_thread(thread_data->init_thread,
    e9d0:	693b      	ldr	r3, [r7, #16]
    e9d2:	681c      	ldr	r4, [r3, #0]
					    K_MSEC(thread_data->init_delay));
    e9d4:	693b      	ldr	r3, [r7, #16]
    e9d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    e9d8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    e9dc:	461a      	mov	r2, r3
    e9de:	ea4f 73e2 	mov.w	r3, r2, asr #31
    e9e2:	4610      	mov	r0, r2
    e9e4:	4619      	mov	r1, r3
    e9e6:	f009 f99e 	bl	17d26 <k_ms_to_ticks_ceil64>
    e9ea:	4602      	mov	r2, r0
    e9ec:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
    e9ee:	4620      	mov	r0, r4
    e9f0:	f009 fb39 	bl	18066 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    e9f4:	693b      	ldr	r3, [r7, #16]
    e9f6:	3330      	adds	r3, #48	; 0x30
    e9f8:	613b      	str	r3, [r7, #16]
    e9fa:	693b      	ldr	r3, [r7, #16]
    e9fc:	4a11      	ldr	r2, [pc, #68]	; (ea44 <z_init_static_threads+0x120>)
    e9fe:	4293      	cmp	r3, r2
    ea00:	d90e      	bls.n	ea20 <z_init_static_threads+0xfc>
    ea02:	f240 3322 	movw	r3, #802	; 0x322
    ea06:	4a10      	ldr	r2, [pc, #64]	; (ea48 <z_init_static_threads+0x124>)
    ea08:	4910      	ldr	r1, [pc, #64]	; (ea4c <z_init_static_threads+0x128>)
    ea0a:	4811      	ldr	r0, [pc, #68]	; (ea50 <z_init_static_threads+0x12c>)
    ea0c:	f001 fb2c 	bl	10068 <printk>
    ea10:	4810      	ldr	r0, [pc, #64]	; (ea54 <z_init_static_threads+0x130>)
    ea12:	f001 fb29 	bl	10068 <printk>
    ea16:	f240 3122 	movw	r1, #802	; 0x322
    ea1a:	480b      	ldr	r0, [pc, #44]	; (ea48 <z_init_static_threads+0x124>)
    ea1c:	f002 f96c 	bl	10cf8 <assert_post_action>
    ea20:	693b      	ldr	r3, [r7, #16]
    ea22:	4a08      	ldr	r2, [pc, #32]	; (ea44 <z_init_static_threads+0x120>)
    ea24:	4293      	cmp	r3, r2
    ea26:	bf34      	ite	cc
    ea28:	2301      	movcc	r3, #1
    ea2a:	2300      	movcs	r3, #0
    ea2c:	b2db      	uxtb	r3, r3
    ea2e:	2b00      	cmp	r3, #0
    ea30:	d1c9      	bne.n	e9c6 <z_init_static_threads+0xa2>
		}
	}
	k_sched_unlock();
    ea32:	f7ff f8d5 	bl	dbe0 <k_sched_unlock>
}
    ea36:	bf00      	nop
    ea38:	371c      	adds	r7, #28
    ea3a:	46bd      	mov	sp, r7
    ea3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ea3e:	bf00      	nop
    ea40:	2000025c 	.word	0x2000025c
    ea44:	2000025c 	.word	0x2000025c
    ea48:	0001c55c 	.word	0x0001c55c
    ea4c:	0001c6d8 	.word	0x0001c6d8
    ea50:	0001c598 	.word	0x0001c598
    ea54:	0001c708 	.word	0x0001c708

0000ea58 <z_spin_lock_valid>:
/* These spinlock assertion predicates are defined here because having
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
    ea58:	b480      	push	{r7}
    ea5a:	b085      	sub	sp, #20
    ea5c:	af00      	add	r7, sp, #0
    ea5e:	6078      	str	r0, [r7, #4]
	uintptr_t thread_cpu = l->thread_cpu;
    ea60:	687b      	ldr	r3, [r7, #4]
    ea62:	681b      	ldr	r3, [r3, #0]
    ea64:	60fb      	str	r3, [r7, #12]

	if (thread_cpu) {
    ea66:	68fb      	ldr	r3, [r7, #12]
    ea68:	2b00      	cmp	r3, #0
    ea6a:	d008      	beq.n	ea7e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1e>
		if ((thread_cpu & 3U) == _current_cpu->id) {
    ea6c:	68fb      	ldr	r3, [r7, #12]
    ea6e:	f003 0303 	and.w	r3, r3, #3
    ea72:	4a06      	ldr	r2, [pc, #24]	; (ea8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2c>)
    ea74:	7e12      	ldrb	r2, [r2, #24]
    ea76:	4293      	cmp	r3, r2
    ea78:	d101      	bne.n	ea7e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1e>
			return false;
    ea7a:	2300      	movs	r3, #0
    ea7c:	e000      	b.n	ea80 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x20>
		}
	}
	return true;
    ea7e:	2301      	movs	r3, #1
}
    ea80:	4618      	mov	r0, r3
    ea82:	3714      	adds	r7, #20
    ea84:	46bd      	mov	sp, r7
    ea86:	bc80      	pop	{r7}
    ea88:	4770      	bx	lr
    ea8a:	bf00      	nop
    ea8c:	20000cd8 	.word	0x20000cd8

0000ea90 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
    ea90:	b480      	push	{r7}
    ea92:	b083      	sub	sp, #12
    ea94:	af00      	add	r7, sp, #0
    ea96:	6078      	str	r0, [r7, #4]
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
    ea98:	687b      	ldr	r3, [r7, #4]
    ea9a:	681a      	ldr	r2, [r3, #0]
    ea9c:	4b09      	ldr	r3, [pc, #36]	; (eac4 <z_spin_unlock_valid+0x34>)
    ea9e:	7e1b      	ldrb	r3, [r3, #24]
    eaa0:	4619      	mov	r1, r3
    eaa2:	4b08      	ldr	r3, [pc, #32]	; (eac4 <z_spin_unlock_valid+0x34>)
    eaa4:	689b      	ldr	r3, [r3, #8]
    eaa6:	430b      	orrs	r3, r1
    eaa8:	429a      	cmp	r2, r3
    eaaa:	d001      	beq.n	eab0 <z_spin_unlock_valid+0x20>
		return false;
    eaac:	2300      	movs	r3, #0
    eaae:	e003      	b.n	eab8 <z_spin_unlock_valid+0x28>
	}
	l->thread_cpu = 0;
    eab0:	687b      	ldr	r3, [r7, #4]
    eab2:	2200      	movs	r2, #0
    eab4:	601a      	str	r2, [r3, #0]
	return true;
    eab6:	2301      	movs	r3, #1
}
    eab8:	4618      	mov	r0, r3
    eaba:	370c      	adds	r7, #12
    eabc:	46bd      	mov	sp, r7
    eabe:	bc80      	pop	{r7}
    eac0:	4770      	bx	lr
    eac2:	bf00      	nop
    eac4:	20000cd8 	.word	0x20000cd8

0000eac8 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
    eac8:	b480      	push	{r7}
    eaca:	b083      	sub	sp, #12
    eacc:	af00      	add	r7, sp, #0
    eace:	6078      	str	r0, [r7, #4]
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
    ead0:	4b06      	ldr	r3, [pc, #24]	; (eaec <z_spin_lock_set_owner+0x24>)
    ead2:	7e1b      	ldrb	r3, [r3, #24]
    ead4:	461a      	mov	r2, r3
    ead6:	4b05      	ldr	r3, [pc, #20]	; (eaec <z_spin_lock_set_owner+0x24>)
    ead8:	689b      	ldr	r3, [r3, #8]
    eada:	431a      	orrs	r2, r3
    eadc:	687b      	ldr	r3, [r7, #4]
    eade:	601a      	str	r2, [r3, #0]
}
    eae0:	bf00      	nop
    eae2:	370c      	adds	r7, #12
    eae4:	46bd      	mov	sp, r7
    eae6:	bc80      	pop	{r7}
    eae8:	4770      	bx	lr
    eaea:	bf00      	nop
    eaec:	20000cd8 	.word	0x20000cd8

0000eaf0 <log_const_source_id>:
{
    eaf0:	b480      	push	{r7}
    eaf2:	b083      	sub	sp, #12
    eaf4:	af00      	add	r7, sp, #0
    eaf6:	6078      	str	r0, [r7, #4]
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    eaf8:	687b      	ldr	r3, [r7, #4]
    eafa:	4a04      	ldr	r2, [pc, #16]	; (eb0c <log_const_source_id+0x1c>)
    eafc:	1a9b      	subs	r3, r3, r2
    eafe:	08db      	lsrs	r3, r3, #3
}
    eb00:	4618      	mov	r0, r3
    eb02:	370c      	adds	r7, #12
    eb04:	46bd      	mov	sp, r7
    eb06:	bc80      	pop	{r7}
    eb08:	4770      	bx	lr
    eb0a:	bf00      	nop
    eb0c:	00018788 	.word	0x00018788

0000eb10 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os);

FUNC_NORETURN void z_self_abort(void)
{
    eb10:	b580      	push	{r7, lr}
    eb12:	b088      	sub	sp, #32
    eb14:	af02      	add	r7, sp, #8
	__asm__ volatile(
    eb16:	f04f 0320 	mov.w	r3, #32
    eb1a:	f3ef 8211 	mrs	r2, BASEPRI
    eb1e:	f383 8811 	msr	BASEPRI, r3
    eb22:	f3bf 8f6f 	isb	sy
    eb26:	60ba      	str	r2, [r7, #8]
    eb28:	607b      	str	r3, [r7, #4]
	return key;
    eb2a:	68bb      	ldr	r3, [r7, #8]
	struct _cpu *cpu;

	/* Lock local IRQs to prevent us from migrating to another CPU
	 * while we set this up
	 */
	key = arch_irq_lock();
    eb2c:	60fb      	str	r3, [r7, #12]
	cpu = _current_cpu;
    eb2e:	4b36      	ldr	r3, [pc, #216]	; (ec08 <z_self_abort+0xf8>)
    eb30:	613b      	str	r3, [r7, #16]
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
    eb32:	693b      	ldr	r3, [r7, #16]
    eb34:	691b      	ldr	r3, [r3, #16]
    eb36:	2b00      	cmp	r3, #0
    eb38:	d00c      	beq.n	eb54 <z_self_abort+0x44>
    eb3a:	2328      	movs	r3, #40	; 0x28
    eb3c:	4a33      	ldr	r2, [pc, #204]	; (ec0c <z_self_abort+0xfc>)
    eb3e:	4934      	ldr	r1, [pc, #208]	; (ec10 <z_self_abort+0x100>)
    eb40:	4834      	ldr	r0, [pc, #208]	; (ec14 <z_self_abort+0x104>)
    eb42:	f001 fa91 	bl	10068 <printk>
    eb46:	4834      	ldr	r0, [pc, #208]	; (ec18 <z_self_abort+0x108>)
    eb48:	f001 fa8e 	bl	10068 <printk>
    eb4c:	2128      	movs	r1, #40	; 0x28
    eb4e:	482f      	ldr	r0, [pc, #188]	; (ec0c <z_self_abort+0xfc>)
    eb50:	f002 f8d2 	bl	10cf8 <assert_post_action>
	cpu->pending_abort = _current;
    eb54:	4b2c      	ldr	r3, [pc, #176]	; (ec08 <z_self_abort+0xf8>)
    eb56:	689a      	ldr	r2, [r3, #8]
    eb58:	693b      	ldr	r3, [r7, #16]
    eb5a:	611a      	str	r2, [r3, #16]

	LOG_DBG("%p self-aborting, handle on idle thread %p",
    eb5c:	2303      	movs	r3, #3
    eb5e:	2b03      	cmp	r3, #3
    eb60:	d93b      	bls.n	ebda <z_self_abort+0xca>
    eb62:	f009 faba 	bl	180da <_is_user_context>
    eb66:	4603      	mov	r3, r0
    eb68:	75fb      	strb	r3, [r7, #23]
    eb6a:	783b      	ldrb	r3, [r7, #0]
    eb6c:	2204      	movs	r2, #4
    eb6e:	f362 0302 	bfi	r3, r2, #0, #3
    eb72:	703b      	strb	r3, [r7, #0]
    eb74:	783b      	ldrb	r3, [r7, #0]
    eb76:	f36f 03c5 	bfc	r3, #3, #3
    eb7a:	703b      	strb	r3, [r7, #0]
    eb7c:	2303      	movs	r3, #3
    eb7e:	2b00      	cmp	r3, #0
    eb80:	d009      	beq.n	eb96 <z_self_abort+0x86>
    eb82:	4b26      	ldr	r3, [pc, #152]	; (ec1c <z_self_abort+0x10c>)
    eb84:	681b      	ldr	r3, [r3, #0]
    eb86:	4618      	mov	r0, r3
    eb88:	f7ff ffb2 	bl	eaf0 <log_const_source_id>
    eb8c:	4603      	mov	r3, r0
    eb8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    eb92:	b29a      	uxth	r2, r3
    eb94:	e000      	b.n	eb98 <z_self_abort+0x88>
    eb96:	2200      	movs	r2, #0
    eb98:	883b      	ldrh	r3, [r7, #0]
    eb9a:	f362 138f 	bfi	r3, r2, #6, #10
    eb9e:	803b      	strh	r3, [r7, #0]
    eba0:	7dfb      	ldrb	r3, [r7, #23]
    eba2:	2b00      	cmp	r3, #0
    eba4:	d00b      	beq.n	ebbe <z_self_abort+0xae>
    eba6:	4b18      	ldr	r3, [pc, #96]	; (ec08 <z_self_abort+0xf8>)
    eba8:	689a      	ldr	r2, [r3, #8]
    ebaa:	693b      	ldr	r3, [r7, #16]
    ebac:	68db      	ldr	r3, [r3, #12]
    ebae:	9300      	str	r3, [sp, #0]
    ebb0:	4613      	mov	r3, r2
    ebb2:	4a1b      	ldr	r2, [pc, #108]	; (ec20 <z_self_abort+0x110>)
    ebb4:	491b      	ldr	r1, [pc, #108]	; (ec24 <z_self_abort+0x114>)
    ebb6:	8838      	ldrh	r0, [r7, #0]
    ebb8:	f7f3 fe9a 	bl	28f0 <log_from_user>
    ebbc:	e00d      	b.n	ebda <z_self_abort+0xca>
    ebbe:	4918      	ldr	r1, [pc, #96]	; (ec20 <z_self_abort+0x110>)
    ebc0:	4b11      	ldr	r3, [pc, #68]	; (ec08 <z_self_abort+0xf8>)
    ebc2:	689b      	ldr	r3, [r3, #8]
    ebc4:	461a      	mov	r2, r3
    ebc6:	693b      	ldr	r3, [r7, #16]
    ebc8:	68db      	ldr	r3, [r3, #12]
    ebca:	4618      	mov	r0, r3
    ebcc:	883b      	ldrh	r3, [r7, #0]
    ebce:	f8ad 3000 	strh.w	r3, [sp]
    ebd2:	4603      	mov	r3, r0
    ebd4:	4813      	ldr	r0, [pc, #76]	; (ec24 <z_self_abort+0x114>)
    ebd6:	f002 fd69 	bl	116ac <log_3>
		_current, cpu->idle_thread);

	k_thread_suspend(_current);
    ebda:	4b0b      	ldr	r3, [pc, #44]	; (ec08 <z_self_abort+0xf8>)
    ebdc:	689b      	ldr	r3, [r3, #8]
    ebde:	4618      	mov	r0, r3
    ebe0:	f009 fa82 	bl	180e8 <k_thread_suspend>
	z_swap_irqlock(key);
    ebe4:	68fb      	ldr	r3, [r7, #12]
    ebe6:	4618      	mov	r0, r3
    ebe8:	f009 fa89 	bl	180fe <z_swap_irqlock>
	__ASSERT(false, "should never get here");
    ebec:	2330      	movs	r3, #48	; 0x30
    ebee:	4a07      	ldr	r2, [pc, #28]	; (ec0c <z_self_abort+0xfc>)
    ebf0:	490d      	ldr	r1, [pc, #52]	; (ec28 <z_self_abort+0x118>)
    ebf2:	4808      	ldr	r0, [pc, #32]	; (ec14 <z_self_abort+0x104>)
    ebf4:	f001 fa38 	bl	10068 <printk>
    ebf8:	480c      	ldr	r0, [pc, #48]	; (ec2c <z_self_abort+0x11c>)
    ebfa:	f001 fa35 	bl	10068 <printk>
    ebfe:	2130      	movs	r1, #48	; 0x30
    ec00:	4802      	ldr	r0, [pc, #8]	; (ec0c <z_self_abort+0xfc>)
    ec02:	f002 f879 	bl	10cf8 <assert_post_action>
    ec06:	bf00      	nop
    ec08:	20000cd8 	.word	0x20000cd8
    ec0c:	0001c728 	.word	0x0001c728
    ec10:	0001c754 	.word	0x0001c754
    ec14:	0001c778 	.word	0x0001c778
    ec18:	0001c798 	.word	0x0001c798
    ec1c:	2000017c 	.word	0x2000017c
    ec20:	0001ce98 	.word	0x0001ce98
    ec24:	0001c7bc 	.word	0x0001c7bc
    ec28:	0001c7ec 	.word	0x0001c7ec
    ec2c:	0001c7f0 	.word	0x0001c7f0

0000ec30 <first>:
#include <syscalls/z_clock_hw_cycles_per_sec_runtime_get_mrsh.c>
#endif /* CONFIG_USERSPACE */
#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */

static struct _timeout *first(void)
{
    ec30:	b580      	push	{r7, lr}
    ec32:	b082      	sub	sp, #8
    ec34:	af00      	add	r7, sp, #0
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
    ec36:	4804      	ldr	r0, [pc, #16]	; (ec48 <first+0x18>)
    ec38:	f009 fa9e 	bl	18178 <sys_dlist_peek_head>
    ec3c:	6078      	str	r0, [r7, #4]

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    ec3e:	687b      	ldr	r3, [r7, #4]
}
    ec40:	4618      	mov	r0, r3
    ec42:	3708      	adds	r7, #8
    ec44:	46bd      	mov	sp, r7
    ec46:	bd80      	pop	{r7, pc}
    ec48:	20000180 	.word	0x20000180

0000ec4c <next>:

static struct _timeout *next(struct _timeout *t)
{
    ec4c:	b580      	push	{r7, lr}
    ec4e:	b084      	sub	sp, #16
    ec50:	af00      	add	r7, sp, #0
    ec52:	6078      	str	r0, [r7, #4]
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
    ec54:	687b      	ldr	r3, [r7, #4]
    ec56:	4619      	mov	r1, r3
    ec58:	4804      	ldr	r0, [pc, #16]	; (ec6c <next+0x20>)
    ec5a:	f009 fab2 	bl	181c2 <sys_dlist_peek_next>
    ec5e:	60f8      	str	r0, [r7, #12]

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
    ec60:	68fb      	ldr	r3, [r7, #12]
}
    ec62:	4618      	mov	r0, r3
    ec64:	3710      	adds	r7, #16
    ec66:	46bd      	mov	sp, r7
    ec68:	bd80      	pop	{r7, pc}
    ec6a:	bf00      	nop
    ec6c:	20000180 	.word	0x20000180

0000ec70 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
    ec70:	b580      	push	{r7, lr}
    ec72:	af00      	add	r7, sp, #0
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
    ec74:	4b05      	ldr	r3, [pc, #20]	; (ec8c <elapsed+0x1c>)
    ec76:	681b      	ldr	r3, [r3, #0]
    ec78:	2b00      	cmp	r3, #0
    ec7a:	d103      	bne.n	ec84 <elapsed+0x14>
    ec7c:	f7f5 fc7c 	bl	4578 <z_clock_elapsed>
    ec80:	4603      	mov	r3, r0
    ec82:	e000      	b.n	ec86 <elapsed+0x16>
    ec84:	2300      	movs	r3, #0
}
    ec86:	4618      	mov	r0, r3
    ec88:	bd80      	pop	{r7, pc}
    ec8a:	bf00      	nop
    ec8c:	20000d24 	.word	0x20000d24

0000ec90 <next_timeout>:

static int32_t next_timeout(void)
{
    ec90:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
    ec94:	b084      	sub	sp, #16
    ec96:	af00      	add	r7, sp, #0
	struct _timeout *to = first();
    ec98:	f7ff ffca 	bl	ec30 <first>
    ec9c:	60b8      	str	r0, [r7, #8]
	int32_t ticks_elapsed = elapsed();
    ec9e:	f7ff ffe7 	bl	ec70 <elapsed>
    eca2:	6078      	str	r0, [r7, #4]
	int32_t ret = to == NULL ? MAX_WAIT
    eca4:	68bb      	ldr	r3, [r7, #8]
    eca6:	2b00      	cmp	r3, #0
    eca8:	d029      	beq.n	ecfe <next_timeout+0x6e>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    ecaa:	68bb      	ldr	r3, [r7, #8]
    ecac:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    ecb0:	687b      	ldr	r3, [r7, #4]
    ecb2:	461a      	mov	r2, r3
    ecb4:	ea4f 73e2 	mov.w	r3, r2, asr #31
    ecb8:	1a84      	subs	r4, r0, r2
    ecba:	eb61 0503 	sbc.w	r5, r1, r3
	int32_t ret = to == NULL ? MAX_WAIT
    ecbe:	2c01      	cmp	r4, #1
    ecc0:	f175 0300 	sbcs.w	r3, r5, #0
    ecc4:	db19      	blt.n	ecfa <next_timeout+0x6a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    ecc6:	68bb      	ldr	r3, [r7, #8]
    ecc8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    eccc:	687b      	ldr	r3, [r7, #4]
    ecce:	461a      	mov	r2, r3
    ecd0:	ea4f 73e2 	mov.w	r3, r2, asr #31
    ecd4:	ebb0 0802 	subs.w	r8, r0, r2
    ecd8:	eb61 0903 	sbc.w	r9, r1, r3
    ecdc:	4642      	mov	r2, r8
    ecde:	464b      	mov	r3, r9
    ece0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    ece4:	f04f 0100 	mov.w	r1, #0
    ece8:	4290      	cmp	r0, r2
    ecea:	4199      	sbcs	r1, r3
    ecec:	da03      	bge.n	ecf6 <next_timeout+0x66>
    ecee:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
    ecf2:	f04f 0300 	mov.w	r3, #0
	int32_t ret = to == NULL ? MAX_WAIT
    ecf6:	4613      	mov	r3, r2
    ecf8:	e003      	b.n	ed02 <next_timeout+0x72>
    ecfa:	2300      	movs	r3, #0
    ecfc:	e001      	b.n	ed02 <next_timeout+0x72>
    ecfe:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    ed02:	60fb      	str	r3, [r7, #12]

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    ed04:	4b08      	ldr	r3, [pc, #32]	; (ed28 <next_timeout+0x98>)
    ed06:	695b      	ldr	r3, [r3, #20]
    ed08:	2b00      	cmp	r3, #0
    ed0a:	d007      	beq.n	ed1c <next_timeout+0x8c>
    ed0c:	4b06      	ldr	r3, [pc, #24]	; (ed28 <next_timeout+0x98>)
    ed0e:	695b      	ldr	r3, [r3, #20]
    ed10:	68fa      	ldr	r2, [r7, #12]
    ed12:	429a      	cmp	r2, r3
    ed14:	dd02      	ble.n	ed1c <next_timeout+0x8c>
		ret = _current_cpu->slice_ticks;
    ed16:	4b04      	ldr	r3, [pc, #16]	; (ed28 <next_timeout+0x98>)
    ed18:	695b      	ldr	r3, [r3, #20]
    ed1a:	60fb      	str	r3, [r7, #12]
	}
#endif
	return ret;
    ed1c:	68fb      	ldr	r3, [r7, #12]
}
    ed1e:	4618      	mov	r0, r3
    ed20:	3710      	adds	r7, #16
    ed22:	46bd      	mov	sp, r7
    ed24:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
    ed28:	20000cd8 	.word	0x20000cd8

0000ed2c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    ed2c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
    ed30:	b09a      	sub	sp, #104	; 0x68
    ed32:	af00      	add	r7, sp, #0
    ed34:	6378      	str	r0, [r7, #52]	; 0x34
    ed36:	6339      	str	r1, [r7, #48]	; 0x30
    ed38:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    ed3c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
    ed40:	f04f 32ff 	mov.w	r2, #4294967295
    ed44:	f04f 33ff 	mov.w	r3, #4294967295
    ed48:	4299      	cmp	r1, r3
    ed4a:	bf08      	it	eq
    ed4c:	4290      	cmpeq	r0, r2
    ed4e:	d100      	bne.n	ed52 <z_add_timeout+0x26>
    ed50:	e115      	b.n	ef7e <z_add_timeout+0x252>
#endif

#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;
    ed52:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
    ed56:	1c54      	adds	r4, r2, #1
    ed58:	f143 0500 	adc.w	r5, r3, #0
    ed5c:	e9c7 4518 	strd	r4, r5, [r7, #96]	; 0x60

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    ed60:	f06f 0001 	mvn.w	r0, #1
    ed64:	f04f 31ff 	mov.w	r1, #4294967295
    ed68:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
    ed6c:	1a84      	subs	r4, r0, r2
    ed6e:	623c      	str	r4, [r7, #32]
    ed70:	eb61 0303 	sbc.w	r3, r1, r3
    ed74:	627b      	str	r3, [r7, #36]	; 0x24
    ed76:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
    ed7a:	2b00      	cmp	r3, #0
    ed7c:	f174 0300 	sbcs.w	r3, r4, #0
    ed80:	db20      	blt.n	edc4 <z_add_timeout+0x98>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
    ed82:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	; 0x60
    ed86:	f7ff ff73 	bl	ec70 <elapsed>
    ed8a:	4603      	mov	r3, r0
    ed8c:	4618      	mov	r0, r3
    ed8e:	ea4f 71e0 	mov.w	r1, r0, asr #31
    ed92:	4b7d      	ldr	r3, [pc, #500]	; (ef88 <z_add_timeout+0x25c>)
    ed94:	e9d3 2300 	ldrd	r2, r3, [r3]
    ed98:	eb10 0a02 	adds.w	sl, r0, r2
    ed9c:	eb41 0b03 	adc.w	fp, r1, r3
    eda0:	eb14 080a 	adds.w	r8, r4, sl
    eda4:	eb45 090b 	adc.w	r9, r5, fp
    eda8:	f06f 0201 	mvn.w	r2, #1
    edac:	f04f 33ff 	mov.w	r3, #4294967295
    edb0:	ebb2 0108 	subs.w	r1, r2, r8
    edb4:	61b9      	str	r1, [r7, #24]
    edb6:	eb63 0309 	sbc.w	r3, r3, r9
    edba:	61fb      	str	r3, [r7, #28]
    edbc:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    edc0:	e9c7 3418 	strd	r3, r4, [r7, #96]	; 0x60
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
    edc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    edc6:	4618      	mov	r0, r3
    edc8:	f009 f9b5 	bl	18136 <sys_dnode_is_linked>
    edcc:	4603      	mov	r3, r0
    edce:	2b00      	cmp	r3, #0
    edd0:	d00c      	beq.n	edec <z_add_timeout+0xc0>
    edd2:	236c      	movs	r3, #108	; 0x6c
    edd4:	4a6d      	ldr	r2, [pc, #436]	; (ef8c <z_add_timeout+0x260>)
    edd6:	496e      	ldr	r1, [pc, #440]	; (ef90 <z_add_timeout+0x264>)
    edd8:	486e      	ldr	r0, [pc, #440]	; (ef94 <z_add_timeout+0x268>)
    edda:	f001 f945 	bl	10068 <printk>
    edde:	486e      	ldr	r0, [pc, #440]	; (ef98 <z_add_timeout+0x26c>)
    ede0:	f001 f942 	bl	10068 <printk>
    ede4:	216c      	movs	r1, #108	; 0x6c
    ede6:	4869      	ldr	r0, [pc, #420]	; (ef8c <z_add_timeout+0x260>)
    ede8:	f001 ff86 	bl	10cf8 <assert_post_action>
	to->fn = fn;
    edec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    edee:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    edf0:	609a      	str	r2, [r3, #8]
	ticks = MAX(1, ticks);
    edf2:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
    edf6:	2a01      	cmp	r2, #1
    edf8:	f173 0100 	sbcs.w	r1, r3, #0
    edfc:	da03      	bge.n	ee06 <z_add_timeout+0xda>
    edfe:	f04f 0201 	mov.w	r2, #1
    ee02:	f04f 0300 	mov.w	r3, #0
    ee06:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60

	LOCKED(&timeout_lock) {
    ee0a:	2300      	movs	r3, #0
    ee0c:	647b      	str	r3, [r7, #68]	; 0x44
    ee0e:	4b63      	ldr	r3, [pc, #396]	; (ef9c <z_add_timeout+0x270>)
    ee10:	65bb      	str	r3, [r7, #88]	; 0x58
	__asm__ volatile(
    ee12:	f04f 0320 	mov.w	r3, #32
    ee16:	f3ef 8211 	mrs	r2, BASEPRI
    ee1a:	f383 8811 	msr	BASEPRI, r3
    ee1e:	f3bf 8f6f 	isb	sy
    ee22:	657a      	str	r2, [r7, #84]	; 0x54
    ee24:	653b      	str	r3, [r7, #80]	; 0x50
	return key;
    ee26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
	k.key = arch_irq_lock();
    ee28:	63bb      	str	r3, [r7, #56]	; 0x38
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    ee2a:	6db8      	ldr	r0, [r7, #88]	; 0x58
    ee2c:	f7ff fe14 	bl	ea58 <z_spin_lock_valid>
    ee30:	4603      	mov	r3, r0
    ee32:	f083 0301 	eor.w	r3, r3, #1
    ee36:	b2db      	uxtb	r3, r3
    ee38:	2b00      	cmp	r3, #0
    ee3a:	d00d      	beq.n	ee58 <z_add_timeout+0x12c>
    ee3c:	2378      	movs	r3, #120	; 0x78
    ee3e:	4a58      	ldr	r2, [pc, #352]	; (efa0 <z_add_timeout+0x274>)
    ee40:	4958      	ldr	r1, [pc, #352]	; (efa4 <z_add_timeout+0x278>)
    ee42:	4854      	ldr	r0, [pc, #336]	; (ef94 <z_add_timeout+0x268>)
    ee44:	f001 f910 	bl	10068 <printk>
    ee48:	6db9      	ldr	r1, [r7, #88]	; 0x58
    ee4a:	4857      	ldr	r0, [pc, #348]	; (efa8 <z_add_timeout+0x27c>)
    ee4c:	f001 f90c 	bl	10068 <printk>
    ee50:	2178      	movs	r1, #120	; 0x78
    ee52:	4853      	ldr	r0, [pc, #332]	; (efa0 <z_add_timeout+0x274>)
    ee54:	f001 ff50 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    ee58:	6db8      	ldr	r0, [r7, #88]	; 0x58
    ee5a:	f7ff fe35 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    ee5e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    ee60:	643b      	str	r3, [r7, #64]	; 0x40
    ee62:	e088      	b.n	ef76 <z_add_timeout+0x24a>
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    ee64:	f7ff ff04 	bl	ec70 <elapsed>
    ee68:	4603      	mov	r3, r0
    ee6a:	4618      	mov	r0, r3
    ee6c:	ea4f 71e0 	mov.w	r1, r0, asr #31
    ee70:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
    ee74:	1884      	adds	r4, r0, r2
    ee76:	613c      	str	r4, [r7, #16]
    ee78:	eb41 0303 	adc.w	r3, r1, r3
    ee7c:	617b      	str	r3, [r7, #20]
    ee7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    ee80:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
    ee84:	e9c3 1204 	strd	r1, r2, [r3, #16]
		for (t = first(); t != NULL; t = next(t)) {
    ee88:	f7ff fed2 	bl	ec30 <first>
    ee8c:	65f8      	str	r0, [r7, #92]	; 0x5c
    ee8e:	e034      	b.n	eefa <z_add_timeout+0x1ce>
			if (t->dticks > to->dticks) {
    ee90:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    ee92:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    ee96:	6b79      	ldr	r1, [r7, #52]	; 0x34
    ee98:	e9d1 0104 	ldrd	r0, r1, [r1, #16]
    ee9c:	4290      	cmp	r0, r2
    ee9e:	eb71 0303 	sbcs.w	r3, r1, r3
    eea2:	da16      	bge.n	eed2 <z_add_timeout+0x1a6>
				t->dticks -= to->dticks;
    eea4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    eea6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    eeaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    eeac:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    eeb0:	1a84      	subs	r4, r0, r2
    eeb2:	60bc      	str	r4, [r7, #8]
    eeb4:	eb61 0303 	sbc.w	r3, r1, r3
    eeb8:	60fb      	str	r3, [r7, #12]
    eeba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    eebc:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
    eec0:	e9c3 1204 	strd	r1, r2, [r3, #16]
				sys_dlist_insert(&t->node, &to->node);
    eec4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    eec6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    eec8:	4611      	mov	r1, r2
    eeca:	4618      	mov	r0, r3
    eecc:	f009 f9a4 	bl	18218 <sys_dlist_insert>
				break;
    eed0:	e016      	b.n	ef00 <z_add_timeout+0x1d4>
			}
			to->dticks -= t->dticks;
    eed2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    eed4:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    eed8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    eeda:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    eede:	1a84      	subs	r4, r0, r2
    eee0:	603c      	str	r4, [r7, #0]
    eee2:	eb61 0303 	sbc.w	r3, r1, r3
    eee6:	607b      	str	r3, [r7, #4]
    eee8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    eeea:	e9d7 1200 	ldrd	r1, r2, [r7]
    eeee:	e9c3 1204 	strd	r1, r2, [r3, #16]
		for (t = first(); t != NULL; t = next(t)) {
    eef2:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    eef4:	f7ff feaa 	bl	ec4c <next>
    eef8:	65f8      	str	r0, [r7, #92]	; 0x5c
    eefa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    eefc:	2b00      	cmp	r3, #0
    eefe:	d1c7      	bne.n	ee90 <z_add_timeout+0x164>
		}

		if (t == NULL) {
    ef00:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    ef02:	2b00      	cmp	r3, #0
    ef04:	d104      	bne.n	ef10 <z_add_timeout+0x1e4>
			sys_dlist_append(&timeout_list, &to->node);
    ef06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    ef08:	4619      	mov	r1, r3
    ef0a:	4828      	ldr	r0, [pc, #160]	; (efac <z_add_timeout+0x280>)
    ef0c:	f009 f96c 	bl	181e8 <sys_dlist_append>
		}

		if (to == first()) {
    ef10:	f7ff fe8e 	bl	ec30 <first>
    ef14:	4602      	mov	r2, r0
    ef16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    ef18:	4293      	cmp	r3, r2
    ef1a:	d106      	bne.n	ef2a <z_add_timeout+0x1fe>
			z_clock_set_timeout(next_timeout(), false);
    ef1c:	f7ff feb8 	bl	ec90 <next_timeout>
    ef20:	4603      	mov	r3, r0
    ef22:	2100      	movs	r1, #0
    ef24:	4618      	mov	r0, r3
    ef26:	f7f5 fa2d 	bl	4384 <z_clock_set_timeout>
    ef2a:	4b1c      	ldr	r3, [pc, #112]	; (ef9c <z_add_timeout+0x270>)
    ef2c:	64fb      	str	r3, [r7, #76]	; 0x4c
    ef2e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    ef30:	63fb      	str	r3, [r7, #60]	; 0x3c
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    ef32:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    ef34:	f7ff fdac 	bl	ea90 <z_spin_unlock_valid>
    ef38:	4603      	mov	r3, r0
    ef3a:	f083 0301 	eor.w	r3, r3, #1
    ef3e:	b2db      	uxtb	r3, r3
    ef40:	2b00      	cmp	r3, #0
    ef42:	d00d      	beq.n	ef60 <z_add_timeout+0x234>
    ef44:	23a3      	movs	r3, #163	; 0xa3
    ef46:	4a16      	ldr	r2, [pc, #88]	; (efa0 <z_add_timeout+0x274>)
    ef48:	4919      	ldr	r1, [pc, #100]	; (efb0 <z_add_timeout+0x284>)
    ef4a:	4812      	ldr	r0, [pc, #72]	; (ef94 <z_add_timeout+0x268>)
    ef4c:	f001 f88c 	bl	10068 <printk>
    ef50:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    ef52:	4818      	ldr	r0, [pc, #96]	; (efb4 <z_add_timeout+0x288>)
    ef54:	f001 f888 	bl	10068 <printk>
    ef58:	21a3      	movs	r1, #163	; 0xa3
    ef5a:	4811      	ldr	r0, [pc, #68]	; (efa0 <z_add_timeout+0x274>)
    ef5c:	f001 fecc 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    ef60:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    ef62:	64bb      	str	r3, [r7, #72]	; 0x48
	__asm__ volatile(
    ef64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    ef66:	f383 8811 	msr	BASEPRI, r3
    ef6a:	f3bf 8f6f 	isb	sy
}
    ef6e:	bf00      	nop
}
    ef70:	bf00      	nop
	LOCKED(&timeout_lock) {
    ef72:	2301      	movs	r3, #1
    ef74:	647b      	str	r3, [r7, #68]	; 0x44
    ef76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    ef78:	2b00      	cmp	r3, #0
    ef7a:	f43f af73 	beq.w	ee64 <z_add_timeout+0x138>
		}
	}
}
    ef7e:	3768      	adds	r7, #104	; 0x68
    ef80:	46bd      	mov	sp, r7
    ef82:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
    ef86:	bf00      	nop
    ef88:	20000638 	.word	0x20000638
    ef8c:	0001c808 	.word	0x0001c808
    ef90:	0001c82c 	.word	0x0001c82c
    ef94:	0001c84c 	.word	0x0001c84c
    ef98:	0001c86c 	.word	0x0001c86c
    ef9c:	20000d20 	.word	0x20000d20
    efa0:	0001c870 	.word	0x0001c870
    efa4:	0001c898 	.word	0x0001c898
    efa8:	0001c8b0 	.word	0x0001c8b0
    efac:	20000180 	.word	0x20000180
    efb0:	0001c8c8 	.word	0x0001c8c8
    efb4:	0001c8e0 	.word	0x0001c8e0

0000efb8 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    efb8:	b580      	push	{r7, lr}
    efba:	b08c      	sub	sp, #48	; 0x30
    efbc:	af00      	add	r7, sp, #0
    efbe:	6078      	str	r0, [r7, #4]
	int ret = -EINVAL;
    efc0:	f06f 0315 	mvn.w	r3, #21
    efc4:	62fb      	str	r3, [r7, #44]	; 0x2c

	LOCKED(&timeout_lock) {
    efc6:	2300      	movs	r3, #0
    efc8:	617b      	str	r3, [r7, #20]
    efca:	4b32      	ldr	r3, [pc, #200]	; (f094 <z_abort_timeout+0xdc>)
    efcc:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    efce:	f04f 0320 	mov.w	r3, #32
    efd2:	f3ef 8211 	mrs	r2, BASEPRI
    efd6:	f383 8811 	msr	BASEPRI, r3
    efda:	f3bf 8f6f 	isb	sy
    efde:	627a      	str	r2, [r7, #36]	; 0x24
    efe0:	623b      	str	r3, [r7, #32]
	return key;
    efe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	k.key = arch_irq_lock();
    efe4:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    efe6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    efe8:	f7ff fd36 	bl	ea58 <z_spin_lock_valid>
    efec:	4603      	mov	r3, r0
    efee:	f083 0301 	eor.w	r3, r3, #1
    eff2:	b2db      	uxtb	r3, r3
    eff4:	2b00      	cmp	r3, #0
    eff6:	d00d      	beq.n	f014 <z_abort_timeout+0x5c>
    eff8:	2378      	movs	r3, #120	; 0x78
    effa:	4a27      	ldr	r2, [pc, #156]	; (f098 <z_abort_timeout+0xe0>)
    effc:	4927      	ldr	r1, [pc, #156]	; (f09c <z_abort_timeout+0xe4>)
    effe:	4828      	ldr	r0, [pc, #160]	; (f0a0 <z_abort_timeout+0xe8>)
    f000:	f001 f832 	bl	10068 <printk>
    f004:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    f006:	4827      	ldr	r0, [pc, #156]	; (f0a4 <z_abort_timeout+0xec>)
    f008:	f001 f82e 	bl	10068 <printk>
    f00c:	2178      	movs	r1, #120	; 0x78
    f00e:	4822      	ldr	r0, [pc, #136]	; (f098 <z_abort_timeout+0xe0>)
    f010:	f001 fe72 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f014:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    f016:	f7ff fd57 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f01a:	68bb      	ldr	r3, [r7, #8]
    f01c:	613b      	str	r3, [r7, #16]
    f01e:	e031      	b.n	f084 <z_abort_timeout+0xcc>
		if (sys_dnode_is_linked(&to->node)) {
    f020:	687b      	ldr	r3, [r7, #4]
    f022:	4618      	mov	r0, r3
    f024:	f009 f887 	bl	18136 <sys_dnode_is_linked>
    f028:	4603      	mov	r3, r0
    f02a:	2b00      	cmp	r3, #0
    f02c:	d004      	beq.n	f038 <z_abort_timeout+0x80>
			remove_timeout(to);
    f02e:	6878      	ldr	r0, [r7, #4]
    f030:	f009 f91f 	bl	18272 <remove_timeout>
			ret = 0;
    f034:	2300      	movs	r3, #0
    f036:	62fb      	str	r3, [r7, #44]	; 0x2c
    f038:	4b16      	ldr	r3, [pc, #88]	; (f094 <z_abort_timeout+0xdc>)
    f03a:	61fb      	str	r3, [r7, #28]
    f03c:	693b      	ldr	r3, [r7, #16]
    f03e:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f040:	69f8      	ldr	r0, [r7, #28]
    f042:	f7ff fd25 	bl	ea90 <z_spin_unlock_valid>
    f046:	4603      	mov	r3, r0
    f048:	f083 0301 	eor.w	r3, r3, #1
    f04c:	b2db      	uxtb	r3, r3
    f04e:	2b00      	cmp	r3, #0
    f050:	d00d      	beq.n	f06e <z_abort_timeout+0xb6>
    f052:	23a3      	movs	r3, #163	; 0xa3
    f054:	4a10      	ldr	r2, [pc, #64]	; (f098 <z_abort_timeout+0xe0>)
    f056:	4914      	ldr	r1, [pc, #80]	; (f0a8 <z_abort_timeout+0xf0>)
    f058:	4811      	ldr	r0, [pc, #68]	; (f0a0 <z_abort_timeout+0xe8>)
    f05a:	f001 f805 	bl	10068 <printk>
    f05e:	69f9      	ldr	r1, [r7, #28]
    f060:	4812      	ldr	r0, [pc, #72]	; (f0ac <z_abort_timeout+0xf4>)
    f062:	f001 f801 	bl	10068 <printk>
    f066:	21a3      	movs	r1, #163	; 0xa3
    f068:	480b      	ldr	r0, [pc, #44]	; (f098 <z_abort_timeout+0xe0>)
    f06a:	f001 fe45 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f06e:	68fb      	ldr	r3, [r7, #12]
    f070:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
    f072:	69bb      	ldr	r3, [r7, #24]
    f074:	f383 8811 	msr	BASEPRI, r3
    f078:	f3bf 8f6f 	isb	sy
}
    f07c:	bf00      	nop
}
    f07e:	bf00      	nop
	LOCKED(&timeout_lock) {
    f080:	2301      	movs	r3, #1
    f082:	617b      	str	r3, [r7, #20]
    f084:	697b      	ldr	r3, [r7, #20]
    f086:	2b00      	cmp	r3, #0
    f088:	d0ca      	beq.n	f020 <z_abort_timeout+0x68>
		}
	}

	return ret;
    f08a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
    f08c:	4618      	mov	r0, r3
    f08e:	3730      	adds	r7, #48	; 0x30
    f090:	46bd      	mov	sp, r7
    f092:	bd80      	pop	{r7, pc}
    f094:	20000d20 	.word	0x20000d20
    f098:	0001c870 	.word	0x0001c870
    f09c:	0001c898 	.word	0x0001c898
    f0a0:	0001c84c 	.word	0x0001c84c
    f0a4:	0001c8b0 	.word	0x0001c8b0
    f0a8:	0001c8c8 	.word	0x0001c8c8
    f0ac:	0001c8e0 	.word	0x0001c8e0

0000f0b0 <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
    f0b0:	b580      	push	{r7, lr}
    f0b2:	b08a      	sub	sp, #40	; 0x28
    f0b4:	af00      	add	r7, sp, #0
	int32_t ret = (int32_t) K_TICKS_FOREVER;
    f0b6:	f04f 33ff 	mov.w	r3, #4294967295
    f0ba:	627b      	str	r3, [r7, #36]	; 0x24

	LOCKED(&timeout_lock) {
    f0bc:	2300      	movs	r3, #0
    f0be:	60fb      	str	r3, [r7, #12]
    f0c0:	4b2d      	ldr	r3, [pc, #180]	; (f178 <z_get_next_timeout_expiry+0xc8>)
    f0c2:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    f0c4:	f04f 0320 	mov.w	r3, #32
    f0c8:	f3ef 8211 	mrs	r2, BASEPRI
    f0cc:	f383 8811 	msr	BASEPRI, r3
    f0d0:	f3bf 8f6f 	isb	sy
    f0d4:	61fa      	str	r2, [r7, #28]
    f0d6:	61bb      	str	r3, [r7, #24]
	return key;
    f0d8:	69fb      	ldr	r3, [r7, #28]
	k.key = arch_irq_lock();
    f0da:	603b      	str	r3, [r7, #0]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    f0dc:	6a38      	ldr	r0, [r7, #32]
    f0de:	f7ff fcbb 	bl	ea58 <z_spin_lock_valid>
    f0e2:	4603      	mov	r3, r0
    f0e4:	f083 0301 	eor.w	r3, r3, #1
    f0e8:	b2db      	uxtb	r3, r3
    f0ea:	2b00      	cmp	r3, #0
    f0ec:	d00d      	beq.n	f10a <z_get_next_timeout_expiry+0x5a>
    f0ee:	2378      	movs	r3, #120	; 0x78
    f0f0:	4a22      	ldr	r2, [pc, #136]	; (f17c <z_get_next_timeout_expiry+0xcc>)
    f0f2:	4923      	ldr	r1, [pc, #140]	; (f180 <z_get_next_timeout_expiry+0xd0>)
    f0f4:	4823      	ldr	r0, [pc, #140]	; (f184 <z_get_next_timeout_expiry+0xd4>)
    f0f6:	f000 ffb7 	bl	10068 <printk>
    f0fa:	6a39      	ldr	r1, [r7, #32]
    f0fc:	4822      	ldr	r0, [pc, #136]	; (f188 <z_get_next_timeout_expiry+0xd8>)
    f0fe:	f000 ffb3 	bl	10068 <printk>
    f102:	2178      	movs	r1, #120	; 0x78
    f104:	481d      	ldr	r0, [pc, #116]	; (f17c <z_get_next_timeout_expiry+0xcc>)
    f106:	f001 fdf7 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f10a:	6a38      	ldr	r0, [r7, #32]
    f10c:	f7ff fcdc 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f110:	683b      	ldr	r3, [r7, #0]
    f112:	60bb      	str	r3, [r7, #8]
    f114:	e028      	b.n	f168 <z_get_next_timeout_expiry+0xb8>
		ret = next_timeout();
    f116:	f7ff fdbb 	bl	ec90 <next_timeout>
    f11a:	6278      	str	r0, [r7, #36]	; 0x24
    f11c:	4b16      	ldr	r3, [pc, #88]	; (f178 <z_get_next_timeout_expiry+0xc8>)
    f11e:	617b      	str	r3, [r7, #20]
    f120:	68bb      	ldr	r3, [r7, #8]
    f122:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f124:	6978      	ldr	r0, [r7, #20]
    f126:	f7ff fcb3 	bl	ea90 <z_spin_unlock_valid>
    f12a:	4603      	mov	r3, r0
    f12c:	f083 0301 	eor.w	r3, r3, #1
    f130:	b2db      	uxtb	r3, r3
    f132:	2b00      	cmp	r3, #0
    f134:	d00d      	beq.n	f152 <z_get_next_timeout_expiry+0xa2>
    f136:	23a3      	movs	r3, #163	; 0xa3
    f138:	4a10      	ldr	r2, [pc, #64]	; (f17c <z_get_next_timeout_expiry+0xcc>)
    f13a:	4914      	ldr	r1, [pc, #80]	; (f18c <z_get_next_timeout_expiry+0xdc>)
    f13c:	4811      	ldr	r0, [pc, #68]	; (f184 <z_get_next_timeout_expiry+0xd4>)
    f13e:	f000 ff93 	bl	10068 <printk>
    f142:	6979      	ldr	r1, [r7, #20]
    f144:	4812      	ldr	r0, [pc, #72]	; (f190 <z_get_next_timeout_expiry+0xe0>)
    f146:	f000 ff8f 	bl	10068 <printk>
    f14a:	21a3      	movs	r1, #163	; 0xa3
    f14c:	480b      	ldr	r0, [pc, #44]	; (f17c <z_get_next_timeout_expiry+0xcc>)
    f14e:	f001 fdd3 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f152:	687b      	ldr	r3, [r7, #4]
    f154:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
    f156:	693b      	ldr	r3, [r7, #16]
    f158:	f383 8811 	msr	BASEPRI, r3
    f15c:	f3bf 8f6f 	isb	sy
}
    f160:	bf00      	nop
}
    f162:	bf00      	nop
	LOCKED(&timeout_lock) {
    f164:	2301      	movs	r3, #1
    f166:	60fb      	str	r3, [r7, #12]
    f168:	68fb      	ldr	r3, [r7, #12]
    f16a:	2b00      	cmp	r3, #0
    f16c:	d0d3      	beq.n	f116 <z_get_next_timeout_expiry+0x66>
	}
	return ret;
    f16e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    f170:	4618      	mov	r0, r3
    f172:	3728      	adds	r7, #40	; 0x28
    f174:	46bd      	mov	sp, r7
    f176:	bd80      	pop	{r7, pc}
    f178:	20000d20 	.word	0x20000d20
    f17c:	0001c870 	.word	0x0001c870
    f180:	0001c898 	.word	0x0001c898
    f184:	0001c84c 	.word	0x0001c84c
    f188:	0001c8b0 	.word	0x0001c8b0
    f18c:	0001c8c8 	.word	0x0001c8c8
    f190:	0001c8e0 	.word	0x0001c8e0

0000f194 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    f194:	b580      	push	{r7, lr}
    f196:	b08e      	sub	sp, #56	; 0x38
    f198:	af00      	add	r7, sp, #0
    f19a:	6078      	str	r0, [r7, #4]
    f19c:	460b      	mov	r3, r1
    f19e:	70fb      	strb	r3, [r7, #3]
	LOCKED(&timeout_lock) {
    f1a0:	2300      	movs	r3, #0
    f1a2:	61bb      	str	r3, [r7, #24]
    f1a4:	4b42      	ldr	r3, [pc, #264]	; (f2b0 <z_set_timeout_expiry+0x11c>)
    f1a6:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
    f1a8:	f04f 0320 	mov.w	r3, #32
    f1ac:	f3ef 8211 	mrs	r2, BASEPRI
    f1b0:	f383 8811 	msr	BASEPRI, r3
    f1b4:	f3bf 8f6f 	isb	sy
    f1b8:	62ba      	str	r2, [r7, #40]	; 0x28
    f1ba:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
    f1bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
	k.key = arch_irq_lock();
    f1be:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    f1c0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    f1c2:	f7ff fc49 	bl	ea58 <z_spin_lock_valid>
    f1c6:	4603      	mov	r3, r0
    f1c8:	f083 0301 	eor.w	r3, r3, #1
    f1cc:	b2db      	uxtb	r3, r3
    f1ce:	2b00      	cmp	r3, #0
    f1d0:	d00d      	beq.n	f1ee <z_set_timeout_expiry+0x5a>
    f1d2:	2378      	movs	r3, #120	; 0x78
    f1d4:	4a37      	ldr	r2, [pc, #220]	; (f2b4 <z_set_timeout_expiry+0x120>)
    f1d6:	4938      	ldr	r1, [pc, #224]	; (f2b8 <z_set_timeout_expiry+0x124>)
    f1d8:	4838      	ldr	r0, [pc, #224]	; (f2bc <z_set_timeout_expiry+0x128>)
    f1da:	f000 ff45 	bl	10068 <printk>
    f1de:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    f1e0:	4837      	ldr	r0, [pc, #220]	; (f2c0 <z_set_timeout_expiry+0x12c>)
    f1e2:	f000 ff41 	bl	10068 <printk>
    f1e6:	2178      	movs	r1, #120	; 0x78
    f1e8:	4832      	ldr	r0, [pc, #200]	; (f2b4 <z_set_timeout_expiry+0x120>)
    f1ea:	f001 fd85 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f1ee:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    f1f0:	f7ff fc6a 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f1f4:	68fb      	ldr	r3, [r7, #12]
    f1f6:	617b      	str	r3, [r7, #20]
    f1f8:	e052      	b.n	f2a0 <z_set_timeout_expiry+0x10c>
		int next_to = next_timeout();
    f1fa:	f7ff fd49 	bl	ec90 <next_timeout>
    f1fe:	6378      	str	r0, [r7, #52]	; 0x34
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks < next_to);
    f200:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f202:	f1b3 3fff 	cmp.w	r3, #4294967295
    f206:	d003      	beq.n	f210 <z_set_timeout_expiry+0x7c>
    f208:	687a      	ldr	r2, [r7, #4]
    f20a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f20c:	429a      	cmp	r2, r3
    f20e:	da01      	bge.n	f214 <z_set_timeout_expiry+0x80>
    f210:	2301      	movs	r3, #1
    f212:	e000      	b.n	f216 <z_set_timeout_expiry+0x82>
    f214:	2300      	movs	r3, #0
		bool sooner = (next_to == K_TICKS_FOREVER)
    f216:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    f21a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    f21e:	f003 0301 	and.w	r3, r3, #1
    f222:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
		bool imminent = next_to <= 1;
    f226:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f228:	2b01      	cmp	r3, #1
    f22a:	bfd4      	ite	le
    f22c:	2301      	movle	r3, #1
    f22e:	2300      	movgt	r3, #0
    f230:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    f234:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    f238:	f083 0301 	eor.w	r3, r3, #1
    f23c:	b2db      	uxtb	r3, r3
    f23e:	2b00      	cmp	r3, #0
    f240:	d008      	beq.n	f254 <z_set_timeout_expiry+0xc0>
    f242:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    f246:	2b00      	cmp	r3, #0
    f248:	d004      	beq.n	f254 <z_set_timeout_expiry+0xc0>
			z_clock_set_timeout(ticks, is_idle);
    f24a:	78fb      	ldrb	r3, [r7, #3]
    f24c:	4619      	mov	r1, r3
    f24e:	6878      	ldr	r0, [r7, #4]
    f250:	f7f5 f898 	bl	4384 <z_clock_set_timeout>
    f254:	4b16      	ldr	r3, [pc, #88]	; (f2b0 <z_set_timeout_expiry+0x11c>)
    f256:	623b      	str	r3, [r7, #32]
    f258:	697b      	ldr	r3, [r7, #20]
    f25a:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f25c:	6a38      	ldr	r0, [r7, #32]
    f25e:	f7ff fc17 	bl	ea90 <z_spin_unlock_valid>
    f262:	4603      	mov	r3, r0
    f264:	f083 0301 	eor.w	r3, r3, #1
    f268:	b2db      	uxtb	r3, r3
    f26a:	2b00      	cmp	r3, #0
    f26c:	d00d      	beq.n	f28a <z_set_timeout_expiry+0xf6>
    f26e:	23a3      	movs	r3, #163	; 0xa3
    f270:	4a10      	ldr	r2, [pc, #64]	; (f2b4 <z_set_timeout_expiry+0x120>)
    f272:	4914      	ldr	r1, [pc, #80]	; (f2c4 <z_set_timeout_expiry+0x130>)
    f274:	4811      	ldr	r0, [pc, #68]	; (f2bc <z_set_timeout_expiry+0x128>)
    f276:	f000 fef7 	bl	10068 <printk>
    f27a:	6a39      	ldr	r1, [r7, #32]
    f27c:	4812      	ldr	r0, [pc, #72]	; (f2c8 <z_set_timeout_expiry+0x134>)
    f27e:	f000 fef3 	bl	10068 <printk>
    f282:	21a3      	movs	r1, #163	; 0xa3
    f284:	480b      	ldr	r0, [pc, #44]	; (f2b4 <z_set_timeout_expiry+0x120>)
    f286:	f001 fd37 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f28a:	693b      	ldr	r3, [r7, #16]
    f28c:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
    f28e:	69fb      	ldr	r3, [r7, #28]
    f290:	f383 8811 	msr	BASEPRI, r3
    f294:	f3bf 8f6f 	isb	sy
}
    f298:	bf00      	nop
}
    f29a:	bf00      	nop
	LOCKED(&timeout_lock) {
    f29c:	2301      	movs	r3, #1
    f29e:	61bb      	str	r3, [r7, #24]
    f2a0:	69bb      	ldr	r3, [r7, #24]
    f2a2:	2b00      	cmp	r3, #0
    f2a4:	d0a9      	beq.n	f1fa <z_set_timeout_expiry+0x66>
		}
	}
}
    f2a6:	bf00      	nop
    f2a8:	bf00      	nop
    f2aa:	3738      	adds	r7, #56	; 0x38
    f2ac:	46bd      	mov	sp, r7
    f2ae:	bd80      	pop	{r7, pc}
    f2b0:	20000d20 	.word	0x20000d20
    f2b4:	0001c870 	.word	0x0001c870
    f2b8:	0001c898 	.word	0x0001c898
    f2bc:	0001c84c 	.word	0x0001c84c
    f2c0:	0001c8b0 	.word	0x0001c8b0
    f2c4:	0001c8c8 	.word	0x0001c8c8
    f2c8:	0001c8e0 	.word	0x0001c8e0

0000f2cc <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
    f2cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f2d0:	b095      	sub	sp, #84	; 0x54
    f2d2:	af00      	add	r7, sp, #0
    f2d4:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    f2d6:	6878      	ldr	r0, [r7, #4]
    f2d8:	f7fd fa7c 	bl	c7d4 <z_time_slice>
    f2dc:	4b87      	ldr	r3, [pc, #540]	; (f4fc <z_clock_announce+0x230>)
    f2de:	647b      	str	r3, [r7, #68]	; 0x44
	__asm__ volatile(
    f2e0:	f04f 0320 	mov.w	r3, #32
    f2e4:	f3ef 8211 	mrs	r2, BASEPRI
    f2e8:	f383 8811 	msr	BASEPRI, r3
    f2ec:	f3bf 8f6f 	isb	sy
    f2f0:	643a      	str	r2, [r7, #64]	; 0x40
    f2f2:	63fb      	str	r3, [r7, #60]	; 0x3c
	return key;
    f2f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
	k.key = arch_irq_lock();
    f2f6:	617b      	str	r3, [r7, #20]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    f2f8:	6c78      	ldr	r0, [r7, #68]	; 0x44
    f2fa:	f7ff fbad 	bl	ea58 <z_spin_lock_valid>
    f2fe:	4603      	mov	r3, r0
    f300:	f083 0301 	eor.w	r3, r3, #1
    f304:	b2db      	uxtb	r3, r3
    f306:	2b00      	cmp	r3, #0
    f308:	d00d      	beq.n	f326 <z_clock_announce+0x5a>
    f30a:	2378      	movs	r3, #120	; 0x78
    f30c:	4a7c      	ldr	r2, [pc, #496]	; (f500 <z_clock_announce+0x234>)
    f30e:	497d      	ldr	r1, [pc, #500]	; (f504 <z_clock_announce+0x238>)
    f310:	487d      	ldr	r0, [pc, #500]	; (f508 <z_clock_announce+0x23c>)
    f312:	f000 fea9 	bl	10068 <printk>
    f316:	6c79      	ldr	r1, [r7, #68]	; 0x44
    f318:	487c      	ldr	r0, [pc, #496]	; (f50c <z_clock_announce+0x240>)
    f31a:	f000 fea5 	bl	10068 <printk>
    f31e:	2178      	movs	r1, #120	; 0x78
    f320:	4877      	ldr	r0, [pc, #476]	; (f500 <z_clock_announce+0x234>)
    f322:	f001 fce9 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f326:	6c78      	ldr	r0, [r7, #68]	; 0x44
    f328:	f7ff fbce 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f32c:	697b      	ldr	r3, [r7, #20]
    f32e:	61fb      	str	r3, [r7, #28]
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    f330:	4a77      	ldr	r2, [pc, #476]	; (f510 <z_clock_announce+0x244>)
    f332:	687b      	ldr	r3, [r7, #4]
    f334:	6013      	str	r3, [r2, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    f336:	e077      	b.n	f428 <z_clock_announce+0x15c>
		struct _timeout *t = first();
    f338:	f7ff fc7a 	bl	ec30 <first>
    f33c:	64f8      	str	r0, [r7, #76]	; 0x4c
		int dt = t->dticks;
    f33e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    f340:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    f344:	4613      	mov	r3, r2
    f346:	64bb      	str	r3, [r7, #72]	; 0x48

		curr_tick += dt;
    f348:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    f34a:	4618      	mov	r0, r3
    f34c:	ea4f 71e0 	mov.w	r1, r0, asr #31
    f350:	4b70      	ldr	r3, [pc, #448]	; (f514 <z_clock_announce+0x248>)
    f352:	e9d3 2300 	ldrd	r2, r3, [r3]
    f356:	eb10 0a02 	adds.w	sl, r0, r2
    f35a:	eb41 0b03 	adc.w	fp, r1, r3
    f35e:	4b6d      	ldr	r3, [pc, #436]	; (f514 <z_clock_announce+0x248>)
    f360:	e9c3 ab00 	strd	sl, fp, [r3]
		announce_remaining -= dt;
    f364:	4b6a      	ldr	r3, [pc, #424]	; (f510 <z_clock_announce+0x244>)
    f366:	681a      	ldr	r2, [r3, #0]
    f368:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    f36a:	1ad3      	subs	r3, r2, r3
    f36c:	4a68      	ldr	r2, [pc, #416]	; (f510 <z_clock_announce+0x244>)
    f36e:	6013      	str	r3, [r2, #0]
		t->dticks = 0;
    f370:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    f372:	f04f 0200 	mov.w	r2, #0
    f376:	f04f 0300 	mov.w	r3, #0
    f37a:	e9c1 2304 	strd	r2, r3, [r1, #16]
		remove_timeout(t);
    f37e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    f380:	f008 ff77 	bl	18272 <remove_timeout>
    f384:	4b5d      	ldr	r3, [pc, #372]	; (f4fc <z_clock_announce+0x230>)
    f386:	62fb      	str	r3, [r7, #44]	; 0x2c
    f388:	69fb      	ldr	r3, [r7, #28]
    f38a:	613b      	str	r3, [r7, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f38c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    f38e:	f7ff fb7f 	bl	ea90 <z_spin_unlock_valid>
    f392:	4603      	mov	r3, r0
    f394:	f083 0301 	eor.w	r3, r3, #1
    f398:	b2db      	uxtb	r3, r3
    f39a:	2b00      	cmp	r3, #0
    f39c:	d00d      	beq.n	f3ba <z_clock_announce+0xee>
    f39e:	23a3      	movs	r3, #163	; 0xa3
    f3a0:	4a57      	ldr	r2, [pc, #348]	; (f500 <z_clock_announce+0x234>)
    f3a2:	495d      	ldr	r1, [pc, #372]	; (f518 <z_clock_announce+0x24c>)
    f3a4:	4858      	ldr	r0, [pc, #352]	; (f508 <z_clock_announce+0x23c>)
    f3a6:	f000 fe5f 	bl	10068 <printk>
    f3aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    f3ac:	485b      	ldr	r0, [pc, #364]	; (f51c <z_clock_announce+0x250>)
    f3ae:	f000 fe5b 	bl	10068 <printk>
    f3b2:	21a3      	movs	r1, #163	; 0xa3
    f3b4:	4852      	ldr	r0, [pc, #328]	; (f500 <z_clock_announce+0x234>)
    f3b6:	f001 fc9f 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f3ba:	693b      	ldr	r3, [r7, #16]
    f3bc:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm__ volatile(
    f3be:	6abb      	ldr	r3, [r7, #40]	; 0x28
    f3c0:	f383 8811 	msr	BASEPRI, r3
    f3c4:	f3bf 8f6f 	isb	sy
}
    f3c8:	bf00      	nop
}
    f3ca:	bf00      	nop

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    f3cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    f3ce:	689b      	ldr	r3, [r3, #8]
    f3d0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    f3d2:	4798      	blx	r3
    f3d4:	4b49      	ldr	r3, [pc, #292]	; (f4fc <z_clock_announce+0x230>)
    f3d6:	63bb      	str	r3, [r7, #56]	; 0x38
	__asm__ volatile(
    f3d8:	f04f 0320 	mov.w	r3, #32
    f3dc:	f3ef 8211 	mrs	r2, BASEPRI
    f3e0:	f383 8811 	msr	BASEPRI, r3
    f3e4:	f3bf 8f6f 	isb	sy
    f3e8:	637a      	str	r2, [r7, #52]	; 0x34
    f3ea:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
    f3ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	k.key = arch_irq_lock();
    f3ee:	60fb      	str	r3, [r7, #12]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    f3f0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    f3f2:	f7ff fb31 	bl	ea58 <z_spin_lock_valid>
    f3f6:	4603      	mov	r3, r0
    f3f8:	f083 0301 	eor.w	r3, r3, #1
    f3fc:	b2db      	uxtb	r3, r3
    f3fe:	2b00      	cmp	r3, #0
    f400:	d00d      	beq.n	f41e <z_clock_announce+0x152>
    f402:	2378      	movs	r3, #120	; 0x78
    f404:	4a3e      	ldr	r2, [pc, #248]	; (f500 <z_clock_announce+0x234>)
    f406:	493f      	ldr	r1, [pc, #252]	; (f504 <z_clock_announce+0x238>)
    f408:	483f      	ldr	r0, [pc, #252]	; (f508 <z_clock_announce+0x23c>)
    f40a:	f000 fe2d 	bl	10068 <printk>
    f40e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    f410:	483e      	ldr	r0, [pc, #248]	; (f50c <z_clock_announce+0x240>)
    f412:	f000 fe29 	bl	10068 <printk>
    f416:	2178      	movs	r1, #120	; 0x78
    f418:	4839      	ldr	r0, [pc, #228]	; (f500 <z_clock_announce+0x234>)
    f41a:	f001 fc6d 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f41e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    f420:	f7ff fb52 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f424:	68fb      	ldr	r3, [r7, #12]
    f426:	61fb      	str	r3, [r7, #28]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    f428:	f7ff fc02 	bl	ec30 <first>
    f42c:	4603      	mov	r3, r0
    f42e:	2b00      	cmp	r3, #0
    f430:	d00e      	beq.n	f450 <z_clock_announce+0x184>
    f432:	f7ff fbfd 	bl	ec30 <first>
    f436:	4603      	mov	r3, r0
    f438:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
    f43c:	4934      	ldr	r1, [pc, #208]	; (f510 <z_clock_announce+0x244>)
    f43e:	6809      	ldr	r1, [r1, #0]
    f440:	4608      	mov	r0, r1
    f442:	ea4f 71e0 	mov.w	r1, r0, asr #31
    f446:	4290      	cmp	r0, r2
    f448:	eb71 0303 	sbcs.w	r3, r1, r3
    f44c:	f6bf af74 	bge.w	f338 <z_clock_announce+0x6c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    f450:	f7ff fbee 	bl	ec30 <first>
    f454:	4603      	mov	r3, r0
    f456:	2b00      	cmp	r3, #0
    f458:	d00f      	beq.n	f47a <z_clock_announce+0x1ae>
		first()->dticks -= announce_remaining;
    f45a:	f7ff fbe9 	bl	ec30 <first>
    f45e:	4606      	mov	r6, r0
    f460:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
    f464:	4b2a      	ldr	r3, [pc, #168]	; (f510 <z_clock_announce+0x244>)
    f466:	681b      	ldr	r3, [r3, #0]
    f468:	461a      	mov	r2, r3
    f46a:	ea4f 73e2 	mov.w	r3, r2, asr #31
    f46e:	ebb0 0802 	subs.w	r8, r0, r2
    f472:	eb61 0903 	sbc.w	r9, r1, r3
    f476:	e9c6 8904 	strd	r8, r9, [r6, #16]
	}

	curr_tick += announce_remaining;
    f47a:	4b25      	ldr	r3, [pc, #148]	; (f510 <z_clock_announce+0x244>)
    f47c:	681b      	ldr	r3, [r3, #0]
    f47e:	4618      	mov	r0, r3
    f480:	ea4f 71e0 	mov.w	r1, r0, asr #31
    f484:	4b23      	ldr	r3, [pc, #140]	; (f514 <z_clock_announce+0x248>)
    f486:	e9d3 2300 	ldrd	r2, r3, [r3]
    f48a:	1884      	adds	r4, r0, r2
    f48c:	eb41 0503 	adc.w	r5, r1, r3
    f490:	4b20      	ldr	r3, [pc, #128]	; (f514 <z_clock_announce+0x248>)
    f492:	e9c3 4500 	strd	r4, r5, [r3]
	announce_remaining = 0;
    f496:	4b1e      	ldr	r3, [pc, #120]	; (f510 <z_clock_announce+0x244>)
    f498:	2200      	movs	r2, #0
    f49a:	601a      	str	r2, [r3, #0]

	z_clock_set_timeout(next_timeout(), false);
    f49c:	f7ff fbf8 	bl	ec90 <next_timeout>
    f4a0:	4603      	mov	r3, r0
    f4a2:	2100      	movs	r1, #0
    f4a4:	4618      	mov	r0, r3
    f4a6:	f7f4 ff6d 	bl	4384 <z_clock_set_timeout>
    f4aa:	4b14      	ldr	r3, [pc, #80]	; (f4fc <z_clock_announce+0x230>)
    f4ac:	627b      	str	r3, [r7, #36]	; 0x24
    f4ae:	69fb      	ldr	r3, [r7, #28]
    f4b0:	61bb      	str	r3, [r7, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f4b2:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f4b4:	f7ff faec 	bl	ea90 <z_spin_unlock_valid>
    f4b8:	4603      	mov	r3, r0
    f4ba:	f083 0301 	eor.w	r3, r3, #1
    f4be:	b2db      	uxtb	r3, r3
    f4c0:	2b00      	cmp	r3, #0
    f4c2:	d00d      	beq.n	f4e0 <z_clock_announce+0x214>
    f4c4:	23a3      	movs	r3, #163	; 0xa3
    f4c6:	4a0e      	ldr	r2, [pc, #56]	; (f500 <z_clock_announce+0x234>)
    f4c8:	4913      	ldr	r1, [pc, #76]	; (f518 <z_clock_announce+0x24c>)
    f4ca:	480f      	ldr	r0, [pc, #60]	; (f508 <z_clock_announce+0x23c>)
    f4cc:	f000 fdcc 	bl	10068 <printk>
    f4d0:	6a79      	ldr	r1, [r7, #36]	; 0x24
    f4d2:	4812      	ldr	r0, [pc, #72]	; (f51c <z_clock_announce+0x250>)
    f4d4:	f000 fdc8 	bl	10068 <printk>
    f4d8:	21a3      	movs	r1, #163	; 0xa3
    f4da:	4809      	ldr	r0, [pc, #36]	; (f500 <z_clock_announce+0x234>)
    f4dc:	f001 fc0c 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f4e0:	69bb      	ldr	r3, [r7, #24]
    f4e2:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
    f4e4:	6a3b      	ldr	r3, [r7, #32]
    f4e6:	f383 8811 	msr	BASEPRI, r3
    f4ea:	f3bf 8f6f 	isb	sy
}
    f4ee:	bf00      	nop
}
    f4f0:	bf00      	nop

	k_spin_unlock(&timeout_lock, key);
}
    f4f2:	bf00      	nop
    f4f4:	3754      	adds	r7, #84	; 0x54
    f4f6:	46bd      	mov	sp, r7
    f4f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f4fc:	20000d20 	.word	0x20000d20
    f500:	0001c870 	.word	0x0001c870
    f504:	0001c898 	.word	0x0001c898
    f508:	0001c84c 	.word	0x0001c84c
    f50c:	0001c8b0 	.word	0x0001c8b0
    f510:	20000d24 	.word	0x20000d24
    f514:	20000638 	.word	0x20000638
    f518:	0001c8c8 	.word	0x0001c8c8
    f51c:	0001c8e0 	.word	0x0001c8e0

0000f520 <z_tick_get>:

int64_t z_tick_get(void)
{
    f520:	b5b0      	push	{r4, r5, r7, lr}
    f522:	b08c      	sub	sp, #48	; 0x30
    f524:	af00      	add	r7, sp, #0
	uint64_t t = 0U;
    f526:	f04f 0200 	mov.w	r2, #0
    f52a:	f04f 0300 	mov.w	r3, #0
    f52e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	LOCKED(&timeout_lock) {
    f532:	2300      	movs	r3, #0
    f534:	613b      	str	r3, [r7, #16]
    f536:	4b34      	ldr	r3, [pc, #208]	; (f608 <z_tick_get+0xe8>)
    f538:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
    f53a:	f04f 0320 	mov.w	r3, #32
    f53e:	f3ef 8211 	mrs	r2, BASEPRI
    f542:	f383 8811 	msr	BASEPRI, r3
    f546:	f3bf 8f6f 	isb	sy
    f54a:	623a      	str	r2, [r7, #32]
    f54c:	61fb      	str	r3, [r7, #28]
	return key;
    f54e:	6a3b      	ldr	r3, [r7, #32]
	k.key = arch_irq_lock();
    f550:	607b      	str	r3, [r7, #4]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    f552:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f554:	f7ff fa80 	bl	ea58 <z_spin_lock_valid>
    f558:	4603      	mov	r3, r0
    f55a:	f083 0301 	eor.w	r3, r3, #1
    f55e:	b2db      	uxtb	r3, r3
    f560:	2b00      	cmp	r3, #0
    f562:	d00d      	beq.n	f580 <z_tick_get+0x60>
    f564:	2378      	movs	r3, #120	; 0x78
    f566:	4a29      	ldr	r2, [pc, #164]	; (f60c <z_tick_get+0xec>)
    f568:	4929      	ldr	r1, [pc, #164]	; (f610 <z_tick_get+0xf0>)
    f56a:	482a      	ldr	r0, [pc, #168]	; (f614 <z_tick_get+0xf4>)
    f56c:	f000 fd7c 	bl	10068 <printk>
    f570:	6a79      	ldr	r1, [r7, #36]	; 0x24
    f572:	4829      	ldr	r0, [pc, #164]	; (f618 <z_tick_get+0xf8>)
    f574:	f000 fd78 	bl	10068 <printk>
    f578:	2178      	movs	r1, #120	; 0x78
    f57a:	4824      	ldr	r0, [pc, #144]	; (f60c <z_tick_get+0xec>)
    f57c:	f001 fbbc 	bl	10cf8 <assert_post_action>
	z_spin_lock_set_owner(l);
    f580:	6a78      	ldr	r0, [r7, #36]	; 0x24
    f582:	f7ff faa1 	bl	eac8 <z_spin_lock_set_owner>
	return k;
    f586:	687b      	ldr	r3, [r7, #4]
    f588:	60fb      	str	r3, [r7, #12]
    f58a:	e033      	b.n	f5f4 <z_tick_get+0xd4>
		t = curr_tick + z_clock_elapsed();
    f58c:	f7f4 fff4 	bl	4578 <z_clock_elapsed>
    f590:	4603      	mov	r3, r0
    f592:	4618      	mov	r0, r3
    f594:	f04f 0100 	mov.w	r1, #0
    f598:	4b20      	ldr	r3, [pc, #128]	; (f61c <z_tick_get+0xfc>)
    f59a:	e9d3 2300 	ldrd	r2, r3, [r3]
    f59e:	1884      	adds	r4, r0, r2
    f5a0:	eb41 0503 	adc.w	r5, r1, r3
    f5a4:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
    f5a8:	4b17      	ldr	r3, [pc, #92]	; (f608 <z_tick_get+0xe8>)
    f5aa:	61bb      	str	r3, [r7, #24]
    f5ac:	68fb      	ldr	r3, [r7, #12]
    f5ae:	60bb      	str	r3, [r7, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    f5b0:	69b8      	ldr	r0, [r7, #24]
    f5b2:	f7ff fa6d 	bl	ea90 <z_spin_unlock_valid>
    f5b6:	4603      	mov	r3, r0
    f5b8:	f083 0301 	eor.w	r3, r3, #1
    f5bc:	b2db      	uxtb	r3, r3
    f5be:	2b00      	cmp	r3, #0
    f5c0:	d00d      	beq.n	f5de <z_tick_get+0xbe>
    f5c2:	23a3      	movs	r3, #163	; 0xa3
    f5c4:	4a11      	ldr	r2, [pc, #68]	; (f60c <z_tick_get+0xec>)
    f5c6:	4916      	ldr	r1, [pc, #88]	; (f620 <z_tick_get+0x100>)
    f5c8:	4812      	ldr	r0, [pc, #72]	; (f614 <z_tick_get+0xf4>)
    f5ca:	f000 fd4d 	bl	10068 <printk>
    f5ce:	69b9      	ldr	r1, [r7, #24]
    f5d0:	4814      	ldr	r0, [pc, #80]	; (f624 <z_tick_get+0x104>)
    f5d2:	f000 fd49 	bl	10068 <printk>
    f5d6:	21a3      	movs	r1, #163	; 0xa3
    f5d8:	480c      	ldr	r0, [pc, #48]	; (f60c <z_tick_get+0xec>)
    f5da:	f001 fb8d 	bl	10cf8 <assert_post_action>
	arch_irq_unlock(key.key);
    f5de:	68bb      	ldr	r3, [r7, #8]
    f5e0:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
    f5e2:	697b      	ldr	r3, [r7, #20]
    f5e4:	f383 8811 	msr	BASEPRI, r3
    f5e8:	f3bf 8f6f 	isb	sy
}
    f5ec:	bf00      	nop
}
    f5ee:	bf00      	nop
	LOCKED(&timeout_lock) {
    f5f0:	2301      	movs	r3, #1
    f5f2:	613b      	str	r3, [r7, #16]
    f5f4:	693b      	ldr	r3, [r7, #16]
    f5f6:	2b00      	cmp	r3, #0
    f5f8:	d0c8      	beq.n	f58c <z_tick_get+0x6c>
	}
	return t;
    f5fa:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
}
    f5fe:	4610      	mov	r0, r2
    f600:	4619      	mov	r1, r3
    f602:	3730      	adds	r7, #48	; 0x30
    f604:	46bd      	mov	sp, r7
    f606:	bdb0      	pop	{r4, r5, r7, pc}
    f608:	20000d20 	.word	0x20000d20
    f60c:	0001c870 	.word	0x0001c870
    f610:	0001c898 	.word	0x0001c898
    f614:	0001c84c 	.word	0x0001c84c
    f618:	0001c8b0 	.word	0x0001c8b0
    f61c:	20000638 	.word	0x20000638
    f620:	0001c8c8 	.word	0x0001c8c8
    f624:	0001c8e0 	.word	0x0001c8e0

0000f628 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    f628:	b580      	push	{r7, lr}
    f62a:	b086      	sub	sp, #24
    f62c:	af00      	add	r7, sp, #0
    f62e:	6078      	str	r0, [r7, #4]
	struct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);
    f630:	687b      	ldr	r3, [r7, #4]
    f632:	617b      	str	r3, [r7, #20]

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    f634:	697b      	ldr	r3, [r7, #20]
    f636:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	; 0x28
    f63a:	f04f 0000 	mov.w	r0, #0
    f63e:	f04f 0100 	mov.w	r1, #0
    f642:	428b      	cmp	r3, r1
    f644:	bf08      	it	eq
    f646:	4282      	cmpeq	r2, r0
    f648:	d011      	beq.n	f66e <z_timer_expiration_handler+0x46>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
    f64a:	697b      	ldr	r3, [r7, #20]
    f64c:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	; 0x28
    f650:	f04f 30ff 	mov.w	r0, #4294967295
    f654:	f04f 31ff 	mov.w	r1, #4294967295
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    f658:	428b      	cmp	r3, r1
    f65a:	bf08      	it	eq
    f65c:	4282      	cmpeq	r2, r0
    f65e:	d006      	beq.n	f66e <z_timer_expiration_handler+0x46>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    f660:	6978      	ldr	r0, [r7, #20]
    f662:	697b      	ldr	r3, [r7, #20]
    f664:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	; 0x28
    f668:	4915      	ldr	r1, [pc, #84]	; (f6c0 <z_timer_expiration_handler+0x98>)
    f66a:	f7ff fb5f 	bl	ed2c <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    f66e:	697b      	ldr	r3, [r7, #20]
    f670:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    f672:	1c5a      	adds	r2, r3, #1
    f674:	697b      	ldr	r3, [r7, #20]
    f676:	631a      	str	r2, [r3, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    f678:	697b      	ldr	r3, [r7, #20]
    f67a:	6a1b      	ldr	r3, [r3, #32]
    f67c:	2b00      	cmp	r3, #0
    f67e:	d003      	beq.n	f688 <z_timer_expiration_handler+0x60>
		timer->expiry_fn(timer);
    f680:	697b      	ldr	r3, [r7, #20]
    f682:	6a1b      	ldr	r3, [r3, #32]
    f684:	6978      	ldr	r0, [r7, #20]
    f686:	4798      	blx	r3
	}

	thread = z_waitq_head(&timer->wait_q);
    f688:	697b      	ldr	r3, [r7, #20]
    f68a:	3318      	adds	r3, #24
    f68c:	4618      	mov	r0, r3
    f68e:	f008 fead 	bl	183ec <z_waitq_head>
    f692:	6138      	str	r0, [r7, #16]

	if (thread == NULL) {
    f694:	693b      	ldr	r3, [r7, #16]
    f696:	2b00      	cmp	r3, #0
    f698:	d00e      	beq.n	f6b8 <z_timer_expiration_handler+0x90>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
    f69a:	6938      	ldr	r0, [r7, #16]
    f69c:	f7fd ffa0 	bl	d5e0 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
    f6a0:	6938      	ldr	r0, [r7, #16]
    f6a2:	f7fd fa51 	bl	cb48 <z_ready_thread>
    f6a6:	693b      	ldr	r3, [r7, #16]
    f6a8:	60fb      	str	r3, [r7, #12]
    f6aa:	2300      	movs	r3, #0
    f6ac:	60bb      	str	r3, [r7, #8]
	thread->arch.swap_return_value = value;
    f6ae:	68fb      	ldr	r3, [r7, #12]
    f6b0:	68ba      	ldr	r2, [r7, #8]
    f6b2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
    f6b6:	e000      	b.n	f6ba <z_timer_expiration_handler+0x92>
		return;
    f6b8:	bf00      	nop

	arch_thread_return_value_set(thread, 0);
}
    f6ba:	3718      	adds	r7, #24
    f6bc:	46bd      	mov	sp, r7
    f6be:	bd80      	pop	{r7, pc}
    f6c0:	0000f629 	.word	0x0000f629

0000f6c4 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    f6c4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
    f6c8:	b086      	sub	sp, #24
    f6ca:	af00      	add	r7, sp, #0
    f6cc:	6178      	str	r0, [r7, #20]
    f6ce:	e9c7 2302 	strd	r2, r3, [r7, #8]
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    f6d2:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    f6d6:	f04f 30ff 	mov.w	r0, #4294967295
    f6da:	f04f 31ff 	mov.w	r1, #4294967295
    f6de:	428b      	cmp	r3, r1
    f6e0:	bf08      	it	eq
    f6e2:	4282      	cmpeq	r2, r0
    f6e4:	d100      	bne.n	f6e8 <z_impl_k_timer_start+0x24>
    f6e6:	e057      	b.n	f798 <z_impl_k_timer_start+0xd4>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
    f6e8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    f6ec:	4313      	orrs	r3, r2
    f6ee:	d022      	beq.n	f736 <z_impl_k_timer_start+0x72>
    f6f0:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    f6f4:	f06f 0001 	mvn.w	r0, #1
    f6f8:	f04f 31ff 	mov.w	r1, #4294967295
    f6fc:	ebb0 0802 	subs.w	r8, r0, r2
    f700:	eb61 0903 	sbc.w	r9, r1, r3
    f704:	f1b8 0f00 	cmp.w	r8, #0
    f708:	f179 0300 	sbcs.w	r3, r9, #0
    f70c:	da13      	bge.n	f736 <z_impl_k_timer_start+0x72>
		period.ticks = MAX(period.ticks - 1, 1);
    f70e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    f712:	f112 31ff 	adds.w	r1, r2, #4294967295
    f716:	6039      	str	r1, [r7, #0]
    f718:	f143 33ff 	adc.w	r3, r3, #4294967295
    f71c:	607b      	str	r3, [r7, #4]
    f71e:	e9d7 2300 	ldrd	r2, r3, [r7]
    f722:	2a01      	cmp	r2, #1
    f724:	f173 0100 	sbcs.w	r1, r3, #0
    f728:	da03      	bge.n	f732 <z_impl_k_timer_start+0x6e>
    f72a:	f04f 0201 	mov.w	r2, #1
    f72e:	f04f 0300 	mov.w	r3, #0
    f732:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    f736:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    f73a:	f06f 0001 	mvn.w	r0, #1
    f73e:	f04f 31ff 	mov.w	r1, #4294967295
    f742:	1a84      	subs	r4, r0, r2
    f744:	eb61 0503 	sbc.w	r5, r1, r3
    f748:	2c00      	cmp	r4, #0
    f74a:	f175 0300 	sbcs.w	r3, r5, #0
    f74e:	da11      	bge.n	f774 <z_impl_k_timer_start+0xb0>
		duration.ticks = MAX(duration.ticks - 1, 0);
    f750:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    f754:	f112 3aff 	adds.w	sl, r2, #4294967295
    f758:	f143 3bff 	adc.w	fp, r3, #4294967295
    f75c:	4652      	mov	r2, sl
    f75e:	465b      	mov	r3, fp
    f760:	2a00      	cmp	r2, #0
    f762:	f173 0100 	sbcs.w	r1, r3, #0
    f766:	da03      	bge.n	f770 <z_impl_k_timer_start+0xac>
    f768:	f04f 0200 	mov.w	r2, #0
    f76c:	f04f 0300 	mov.w	r3, #0
    f770:	e9c7 2302 	strd	r2, r3, [r7, #8]
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
    f774:	697b      	ldr	r3, [r7, #20]
    f776:	4618      	mov	r0, r3
    f778:	f7ff fc1e 	bl	efb8 <z_abort_timeout>
	timer->period = period;
    f77c:	6979      	ldr	r1, [r7, #20]
    f77e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
    f782:	e9c1 230a 	strd	r2, r3, [r1, #40]	; 0x28
	timer->status = 0U;
    f786:	697b      	ldr	r3, [r7, #20]
    f788:	2200      	movs	r2, #0
    f78a:	631a      	str	r2, [r3, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    f78c:	6978      	ldr	r0, [r7, #20]
    f78e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    f792:	4903      	ldr	r1, [pc, #12]	; (f7a0 <z_impl_k_timer_start+0xdc>)
    f794:	f7ff faca 	bl	ed2c <z_add_timeout>
		     duration);
}
    f798:	3718      	adds	r7, #24
    f79a:	46bd      	mov	sp, r7
    f79c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
    f7a0:	0000f629 	.word	0x0000f629

0000f7a4 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(const struct device *unused)
{
    f7a4:	b580      	push	{r7, lr}
    f7a6:	b084      	sub	sp, #16
    f7a8:	af00      	add	r7, sp, #0
    f7aa:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    f7ac:	4b16      	ldr	r3, [pc, #88]	; (f808 <statics_init+0x64>)
    f7ae:	60fb      	str	r3, [r7, #12]
    f7b0:	e00a      	b.n	f7c8 <statics_init+0x24>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    f7b2:	68fb      	ldr	r3, [r7, #12]
    f7b4:	6859      	ldr	r1, [r3, #4]
    f7b6:	68fb      	ldr	r3, [r7, #12]
    f7b8:	689b      	ldr	r3, [r3, #8]
    f7ba:	461a      	mov	r2, r3
    f7bc:	68f8      	ldr	r0, [r7, #12]
    f7be:	f008 fe8c 	bl	184da <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    f7c2:	68fb      	ldr	r3, [r7, #12]
    f7c4:	3318      	adds	r3, #24
    f7c6:	60fb      	str	r3, [r7, #12]
    f7c8:	68fb      	ldr	r3, [r7, #12]
    f7ca:	4a10      	ldr	r2, [pc, #64]	; (f80c <statics_init+0x68>)
    f7cc:	4293      	cmp	r3, r2
    f7ce:	d90c      	bls.n	f7ea <statics_init+0x46>
    f7d0:	2315      	movs	r3, #21
    f7d2:	4a0f      	ldr	r2, [pc, #60]	; (f810 <statics_init+0x6c>)
    f7d4:	490f      	ldr	r1, [pc, #60]	; (f814 <statics_init+0x70>)
    f7d6:	4810      	ldr	r0, [pc, #64]	; (f818 <statics_init+0x74>)
    f7d8:	f000 fc46 	bl	10068 <printk>
    f7dc:	480f      	ldr	r0, [pc, #60]	; (f81c <statics_init+0x78>)
    f7de:	f000 fc43 	bl	10068 <printk>
    f7e2:	2115      	movs	r1, #21
    f7e4:	480a      	ldr	r0, [pc, #40]	; (f810 <statics_init+0x6c>)
    f7e6:	f001 fa87 	bl	10cf8 <assert_post_action>
    f7ea:	68fb      	ldr	r3, [r7, #12]
    f7ec:	4a07      	ldr	r2, [pc, #28]	; (f80c <statics_init+0x68>)
    f7ee:	4293      	cmp	r3, r2
    f7f0:	bf34      	ite	cc
    f7f2:	2301      	movcc	r3, #1
    f7f4:	2300      	movcs	r3, #0
    f7f6:	b2db      	uxtb	r3, r3
    f7f8:	2b00      	cmp	r3, #0
    f7fa:	d1da      	bne.n	f7b2 <statics_init+0xe>
	}
	return 0;
    f7fc:	2300      	movs	r3, #0
}
    f7fe:	4618      	mov	r0, r3
    f800:	3710      	adds	r7, #16
    f802:	46bd      	mov	sp, r7
    f804:	bd80      	pop	{r7, pc}
    f806:	bf00      	nop
    f808:	2000025c 	.word	0x2000025c
    f80c:	2000025c 	.word	0x2000025c
    f810:	0001c8f8 	.word	0x0001c8f8
    f814:	0001c91c 	.word	0x0001c91c
    f818:	0001c934 	.word	0x0001c934
    f81c:	0001c954 	.word	0x0001c954

0000f820 <nrf_cc3xx_platform_init_no_rng>:
    f820:	b510      	push	{r4, lr}
    f822:	4c0a      	ldr	r4, [pc, #40]	; (f84c <nrf_cc3xx_platform_init_no_rng+0x2c>)
    f824:	6823      	ldr	r3, [r4, #0]
    f826:	b11b      	cbz	r3, f830 <nrf_cc3xx_platform_init_no_rng+0x10>
    f828:	2301      	movs	r3, #1
    f82a:	2000      	movs	r0, #0
    f82c:	6023      	str	r3, [r4, #0]
    f82e:	bd10      	pop	{r4, pc}
    f830:	f000 f898 	bl	f964 <CC_LibInitNoRng>
    f834:	2800      	cmp	r0, #0
    f836:	d0f7      	beq.n	f828 <nrf_cc3xx_platform_init_no_rng+0x8>
    f838:	3801      	subs	r0, #1
    f83a:	2806      	cmp	r0, #6
    f83c:	d803      	bhi.n	f846 <nrf_cc3xx_platform_init_no_rng+0x26>
    f83e:	4b04      	ldr	r3, [pc, #16]	; (f850 <nrf_cc3xx_platform_init_no_rng+0x30>)
    f840:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    f844:	bd10      	pop	{r4, pc}
    f846:	4803      	ldr	r0, [pc, #12]	; (f854 <nrf_cc3xx_platform_init_no_rng+0x34>)
    f848:	bd10      	pop	{r4, pc}
    f84a:	bf00      	nop
    f84c:	20000d28 	.word	0x20000d28
    f850:	0001cea8 	.word	0x0001cea8
    f854:	ffff8ffe 	.word	0xffff8ffe

0000f858 <nrf_cc3xx_platform_abort>:
    f858:	f3bf 8f4f 	dsb	sy
    f85c:	4905      	ldr	r1, [pc, #20]	; (f874 <nrf_cc3xx_platform_abort+0x1c>)
    f85e:	4b06      	ldr	r3, [pc, #24]	; (f878 <nrf_cc3xx_platform_abort+0x20>)
    f860:	68ca      	ldr	r2, [r1, #12]
    f862:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    f866:	4313      	orrs	r3, r2
    f868:	60cb      	str	r3, [r1, #12]
    f86a:	f3bf 8f4f 	dsb	sy
    f86e:	bf00      	nop
    f870:	e7fd      	b.n	f86e <nrf_cc3xx_platform_abort+0x16>
    f872:	bf00      	nop
    f874:	e000ed00 	.word	0xe000ed00
    f878:	05fa0004 	.word	0x05fa0004

0000f87c <CC_PalAbort>:
    f87c:	4b01      	ldr	r3, [pc, #4]	; (f884 <CC_PalAbort+0x8>)
    f87e:	685b      	ldr	r3, [r3, #4]
    f880:	4718      	bx	r3
    f882:	bf00      	nop
    f884:	20000188 	.word	0x20000188

0000f888 <nrf_cc3xx_platform_set_abort>:
    f888:	4b02      	ldr	r3, [pc, #8]	; (f894 <nrf_cc3xx_platform_set_abort+0xc>)
    f88a:	e9d0 1200 	ldrd	r1, r2, [r0]
    f88e:	e9c3 1200 	strd	r1, r2, [r3]
    f892:	4770      	bx	lr
    f894:	20000188 	.word	0x20000188

0000f898 <mutex_unlock>:
    f898:	b148      	cbz	r0, f8ae <mutex_unlock+0x16>
    f89a:	6843      	ldr	r3, [r0, #4]
    f89c:	b12b      	cbz	r3, f8aa <mutex_unlock+0x12>
    f89e:	f3bf 8f5f 	dmb	sy
    f8a2:	2300      	movs	r3, #0
    f8a4:	6003      	str	r3, [r0, #0]
    f8a6:	4618      	mov	r0, r3
    f8a8:	4770      	bx	lr
    f8aa:	4802      	ldr	r0, [pc, #8]	; (f8b4 <mutex_unlock+0x1c>)
    f8ac:	4770      	bx	lr
    f8ae:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    f8b2:	4770      	bx	lr
    f8b4:	ffff8fea 	.word	0xffff8fea

0000f8b8 <mutex_free>:
    f8b8:	b510      	push	{r4, lr}
    f8ba:	4604      	mov	r4, r0
    f8bc:	b128      	cbz	r0, f8ca <mutex_free+0x12>
    f8be:	6863      	ldr	r3, [r4, #4]
    f8c0:	b113      	cbz	r3, f8c8 <mutex_free+0x10>
    f8c2:	2300      	movs	r3, #0
    f8c4:	6023      	str	r3, [r4, #0]
    f8c6:	6063      	str	r3, [r4, #4]
    f8c8:	bd10      	pop	{r4, pc}
    f8ca:	4b02      	ldr	r3, [pc, #8]	; (f8d4 <mutex_free+0x1c>)
    f8cc:	4802      	ldr	r0, [pc, #8]	; (f8d8 <mutex_free+0x20>)
    f8ce:	685b      	ldr	r3, [r3, #4]
    f8d0:	4798      	blx	r3
    f8d2:	e7f4      	b.n	f8be <mutex_free+0x6>
    f8d4:	20000188 	.word	0x20000188
    f8d8:	0001cec4 	.word	0x0001cec4

0000f8dc <mutex_init>:
    f8dc:	b510      	push	{r4, lr}
    f8de:	4604      	mov	r4, r0
    f8e0:	b130      	cbz	r0, f8f0 <mutex_init+0x14>
    f8e2:	2200      	movs	r2, #0
    f8e4:	6863      	ldr	r3, [r4, #4]
    f8e6:	6022      	str	r2, [r4, #0]
    f8e8:	f043 0301 	orr.w	r3, r3, #1
    f8ec:	6063      	str	r3, [r4, #4]
    f8ee:	bd10      	pop	{r4, pc}
    f8f0:	4801      	ldr	r0, [pc, #4]	; (f8f8 <mutex_init+0x1c>)
    f8f2:	f7ff ffc3 	bl	f87c <CC_PalAbort>
    f8f6:	e7f4      	b.n	f8e2 <mutex_init+0x6>
    f8f8:	0001ceec 	.word	0x0001ceec

0000f8fc <mutex_lock>:
    f8fc:	b180      	cbz	r0, f920 <mutex_lock+0x24>
    f8fe:	6843      	ldr	r3, [r0, #4]
    f900:	b163      	cbz	r3, f91c <mutex_lock+0x20>
    f902:	2201      	movs	r2, #1
    f904:	e8d0 3fef 	ldaex	r3, [r0]
    f908:	e8c0 2fe1 	stlex	r1, r2, [r0]
    f90c:	2900      	cmp	r1, #0
    f90e:	d1f9      	bne.n	f904 <mutex_lock+0x8>
    f910:	2b01      	cmp	r3, #1
    f912:	d0f7      	beq.n	f904 <mutex_lock+0x8>
    f914:	f3bf 8f5f 	dmb	sy
    f918:	2000      	movs	r0, #0
    f91a:	4770      	bx	lr
    f91c:	4802      	ldr	r0, [pc, #8]	; (f928 <mutex_lock+0x2c>)
    f91e:	4770      	bx	lr
    f920:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    f924:	4770      	bx	lr
    f926:	bf00      	nop
    f928:	ffff8fea 	.word	0xffff8fea

0000f92c <nrf_cc3xx_platform_set_mutexes>:
    f92c:	b470      	push	{r4, r5, r6}
    f92e:	4b0b      	ldr	r3, [pc, #44]	; (f95c <nrf_cc3xx_platform_set_mutexes+0x30>)
    f930:	6806      	ldr	r6, [r0, #0]
    f932:	68c2      	ldr	r2, [r0, #12]
    f934:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    f938:	e9c3 4202 	strd	r4, r2, [r3, #8]
    f93c:	e9c3 6500 	strd	r6, r5, [r3]
    f940:	e9d1 0203 	ldrd	r0, r2, [r1, #12]
    f944:	680e      	ldr	r6, [r1, #0]
    f946:	4b06      	ldr	r3, [pc, #24]	; (f960 <nrf_cc3xx_platform_set_mutexes+0x34>)
    f948:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    f94c:	e9c3 6500 	strd	r6, r5, [r3]
    f950:	e9c3 4002 	strd	r4, r0, [r3, #8]
    f954:	611a      	str	r2, [r3, #16]
    f956:	bc70      	pop	{r4, r5, r6}
    f958:	4770      	bx	lr
    f95a:	bf00      	nop
    f95c:	20000198 	.word	0x20000198
    f960:	200001a8 	.word	0x200001a8

0000f964 <CC_LibInitNoRng>:
    f964:	b510      	push	{r4, lr}
    f966:	f000 f833 	bl	f9d0 <CC_HalInit>
    f96a:	b120      	cbz	r0, f976 <CC_LibInitNoRng+0x12>
    f96c:	2403      	movs	r4, #3
    f96e:	f000 f867 	bl	fa40 <CC_PalTerminate>
    f972:	4620      	mov	r0, r4
    f974:	bd10      	pop	{r4, pc}
    f976:	f000 f835 	bl	f9e4 <CC_PalInit>
    f97a:	b990      	cbnz	r0, f9a2 <CC_LibInitNoRng+0x3e>
    f97c:	f000 f8b0 	bl	fae0 <CC_PalPowerSaveModeSelect>
    f980:	b990      	cbnz	r0, f9a8 <CC_LibInitNoRng+0x44>
    f982:	4b0f      	ldr	r3, [pc, #60]	; (f9c0 <CC_LibInitNoRng+0x5c>)
    f984:	681b      	ldr	r3, [r3, #0]
    f986:	0e1b      	lsrs	r3, r3, #24
    f988:	2bf0      	cmp	r3, #240	; 0xf0
    f98a:	d108      	bne.n	f99e <CC_LibInitNoRng+0x3a>
    f98c:	4a0d      	ldr	r2, [pc, #52]	; (f9c4 <CC_LibInitNoRng+0x60>)
    f98e:	4b0e      	ldr	r3, [pc, #56]	; (f9c8 <CC_LibInitNoRng+0x64>)
    f990:	6812      	ldr	r2, [r2, #0]
    f992:	429a      	cmp	r2, r3
    f994:	d00a      	beq.n	f9ac <CC_LibInitNoRng+0x48>
    f996:	2407      	movs	r4, #7
    f998:	f000 f81c 	bl	f9d4 <CC_HalTerminate>
    f99c:	e7e7      	b.n	f96e <CC_LibInitNoRng+0xa>
    f99e:	2406      	movs	r4, #6
    f9a0:	e7fa      	b.n	f998 <CC_LibInitNoRng+0x34>
    f9a2:	2404      	movs	r4, #4
    f9a4:	4620      	mov	r0, r4
    f9a6:	bd10      	pop	{r4, pc}
    f9a8:	2400      	movs	r4, #0
    f9aa:	e7f5      	b.n	f998 <CC_LibInitNoRng+0x34>
    f9ac:	2001      	movs	r0, #1
    f9ae:	f000 f897 	bl	fae0 <CC_PalPowerSaveModeSelect>
    f9b2:	4604      	mov	r4, r0
    f9b4:	2800      	cmp	r0, #0
    f9b6:	d1f7      	bne.n	f9a8 <CC_LibInitNoRng+0x44>
    f9b8:	4b04      	ldr	r3, [pc, #16]	; (f9cc <CC_LibInitNoRng+0x68>)
    f9ba:	6018      	str	r0, [r3, #0]
    f9bc:	e7d9      	b.n	f972 <CC_LibInitNoRng+0xe>
    f9be:	bf00      	nop
    f9c0:	50841928 	.word	0x50841928
    f9c4:	50841a24 	.word	0x50841a24
    f9c8:	20e00000 	.word	0x20e00000
    f9cc:	50841a0c 	.word	0x50841a0c

0000f9d0 <CC_HalInit>:
    f9d0:	2000      	movs	r0, #0
    f9d2:	4770      	bx	lr

0000f9d4 <CC_HalTerminate>:
    f9d4:	2000      	movs	r0, #0
    f9d6:	4770      	bx	lr

0000f9d8 <CC_HalMaskInterrupt>:
    f9d8:	4b01      	ldr	r3, [pc, #4]	; (f9e0 <CC_HalMaskInterrupt+0x8>)
    f9da:	6018      	str	r0, [r3, #0]
    f9dc:	4770      	bx	lr
    f9de:	bf00      	nop
    f9e0:	50841a04 	.word	0x50841a04

0000f9e4 <CC_PalInit>:
    f9e4:	b510      	push	{r4, lr}
    f9e6:	4811      	ldr	r0, [pc, #68]	; (fa2c <CC_PalInit+0x48>)
    f9e8:	f000 f848 	bl	fa7c <CC_PalMutexCreate>
    f9ec:	b100      	cbz	r0, f9f0 <CC_PalInit+0xc>
    f9ee:	bd10      	pop	{r4, pc}
    f9f0:	480f      	ldr	r0, [pc, #60]	; (fa30 <CC_PalInit+0x4c>)
    f9f2:	f000 f843 	bl	fa7c <CC_PalMutexCreate>
    f9f6:	2800      	cmp	r0, #0
    f9f8:	d1f9      	bne.n	f9ee <CC_PalInit+0xa>
    f9fa:	4c0e      	ldr	r4, [pc, #56]	; (fa34 <CC_PalInit+0x50>)
    f9fc:	4620      	mov	r0, r4
    f9fe:	f000 f83d 	bl	fa7c <CC_PalMutexCreate>
    fa02:	2800      	cmp	r0, #0
    fa04:	d1f3      	bne.n	f9ee <CC_PalInit+0xa>
    fa06:	4b0c      	ldr	r3, [pc, #48]	; (fa38 <CC_PalInit+0x54>)
    fa08:	480c      	ldr	r0, [pc, #48]	; (fa3c <CC_PalInit+0x58>)
    fa0a:	601c      	str	r4, [r3, #0]
    fa0c:	f000 f836 	bl	fa7c <CC_PalMutexCreate>
    fa10:	4601      	mov	r1, r0
    fa12:	2800      	cmp	r0, #0
    fa14:	d1eb      	bne.n	f9ee <CC_PalInit+0xa>
    fa16:	f000 f82d 	bl	fa74 <CC_PalDmaInit>
    fa1a:	4604      	mov	r4, r0
    fa1c:	b108      	cbz	r0, fa22 <CC_PalInit+0x3e>
    fa1e:	4620      	mov	r0, r4
    fa20:	bd10      	pop	{r4, pc}
    fa22:	f000 f83f 	bl	faa4 <CC_PalPowerSaveModeInit>
    fa26:	4620      	mov	r0, r4
    fa28:	e7fa      	b.n	fa20 <CC_PalInit+0x3c>
    fa2a:	bf00      	nop
    fa2c:	200001e0 	.word	0x200001e0
    fa30:	200001d4 	.word	0x200001d4
    fa34:	200001dc 	.word	0x200001dc
    fa38:	200001e4 	.word	0x200001e4
    fa3c:	200001d8 	.word	0x200001d8

0000fa40 <CC_PalTerminate>:
    fa40:	b508      	push	{r3, lr}
    fa42:	4808      	ldr	r0, [pc, #32]	; (fa64 <CC_PalTerminate+0x24>)
    fa44:	f000 f824 	bl	fa90 <CC_PalMutexDestroy>
    fa48:	4807      	ldr	r0, [pc, #28]	; (fa68 <CC_PalTerminate+0x28>)
    fa4a:	f000 f821 	bl	fa90 <CC_PalMutexDestroy>
    fa4e:	4807      	ldr	r0, [pc, #28]	; (fa6c <CC_PalTerminate+0x2c>)
    fa50:	f000 f81e 	bl	fa90 <CC_PalMutexDestroy>
    fa54:	4806      	ldr	r0, [pc, #24]	; (fa70 <CC_PalTerminate+0x30>)
    fa56:	f000 f81b 	bl	fa90 <CC_PalMutexDestroy>
    fa5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    fa5e:	f000 b80b 	b.w	fa78 <CC_PalDmaTerminate>
    fa62:	bf00      	nop
    fa64:	200001e0 	.word	0x200001e0
    fa68:	200001d4 	.word	0x200001d4
    fa6c:	200001dc 	.word	0x200001dc
    fa70:	200001d8 	.word	0x200001d8

0000fa74 <CC_PalDmaInit>:
    fa74:	2000      	movs	r0, #0
    fa76:	4770      	bx	lr

0000fa78 <CC_PalDmaTerminate>:
    fa78:	4770      	bx	lr
    fa7a:	bf00      	nop

0000fa7c <CC_PalMutexCreate>:
    fa7c:	b508      	push	{r3, lr}
    fa7e:	4b03      	ldr	r3, [pc, #12]	; (fa8c <CC_PalMutexCreate+0x10>)
    fa80:	6802      	ldr	r2, [r0, #0]
    fa82:	681b      	ldr	r3, [r3, #0]
    fa84:	6810      	ldr	r0, [r2, #0]
    fa86:	4798      	blx	r3
    fa88:	2000      	movs	r0, #0
    fa8a:	bd08      	pop	{r3, pc}
    fa8c:	20000198 	.word	0x20000198

0000fa90 <CC_PalMutexDestroy>:
    fa90:	b508      	push	{r3, lr}
    fa92:	4b03      	ldr	r3, [pc, #12]	; (faa0 <CC_PalMutexDestroy+0x10>)
    fa94:	6802      	ldr	r2, [r0, #0]
    fa96:	685b      	ldr	r3, [r3, #4]
    fa98:	6810      	ldr	r0, [r2, #0]
    fa9a:	4798      	blx	r3
    fa9c:	2000      	movs	r0, #0
    fa9e:	bd08      	pop	{r3, pc}
    faa0:	20000198 	.word	0x20000198

0000faa4 <CC_PalPowerSaveModeInit>:
    faa4:	b570      	push	{r4, r5, r6, lr}
    faa6:	4c09      	ldr	r4, [pc, #36]	; (facc <CC_PalPowerSaveModeInit+0x28>)
    faa8:	4d09      	ldr	r5, [pc, #36]	; (fad0 <CC_PalPowerSaveModeInit+0x2c>)
    faaa:	6920      	ldr	r0, [r4, #16]
    faac:	68ab      	ldr	r3, [r5, #8]
    faae:	4798      	blx	r3
    fab0:	b118      	cbz	r0, faba <CC_PalPowerSaveModeInit+0x16>
    fab2:	4b08      	ldr	r3, [pc, #32]	; (fad4 <CC_PalPowerSaveModeInit+0x30>)
    fab4:	4808      	ldr	r0, [pc, #32]	; (fad8 <CC_PalPowerSaveModeInit+0x34>)
    fab6:	685b      	ldr	r3, [r3, #4]
    fab8:	4798      	blx	r3
    faba:	2100      	movs	r1, #0
    fabc:	4a07      	ldr	r2, [pc, #28]	; (fadc <CC_PalPowerSaveModeInit+0x38>)
    fabe:	68eb      	ldr	r3, [r5, #12]
    fac0:	6011      	str	r1, [r2, #0]
    fac2:	6920      	ldr	r0, [r4, #16]
    fac4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fac8:	4718      	bx	r3
    faca:	bf00      	nop
    facc:	200001a8 	.word	0x200001a8
    fad0:	20000198 	.word	0x20000198
    fad4:	20000188 	.word	0x20000188
    fad8:	0001cf10 	.word	0x0001cf10
    fadc:	20000d3c 	.word	0x20000d3c

0000fae0 <CC_PalPowerSaveModeSelect>:
    fae0:	b570      	push	{r4, r5, r6, lr}
    fae2:	4d1a      	ldr	r5, [pc, #104]	; (fb4c <CC_PalPowerSaveModeSelect+0x6c>)
    fae4:	4e1a      	ldr	r6, [pc, #104]	; (fb50 <CC_PalPowerSaveModeSelect+0x70>)
    fae6:	4604      	mov	r4, r0
    fae8:	68b2      	ldr	r2, [r6, #8]
    faea:	6928      	ldr	r0, [r5, #16]
    faec:	4790      	blx	r2
    faee:	b9f0      	cbnz	r0, fb2e <CC_PalPowerSaveModeSelect+0x4e>
    faf0:	b15c      	cbz	r4, fb0a <CC_PalPowerSaveModeSelect+0x2a>
    faf2:	4c18      	ldr	r4, [pc, #96]	; (fb54 <CC_PalPowerSaveModeSelect+0x74>)
    faf4:	6823      	ldr	r3, [r4, #0]
    faf6:	b1ab      	cbz	r3, fb24 <CC_PalPowerSaveModeSelect+0x44>
    faf8:	2b01      	cmp	r3, #1
    fafa:	d01a      	beq.n	fb32 <CC_PalPowerSaveModeSelect+0x52>
    fafc:	3b01      	subs	r3, #1
    fafe:	6023      	str	r3, [r4, #0]
    fb00:	6928      	ldr	r0, [r5, #16]
    fb02:	68f3      	ldr	r3, [r6, #12]
    fb04:	4798      	blx	r3
    fb06:	2000      	movs	r0, #0
    fb08:	bd70      	pop	{r4, r5, r6, pc}
    fb0a:	4c12      	ldr	r4, [pc, #72]	; (fb54 <CC_PalPowerSaveModeSelect+0x74>)
    fb0c:	6821      	ldr	r1, [r4, #0]
    fb0e:	b939      	cbnz	r1, fb20 <CC_PalPowerSaveModeSelect+0x40>
    fb10:	2001      	movs	r0, #1
    fb12:	4b11      	ldr	r3, [pc, #68]	; (fb58 <CC_PalPowerSaveModeSelect+0x78>)
    fb14:	4a11      	ldr	r2, [pc, #68]	; (fb5c <CC_PalPowerSaveModeSelect+0x7c>)
    fb16:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    fb1a:	6813      	ldr	r3, [r2, #0]
    fb1c:	2b00      	cmp	r3, #0
    fb1e:	d1fc      	bne.n	fb1a <CC_PalPowerSaveModeSelect+0x3a>
    fb20:	3101      	adds	r1, #1
    fb22:	6021      	str	r1, [r4, #0]
    fb24:	68f3      	ldr	r3, [r6, #12]
    fb26:	6928      	ldr	r0, [r5, #16]
    fb28:	4798      	blx	r3
    fb2a:	2000      	movs	r0, #0
    fb2c:	bd70      	pop	{r4, r5, r6, pc}
    fb2e:	480c      	ldr	r0, [pc, #48]	; (fb60 <CC_PalPowerSaveModeSelect+0x80>)
    fb30:	bd70      	pop	{r4, r5, r6, pc}
    fb32:	4a0a      	ldr	r2, [pc, #40]	; (fb5c <CC_PalPowerSaveModeSelect+0x7c>)
    fb34:	6813      	ldr	r3, [r2, #0]
    fb36:	2b00      	cmp	r3, #0
    fb38:	d1fc      	bne.n	fb34 <CC_PalPowerSaveModeSelect+0x54>
    fb3a:	4a07      	ldr	r2, [pc, #28]	; (fb58 <CC_PalPowerSaveModeSelect+0x78>)
    fb3c:	f06f 407e 	mvn.w	r0, #4261412864	; 0xfe000000
    fb40:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
    fb44:	f7ff ff48 	bl	f9d8 <CC_HalMaskInterrupt>
    fb48:	6823      	ldr	r3, [r4, #0]
    fb4a:	e7d7      	b.n	fafc <CC_PalPowerSaveModeSelect+0x1c>
    fb4c:	200001a8 	.word	0x200001a8
    fb50:	20000198 	.word	0x20000198
    fb54:	20000d3c 	.word	0x20000d3c
    fb58:	50840000 	.word	0x50840000
    fb5c:	50841910 	.word	0x50841910
    fb60:	ffff8fe9 	.word	0xffff8fe9

0000fb64 <k_ms_to_ticks_ceil64>:
 * Rounds up to the next highest output unit.
 *
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint64_t k_ms_to_ticks_ceil64(uint64_t t)
{
    fb64:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
    fb68:	b08c      	sub	sp, #48	; 0x30
    fb6a:	af00      	add	r7, sp, #0
    fb6c:	e9c7 0100 	strd	r0, r1, [r7]
    fb70:	e9d7 2300 	ldrd	r2, r3, [r7]
    fb74:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
    fb78:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    fb7c:	627b      	str	r3, [r7, #36]	; 0x24
    fb7e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    fb82:	623b      	str	r3, [r7, #32]
    fb84:	2301      	movs	r3, #1
    fb86:	77fb      	strb	r3, [r7, #31]
    fb88:	2300      	movs	r3, #0
    fb8a:	77bb      	strb	r3, [r7, #30]
    fb8c:	2301      	movs	r3, #1
    fb8e:	777b      	strb	r3, [r7, #29]
    fb90:	2300      	movs	r3, #0
    fb92:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    fb94:	7ffb      	ldrb	r3, [r7, #31]
    fb96:	2b00      	cmp	r3, #0
    fb98:	d00f      	beq.n	fbba <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
    fb9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fb9c:	6a3b      	ldr	r3, [r7, #32]
    fb9e:	429a      	cmp	r2, r3
    fba0:	d20b      	bcs.n	fbba <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    fba2:	6a3b      	ldr	r3, [r7, #32]
    fba4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fba6:	fbb3 f2f2 	udiv	r2, r3, r2
    fbaa:	6a79      	ldr	r1, [r7, #36]	; 0x24
    fbac:	fb01 f202 	mul.w	r2, r1, r2
    fbb0:	1a9b      	subs	r3, r3, r2
    fbb2:	2b00      	cmp	r3, #0
    fbb4:	d101      	bne.n	fbba <k_ms_to_ticks_ceil64+0x56>
    fbb6:	2301      	movs	r3, #1
    fbb8:	e000      	b.n	fbbc <k_ms_to_ticks_ceil64+0x58>
    fbba:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
    fbbc:	76fb      	strb	r3, [r7, #27]
    fbbe:	7efb      	ldrb	r3, [r7, #27]
    fbc0:	f003 0301 	and.w	r3, r3, #1
    fbc4:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    fbc6:	7ffb      	ldrb	r3, [r7, #31]
    fbc8:	2b00      	cmp	r3, #0
    fbca:	d00f      	beq.n	fbec <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
    fbcc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fbce:	6a3b      	ldr	r3, [r7, #32]
    fbd0:	429a      	cmp	r2, r3
    fbd2:	d90b      	bls.n	fbec <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    fbd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fbd6:	6a3a      	ldr	r2, [r7, #32]
    fbd8:	fbb3 f2f2 	udiv	r2, r3, r2
    fbdc:	6a39      	ldr	r1, [r7, #32]
    fbde:	fb01 f202 	mul.w	r2, r1, r2
    fbe2:	1a9b      	subs	r3, r3, r2
    fbe4:	2b00      	cmp	r3, #0
    fbe6:	d101      	bne.n	fbec <k_ms_to_ticks_ceil64+0x88>
    fbe8:	2301      	movs	r3, #1
    fbea:	e000      	b.n	fbee <k_ms_to_ticks_ceil64+0x8a>
    fbec:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
    fbee:	76bb      	strb	r3, [r7, #26]
    fbf0:	7ebb      	ldrb	r3, [r7, #26]
    fbf2:	f003 0301 	and.w	r3, r3, #1
    fbf6:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
    fbf8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fbfa:	6a3b      	ldr	r3, [r7, #32]
    fbfc:	429a      	cmp	r2, r3
    fbfe:	d10a      	bne.n	fc16 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
    fc00:	7fbb      	ldrb	r3, [r7, #30]
    fc02:	2b00      	cmp	r3, #0
    fc04:	d004      	beq.n	fc10 <k_ms_to_ticks_ceil64+0xac>
    fc06:	6abb      	ldr	r3, [r7, #40]	; 0x28
    fc08:	461a      	mov	r2, r3
    fc0a:	f04f 0300 	mov.w	r3, #0
    fc0e:	e0c8      	b.n	fda2 <__kernel_ram_size+0x62>
    fc10:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
    fc14:	e0c5      	b.n	fda2 <__kernel_ram_size+0x62>
	uint64_t off = 0;
    fc16:	f04f 0200 	mov.w	r2, #0
    fc1a:	f04f 0300 	mov.w	r3, #0
    fc1e:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
    fc22:	7efb      	ldrb	r3, [r7, #27]
    fc24:	f083 0301 	eor.w	r3, r3, #1
    fc28:	b2db      	uxtb	r3, r3
    fc2a:	2b00      	cmp	r3, #0
    fc2c:	d01e      	beq.n	fc6c <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    fc2e:	7ebb      	ldrb	r3, [r7, #26]
    fc30:	2b00      	cmp	r3, #0
    fc32:	d004      	beq.n	fc3e <k_ms_to_ticks_ceil64+0xda>
    fc34:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fc36:	6a3b      	ldr	r3, [r7, #32]
    fc38:	fbb2 f3f3 	udiv	r3, r2, r3
    fc3c:	e000      	b.n	fc40 <k_ms_to_ticks_ceil64+0xdc>
    fc3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fc40:	60fb      	str	r3, [r7, #12]
		if (round_up) {
    fc42:	7f7b      	ldrb	r3, [r7, #29]
    fc44:	2b00      	cmp	r3, #0
    fc46:	d007      	beq.n	fc58 <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
    fc48:	68fb      	ldr	r3, [r7, #12]
    fc4a:	3b01      	subs	r3, #1
    fc4c:	461a      	mov	r2, r3
    fc4e:	f04f 0300 	mov.w	r3, #0
    fc52:	e9c7 2304 	strd	r2, r3, [r7, #16]
    fc56:	e009      	b.n	fc6c <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
    fc58:	7f3b      	ldrb	r3, [r7, #28]
    fc5a:	2b00      	cmp	r3, #0
    fc5c:	d006      	beq.n	fc6c <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
    fc5e:	68fb      	ldr	r3, [r7, #12]
    fc60:	085b      	lsrs	r3, r3, #1
    fc62:	461a      	mov	r2, r3
    fc64:	f04f 0300 	mov.w	r3, #0
    fc68:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
    fc6c:	7ebb      	ldrb	r3, [r7, #26]
    fc6e:	2b00      	cmp	r3, #0
    fc70:	d02a      	beq.n	fcc8 <k_ms_to_ticks_ceil64+0x164>
		t += off;
    fc72:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
    fc76:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    fc7a:	1884      	adds	r4, r0, r2
    fc7c:	eb41 0503 	adc.w	r5, r1, r3
    fc80:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
    fc84:	7fbb      	ldrb	r3, [r7, #30]
    fc86:	2b00      	cmp	r3, #0
    fc88:	d010      	beq.n	fcac <k_ms_to_ticks_ceil64+0x148>
    fc8a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
    fc8e:	2b01      	cmp	r3, #1
    fc90:	bf08      	it	eq
    fc92:	2a00      	cmpeq	r2, #0
    fc94:	d20a      	bcs.n	fcac <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
    fc96:	6aba      	ldr	r2, [r7, #40]	; 0x28
    fc98:	6a79      	ldr	r1, [r7, #36]	; 0x24
    fc9a:	6a3b      	ldr	r3, [r7, #32]
    fc9c:	fbb1 f3f3 	udiv	r3, r1, r3
    fca0:	fbb2 f3f3 	udiv	r3, r2, r3
    fca4:	461a      	mov	r2, r3
    fca6:	f04f 0300 	mov.w	r3, #0
    fcaa:	e07a      	b.n	fda2 <__kernel_ram_size+0x62>
			return t / (from_hz / to_hz);
    fcac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fcae:	6a3b      	ldr	r3, [r7, #32]
    fcb0:	fbb2 f3f3 	udiv	r3, r2, r3
    fcb4:	461a      	mov	r2, r3
    fcb6:	f04f 0300 	mov.w	r3, #0
    fcba:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
    fcbe:	f7f0 fa41 	bl	144 <__aeabi_uldivmod>
    fcc2:	4602      	mov	r2, r0
    fcc4:	460b      	mov	r3, r1
    fcc6:	e06c      	b.n	fda2 <__kernel_ram_size+0x62>
	} else if (mul_ratio) {
    fcc8:	7efb      	ldrb	r3, [r7, #27]
    fcca:	2b00      	cmp	r3, #0
    fccc:	d021      	beq.n	fd12 <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
    fcce:	7fbb      	ldrb	r3, [r7, #30]
    fcd0:	2b00      	cmp	r3, #0
    fcd2:	d00a      	beq.n	fcea <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
    fcd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    fcd6:	6a39      	ldr	r1, [r7, #32]
    fcd8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    fcda:	fbb1 f2f2 	udiv	r2, r1, r2
    fcde:	fb02 f303 	mul.w	r3, r2, r3
    fce2:	461a      	mov	r2, r3
    fce4:	f04f 0300 	mov.w	r3, #0
    fce8:	e05b      	b.n	fda2 <__kernel_ram_size+0x62>
			return t * (to_hz / from_hz);
    fcea:	6a3a      	ldr	r2, [r7, #32]
    fcec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fcee:	fbb2 f3f3 	udiv	r3, r2, r3
    fcf2:	461a      	mov	r2, r3
    fcf4:	f04f 0300 	mov.w	r3, #0
    fcf8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    fcfa:	fb03 f001 	mul.w	r0, r3, r1
    fcfe:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    fd00:	fb02 f101 	mul.w	r1, r2, r1
    fd04:	4401      	add	r1, r0
    fd06:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    fd08:	fba0 2302 	umull	r2, r3, r0, r2
    fd0c:	4419      	add	r1, r3
    fd0e:	460b      	mov	r3, r1
    fd10:	e047      	b.n	fda2 <__kernel_ram_size+0x62>
		if (result32) {
    fd12:	7fbb      	ldrb	r3, [r7, #30]
    fd14:	2b00      	cmp	r3, #0
    fd16:	d024      	beq.n	fd62 <__kernel_ram_size+0x22>
			return (uint32_t)((t * to_hz + off) / from_hz);
    fd18:	6a3b      	ldr	r3, [r7, #32]
    fd1a:	461a      	mov	r2, r3
    fd1c:	f04f 0300 	mov.w	r3, #0
    fd20:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    fd22:	fb03 f001 	mul.w	r0, r3, r1
    fd26:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    fd28:	fb02 f101 	mul.w	r1, r2, r1
    fd2c:	4401      	add	r1, r0
    fd2e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    fd30:	fba0 2302 	umull	r2, r3, r0, r2
    fd34:	4419      	add	r1, r3
    fd36:	460b      	mov	r3, r1
    fd38:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    fd3c:	eb12 0a00 	adds.w	sl, r2, r0
    fd40:	eb43 0b01 	adc.w	fp, r3, r1
    fd44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fd46:	461a      	mov	r2, r3
    fd48:	f04f 0300 	mov.w	r3, #0
    fd4c:	4650      	mov	r0, sl
    fd4e:	4659      	mov	r1, fp
    fd50:	f7f0 f9f8 	bl	144 <__aeabi_uldivmod>
    fd54:	4602      	mov	r2, r0
    fd56:	460b      	mov	r3, r1
    fd58:	4613      	mov	r3, r2
    fd5a:	461a      	mov	r2, r3
    fd5c:	f04f 0300 	mov.w	r3, #0
    fd60:	e01f      	b.n	fda2 <__kernel_ram_size+0x62>
			return (t * to_hz + off) / from_hz;
    fd62:	6a3b      	ldr	r3, [r7, #32]
    fd64:	461a      	mov	r2, r3
    fd66:	f04f 0300 	mov.w	r3, #0
    fd6a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    fd6c:	fb03 f001 	mul.w	r0, r3, r1
    fd70:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    fd72:	fb02 f101 	mul.w	r1, r2, r1
    fd76:	4401      	add	r1, r0
    fd78:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    fd7a:	fba0 2302 	umull	r2, r3, r0, r2
    fd7e:	4419      	add	r1, r3
    fd80:	460b      	mov	r3, r1
    fd82:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    fd86:	eb12 0800 	adds.w	r8, r2, r0
    fd8a:	eb43 0901 	adc.w	r9, r3, r1
    fd8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    fd90:	461a      	mov	r2, r3
    fd92:	f04f 0300 	mov.w	r3, #0
    fd96:	4640      	mov	r0, r8
    fd98:	4649      	mov	r1, r9
    fd9a:	f7f0 f9d3 	bl	144 <__aeabi_uldivmod>
    fd9e:	4602      	mov	r2, r0
    fda0:	460b      	mov	r3, r1
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, false, true, false);
}
    fda2:	4610      	mov	r0, r2
    fda4:	4619      	mov	r1, r3
    fda6:	3730      	adds	r7, #48	; 0x30
    fda8:	46bd      	mov	sp, r7
    fdaa:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0000fdae <k_msleep>:
{
    fdae:	b580      	push	{r7, lr}
    fdb0:	b082      	sub	sp, #8
    fdb2:	af00      	add	r7, sp, #0
    fdb4:	6078      	str	r0, [r7, #4]
	return k_sleep(Z_TIMEOUT_MS(ms));
    fdb6:	687b      	ldr	r3, [r7, #4]
    fdb8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    fdbc:	461a      	mov	r2, r3
    fdbe:	ea4f 73e2 	mov.w	r3, r2, asr #31
    fdc2:	4610      	mov	r0, r2
    fdc4:	4619      	mov	r1, r3
    fdc6:	f7ff fecd 	bl	fb64 <k_ms_to_ticks_ceil64>
    fdca:	4602      	mov	r2, r0
    fdcc:	460b      	mov	r3, r1
    fdce:	4610      	mov	r0, r2
    fdd0:	4619      	mov	r1, r3
    fdd2:	f000 f806 	bl	fde2 <k_sleep>
    fdd6:	4601      	mov	r1, r0
    fdd8:	460b      	mov	r3, r1
}
    fdda:	4618      	mov	r0, r3
    fddc:	3708      	adds	r7, #8
    fdde:	46bd      	mov	sp, r7
    fde0:	bd80      	pop	{r7, pc}

0000fde2 <k_sleep>:
}


extern int32_t z_impl_k_sleep(k_timeout_t timeout);
static inline int32_t k_sleep(k_timeout_t timeout)
{
    fde2:	b580      	push	{r7, lr}
    fde4:	b082      	sub	sp, #8
    fde6:	af00      	add	r7, sp, #0
    fde8:	e9c7 0100 	strd	r0, r1, [r7]
		parm0.val = timeout;
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
    fdec:	e9d7 0100 	ldrd	r0, r1, [r7]
    fdf0:	f7fe fa50 	bl	e294 <z_impl_k_sleep>
    fdf4:	4603      	mov	r3, r0
}
    fdf6:	4618      	mov	r0, r3
    fdf8:	3708      	adds	r7, #8
    fdfa:	46bd      	mov	sp, r7
    fdfc:	bd80      	pop	{r7, pc}

0000fdfe <device_get_binding>:
extern "C" {
#endif

extern const struct device * z_impl_device_get_binding(const char * name);
static inline const struct device * device_get_binding(const char * name)
{
    fdfe:	b580      	push	{r7, lr}
    fe00:	b082      	sub	sp, #8
    fe02:	af00      	add	r7, sp, #0
    fe04:	6078      	str	r0, [r7, #4]
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    fe06:	6878      	ldr	r0, [r7, #4]
    fe08:	f7fa fe72 	bl	aaf0 <z_impl_device_get_binding>
    fe0c:	4603      	mov	r3, r0
}
    fe0e:	4618      	mov	r0, r3
    fe10:	3708      	adds	r7, #8
    fe12:	46bd      	mov	sp, r7
    fe14:	bd80      	pop	{r7, pc}

0000fe16 <uart_fifo_fill>:
 * @return Number of bytes sent.
 */
static inline int uart_fifo_fill(const struct device *dev,
				 const uint8_t *tx_data,
				 int size)
{
    fe16:	b580      	push	{r7, lr}
    fe18:	b086      	sub	sp, #24
    fe1a:	af00      	add	r7, sp, #0
    fe1c:	60f8      	str	r0, [r7, #12]
    fe1e:	60b9      	str	r1, [r7, #8]
    fe20:	607a      	str	r2, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    fe22:	68fb      	ldr	r3, [r7, #12]
    fe24:	689b      	ldr	r3, [r3, #8]
    fe26:	617b      	str	r3, [r7, #20]
		(const struct uart_driver_api *)dev->api;

	if (api->fifo_fill) {
    fe28:	697b      	ldr	r3, [r7, #20]
    fe2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fe2c:	2b00      	cmp	r3, #0
    fe2e:	d007      	beq.n	fe40 <uart_fifo_fill+0x2a>
		return api->fifo_fill(dev, tx_data, size);
    fe30:	697b      	ldr	r3, [r7, #20]
    fe32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    fe34:	687a      	ldr	r2, [r7, #4]
    fe36:	68b9      	ldr	r1, [r7, #8]
    fe38:	68f8      	ldr	r0, [r7, #12]
    fe3a:	4798      	blx	r3
    fe3c:	4603      	mov	r3, r0
    fe3e:	e000      	b.n	fe42 <uart_fifo_fill+0x2c>
	}
#endif

	return 0;
    fe40:	2300      	movs	r3, #0
}
    fe42:	4618      	mov	r0, r3
    fe44:	3718      	adds	r7, #24
    fe46:	46bd      	mov	sp, r7
    fe48:	bd80      	pop	{r7, pc}

0000fe4a <uart_fifo_read>:
 *
 * @return Number of bytes read.
 */
static inline int uart_fifo_read(const struct device *dev, uint8_t *rx_data,
				 const int size)
{
    fe4a:	b580      	push	{r7, lr}
    fe4c:	b086      	sub	sp, #24
    fe4e:	af00      	add	r7, sp, #0
    fe50:	60f8      	str	r0, [r7, #12]
    fe52:	60b9      	str	r1, [r7, #8]
    fe54:	607a      	str	r2, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    fe56:	68fb      	ldr	r3, [r7, #12]
    fe58:	689b      	ldr	r3, [r3, #8]
    fe5a:	617b      	str	r3, [r7, #20]
		(const struct uart_driver_api *)dev->api;

	if (api->fifo_read) {
    fe5c:	697b      	ldr	r3, [r7, #20]
    fe5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    fe60:	2b00      	cmp	r3, #0
    fe62:	d007      	beq.n	fe74 <uart_fifo_read+0x2a>
		return api->fifo_read(dev, rx_data, size);
    fe64:	697b      	ldr	r3, [r7, #20]
    fe66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    fe68:	687a      	ldr	r2, [r7, #4]
    fe6a:	68b9      	ldr	r1, [r7, #8]
    fe6c:	68f8      	ldr	r0, [r7, #12]
    fe6e:	4798      	blx	r3
    fe70:	4603      	mov	r3, r0
    fe72:	e000      	b.n	fe76 <uart_fifo_read+0x2c>
	}
#endif

	return 0;
    fe74:	2300      	movs	r3, #0
}
    fe76:	4618      	mov	r0, r3
    fe78:	3718      	adds	r7, #24
    fe7a:	46bd      	mov	sp, r7
    fe7c:	bd80      	pop	{r7, pc}

0000fe7e <z_impl_uart_irq_tx_enable>:
 * @return N/A
 */
__syscall void uart_irq_tx_enable(const struct device *dev);

static inline void z_impl_uart_irq_tx_enable(const struct device *dev)
{
    fe7e:	b580      	push	{r7, lr}
    fe80:	b084      	sub	sp, #16
    fe82:	af00      	add	r7, sp, #0
    fe84:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    fe86:	687b      	ldr	r3, [r7, #4]
    fe88:	689b      	ldr	r3, [r3, #8]
    fe8a:	60fb      	str	r3, [r7, #12]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_enable) {
    fe8c:	68fb      	ldr	r3, [r7, #12]
    fe8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    fe90:	2b00      	cmp	r3, #0
    fe92:	d003      	beq.n	fe9c <z_impl_uart_irq_tx_enable+0x1e>
		api->irq_tx_enable(dev);
    fe94:	68fb      	ldr	r3, [r7, #12]
    fe96:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    fe98:	6878      	ldr	r0, [r7, #4]
    fe9a:	4798      	blx	r3
	}
#endif
}
    fe9c:	bf00      	nop
    fe9e:	3710      	adds	r7, #16
    fea0:	46bd      	mov	sp, r7
    fea2:	bd80      	pop	{r7, pc}

0000fea4 <z_impl_uart_irq_tx_disable>:
 * @return N/A
 */
__syscall void uart_irq_tx_disable(const struct device *dev);

static inline void z_impl_uart_irq_tx_disable(const struct device *dev)
{
    fea4:	b580      	push	{r7, lr}
    fea6:	b084      	sub	sp, #16
    fea8:	af00      	add	r7, sp, #0
    feaa:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    feac:	687b      	ldr	r3, [r7, #4]
    feae:	689b      	ldr	r3, [r3, #8]
    feb0:	60fb      	str	r3, [r7, #12]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_disable) {
    feb2:	68fb      	ldr	r3, [r7, #12]
    feb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    feb6:	2b00      	cmp	r3, #0
    feb8:	d003      	beq.n	fec2 <z_impl_uart_irq_tx_disable+0x1e>
		api->irq_tx_disable(dev);
    feba:	68fb      	ldr	r3, [r7, #12]
    febc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    febe:	6878      	ldr	r0, [r7, #4]
    fec0:	4798      	blx	r3
	}
#endif
}
    fec2:	bf00      	nop
    fec4:	3710      	adds	r7, #16
    fec6:	46bd      	mov	sp, r7
    fec8:	bd80      	pop	{r7, pc}

0000feca <uart_irq_tx_ready>:
 *
 * @retval 1 If at least one char can be written to UART.
 * @retval 0 Otherwise.
 */
static inline int uart_irq_tx_ready(const struct device *dev)
{
    feca:	b580      	push	{r7, lr}
    fecc:	b084      	sub	sp, #16
    fece:	af00      	add	r7, sp, #0
    fed0:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    fed2:	687b      	ldr	r3, [r7, #4]
    fed4:	689b      	ldr	r3, [r3, #8]
    fed6:	60fb      	str	r3, [r7, #12]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_ready) {
    fed8:	68fb      	ldr	r3, [r7, #12]
    feda:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    fedc:	2b00      	cmp	r3, #0
    fede:	d005      	beq.n	feec <uart_irq_tx_ready+0x22>
		return api->irq_tx_ready(dev);
    fee0:	68fb      	ldr	r3, [r7, #12]
    fee2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    fee4:	6878      	ldr	r0, [r7, #4]
    fee6:	4798      	blx	r3
    fee8:	4603      	mov	r3, r0
    feea:	e000      	b.n	feee <uart_irq_tx_ready+0x24>
	}
#endif

	return 0;
    feec:	2300      	movs	r3, #0
}
    feee:	4618      	mov	r0, r3
    fef0:	3710      	adds	r7, #16
    fef2:	46bd      	mov	sp, r7
    fef4:	bd80      	pop	{r7, pc}

0000fef6 <z_impl_uart_irq_rx_enable>:
 * @return N/A
 */
__syscall void uart_irq_rx_enable(const struct device *dev);

static inline void z_impl_uart_irq_rx_enable(const struct device *dev)
{
    fef6:	b580      	push	{r7, lr}
    fef8:	b084      	sub	sp, #16
    fefa:	af00      	add	r7, sp, #0
    fefc:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    fefe:	687b      	ldr	r3, [r7, #4]
    ff00:	689b      	ldr	r3, [r3, #8]
    ff02:	60fb      	str	r3, [r7, #12]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_enable) {
    ff04:	68fb      	ldr	r3, [r7, #12]
    ff06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    ff08:	2b00      	cmp	r3, #0
    ff0a:	d003      	beq.n	ff14 <z_impl_uart_irq_rx_enable+0x1e>
		api->irq_rx_enable(dev);
    ff0c:	68fb      	ldr	r3, [r7, #12]
    ff0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    ff10:	6878      	ldr	r0, [r7, #4]
    ff12:	4798      	blx	r3
	}
#endif
}
    ff14:	bf00      	nop
    ff16:	3710      	adds	r7, #16
    ff18:	46bd      	mov	sp, r7
    ff1a:	bd80      	pop	{r7, pc}

0000ff1c <uart_irq_rx_ready>:
 * @retval 1 If a received char is ready.
 * @retval 0 Otherwise.
 * @retval -ENOTSUP if this function is not supported
 */
static inline int uart_irq_rx_ready(const struct device *dev)
{
    ff1c:	b580      	push	{r7, lr}
    ff1e:	b084      	sub	sp, #16
    ff20:	af00      	add	r7, sp, #0
    ff22:	6078      	str	r0, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    ff24:	687b      	ldr	r3, [r7, #4]
    ff26:	689b      	ldr	r3, [r3, #8]
    ff28:	60fb      	str	r3, [r7, #12]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_ready) {
    ff2a:	68fb      	ldr	r3, [r7, #12]
    ff2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    ff2e:	2b00      	cmp	r3, #0
    ff30:	d005      	beq.n	ff3e <uart_irq_rx_ready+0x22>
		return api->irq_rx_ready(dev);
    ff32:	68fb      	ldr	r3, [r7, #12]
    ff34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    ff36:	6878      	ldr	r0, [r7, #4]
    ff38:	4798      	blx	r3
    ff3a:	4603      	mov	r3, r0
    ff3c:	e000      	b.n	ff40 <uart_irq_rx_ready+0x24>
	}
#endif

	return 0;
    ff3e:	2300      	movs	r3, #0
}
    ff40:	4618      	mov	r0, r3
    ff42:	3710      	adds	r7, #16
    ff44:	46bd      	mov	sp, r7
    ff46:	bd80      	pop	{r7, pc}

0000ff48 <uart_irq_callback_user_data_set>:
 * @return N/A
 */
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
    ff48:	b580      	push	{r7, lr}
    ff4a:	b086      	sub	sp, #24
    ff4c:	af00      	add	r7, sp, #0
    ff4e:	60f8      	str	r0, [r7, #12]
    ff50:	60b9      	str	r1, [r7, #8]
    ff52:	607a      	str	r2, [r7, #4]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    ff54:	68fb      	ldr	r3, [r7, #12]
    ff56:	689b      	ldr	r3, [r3, #8]
    ff58:	617b      	str	r3, [r7, #20]
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    ff5a:	697b      	ldr	r3, [r7, #20]
    ff5c:	2b00      	cmp	r3, #0
    ff5e:	d009      	beq.n	ff74 <uart_irq_callback_user_data_set+0x2c>
    ff60:	697b      	ldr	r3, [r7, #20]
    ff62:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ff64:	2b00      	cmp	r3, #0
    ff66:	d005      	beq.n	ff74 <uart_irq_callback_user_data_set+0x2c>
		api->irq_callback_set(dev, cb, user_data);
    ff68:	697b      	ldr	r3, [r7, #20]
    ff6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ff6c:	687a      	ldr	r2, [r7, #4]
    ff6e:	68b9      	ldr	r1, [r7, #8]
    ff70:	68f8      	ldr	r0, [r7, #12]
    ff72:	4798      	blx	r3
	}
#endif
}
    ff74:	bf00      	nop
    ff76:	3718      	adds	r7, #24
    ff78:	46bd      	mov	sp, r7
    ff7a:	bd80      	pop	{r7, pc}

0000ff7c <uart_irq_callback_set>:
 *
 * @return N/A
 */
static inline void uart_irq_callback_set(const struct device *dev,
					 uart_irq_callback_user_data_t cb)
{
    ff7c:	b580      	push	{r7, lr}
    ff7e:	b082      	sub	sp, #8
    ff80:	af00      	add	r7, sp, #0
    ff82:	6078      	str	r0, [r7, #4]
    ff84:	6039      	str	r1, [r7, #0]
	uart_irq_callback_user_data_set(dev, cb, NULL);
    ff86:	2200      	movs	r2, #0
    ff88:	6839      	ldr	r1, [r7, #0]
    ff8a:	6878      	ldr	r0, [r7, #4]
    ff8c:	f7ff ffdc 	bl	ff48 <uart_irq_callback_user_data_set>
}
    ff90:	bf00      	nop
    ff92:	3708      	adds	r7, #8
    ff94:	46bd      	mov	sp, r7
    ff96:	bd80      	pop	{r7, pc}

0000ff98 <uart_irq_tx_enable>:
}


extern void z_impl_uart_irq_tx_enable(const struct device * dev);
static inline void uart_irq_tx_enable(const struct device * dev)
{
    ff98:	b580      	push	{r7, lr}
    ff9a:	b082      	sub	sp, #8
    ff9c:	af00      	add	r7, sp, #0
    ff9e:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_enable(dev);
    ffa0:	6878      	ldr	r0, [r7, #4]
    ffa2:	f7ff ff6c 	bl	fe7e <z_impl_uart_irq_tx_enable>
}
    ffa6:	bf00      	nop
    ffa8:	3708      	adds	r7, #8
    ffaa:	46bd      	mov	sp, r7
    ffac:	bd80      	pop	{r7, pc}

0000ffae <uart_irq_tx_disable>:


extern void z_impl_uart_irq_tx_disable(const struct device * dev);
static inline void uart_irq_tx_disable(const struct device * dev)
{
    ffae:	b580      	push	{r7, lr}
    ffb0:	b082      	sub	sp, #8
    ffb2:	af00      	add	r7, sp, #0
    ffb4:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_DISABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
    ffb6:	6878      	ldr	r0, [r7, #4]
    ffb8:	f7ff ff74 	bl	fea4 <z_impl_uart_irq_tx_disable>
}
    ffbc:	bf00      	nop
    ffbe:	3708      	adds	r7, #8
    ffc0:	46bd      	mov	sp, r7
    ffc2:	bd80      	pop	{r7, pc}

0000ffc4 <uart_irq_rx_enable>:


extern void z_impl_uart_irq_rx_enable(const struct device * dev);
static inline void uart_irq_rx_enable(const struct device * dev)
{
    ffc4:	b580      	push	{r7, lr}
    ffc6:	b082      	sub	sp, #8
    ffc8:	af00      	add	r7, sp, #0
    ffca:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_RX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_rx_enable(dev);
    ffcc:	6878      	ldr	r0, [r7, #4]
    ffce:	f7ff ff92 	bl	fef6 <z_impl_uart_irq_rx_enable>
}
    ffd2:	bf00      	nop
    ffd4:	3708      	adds	r7, #8
    ffd6:	46bd      	mov	sp, r7
    ffd8:	bd80      	pop	{r7, pc}

0000ffda <sys_notify_get_method>:
{
    ffda:	b480      	push	{r7}
    ffdc:	b085      	sub	sp, #20
    ffde:	af00      	add	r7, sp, #0
    ffe0:	6078      	str	r0, [r7, #4]
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    ffe2:	687b      	ldr	r3, [r7, #4]
    ffe4:	685b      	ldr	r3, [r3, #4]
    ffe6:	60fb      	str	r3, [r7, #12]
	return method & SYS_NOTIFY_METHOD_MASK;
    ffe8:	68fb      	ldr	r3, [r7, #12]
    ffea:	f003 0303 	and.w	r3, r3, #3
}
    ffee:	4618      	mov	r0, r3
    fff0:	3714      	adds	r7, #20
    fff2:	46bd      	mov	sp, r7
    fff4:	bc80      	pop	{r7}
    fff6:	4770      	bx	lr

0000fff8 <sys_notify_validate>:
{
    fff8:	b580      	push	{r7, lr}
    fffa:	b084      	sub	sp, #16
    fffc:	af00      	add	r7, sp, #0
    fffe:	6078      	str	r0, [r7, #4]
	int rv = 0;
   10000:	2300      	movs	r3, #0
   10002:	60fb      	str	r3, [r7, #12]
	if (notify == NULL) {
   10004:	687b      	ldr	r3, [r7, #4]
   10006:	2b00      	cmp	r3, #0
   10008:	d102      	bne.n	10010 <sys_notify_validate+0x18>
		return -EINVAL;
   1000a:	f06f 0315 	mvn.w	r3, #21
   1000e:	e01d      	b.n	1004c <sys_notify_validate+0x54>
	switch (sys_notify_get_method(notify)) {
   10010:	6878      	ldr	r0, [r7, #4]
   10012:	f7ff ffe2 	bl	ffda <sys_notify_get_method>
   10016:	4603      	mov	r3, r0
   10018:	2b01      	cmp	r3, #1
   1001a:	d00d      	beq.n	10038 <sys_notify_validate+0x40>
   1001c:	2b03      	cmp	r3, #3
   1001e:	d107      	bne.n	10030 <sys_notify_validate+0x38>
		if (notify->method.callback == NULL) {
   10020:	687b      	ldr	r3, [r7, #4]
   10022:	681b      	ldr	r3, [r3, #0]
   10024:	2b00      	cmp	r3, #0
   10026:	d109      	bne.n	1003c <sys_notify_validate+0x44>
			rv = -EINVAL;
   10028:	f06f 0315 	mvn.w	r3, #21
   1002c:	60fb      	str	r3, [r7, #12]
		break;
   1002e:	e005      	b.n	1003c <sys_notify_validate+0x44>
		rv = -EINVAL;
   10030:	f06f 0315 	mvn.w	r3, #21
   10034:	60fb      	str	r3, [r7, #12]
		break;
   10036:	e002      	b.n	1003e <sys_notify_validate+0x46>
		break;
   10038:	bf00      	nop
   1003a:	e000      	b.n	1003e <sys_notify_validate+0x46>
		break;
   1003c:	bf00      	nop
	if (rv == 0) {
   1003e:	68fb      	ldr	r3, [r7, #12]
   10040:	2b00      	cmp	r3, #0
   10042:	d102      	bne.n	1004a <sys_notify_validate+0x52>
		notify->result = 0;
   10044:	687b      	ldr	r3, [r7, #4]
   10046:	2200      	movs	r2, #0
   10048:	609a      	str	r2, [r3, #8]
	return rv;
   1004a:	68fb      	ldr	r3, [r7, #12]
}
   1004c:	4618      	mov	r0, r3
   1004e:	3710      	adds	r7, #16
   10050:	46bd      	mov	sp, r7
   10052:	bd80      	pop	{r7, pc}

00010054 <arch_printk_char_out>:
{
   10054:	b480      	push	{r7}
   10056:	b083      	sub	sp, #12
   10058:	af00      	add	r7, sp, #0
   1005a:	6078      	str	r0, [r7, #4]
	return 0;
   1005c:	2300      	movs	r3, #0
}
   1005e:	4618      	mov	r0, r3
   10060:	370c      	adds	r7, #12
   10062:	46bd      	mov	sp, r7
   10064:	bc80      	pop	{r7}
   10066:	4770      	bx	lr

00010068 <printk>:
{
   10068:	b40f      	push	{r0, r1, r2, r3}
   1006a:	b580      	push	{r7, lr}
   1006c:	b082      	sub	sp, #8
   1006e:	af00      	add	r7, sp, #0
	va_start(ap, fmt);
   10070:	f107 0314 	add.w	r3, r7, #20
   10074:	607b      	str	r3, [r7, #4]
		vprintk(fmt, ap);
   10076:	6879      	ldr	r1, [r7, #4]
   10078:	6938      	ldr	r0, [r7, #16]
   1007a:	f7f0 fae1 	bl	640 <vprintk>
}
   1007e:	bf00      	nop
   10080:	3708      	adds	r7, #8
   10082:	46bd      	mov	sp, r7
   10084:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   10088:	b004      	add	sp, #16
   1008a:	4770      	bx	lr

0001008c <str_out>:
{
   1008c:	b480      	push	{r7}
   1008e:	b083      	sub	sp, #12
   10090:	af00      	add	r7, sp, #0
   10092:	6078      	str	r0, [r7, #4]
   10094:	6039      	str	r1, [r7, #0]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   10096:	683b      	ldr	r3, [r7, #0]
   10098:	681b      	ldr	r3, [r3, #0]
   1009a:	2b00      	cmp	r3, #0
   1009c:	d005      	beq.n	100aa <str_out+0x1e>
   1009e:	683b      	ldr	r3, [r7, #0]
   100a0:	689a      	ldr	r2, [r3, #8]
   100a2:	683b      	ldr	r3, [r7, #0]
   100a4:	685b      	ldr	r3, [r3, #4]
   100a6:	429a      	cmp	r2, r3
   100a8:	db06      	blt.n	100b8 <str_out+0x2c>
		ctx->count++;
   100aa:	683b      	ldr	r3, [r7, #0]
   100ac:	689b      	ldr	r3, [r3, #8]
   100ae:	1c5a      	adds	r2, r3, #1
   100b0:	683b      	ldr	r3, [r7, #0]
   100b2:	609a      	str	r2, [r3, #8]
		return c;
   100b4:	687b      	ldr	r3, [r7, #4]
   100b6:	e01d      	b.n	100f4 <str_out+0x68>
	if (ctx->count == ctx->max - 1) {
   100b8:	683b      	ldr	r3, [r7, #0]
   100ba:	689a      	ldr	r2, [r3, #8]
   100bc:	683b      	ldr	r3, [r7, #0]
   100be:	685b      	ldr	r3, [r3, #4]
   100c0:	3b01      	subs	r3, #1
   100c2:	429a      	cmp	r2, r3
   100c4:	d10a      	bne.n	100dc <str_out+0x50>
		ctx->str[ctx->count++] = '\0';
   100c6:	683b      	ldr	r3, [r7, #0]
   100c8:	681a      	ldr	r2, [r3, #0]
   100ca:	683b      	ldr	r3, [r7, #0]
   100cc:	689b      	ldr	r3, [r3, #8]
   100ce:	1c58      	adds	r0, r3, #1
   100d0:	6839      	ldr	r1, [r7, #0]
   100d2:	6088      	str	r0, [r1, #8]
   100d4:	4413      	add	r3, r2
   100d6:	2200      	movs	r2, #0
   100d8:	701a      	strb	r2, [r3, #0]
   100da:	e00a      	b.n	100f2 <str_out+0x66>
		ctx->str[ctx->count++] = c;
   100dc:	683b      	ldr	r3, [r7, #0]
   100de:	681a      	ldr	r2, [r3, #0]
   100e0:	683b      	ldr	r3, [r7, #0]
   100e2:	689b      	ldr	r3, [r3, #8]
   100e4:	1c58      	adds	r0, r3, #1
   100e6:	6839      	ldr	r1, [r7, #0]
   100e8:	6088      	str	r0, [r1, #8]
   100ea:	4413      	add	r3, r2
   100ec:	687a      	ldr	r2, [r7, #4]
   100ee:	b2d2      	uxtb	r2, r2
   100f0:	701a      	strb	r2, [r3, #0]
	return c;
   100f2:	687b      	ldr	r3, [r7, #4]
}
   100f4:	4618      	mov	r0, r3
   100f6:	370c      	adds	r7, #12
   100f8:	46bd      	mov	sp, r7
   100fa:	bc80      	pop	{r7}
   100fc:	4770      	bx	lr

000100fe <snprintk>:
{
   100fe:	b40c      	push	{r2, r3}
   10100:	b580      	push	{r7, lr}
   10102:	b084      	sub	sp, #16
   10104:	af00      	add	r7, sp, #0
   10106:	6078      	str	r0, [r7, #4]
   10108:	6039      	str	r1, [r7, #0]
	va_start(ap, fmt);
   1010a:	f107 031c 	add.w	r3, r7, #28
   1010e:	60bb      	str	r3, [r7, #8]
	ret = vsnprintk(str, size, fmt, ap);
   10110:	68bb      	ldr	r3, [r7, #8]
   10112:	69ba      	ldr	r2, [r7, #24]
   10114:	6839      	ldr	r1, [r7, #0]
   10116:	6878      	ldr	r0, [r7, #4]
   10118:	f7f0 faa6 	bl	668 <vsnprintk>
   1011c:	60f8      	str	r0, [r7, #12]
	return ret;
   1011e:	68fb      	ldr	r3, [r7, #12]
}
   10120:	4618      	mov	r0, r3
   10122:	3710      	adds	r7, #16
   10124:	46bd      	mov	sp, r7
   10126:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   1012a:	b002      	add	sp, #8
   1012c:	4770      	bx	lr

0001012e <sys_slist_init>:
 * @brief Initialize a list
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
   1012e:	b480      	push	{r7}
   10130:	b083      	sub	sp, #12
   10132:	af00      	add	r7, sp, #0
   10134:	6078      	str	r0, [r7, #4]
	list->head = NULL;
   10136:	687b      	ldr	r3, [r7, #4]
   10138:	2200      	movs	r2, #0
   1013a:	601a      	str	r2, [r3, #0]
	list->tail = NULL;
   1013c:	687b      	ldr	r3, [r7, #4]
   1013e:	2200      	movs	r2, #0
   10140:	605a      	str	r2, [r3, #4]
}
   10142:	bf00      	nop
   10144:	370c      	adds	r7, #12
   10146:	46bd      	mov	sp, r7
   10148:	bc80      	pop	{r7}
   1014a:	4770      	bx	lr

0001014c <z_snode_next_peek>:

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
   1014c:	b480      	push	{r7}
   1014e:	b083      	sub	sp, #12
   10150:	af00      	add	r7, sp, #0
   10152:	6078      	str	r0, [r7, #4]
	return node->next;
   10154:	687b      	ldr	r3, [r7, #4]
   10156:	681b      	ldr	r3, [r3, #0]
}
   10158:	4618      	mov	r0, r3
   1015a:	370c      	adds	r7, #12
   1015c:	46bd      	mov	sp, r7
   1015e:	bc80      	pop	{r7}
   10160:	4770      	bx	lr

00010162 <z_snode_next_set>:

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
   10162:	b480      	push	{r7}
   10164:	b083      	sub	sp, #12
   10166:	af00      	add	r7, sp, #0
   10168:	6078      	str	r0, [r7, #4]
   1016a:	6039      	str	r1, [r7, #0]
	parent->next = child;
   1016c:	687b      	ldr	r3, [r7, #4]
   1016e:	683a      	ldr	r2, [r7, #0]
   10170:	601a      	str	r2, [r3, #0]
}
   10172:	bf00      	nop
   10174:	370c      	adds	r7, #12
   10176:	46bd      	mov	sp, r7
   10178:	bc80      	pop	{r7}
   1017a:	4770      	bx	lr

0001017c <z_slist_head_set>:

static inline void z_slist_head_set(sys_slist_t *list, sys_snode_t *node)
{
   1017c:	b480      	push	{r7}
   1017e:	b083      	sub	sp, #12
   10180:	af00      	add	r7, sp, #0
   10182:	6078      	str	r0, [r7, #4]
   10184:	6039      	str	r1, [r7, #0]
	list->head = node;
   10186:	687b      	ldr	r3, [r7, #4]
   10188:	683a      	ldr	r2, [r7, #0]
   1018a:	601a      	str	r2, [r3, #0]
}
   1018c:	bf00      	nop
   1018e:	370c      	adds	r7, #12
   10190:	46bd      	mov	sp, r7
   10192:	bc80      	pop	{r7}
   10194:	4770      	bx	lr

00010196 <z_slist_tail_set>:

static inline void z_slist_tail_set(sys_slist_t *list, sys_snode_t *node)
{
   10196:	b480      	push	{r7}
   10198:	b083      	sub	sp, #12
   1019a:	af00      	add	r7, sp, #0
   1019c:	6078      	str	r0, [r7, #4]
   1019e:	6039      	str	r1, [r7, #0]
	list->tail = node;
   101a0:	687b      	ldr	r3, [r7, #4]
   101a2:	683a      	ldr	r2, [r7, #0]
   101a4:	605a      	str	r2, [r3, #4]
}
   101a6:	bf00      	nop
   101a8:	370c      	adds	r7, #12
   101aa:	46bd      	mov	sp, r7
   101ac:	bc80      	pop	{r7}
   101ae:	4770      	bx	lr

000101b0 <sys_slist_peek_head>:
 * @param list A point on the list to peek the first node from
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
   101b0:	b480      	push	{r7}
   101b2:	b083      	sub	sp, #12
   101b4:	af00      	add	r7, sp, #0
   101b6:	6078      	str	r0, [r7, #4]
	return list->head;
   101b8:	687b      	ldr	r3, [r7, #4]
   101ba:	681b      	ldr	r3, [r3, #0]
}
   101bc:	4618      	mov	r0, r3
   101be:	370c      	adds	r7, #12
   101c0:	46bd      	mov	sp, r7
   101c2:	bc80      	pop	{r7}
   101c4:	4770      	bx	lr

000101c6 <sys_slist_peek_tail>:
 * @param list A point on the list to peek the last node from
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
   101c6:	b480      	push	{r7}
   101c8:	b083      	sub	sp, #12
   101ca:	af00      	add	r7, sp, #0
   101cc:	6078      	str	r0, [r7, #4]
	return list->tail;
   101ce:	687b      	ldr	r3, [r7, #4]
   101d0:	685b      	ldr	r3, [r3, #4]
}
   101d2:	4618      	mov	r0, r3
   101d4:	370c      	adds	r7, #12
   101d6:	46bd      	mov	sp, r7
   101d8:	bc80      	pop	{r7}
   101da:	4770      	bx	lr

000101dc <sys_slist_is_empty>:
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_slist_is_empty(sys_slist_t *list);

Z_GENLIST_IS_EMPTY(slist)
   101dc:	b580      	push	{r7, lr}
   101de:	b082      	sub	sp, #8
   101e0:	af00      	add	r7, sp, #0
   101e2:	6078      	str	r0, [r7, #4]
   101e4:	6878      	ldr	r0, [r7, #4]
   101e6:	f7ff ffe3 	bl	101b0 <sys_slist_peek_head>
   101ea:	4603      	mov	r3, r0
   101ec:	2b00      	cmp	r3, #0
   101ee:	bf0c      	ite	eq
   101f0:	2301      	moveq	r3, #1
   101f2:	2300      	movne	r3, #0
   101f4:	b2db      	uxtb	r3, r3
   101f6:	4618      	mov	r0, r3
   101f8:	3708      	adds	r7, #8
   101fa:	46bd      	mov	sp, r7
   101fc:	bd80      	pop	{r7, pc}

000101fe <sys_slist_peek_next_no_check>:
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   101fe:	b580      	push	{r7, lr}
   10200:	b082      	sub	sp, #8
   10202:	af00      	add	r7, sp, #0
   10204:	6078      	str	r0, [r7, #4]
   10206:	6878      	ldr	r0, [r7, #4]
   10208:	f7ff ffa0 	bl	1014c <z_snode_next_peek>
   1020c:	4603      	mov	r3, r0
   1020e:	4618      	mov	r0, r3
   10210:	3708      	adds	r7, #8
   10212:	46bd      	mov	sp, r7
   10214:	bd80      	pop	{r7, pc}

00010216 <sys_slist_peek_next>:
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
   10216:	b580      	push	{r7, lr}
   10218:	b082      	sub	sp, #8
   1021a:	af00      	add	r7, sp, #0
   1021c:	6078      	str	r0, [r7, #4]
   1021e:	687b      	ldr	r3, [r7, #4]
   10220:	2b00      	cmp	r3, #0
   10222:	d004      	beq.n	1022e <sys_slist_peek_next+0x18>
   10224:	6878      	ldr	r0, [r7, #4]
   10226:	f7ff ffea 	bl	101fe <sys_slist_peek_next_no_check>
   1022a:	4603      	mov	r3, r0
   1022c:	e000      	b.n	10230 <sys_slist_peek_next+0x1a>
   1022e:	2300      	movs	r3, #0
   10230:	4618      	mov	r0, r3
   10232:	3708      	adds	r7, #8
   10234:	46bd      	mov	sp, r7
   10236:	bd80      	pop	{r7, pc}

00010238 <sys_slist_append>:
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   10238:	b580      	push	{r7, lr}
   1023a:	b082      	sub	sp, #8
   1023c:	af00      	add	r7, sp, #0
   1023e:	6078      	str	r0, [r7, #4]
   10240:	6039      	str	r1, [r7, #0]
   10242:	2100      	movs	r1, #0
   10244:	6838      	ldr	r0, [r7, #0]
   10246:	f7ff ff8c 	bl	10162 <z_snode_next_set>
   1024a:	6878      	ldr	r0, [r7, #4]
   1024c:	f7ff ffbb 	bl	101c6 <sys_slist_peek_tail>
   10250:	4603      	mov	r3, r0
   10252:	2b00      	cmp	r3, #0
   10254:	d108      	bne.n	10268 <sys_slist_append+0x30>
   10256:	6839      	ldr	r1, [r7, #0]
   10258:	6878      	ldr	r0, [r7, #4]
   1025a:	f7ff ff9c 	bl	10196 <z_slist_tail_set>
   1025e:	6839      	ldr	r1, [r7, #0]
   10260:	6878      	ldr	r0, [r7, #4]
   10262:	f7ff ff8b 	bl	1017c <z_slist_head_set>
   10266:	e00b      	b.n	10280 <sys_slist_append+0x48>
   10268:	6878      	ldr	r0, [r7, #4]
   1026a:	f7ff ffac 	bl	101c6 <sys_slist_peek_tail>
   1026e:	4603      	mov	r3, r0
   10270:	6839      	ldr	r1, [r7, #0]
   10272:	4618      	mov	r0, r3
   10274:	f7ff ff75 	bl	10162 <z_snode_next_set>
   10278:	6839      	ldr	r1, [r7, #0]
   1027a:	6878      	ldr	r0, [r7, #4]
   1027c:	f7ff ff8b 	bl	10196 <z_slist_tail_set>
   10280:	bf00      	nop
   10282:	3708      	adds	r7, #8
   10284:	46bd      	mov	sp, r7
   10286:	bd80      	pop	{r7, pc}

00010288 <sys_slist_get_not_empty>:
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   10288:	b580      	push	{r7, lr}
   1028a:	b084      	sub	sp, #16
   1028c:	af00      	add	r7, sp, #0
   1028e:	6078      	str	r0, [r7, #4]
   10290:	6878      	ldr	r0, [r7, #4]
   10292:	f7ff ff8d 	bl	101b0 <sys_slist_peek_head>
   10296:	60f8      	str	r0, [r7, #12]
   10298:	68f8      	ldr	r0, [r7, #12]
   1029a:	f7ff ff57 	bl	1014c <z_snode_next_peek>
   1029e:	4603      	mov	r3, r0
   102a0:	4619      	mov	r1, r3
   102a2:	6878      	ldr	r0, [r7, #4]
   102a4:	f7ff ff6a 	bl	1017c <z_slist_head_set>
   102a8:	6878      	ldr	r0, [r7, #4]
   102aa:	f7ff ff8c 	bl	101c6 <sys_slist_peek_tail>
   102ae:	4602      	mov	r2, r0
   102b0:	68fb      	ldr	r3, [r7, #12]
   102b2:	4293      	cmp	r3, r2
   102b4:	d107      	bne.n	102c6 <sys_slist_get_not_empty+0x3e>
   102b6:	6878      	ldr	r0, [r7, #4]
   102b8:	f7ff ff7a 	bl	101b0 <sys_slist_peek_head>
   102bc:	4603      	mov	r3, r0
   102be:	4619      	mov	r1, r3
   102c0:	6878      	ldr	r0, [r7, #4]
   102c2:	f7ff ff68 	bl	10196 <z_slist_tail_set>
   102c6:	68fb      	ldr	r3, [r7, #12]
   102c8:	4618      	mov	r0, r3
   102ca:	3710      	adds	r7, #16
   102cc:	46bd      	mov	sp, r7
   102ce:	bd80      	pop	{r7, pc}

000102d0 <set_state>:
{
   102d0:	b480      	push	{r7}
   102d2:	b083      	sub	sp, #12
   102d4:	af00      	add	r7, sp, #0
   102d6:	6078      	str	r0, [r7, #4]
   102d8:	6039      	str	r1, [r7, #0]
	mgr->flags = (state & ONOFF_STATE_MASK)
   102da:	683b      	ldr	r3, [r7, #0]
   102dc:	b29b      	uxth	r3, r3
   102de:	f003 0307 	and.w	r3, r3, #7
   102e2:	b29a      	uxth	r2, r3
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   102e4:	687b      	ldr	r3, [r7, #4]
   102e6:	8b9b      	ldrh	r3, [r3, #28]
   102e8:	f023 0307 	bic.w	r3, r3, #7
   102ec:	b29b      	uxth	r3, r3
   102ee:	4313      	orrs	r3, r2
   102f0:	b29a      	uxth	r2, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
   102f2:	687b      	ldr	r3, [r7, #4]
   102f4:	839a      	strh	r2, [r3, #28]
}
   102f6:	bf00      	nop
   102f8:	370c      	adds	r7, #12
   102fa:	46bd      	mov	sp, r7
   102fc:	bc80      	pop	{r7}
   102fe:	4770      	bx	lr

00010300 <validate_args>:
{
   10300:	b580      	push	{r7, lr}
   10302:	b084      	sub	sp, #16
   10304:	af00      	add	r7, sp, #0
   10306:	6078      	str	r0, [r7, #4]
   10308:	6039      	str	r1, [r7, #0]
	if ((mgr == NULL) || (cli == NULL)) {
   1030a:	687b      	ldr	r3, [r7, #4]
   1030c:	2b00      	cmp	r3, #0
   1030e:	d002      	beq.n	10316 <validate_args+0x16>
   10310:	683b      	ldr	r3, [r7, #0]
   10312:	2b00      	cmp	r3, #0
   10314:	d102      	bne.n	1031c <validate_args+0x1c>
		return -EINVAL;
   10316:	f06f 0315 	mvn.w	r3, #21
   1031a:	e012      	b.n	10342 <validate_args+0x42>
	int rv = sys_notify_validate(&cli->notify);
   1031c:	683b      	ldr	r3, [r7, #0]
   1031e:	3304      	adds	r3, #4
   10320:	4618      	mov	r0, r3
   10322:	f7ff fe69 	bl	fff8 <sys_notify_validate>
   10326:	60f8      	str	r0, [r7, #12]
	if ((rv == 0)
   10328:	68fb      	ldr	r3, [r7, #12]
   1032a:	2b00      	cmp	r3, #0
   1032c:	d108      	bne.n	10340 <validate_args+0x40>
	    && ((cli->notify.flags
   1032e:	683b      	ldr	r3, [r7, #0]
   10330:	689b      	ldr	r3, [r3, #8]
		 & ~BIT_MASK(ONOFF_CLIENT_EXTENSION_POS)) != 0)) {
   10332:	f023 0303 	bic.w	r3, r3, #3
	    && ((cli->notify.flags
   10336:	2b00      	cmp	r3, #0
   10338:	d002      	beq.n	10340 <validate_args+0x40>
		rv = -EINVAL;
   1033a:	f06f 0315 	mvn.w	r3, #21
   1033e:	60fb      	str	r3, [r7, #12]
	return rv;
   10340:	68fb      	ldr	r3, [r7, #12]
}
   10342:	4618      	mov	r0, r3
   10344:	3710      	adds	r7, #16
   10346:	46bd      	mov	sp, r7
   10348:	bd80      	pop	{r7, pc}

0001034a <onoff_manager_init>:
{
   1034a:	b580      	push	{r7, lr}
   1034c:	b08a      	sub	sp, #40	; 0x28
   1034e:	af00      	add	r7, sp, #0
   10350:	6078      	str	r0, [r7, #4]
   10352:	6039      	str	r1, [r7, #0]
	if ((mgr == NULL)
   10354:	687b      	ldr	r3, [r7, #4]
   10356:	2b00      	cmp	r3, #0
   10358:	d00a      	beq.n	10370 <onoff_manager_init+0x26>
	    || (transitions == NULL)
   1035a:	683b      	ldr	r3, [r7, #0]
   1035c:	2b00      	cmp	r3, #0
   1035e:	d007      	beq.n	10370 <onoff_manager_init+0x26>
	    || (transitions->start == NULL)
   10360:	683b      	ldr	r3, [r7, #0]
   10362:	681b      	ldr	r3, [r3, #0]
   10364:	2b00      	cmp	r3, #0
   10366:	d003      	beq.n	10370 <onoff_manager_init+0x26>
	    || (transitions->stop == NULL)) {
   10368:	683b      	ldr	r3, [r7, #0]
   1036a:	685b      	ldr	r3, [r3, #4]
   1036c:	2b00      	cmp	r3, #0
   1036e:	d102      	bne.n	10376 <onoff_manager_init+0x2c>
		return -EINVAL;
   10370:	f06f 0315 	mvn.w	r3, #21
   10374:	e00a      	b.n	1038c <onoff_manager_init+0x42>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   10376:	687b      	ldr	r3, [r7, #4]
   10378:	4618      	mov	r0, r3
   1037a:	2320      	movs	r3, #32
   1037c:	461a      	mov	r2, r3
   1037e:	2100      	movs	r1, #0
   10380:	f002 ff2b 	bl	131da <memset>
   10384:	687b      	ldr	r3, [r7, #4]
   10386:	683a      	ldr	r2, [r7, #0]
   10388:	611a      	str	r2, [r3, #16]
	return 0;
   1038a:	2300      	movs	r3, #0
}
   1038c:	4618      	mov	r0, r3
   1038e:	3728      	adds	r7, #40	; 0x28
   10390:	46bd      	mov	sp, r7
   10392:	bd80      	pop	{r7, pc}

00010394 <notify_monitors>:
{
   10394:	b590      	push	{r4, r7, lr}
   10396:	b089      	sub	sp, #36	; 0x24
   10398:	af00      	add	r7, sp, #0
   1039a:	60f8      	str	r0, [r7, #12]
   1039c:	60b9      	str	r1, [r7, #8]
   1039e:	607a      	str	r2, [r7, #4]
	sys_slist_t *mlist = &mgr->monitors;
   103a0:	68fb      	ldr	r3, [r7, #12]
   103a2:	3308      	adds	r3, #8
   103a4:	617b      	str	r3, [r7, #20]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   103a6:	6978      	ldr	r0, [r7, #20]
   103a8:	f7ff ff02 	bl	101b0 <sys_slist_peek_head>
   103ac:	4603      	mov	r3, r0
   103ae:	2b00      	cmp	r3, #0
   103b0:	d004      	beq.n	103bc <notify_monitors+0x28>
   103b2:	6978      	ldr	r0, [r7, #20]
   103b4:	f7ff fefc 	bl	101b0 <sys_slist_peek_head>
   103b8:	4603      	mov	r3, r0
   103ba:	e000      	b.n	103be <notify_monitors+0x2a>
   103bc:	2300      	movs	r3, #0
   103be:	61fb      	str	r3, [r7, #28]
   103c0:	69fb      	ldr	r3, [r7, #28]
   103c2:	2b00      	cmp	r3, #0
   103c4:	d00e      	beq.n	103e4 <notify_monitors+0x50>
   103c6:	69fb      	ldr	r3, [r7, #28]
   103c8:	4618      	mov	r0, r3
   103ca:	f7ff ff24 	bl	10216 <sys_slist_peek_next>
   103ce:	4603      	mov	r3, r0
   103d0:	2b00      	cmp	r3, #0
   103d2:	d005      	beq.n	103e0 <notify_monitors+0x4c>
   103d4:	69fb      	ldr	r3, [r7, #28]
   103d6:	4618      	mov	r0, r3
   103d8:	f7ff ff1d 	bl	10216 <sys_slist_peek_next>
   103dc:	4603      	mov	r3, r0
   103de:	e002      	b.n	103e6 <notify_monitors+0x52>
   103e0:	2300      	movs	r3, #0
   103e2:	e000      	b.n	103e6 <notify_monitors+0x52>
   103e4:	2300      	movs	r3, #0
   103e6:	61bb      	str	r3, [r7, #24]
   103e8:	e01c      	b.n	10424 <notify_monitors+0x90>
		mon->callback(mgr, mon, state, res);
   103ea:	69fb      	ldr	r3, [r7, #28]
   103ec:	685c      	ldr	r4, [r3, #4]
   103ee:	687b      	ldr	r3, [r7, #4]
   103f0:	68ba      	ldr	r2, [r7, #8]
   103f2:	69f9      	ldr	r1, [r7, #28]
   103f4:	68f8      	ldr	r0, [r7, #12]
   103f6:	47a0      	blx	r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   103f8:	69bb      	ldr	r3, [r7, #24]
   103fa:	61fb      	str	r3, [r7, #28]
   103fc:	69fb      	ldr	r3, [r7, #28]
   103fe:	2b00      	cmp	r3, #0
   10400:	d00e      	beq.n	10420 <notify_monitors+0x8c>
   10402:	69fb      	ldr	r3, [r7, #28]
   10404:	4618      	mov	r0, r3
   10406:	f7ff ff06 	bl	10216 <sys_slist_peek_next>
   1040a:	4603      	mov	r3, r0
   1040c:	2b00      	cmp	r3, #0
   1040e:	d005      	beq.n	1041c <notify_monitors+0x88>
   10410:	69fb      	ldr	r3, [r7, #28]
   10412:	4618      	mov	r0, r3
   10414:	f7ff feff 	bl	10216 <sys_slist_peek_next>
   10418:	4603      	mov	r3, r0
   1041a:	e002      	b.n	10422 <notify_monitors+0x8e>
   1041c:	2300      	movs	r3, #0
   1041e:	e000      	b.n	10422 <notify_monitors+0x8e>
   10420:	2300      	movs	r3, #0
   10422:	61bb      	str	r3, [r7, #24]
   10424:	69fb      	ldr	r3, [r7, #28]
   10426:	2b00      	cmp	r3, #0
   10428:	d1df      	bne.n	103ea <notify_monitors+0x56>
}
   1042a:	bf00      	nop
   1042c:	bf00      	nop
   1042e:	3724      	adds	r7, #36	; 0x24
   10430:	46bd      	mov	sp, r7
   10432:	bd90      	pop	{r4, r7, pc}

00010434 <notify_one>:
{
   10434:	b590      	push	{r4, r7, lr}
   10436:	b087      	sub	sp, #28
   10438:	af00      	add	r7, sp, #0
   1043a:	60f8      	str	r0, [r7, #12]
   1043c:	60b9      	str	r1, [r7, #8]
   1043e:	607a      	str	r2, [r7, #4]
   10440:	603b      	str	r3, [r7, #0]
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   10442:	68bb      	ldr	r3, [r7, #8]
   10444:	3304      	adds	r3, #4
   10446:	6839      	ldr	r1, [r7, #0]
   10448:	4618      	mov	r0, r3
   1044a:	f7f0 f893 	bl	574 <sys_notify_finalize>
   1044e:	6178      	str	r0, [r7, #20]
	if (cb) {
   10450:	697b      	ldr	r3, [r7, #20]
   10452:	2b00      	cmp	r3, #0
   10454:	d005      	beq.n	10462 <notify_one+0x2e>
		cb(mgr, cli, state, res);
   10456:	697c      	ldr	r4, [r7, #20]
   10458:	683b      	ldr	r3, [r7, #0]
   1045a:	687a      	ldr	r2, [r7, #4]
   1045c:	68b9      	ldr	r1, [r7, #8]
   1045e:	68f8      	ldr	r0, [r7, #12]
   10460:	47a0      	blx	r4
}
   10462:	bf00      	nop
   10464:	371c      	adds	r7, #28
   10466:	46bd      	mov	sp, r7
   10468:	bd90      	pop	{r4, r7, pc}

0001046a <notify_all>:
{
   1046a:	b580      	push	{r7, lr}
   1046c:	b086      	sub	sp, #24
   1046e:	af00      	add	r7, sp, #0
   10470:	60f8      	str	r0, [r7, #12]
   10472:	60b9      	str	r1, [r7, #8]
   10474:	607a      	str	r2, [r7, #4]
   10476:	603b      	str	r3, [r7, #0]
	while (!sys_slist_is_empty(list)) {
   10478:	e00b      	b.n	10492 <notify_all+0x28>
		sys_snode_t *node = sys_slist_get_not_empty(list);
   1047a:	68b8      	ldr	r0, [r7, #8]
   1047c:	f7ff ff04 	bl	10288 <sys_slist_get_not_empty>
   10480:	6178      	str	r0, [r7, #20]
		struct onoff_client *cli =
   10482:	697b      	ldr	r3, [r7, #20]
   10484:	613b      	str	r3, [r7, #16]
		notify_one(mgr, cli, state, res);
   10486:	683b      	ldr	r3, [r7, #0]
   10488:	687a      	ldr	r2, [r7, #4]
   1048a:	6939      	ldr	r1, [r7, #16]
   1048c:	68f8      	ldr	r0, [r7, #12]
   1048e:	f7ff ffd1 	bl	10434 <notify_one>
	while (!sys_slist_is_empty(list)) {
   10492:	68b8      	ldr	r0, [r7, #8]
   10494:	f7ff fea2 	bl	101dc <sys_slist_is_empty>
   10498:	4603      	mov	r3, r0
   1049a:	f083 0301 	eor.w	r3, r3, #1
   1049e:	b2db      	uxtb	r3, r3
   104a0:	2b00      	cmp	r3, #0
   104a2:	d1ea      	bne.n	1047a <notify_all+0x10>
}
   104a4:	bf00      	nop
   104a6:	bf00      	nop
   104a8:	3718      	adds	r7, #24
   104aa:	46bd      	mov	sp, r7
   104ac:	bd80      	pop	{r7, pc}

000104ae <process_recheck>:
{
   104ae:	b580      	push	{r7, lr}
   104b0:	b084      	sub	sp, #16
   104b2:	af00      	add	r7, sp, #0
   104b4:	6078      	str	r0, [r7, #4]
	int evt = EVT_NOP;
   104b6:	2300      	movs	r3, #0
   104b8:	60fb      	str	r3, [r7, #12]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   104ba:	687b      	ldr	r3, [r7, #4]
   104bc:	8b9b      	ldrh	r3, [r3, #28]
   104be:	f003 0307 	and.w	r3, r3, #7
   104c2:	60bb      	str	r3, [r7, #8]
	if ((state == ONOFF_STATE_OFF)
   104c4:	68bb      	ldr	r3, [r7, #8]
   104c6:	2b00      	cmp	r3, #0
   104c8:	d10c      	bne.n	104e4 <process_recheck+0x36>
	    && !sys_slist_is_empty(&mgr->clients)) {
   104ca:	687b      	ldr	r3, [r7, #4]
   104cc:	4618      	mov	r0, r3
   104ce:	f7ff fe85 	bl	101dc <sys_slist_is_empty>
   104d2:	4603      	mov	r3, r0
   104d4:	f083 0301 	eor.w	r3, r3, #1
   104d8:	b2db      	uxtb	r3, r3
   104da:	2b00      	cmp	r3, #0
   104dc:	d002      	beq.n	104e4 <process_recheck+0x36>
		evt = EVT_START;
   104de:	2303      	movs	r3, #3
   104e0:	60fb      	str	r3, [r7, #12]
   104e2:	e018      	b.n	10516 <process_recheck+0x68>
	} else if ((state == ONOFF_STATE_ON)
   104e4:	68bb      	ldr	r3, [r7, #8]
   104e6:	2b02      	cmp	r3, #2
   104e8:	d106      	bne.n	104f8 <process_recheck+0x4a>
		   && (mgr->refs == 0U)) {
   104ea:	687b      	ldr	r3, [r7, #4]
   104ec:	8bdb      	ldrh	r3, [r3, #30]
   104ee:	2b00      	cmp	r3, #0
   104f0:	d102      	bne.n	104f8 <process_recheck+0x4a>
		evt = EVT_STOP;
   104f2:	2304      	movs	r3, #4
   104f4:	60fb      	str	r3, [r7, #12]
   104f6:	e00e      	b.n	10516 <process_recheck+0x68>
	} else if ((state == ONOFF_STATE_ERROR)
   104f8:	68bb      	ldr	r3, [r7, #8]
   104fa:	2b01      	cmp	r3, #1
   104fc:	d10b      	bne.n	10516 <process_recheck+0x68>
		   && !sys_slist_is_empty(&mgr->clients)) {
   104fe:	687b      	ldr	r3, [r7, #4]
   10500:	4618      	mov	r0, r3
   10502:	f7ff fe6b 	bl	101dc <sys_slist_is_empty>
   10506:	4603      	mov	r3, r0
   10508:	f083 0301 	eor.w	r3, r3, #1
   1050c:	b2db      	uxtb	r3, r3
   1050e:	2b00      	cmp	r3, #0
   10510:	d001      	beq.n	10516 <process_recheck+0x68>
		evt = EVT_RESET;
   10512:	2305      	movs	r3, #5
   10514:	60fb      	str	r3, [r7, #12]
	return evt;
   10516:	68fb      	ldr	r3, [r7, #12]
}
   10518:	4618      	mov	r0, r3
   1051a:	3710      	adds	r7, #16
   1051c:	46bd      	mov	sp, r7
   1051e:	bd80      	pop	{r7, pc}

00010520 <k_current_get>:
}


extern k_tid_t z_impl_k_current_get();
static inline k_tid_t k_current_get()
{
   10520:	b580      	push	{r7, lr}
   10522:	af00      	add	r7, sp, #0
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_K_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_current_get();
   10524:	f7fd ff0c 	bl	e340 <z_impl_k_current_get>
   10528:	4603      	mov	r3, r0
}
   1052a:	4618      	mov	r0, r3
   1052c:	bd80      	pop	{r7, pc}

0001052e <k_thread_abort>:


extern void z_impl_k_thread_abort(k_tid_t thread);
static inline void k_thread_abort(k_tid_t thread)
{
   1052e:	b580      	push	{r7, lr}
   10530:	b082      	sub	sp, #8
   10532:	af00      	add	r7, sp, #0
   10534:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
   10536:	6878      	ldr	r0, [r7, #4]
   10538:	f7f5 fde8 	bl	610c <z_impl_k_thread_abort>
}
   1053c:	bf00      	nop
   1053e:	3708      	adds	r7, #8
   10540:	46bd      	mov	sp, r7
   10542:	bd80      	pop	{r7, pc}

00010544 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   10544:	b580      	push	{r7, lr}
   10546:	b084      	sub	sp, #16
   10548:	af00      	add	r7, sp, #0
   1054a:	60f8      	str	r0, [r7, #12]
   1054c:	60b9      	str	r1, [r7, #8]
   1054e:	607a      	str	r2, [r7, #4]
   10550:	603b      	str	r3, [r7, #0]
	entry(p1, p2, p3);
   10552:	68fb      	ldr	r3, [r7, #12]
   10554:	683a      	ldr	r2, [r7, #0]
   10556:	6879      	ldr	r1, [r7, #4]
   10558:	68b8      	ldr	r0, [r7, #8]
   1055a:	4798      	blx	r3

	k_thread_abort(k_current_get());
   1055c:	f7ff ffe0 	bl	10520 <k_current_get>
   10560:	4603      	mov	r3, r0
   10562:	4618      	mov	r0, r3
   10564:	f7ff ffe3 	bl	1052e <k_thread_abort>

00010568 <big_heap_chunks>:
	uint32_t avail_buckets;
	struct z_heap_bucket buckets[0];
};

static inline bool big_heap_chunks(size_t chunks)
{
   10568:	b480      	push	{r7}
   1056a:	b083      	sub	sp, #12
   1056c:	af00      	add	r7, sp, #0
   1056e:	6078      	str	r0, [r7, #4]
	return sizeof(void *) > 4U || chunks > 0x7fffU;
   10570:	687b      	ldr	r3, [r7, #4]
   10572:	f647 72ff 	movw	r2, #32767	; 0x7fff
   10576:	4293      	cmp	r3, r2
   10578:	bf8c      	ite	hi
   1057a:	2301      	movhi	r3, #1
   1057c:	2300      	movls	r3, #0
   1057e:	b2db      	uxtb	r3, r3
}
   10580:	4618      	mov	r0, r3
   10582:	370c      	adds	r7, #12
   10584:	46bd      	mov	sp, r7
   10586:	bc80      	pop	{r7}
   10588:	4770      	bx	lr

0001058a <big_heap_bytes>:

static inline bool big_heap_bytes(size_t bytes)
{
   1058a:	b580      	push	{r7, lr}
   1058c:	b082      	sub	sp, #8
   1058e:	af00      	add	r7, sp, #0
   10590:	6078      	str	r0, [r7, #4]
	return big_heap_chunks(bytes / CHUNK_UNIT);
   10592:	687b      	ldr	r3, [r7, #4]
   10594:	08db      	lsrs	r3, r3, #3
   10596:	4618      	mov	r0, r3
   10598:	f7ff ffe6 	bl	10568 <big_heap_chunks>
   1059c:	4603      	mov	r3, r0
}
   1059e:	4618      	mov	r0, r3
   105a0:	3708      	adds	r7, #8
   105a2:	46bd      	mov	sp, r7
   105a4:	bd80      	pop	{r7, pc}

000105a6 <big_heap>:

static inline bool big_heap(struct z_heap *h)
{
   105a6:	b580      	push	{r7, lr}
   105a8:	b082      	sub	sp, #8
   105aa:	af00      	add	r7, sp, #0
   105ac:	6078      	str	r0, [r7, #4]
	return big_heap_chunks(h->len);
   105ae:	687b      	ldr	r3, [r7, #4]
   105b0:	689b      	ldr	r3, [r3, #8]
   105b2:	4618      	mov	r0, r3
   105b4:	f7ff ffd8 	bl	10568 <big_heap_chunks>
   105b8:	4603      	mov	r3, r0
}
   105ba:	4618      	mov	r0, r3
   105bc:	3708      	adds	r7, #8
   105be:	46bd      	mov	sp, r7
   105c0:	bd80      	pop	{r7, pc}

000105c2 <chunk_buf>:

static inline chunk_unit_t *chunk_buf(struct z_heap *h)
{
   105c2:	b480      	push	{r7}
   105c4:	b083      	sub	sp, #12
   105c6:	af00      	add	r7, sp, #0
   105c8:	6078      	str	r0, [r7, #4]
	/* the struct z_heap matches with the first chunk */
	return (chunk_unit_t *)h;
   105ca:	687b      	ldr	r3, [r7, #4]
}
   105cc:	4618      	mov	r0, r3
   105ce:	370c      	adds	r7, #12
   105d0:	46bd      	mov	sp, r7
   105d2:	bc80      	pop	{r7}
   105d4:	4770      	bx	lr

000105d6 <chunk_field>:

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
   105d6:	b580      	push	{r7, lr}
   105d8:	b086      	sub	sp, #24
   105da:	af00      	add	r7, sp, #0
   105dc:	60f8      	str	r0, [r7, #12]
   105de:	60b9      	str	r1, [r7, #8]
   105e0:	4613      	mov	r3, r2
   105e2:	71fb      	strb	r3, [r7, #7]
	chunk_unit_t *buf = chunk_buf(h);
   105e4:	68f8      	ldr	r0, [r7, #12]
   105e6:	f7ff ffec 	bl	105c2 <chunk_buf>
   105ea:	6178      	str	r0, [r7, #20]
	void *cmem = &buf[c];
   105ec:	68bb      	ldr	r3, [r7, #8]
   105ee:	00db      	lsls	r3, r3, #3
   105f0:	697a      	ldr	r2, [r7, #20]
   105f2:	4413      	add	r3, r2
   105f4:	613b      	str	r3, [r7, #16]

	if (big_heap(h)) {
   105f6:	68f8      	ldr	r0, [r7, #12]
   105f8:	f7ff ffd5 	bl	105a6 <big_heap>
   105fc:	4603      	mov	r3, r0
   105fe:	2b00      	cmp	r3, #0
   10600:	d005      	beq.n	1060e <chunk_field+0x38>
		return ((uint32_t *)cmem)[f];
   10602:	79fb      	ldrb	r3, [r7, #7]
   10604:	009b      	lsls	r3, r3, #2
   10606:	693a      	ldr	r2, [r7, #16]
   10608:	4413      	add	r3, r2
   1060a:	681b      	ldr	r3, [r3, #0]
   1060c:	e004      	b.n	10618 <chunk_field+0x42>
	} else {
		return ((uint16_t *)cmem)[f];
   1060e:	79fb      	ldrb	r3, [r7, #7]
   10610:	005b      	lsls	r3, r3, #1
   10612:	693a      	ldr	r2, [r7, #16]
   10614:	4413      	add	r3, r2
   10616:	881b      	ldrh	r3, [r3, #0]
	}
}
   10618:	4618      	mov	r0, r3
   1061a:	3718      	adds	r7, #24
   1061c:	46bd      	mov	sp, r7
   1061e:	bd80      	pop	{r7, pc}

00010620 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
   10620:	b580      	push	{r7, lr}
   10622:	b086      	sub	sp, #24
   10624:	af00      	add	r7, sp, #0
   10626:	60f8      	str	r0, [r7, #12]
   10628:	60b9      	str	r1, [r7, #8]
   1062a:	603b      	str	r3, [r7, #0]
   1062c:	4613      	mov	r3, r2
   1062e:	71fb      	strb	r3, [r7, #7]
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
   10630:	68f8      	ldr	r0, [r7, #12]
   10632:	f7ff ffc6 	bl	105c2 <chunk_buf>
   10636:	6178      	str	r0, [r7, #20]
	void *cmem = &buf[c];
   10638:	68bb      	ldr	r3, [r7, #8]
   1063a:	00db      	lsls	r3, r3, #3
   1063c:	697a      	ldr	r2, [r7, #20]
   1063e:	4413      	add	r3, r2
   10640:	613b      	str	r3, [r7, #16]

	if (big_heap(h)) {
   10642:	68f8      	ldr	r0, [r7, #12]
   10644:	f7ff ffaf 	bl	105a6 <big_heap>
   10648:	4603      	mov	r3, r0
   1064a:	2b00      	cmp	r3, #0
   1064c:	d006      	beq.n	1065c <chunk_set+0x3c>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
   1064e:	79fb      	ldrb	r3, [r7, #7]
   10650:	009b      	lsls	r3, r3, #2
   10652:	693a      	ldr	r2, [r7, #16]
   10654:	4413      	add	r3, r2
   10656:	683a      	ldr	r2, [r7, #0]
   10658:	601a      	str	r2, [r3, #0]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
	}
}
   1065a:	e006      	b.n	1066a <chunk_set+0x4a>
		((uint16_t *)cmem)[f] = val;
   1065c:	79fb      	ldrb	r3, [r7, #7]
   1065e:	005b      	lsls	r3, r3, #1
   10660:	693a      	ldr	r2, [r7, #16]
   10662:	4413      	add	r3, r2
   10664:	683a      	ldr	r2, [r7, #0]
   10666:	b292      	uxth	r2, r2
   10668:	801a      	strh	r2, [r3, #0]
}
   1066a:	bf00      	nop
   1066c:	3718      	adds	r7, #24
   1066e:	46bd      	mov	sp, r7
   10670:	bd80      	pop	{r7, pc}

00010672 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
   10672:	b580      	push	{r7, lr}
   10674:	b082      	sub	sp, #8
   10676:	af00      	add	r7, sp, #0
   10678:	6078      	str	r0, [r7, #4]
   1067a:	6039      	str	r1, [r7, #0]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   1067c:	2201      	movs	r2, #1
   1067e:	6839      	ldr	r1, [r7, #0]
   10680:	6878      	ldr	r0, [r7, #4]
   10682:	f7ff ffa8 	bl	105d6 <chunk_field>
   10686:	4603      	mov	r3, r0
   10688:	085b      	lsrs	r3, r3, #1
}
   1068a:	4618      	mov	r0, r3
   1068c:	3708      	adds	r7, #8
   1068e:	46bd      	mov	sp, r7
   10690:	bd80      	pop	{r7, pc}

00010692 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
   10692:	b580      	push	{r7, lr}
   10694:	b086      	sub	sp, #24
   10696:	af00      	add	r7, sp, #0
   10698:	60f8      	str	r0, [r7, #12]
   1069a:	60b9      	str	r1, [r7, #8]
   1069c:	4613      	mov	r3, r2
   1069e:	71fb      	strb	r3, [r7, #7]
	chunk_unit_t *buf = chunk_buf(h);
   106a0:	68f8      	ldr	r0, [r7, #12]
   106a2:	f7ff ff8e 	bl	105c2 <chunk_buf>
   106a6:	6178      	str	r0, [r7, #20]
	void *cmem = &buf[c];
   106a8:	68bb      	ldr	r3, [r7, #8]
   106aa:	00db      	lsls	r3, r3, #3
   106ac:	697a      	ldr	r2, [r7, #20]
   106ae:	4413      	add	r3, r2
   106b0:	613b      	str	r3, [r7, #16]

	if (big_heap(h)) {
   106b2:	68f8      	ldr	r0, [r7, #12]
   106b4:	f7ff ff77 	bl	105a6 <big_heap>
   106b8:	4603      	mov	r3, r0
   106ba:	2b00      	cmp	r3, #0
   106bc:	d014      	beq.n	106e8 <set_chunk_used+0x56>
		if (used) {
   106be:	79fb      	ldrb	r3, [r7, #7]
   106c0:	2b00      	cmp	r3, #0
   106c2:	d008      	beq.n	106d6 <set_chunk_used+0x44>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   106c4:	693b      	ldr	r3, [r7, #16]
   106c6:	3304      	adds	r3, #4
   106c8:	681a      	ldr	r2, [r3, #0]
   106ca:	693b      	ldr	r3, [r7, #16]
   106cc:	3304      	adds	r3, #4
   106ce:	f042 0201 	orr.w	r2, r2, #1
   106d2:	601a      	str	r2, [r3, #0]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
   106d4:	e01e      	b.n	10714 <set_chunk_used+0x82>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
   106d6:	693b      	ldr	r3, [r7, #16]
   106d8:	3304      	adds	r3, #4
   106da:	681a      	ldr	r2, [r3, #0]
   106dc:	693b      	ldr	r3, [r7, #16]
   106de:	3304      	adds	r3, #4
   106e0:	f022 0201 	bic.w	r2, r2, #1
   106e4:	601a      	str	r2, [r3, #0]
}
   106e6:	e015      	b.n	10714 <set_chunk_used+0x82>
		if (used) {
   106e8:	79fb      	ldrb	r3, [r7, #7]
   106ea:	2b00      	cmp	r3, #0
   106ec:	d009      	beq.n	10702 <set_chunk_used+0x70>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   106ee:	693b      	ldr	r3, [r7, #16]
   106f0:	3302      	adds	r3, #2
   106f2:	881a      	ldrh	r2, [r3, #0]
   106f4:	693b      	ldr	r3, [r7, #16]
   106f6:	3302      	adds	r3, #2
   106f8:	f042 0201 	orr.w	r2, r2, #1
   106fc:	b292      	uxth	r2, r2
   106fe:	801a      	strh	r2, [r3, #0]
}
   10700:	e008      	b.n	10714 <set_chunk_used+0x82>
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   10702:	693b      	ldr	r3, [r7, #16]
   10704:	3302      	adds	r3, #2
   10706:	881a      	ldrh	r2, [r3, #0]
   10708:	693b      	ldr	r3, [r7, #16]
   1070a:	3302      	adds	r3, #2
   1070c:	f022 0201 	bic.w	r2, r2, #1
   10710:	b292      	uxth	r2, r2
   10712:	801a      	strh	r2, [r3, #0]
}
   10714:	bf00      	nop
   10716:	3718      	adds	r7, #24
   10718:	46bd      	mov	sp, r7
   1071a:	bd80      	pop	{r7, pc}

0001071c <set_chunk_size>:
 * Note: no need to preserve the used bit here as the chunk is never in use
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
   1071c:	b580      	push	{r7, lr}
   1071e:	b084      	sub	sp, #16
   10720:	af00      	add	r7, sp, #0
   10722:	60f8      	str	r0, [r7, #12]
   10724:	60b9      	str	r1, [r7, #8]
   10726:	607a      	str	r2, [r7, #4]
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   10728:	687b      	ldr	r3, [r7, #4]
   1072a:	005b      	lsls	r3, r3, #1
   1072c:	2201      	movs	r2, #1
   1072e:	68b9      	ldr	r1, [r7, #8]
   10730:	68f8      	ldr	r0, [r7, #12]
   10732:	f7ff ff75 	bl	10620 <chunk_set>
}
   10736:	bf00      	nop
   10738:	3710      	adds	r7, #16
   1073a:	46bd      	mov	sp, r7
   1073c:	bd80      	pop	{r7, pc}

0001073e <prev_free_chunk>:

static inline chunkid_t prev_free_chunk(struct z_heap *h, chunkid_t c)
{
   1073e:	b580      	push	{r7, lr}
   10740:	b082      	sub	sp, #8
   10742:	af00      	add	r7, sp, #0
   10744:	6078      	str	r0, [r7, #4]
   10746:	6039      	str	r1, [r7, #0]
	return chunk_field(h, c, FREE_PREV);
   10748:	2202      	movs	r2, #2
   1074a:	6839      	ldr	r1, [r7, #0]
   1074c:	6878      	ldr	r0, [r7, #4]
   1074e:	f7ff ff42 	bl	105d6 <chunk_field>
   10752:	4603      	mov	r3, r0
}
   10754:	4618      	mov	r0, r3
   10756:	3708      	adds	r7, #8
   10758:	46bd      	mov	sp, r7
   1075a:	bd80      	pop	{r7, pc}

0001075c <set_prev_free_chunk>:
	return chunk_field(h, c, FREE_NEXT);
}

static inline void set_prev_free_chunk(struct z_heap *h, chunkid_t c,
				       chunkid_t prev)
{
   1075c:	b580      	push	{r7, lr}
   1075e:	b084      	sub	sp, #16
   10760:	af00      	add	r7, sp, #0
   10762:	60f8      	str	r0, [r7, #12]
   10764:	60b9      	str	r1, [r7, #8]
   10766:	607a      	str	r2, [r7, #4]
	chunk_set(h, c, FREE_PREV, prev);
   10768:	687b      	ldr	r3, [r7, #4]
   1076a:	2202      	movs	r2, #2
   1076c:	68b9      	ldr	r1, [r7, #8]
   1076e:	68f8      	ldr	r0, [r7, #12]
   10770:	f7ff ff56 	bl	10620 <chunk_set>
}
   10774:	bf00      	nop
   10776:	3710      	adds	r7, #16
   10778:	46bd      	mov	sp, r7
   1077a:	bd80      	pop	{r7, pc}

0001077c <set_next_free_chunk>:

static inline void set_next_free_chunk(struct z_heap *h, chunkid_t c,
				       chunkid_t next)
{
   1077c:	b580      	push	{r7, lr}
   1077e:	b084      	sub	sp, #16
   10780:	af00      	add	r7, sp, #0
   10782:	60f8      	str	r0, [r7, #12]
   10784:	60b9      	str	r1, [r7, #8]
   10786:	607a      	str	r2, [r7, #4]
	chunk_set(h, c, FREE_NEXT, next);
   10788:	687b      	ldr	r3, [r7, #4]
   1078a:	2203      	movs	r2, #3
   1078c:	68b9      	ldr	r1, [r7, #8]
   1078e:	68f8      	ldr	r0, [r7, #12]
   10790:	f7ff ff46 	bl	10620 <chunk_set>
}
   10794:	bf00      	nop
   10796:	3710      	adds	r7, #16
   10798:	46bd      	mov	sp, r7
   1079a:	bd80      	pop	{r7, pc}

0001079c <set_left_chunk_size>:
	return c + chunk_size(h, c);
}

static inline void set_left_chunk_size(struct z_heap *h, chunkid_t c,
				       size_t size)
{
   1079c:	b580      	push	{r7, lr}
   1079e:	b084      	sub	sp, #16
   107a0:	af00      	add	r7, sp, #0
   107a2:	60f8      	str	r0, [r7, #12]
   107a4:	60b9      	str	r1, [r7, #8]
   107a6:	607a      	str	r2, [r7, #4]
	chunk_set(h, c, LEFT_SIZE, size);
   107a8:	687b      	ldr	r3, [r7, #4]
   107aa:	2200      	movs	r2, #0
   107ac:	68b9      	ldr	r1, [r7, #8]
   107ae:	68f8      	ldr	r0, [r7, #12]
   107b0:	f7ff ff36 	bl	10620 <chunk_set>
}
   107b4:	bf00      	nop
   107b6:	3710      	adds	r7, #16
   107b8:	46bd      	mov	sp, r7
   107ba:	bd80      	pop	{r7, pc}

000107bc <solo_free_header>:

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
   107bc:	b580      	push	{r7, lr}
   107be:	b082      	sub	sp, #8
   107c0:	af00      	add	r7, sp, #0
   107c2:	6078      	str	r0, [r7, #4]
   107c4:	6039      	str	r1, [r7, #0]
	return big_heap(h) && chunk_size(h, c) == 1U;
   107c6:	6878      	ldr	r0, [r7, #4]
   107c8:	f7ff feed 	bl	105a6 <big_heap>
   107cc:	4603      	mov	r3, r0
   107ce:	2b00      	cmp	r3, #0
   107d0:	d008      	beq.n	107e4 <solo_free_header+0x28>
   107d2:	6839      	ldr	r1, [r7, #0]
   107d4:	6878      	ldr	r0, [r7, #4]
   107d6:	f7ff ff4c 	bl	10672 <chunk_size>
   107da:	4603      	mov	r3, r0
   107dc:	2b01      	cmp	r3, #1
   107de:	d101      	bne.n	107e4 <solo_free_header+0x28>
   107e0:	2301      	movs	r3, #1
   107e2:	e000      	b.n	107e6 <solo_free_header+0x2a>
   107e4:	2300      	movs	r3, #0
   107e6:	f003 0301 	and.w	r3, r3, #1
   107ea:	b2db      	uxtb	r3, r3
}
   107ec:	4618      	mov	r0, r3
   107ee:	3708      	adds	r7, #8
   107f0:	46bd      	mov	sp, r7
   107f2:	bd80      	pop	{r7, pc}

000107f4 <chunk_header_bytes>:

static inline size_t chunk_header_bytes(struct z_heap *h)
{
   107f4:	b580      	push	{r7, lr}
   107f6:	b082      	sub	sp, #8
   107f8:	af00      	add	r7, sp, #0
   107fa:	6078      	str	r0, [r7, #4]
	return big_heap(h) ? 8 : 4;
   107fc:	6878      	ldr	r0, [r7, #4]
   107fe:	f7ff fed2 	bl	105a6 <big_heap>
   10802:	4603      	mov	r3, r0
   10804:	2b00      	cmp	r3, #0
   10806:	d001      	beq.n	1080c <chunk_header_bytes+0x18>
   10808:	2308      	movs	r3, #8
   1080a:	e000      	b.n	1080e <chunk_header_bytes+0x1a>
   1080c:	2304      	movs	r3, #4
}
   1080e:	4618      	mov	r0, r3
   10810:	3708      	adds	r7, #8
   10812:	46bd      	mov	sp, r7
   10814:	bd80      	pop	{r7, pc}

00010816 <heap_footer_bytes>:

static inline size_t heap_footer_bytes(size_t size)
{
   10816:	b580      	push	{r7, lr}
   10818:	b082      	sub	sp, #8
   1081a:	af00      	add	r7, sp, #0
   1081c:	6078      	str	r0, [r7, #4]
	return big_heap_bytes(size) ? 8 : 4;
   1081e:	6878      	ldr	r0, [r7, #4]
   10820:	f7ff feb3 	bl	1058a <big_heap_bytes>
   10824:	4603      	mov	r3, r0
   10826:	2b00      	cmp	r3, #0
   10828:	d001      	beq.n	1082e <heap_footer_bytes+0x18>
   1082a:	2308      	movs	r3, #8
   1082c:	e000      	b.n	10830 <heap_footer_bytes+0x1a>
   1082e:	2304      	movs	r3, #4
}
   10830:	4618      	mov	r0, r3
   10832:	3708      	adds	r7, #8
   10834:	46bd      	mov	sp, r7
   10836:	bd80      	pop	{r7, pc}

00010838 <chunksz>:

static inline size_t chunksz(size_t bytes)
{
   10838:	b480      	push	{r7}
   1083a:	b083      	sub	sp, #12
   1083c:	af00      	add	r7, sp, #0
   1083e:	6078      	str	r0, [r7, #4]
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   10840:	687b      	ldr	r3, [r7, #4]
   10842:	3307      	adds	r3, #7
   10844:	08db      	lsrs	r3, r3, #3
}
   10846:	4618      	mov	r0, r3
   10848:	370c      	adds	r7, #12
   1084a:	46bd      	mov	sp, r7
   1084c:	bc80      	pop	{r7}
   1084e:	4770      	bx	lr

00010850 <bytes_to_chunksz>:

static inline size_t bytes_to_chunksz(struct z_heap *h, size_t bytes)
{
   10850:	b580      	push	{r7, lr}
   10852:	b082      	sub	sp, #8
   10854:	af00      	add	r7, sp, #0
   10856:	6078      	str	r0, [r7, #4]
   10858:	6039      	str	r1, [r7, #0]
	return chunksz(chunk_header_bytes(h) + bytes);
   1085a:	6878      	ldr	r0, [r7, #4]
   1085c:	f7ff ffca 	bl	107f4 <chunk_header_bytes>
   10860:	4602      	mov	r2, r0
   10862:	683b      	ldr	r3, [r7, #0]
   10864:	4413      	add	r3, r2
   10866:	4618      	mov	r0, r3
   10868:	f7ff ffe6 	bl	10838 <chunksz>
   1086c:	4603      	mov	r3, r0
}
   1086e:	4618      	mov	r0, r3
   10870:	3708      	adds	r7, #8
   10872:	46bd      	mov	sp, r7
   10874:	bd80      	pop	{r7, pc}

00010876 <min_chunk_size>:

static inline int min_chunk_size(struct z_heap *h)
{
   10876:	b580      	push	{r7, lr}
   10878:	b082      	sub	sp, #8
   1087a:	af00      	add	r7, sp, #0
   1087c:	6078      	str	r0, [r7, #4]
	return bytes_to_chunksz(h, 1);
   1087e:	2101      	movs	r1, #1
   10880:	6878      	ldr	r0, [r7, #4]
   10882:	f7ff ffe5 	bl	10850 <bytes_to_chunksz>
   10886:	4603      	mov	r3, r0
}
   10888:	4618      	mov	r0, r3
   1088a:	3708      	adds	r7, #8
   1088c:	46bd      	mov	sp, r7
   1088e:	bd80      	pop	{r7, pc}

00010890 <bucket_idx>:

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
   10890:	b580      	push	{r7, lr}
   10892:	b084      	sub	sp, #16
   10894:	af00      	add	r7, sp, #0
   10896:	6078      	str	r0, [r7, #4]
   10898:	6039      	str	r1, [r7, #0]
	size_t usable_sz = sz - min_chunk_size(h) + 1;
   1089a:	6878      	ldr	r0, [r7, #4]
   1089c:	f7ff ffeb 	bl	10876 <min_chunk_size>
   108a0:	4603      	mov	r3, r0
   108a2:	461a      	mov	r2, r3
   108a4:	683b      	ldr	r3, [r7, #0]
   108a6:	1a9b      	subs	r3, r3, r2
   108a8:	3301      	adds	r3, #1
   108aa:	60fb      	str	r3, [r7, #12]
	return 31 - __builtin_clz(usable_sz);
   108ac:	68fb      	ldr	r3, [r7, #12]
   108ae:	fab3 f383 	clz	r3, r3
   108b2:	f1c3 031f 	rsb	r3, r3, #31
}
   108b6:	4618      	mov	r0, r3
   108b8:	3710      	adds	r7, #16
   108ba:	46bd      	mov	sp, r7
   108bc:	bd80      	pop	{r7, pc}

000108be <free_list_add_bidx>:
{
   108be:	b580      	push	{r7, lr}
   108c0:	b088      	sub	sp, #32
   108c2:	af00      	add	r7, sp, #0
   108c4:	60f8      	str	r0, [r7, #12]
   108c6:	60b9      	str	r1, [r7, #8]
   108c8:	607a      	str	r2, [r7, #4]
	struct z_heap_bucket *b = &h->buckets[bidx];
   108ca:	687b      	ldr	r3, [r7, #4]
   108cc:	3304      	adds	r3, #4
   108ce:	009b      	lsls	r3, r3, #2
   108d0:	68fa      	ldr	r2, [r7, #12]
   108d2:	4413      	add	r3, r2
   108d4:	61fb      	str	r3, [r7, #28]
	if (b->next == 0U) {
   108d6:	69fb      	ldr	r3, [r7, #28]
   108d8:	681b      	ldr	r3, [r3, #0]
   108da:	2b00      	cmp	r3, #0
   108dc:	d116      	bne.n	1090c <free_list_add_bidx+0x4e>
		h->avail_buckets |= (1 << bidx);
   108de:	68fb      	ldr	r3, [r7, #12]
   108e0:	68db      	ldr	r3, [r3, #12]
   108e2:	2101      	movs	r1, #1
   108e4:	687a      	ldr	r2, [r7, #4]
   108e6:	fa01 f202 	lsl.w	r2, r1, r2
   108ea:	431a      	orrs	r2, r3
   108ec:	68fb      	ldr	r3, [r7, #12]
   108ee:	60da      	str	r2, [r3, #12]
		b->next = c;
   108f0:	69fb      	ldr	r3, [r7, #28]
   108f2:	68ba      	ldr	r2, [r7, #8]
   108f4:	601a      	str	r2, [r3, #0]
		set_prev_free_chunk(h, c, c);
   108f6:	68ba      	ldr	r2, [r7, #8]
   108f8:	68b9      	ldr	r1, [r7, #8]
   108fa:	68f8      	ldr	r0, [r7, #12]
   108fc:	f7ff ff2e 	bl	1075c <set_prev_free_chunk>
		set_next_free_chunk(h, c, c);
   10900:	68ba      	ldr	r2, [r7, #8]
   10902:	68b9      	ldr	r1, [r7, #8]
   10904:	68f8      	ldr	r0, [r7, #12]
   10906:	f7ff ff39 	bl	1077c <set_next_free_chunk>
}
   1090a:	e01b      	b.n	10944 <free_list_add_bidx+0x86>
		chunkid_t second = b->next;
   1090c:	69fb      	ldr	r3, [r7, #28]
   1090e:	681b      	ldr	r3, [r3, #0]
   10910:	61bb      	str	r3, [r7, #24]
		chunkid_t first = prev_free_chunk(h, second);
   10912:	69b9      	ldr	r1, [r7, #24]
   10914:	68f8      	ldr	r0, [r7, #12]
   10916:	f7ff ff12 	bl	1073e <prev_free_chunk>
   1091a:	6178      	str	r0, [r7, #20]
		set_prev_free_chunk(h, c, first);
   1091c:	697a      	ldr	r2, [r7, #20]
   1091e:	68b9      	ldr	r1, [r7, #8]
   10920:	68f8      	ldr	r0, [r7, #12]
   10922:	f7ff ff1b 	bl	1075c <set_prev_free_chunk>
		set_next_free_chunk(h, c, second);
   10926:	69ba      	ldr	r2, [r7, #24]
   10928:	68b9      	ldr	r1, [r7, #8]
   1092a:	68f8      	ldr	r0, [r7, #12]
   1092c:	f7ff ff26 	bl	1077c <set_next_free_chunk>
		set_next_free_chunk(h, first, c);
   10930:	68ba      	ldr	r2, [r7, #8]
   10932:	6979      	ldr	r1, [r7, #20]
   10934:	68f8      	ldr	r0, [r7, #12]
   10936:	f7ff ff21 	bl	1077c <set_next_free_chunk>
		set_prev_free_chunk(h, second, c);
   1093a:	68ba      	ldr	r2, [r7, #8]
   1093c:	69b9      	ldr	r1, [r7, #24]
   1093e:	68f8      	ldr	r0, [r7, #12]
   10940:	f7ff ff0c 	bl	1075c <set_prev_free_chunk>
}
   10944:	bf00      	nop
   10946:	3720      	adds	r7, #32
   10948:	46bd      	mov	sp, r7
   1094a:	bd80      	pop	{r7, pc}

0001094c <free_list_add>:
{
   1094c:	b580      	push	{r7, lr}
   1094e:	b084      	sub	sp, #16
   10950:	af00      	add	r7, sp, #0
   10952:	6078      	str	r0, [r7, #4]
   10954:	6039      	str	r1, [r7, #0]
	if (!solo_free_header(h, c)) {
   10956:	6839      	ldr	r1, [r7, #0]
   10958:	6878      	ldr	r0, [r7, #4]
   1095a:	f7ff ff2f 	bl	107bc <solo_free_header>
   1095e:	4603      	mov	r3, r0
   10960:	f083 0301 	eor.w	r3, r3, #1
   10964:	b2db      	uxtb	r3, r3
   10966:	2b00      	cmp	r3, #0
   10968:	d00e      	beq.n	10988 <free_list_add+0x3c>
		int bidx = bucket_idx(h, chunk_size(h, c));
   1096a:	6839      	ldr	r1, [r7, #0]
   1096c:	6878      	ldr	r0, [r7, #4]
   1096e:	f7ff fe80 	bl	10672 <chunk_size>
   10972:	4603      	mov	r3, r0
   10974:	4619      	mov	r1, r3
   10976:	6878      	ldr	r0, [r7, #4]
   10978:	f7ff ff8a 	bl	10890 <bucket_idx>
   1097c:	60f8      	str	r0, [r7, #12]
		free_list_add_bidx(h, c, bidx);
   1097e:	68fa      	ldr	r2, [r7, #12]
   10980:	6839      	ldr	r1, [r7, #0]
   10982:	6878      	ldr	r0, [r7, #4]
   10984:	f7ff ff9b 	bl	108be <free_list_add_bidx>
}
   10988:	bf00      	nop
   1098a:	3710      	adds	r7, #16
   1098c:	46bd      	mov	sp, r7
   1098e:	bd80      	pop	{r7, pc}

00010990 <isupper>:
#ifdef __cplusplus
extern "C" {
#endif

static inline int isupper(int a)
{
   10990:	b480      	push	{r7}
   10992:	b083      	sub	sp, #12
   10994:	af00      	add	r7, sp, #0
   10996:	6078      	str	r0, [r7, #4]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   10998:	687b      	ldr	r3, [r7, #4]
   1099a:	3b41      	subs	r3, #65	; 0x41
   1099c:	2b19      	cmp	r3, #25
   1099e:	bf94      	ite	ls
   109a0:	2301      	movls	r3, #1
   109a2:	2300      	movhi	r3, #0
   109a4:	b2db      	uxtb	r3, r3
}
   109a6:	4618      	mov	r0, r3
   109a8:	370c      	adds	r7, #12
   109aa:	46bd      	mov	sp, r7
   109ac:	bc80      	pop	{r7}
   109ae:	4770      	bx	lr

000109b0 <isdigit>:
	return (int)((((unsigned)c) >= ' ') &&
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
   109b0:	b480      	push	{r7}
   109b2:	b083      	sub	sp, #12
   109b4:	af00      	add	r7, sp, #0
   109b6:	6078      	str	r0, [r7, #4]
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   109b8:	687b      	ldr	r3, [r7, #4]
   109ba:	3b30      	subs	r3, #48	; 0x30
   109bc:	2b09      	cmp	r3, #9
   109be:	bf94      	ite	ls
   109c0:	2301      	movls	r3, #1
   109c2:	2300      	movhi	r3, #0
   109c4:	b2db      	uxtb	r3, r3
}
   109c6:	4618      	mov	r0, r3
   109c8:	370c      	adds	r7, #12
   109ca:	46bd      	mov	sp, r7
   109cc:	bc80      	pop	{r7}
   109ce:	4770      	bx	lr

000109d0 <extract_decimal>:
{
   109d0:	b580      	push	{r7, lr}
   109d2:	b084      	sub	sp, #16
   109d4:	af00      	add	r7, sp, #0
   109d6:	6078      	str	r0, [r7, #4]
	const char *sp = *str;
   109d8:	687b      	ldr	r3, [r7, #4]
   109da:	681b      	ldr	r3, [r3, #0]
   109dc:	60fb      	str	r3, [r7, #12]
	size_t val = 0;
   109de:	2300      	movs	r3, #0
   109e0:	60bb      	str	r3, [r7, #8]
	while (isdigit((int)(unsigned char)*sp)) {
   109e2:	e00c      	b.n	109fe <extract_decimal+0x2e>
		val = 10U * val + *sp++ - '0';
   109e4:	68ba      	ldr	r2, [r7, #8]
   109e6:	4613      	mov	r3, r2
   109e8:	009b      	lsls	r3, r3, #2
   109ea:	4413      	add	r3, r2
   109ec:	005b      	lsls	r3, r3, #1
   109ee:	4619      	mov	r1, r3
   109f0:	68fb      	ldr	r3, [r7, #12]
   109f2:	1c5a      	adds	r2, r3, #1
   109f4:	60fa      	str	r2, [r7, #12]
   109f6:	781b      	ldrb	r3, [r3, #0]
   109f8:	440b      	add	r3, r1
   109fa:	3b30      	subs	r3, #48	; 0x30
   109fc:	60bb      	str	r3, [r7, #8]
	while (isdigit((int)(unsigned char)*sp)) {
   109fe:	68fb      	ldr	r3, [r7, #12]
   10a00:	781b      	ldrb	r3, [r3, #0]
   10a02:	4618      	mov	r0, r3
   10a04:	f7ff ffd4 	bl	109b0 <isdigit>
   10a08:	4603      	mov	r3, r0
   10a0a:	2b00      	cmp	r3, #0
   10a0c:	d1ea      	bne.n	109e4 <extract_decimal+0x14>
	*str = sp;
   10a0e:	687b      	ldr	r3, [r7, #4]
   10a10:	68fa      	ldr	r2, [r7, #12]
   10a12:	601a      	str	r2, [r3, #0]
	return val;
   10a14:	68bb      	ldr	r3, [r7, #8]
}
   10a16:	4618      	mov	r0, r3
   10a18:	3710      	adds	r7, #16
   10a1a:	46bd      	mov	sp, r7
   10a1c:	bd80      	pop	{r7, pc}

00010a1e <extract_width>:
{
   10a1e:	b580      	push	{r7, lr}
   10a20:	b084      	sub	sp, #16
   10a22:	af00      	add	r7, sp, #0
   10a24:	6078      	str	r0, [r7, #4]
   10a26:	6039      	str	r1, [r7, #0]
	if (*sp == '*') {
   10a28:	683b      	ldr	r3, [r7, #0]
   10a2a:	781b      	ldrb	r3, [r3, #0]
   10a2c:	2b2a      	cmp	r3, #42	; 0x2a
   10a2e:	d10e      	bne.n	10a4e <extract_width+0x30>
		conv->width_present = true;
   10a30:	687a      	ldr	r2, [r7, #4]
   10a32:	7813      	ldrb	r3, [r2, #0]
   10a34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   10a38:	7013      	strb	r3, [r2, #0]
		conv->width_star = true;
   10a3a:	687a      	ldr	r2, [r7, #4]
   10a3c:	7853      	ldrb	r3, [r2, #1]
   10a3e:	f043 0301 	orr.w	r3, r3, #1
   10a42:	7053      	strb	r3, [r2, #1]
		return ++sp;
   10a44:	683b      	ldr	r3, [r7, #0]
   10a46:	3301      	adds	r3, #1
   10a48:	603b      	str	r3, [r7, #0]
   10a4a:	683b      	ldr	r3, [r7, #0]
   10a4c:	e01e      	b.n	10a8c <extract_width+0x6e>
	const char *wp = sp;
   10a4e:	683b      	ldr	r3, [r7, #0]
   10a50:	60fb      	str	r3, [r7, #12]
	size_t width = extract_decimal(&sp);
   10a52:	463b      	mov	r3, r7
   10a54:	4618      	mov	r0, r3
   10a56:	f7ff ffbb 	bl	109d0 <extract_decimal>
   10a5a:	60b8      	str	r0, [r7, #8]
	if (sp != wp) {
   10a5c:	683b      	ldr	r3, [r7, #0]
   10a5e:	68fa      	ldr	r2, [r7, #12]
   10a60:	429a      	cmp	r2, r3
   10a62:	d012      	beq.n	10a8a <extract_width+0x6c>
		conv->width_present = true;
   10a64:	687a      	ldr	r2, [r7, #4]
   10a66:	7813      	ldrb	r3, [r2, #0]
   10a68:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   10a6c:	7013      	strb	r3, [r2, #0]
		conv->width_value = width;
   10a6e:	68ba      	ldr	r2, [r7, #8]
   10a70:	687b      	ldr	r3, [r7, #4]
   10a72:	605a      	str	r2, [r3, #4]
		if (width != conv->width_value) {
   10a74:	687b      	ldr	r3, [r7, #4]
   10a76:	685b      	ldr	r3, [r3, #4]
   10a78:	461a      	mov	r2, r3
   10a7a:	68bb      	ldr	r3, [r7, #8]
   10a7c:	4293      	cmp	r3, r2
   10a7e:	d004      	beq.n	10a8a <extract_width+0x6c>
			conv->unsupported = true;
   10a80:	687a      	ldr	r2, [r7, #4]
   10a82:	7813      	ldrb	r3, [r2, #0]
   10a84:	f043 0302 	orr.w	r3, r3, #2
   10a88:	7013      	strb	r3, [r2, #0]
	return sp;
   10a8a:	683b      	ldr	r3, [r7, #0]
}
   10a8c:	4618      	mov	r0, r3
   10a8e:	3710      	adds	r7, #16
   10a90:	46bd      	mov	sp, r7
   10a92:	bd80      	pop	{r7, pc}

00010a94 <extract_prec>:
{
   10a94:	b580      	push	{r7, lr}
   10a96:	b084      	sub	sp, #16
   10a98:	af00      	add	r7, sp, #0
   10a9a:	6078      	str	r0, [r7, #4]
   10a9c:	6039      	str	r1, [r7, #0]
	if (*sp != '.') {
   10a9e:	683b      	ldr	r3, [r7, #0]
   10aa0:	781b      	ldrb	r3, [r3, #0]
   10aa2:	2b2e      	cmp	r3, #46	; 0x2e
   10aa4:	d001      	beq.n	10aaa <extract_prec+0x16>
		return sp;
   10aa6:	683b      	ldr	r3, [r7, #0]
   10aa8:	e034      	b.n	10b14 <extract_prec+0x80>
	++sp;
   10aaa:	683b      	ldr	r3, [r7, #0]
   10aac:	3301      	adds	r3, #1
   10aae:	603b      	str	r3, [r7, #0]
	if (*sp == '*') {
   10ab0:	683b      	ldr	r3, [r7, #0]
   10ab2:	781b      	ldrb	r3, [r3, #0]
   10ab4:	2b2a      	cmp	r3, #42	; 0x2a
   10ab6:	d10e      	bne.n	10ad6 <extract_prec+0x42>
		conv->prec_present = true;
   10ab8:	687a      	ldr	r2, [r7, #4]
   10aba:	7853      	ldrb	r3, [r2, #1]
   10abc:	f043 0302 	orr.w	r3, r3, #2
   10ac0:	7053      	strb	r3, [r2, #1]
		conv->prec_star = true;
   10ac2:	687a      	ldr	r2, [r7, #4]
   10ac4:	7853      	ldrb	r3, [r2, #1]
   10ac6:	f043 0304 	orr.w	r3, r3, #4
   10aca:	7053      	strb	r3, [r2, #1]
		return ++sp;
   10acc:	683b      	ldr	r3, [r7, #0]
   10ace:	3301      	adds	r3, #1
   10ad0:	603b      	str	r3, [r7, #0]
   10ad2:	683b      	ldr	r3, [r7, #0]
   10ad4:	e01e      	b.n	10b14 <extract_prec+0x80>
	const char *wp = sp;
   10ad6:	683b      	ldr	r3, [r7, #0]
   10ad8:	60fb      	str	r3, [r7, #12]
	size_t prec = extract_decimal(&sp);
   10ada:	463b      	mov	r3, r7
   10adc:	4618      	mov	r0, r3
   10ade:	f7ff ff77 	bl	109d0 <extract_decimal>
   10ae2:	60b8      	str	r0, [r7, #8]
	if (sp != wp) {
   10ae4:	683b      	ldr	r3, [r7, #0]
   10ae6:	68fa      	ldr	r2, [r7, #12]
   10ae8:	429a      	cmp	r2, r3
   10aea:	d012      	beq.n	10b12 <extract_prec+0x7e>
		conv->prec_present = true;
   10aec:	687a      	ldr	r2, [r7, #4]
   10aee:	7853      	ldrb	r3, [r2, #1]
   10af0:	f043 0302 	orr.w	r3, r3, #2
   10af4:	7053      	strb	r3, [r2, #1]
		conv->prec_value = prec;
   10af6:	68ba      	ldr	r2, [r7, #8]
   10af8:	687b      	ldr	r3, [r7, #4]
   10afa:	609a      	str	r2, [r3, #8]
		if (prec != conv->prec_value) {
   10afc:	687b      	ldr	r3, [r7, #4]
   10afe:	689b      	ldr	r3, [r3, #8]
   10b00:	461a      	mov	r2, r3
   10b02:	68bb      	ldr	r3, [r7, #8]
   10b04:	4293      	cmp	r3, r2
   10b06:	d004      	beq.n	10b12 <extract_prec+0x7e>
			conv->unsupported = true;
   10b08:	687a      	ldr	r2, [r7, #4]
   10b0a:	7813      	ldrb	r3, [r2, #0]
   10b0c:	f043 0302 	orr.w	r3, r3, #2
   10b10:	7013      	strb	r3, [r2, #0]
	return sp;
   10b12:	683b      	ldr	r3, [r7, #0]
}
   10b14:	4618      	mov	r0, r3
   10b16:	3710      	adds	r7, #16
   10b18:	46bd      	mov	sp, r7
   10b1a:	bd80      	pop	{r7, pc}

00010b1c <extract_conversion>:
{
   10b1c:	b580      	push	{r7, lr}
   10b1e:	b086      	sub	sp, #24
   10b20:	af00      	add	r7, sp, #0
   10b22:	6078      	str	r0, [r7, #4]
   10b24:	6039      	str	r1, [r7, #0]
	*conv = (struct conversion) {
   10b26:	687b      	ldr	r3, [r7, #4]
   10b28:	461a      	mov	r2, r3
   10b2a:	2300      	movs	r3, #0
   10b2c:	6013      	str	r3, [r2, #0]
   10b2e:	6053      	str	r3, [r2, #4]
   10b30:	6093      	str	r3, [r2, #8]
	++sp;
   10b32:	683b      	ldr	r3, [r7, #0]
   10b34:	3301      	adds	r3, #1
   10b36:	603b      	str	r3, [r7, #0]
	if (*sp == '%') {
   10b38:	683b      	ldr	r3, [r7, #0]
   10b3a:	781b      	ldrb	r3, [r3, #0]
   10b3c:	2b25      	cmp	r3, #37	; 0x25
   10b3e:	d107      	bne.n	10b50 <extract_conversion+0x34>
		conv->specifier = *sp++;
   10b40:	683b      	ldr	r3, [r7, #0]
   10b42:	1c5a      	adds	r2, r3, #1
   10b44:	603a      	str	r2, [r7, #0]
   10b46:	781a      	ldrb	r2, [r3, #0]
   10b48:	687b      	ldr	r3, [r7, #4]
   10b4a:	70da      	strb	r2, [r3, #3]
		return sp;
   10b4c:	683b      	ldr	r3, [r7, #0]
   10b4e:	e019      	b.n	10b84 <extract_conversion+0x68>
	sp = extract_flags(conv, sp);
   10b50:	6839      	ldr	r1, [r7, #0]
   10b52:	6878      	ldr	r0, [r7, #4]
   10b54:	f7f0 fabc 	bl	10d0 <extract_flags>
   10b58:	6038      	str	r0, [r7, #0]
	sp = extract_width(conv, sp);
   10b5a:	6839      	ldr	r1, [r7, #0]
   10b5c:	6878      	ldr	r0, [r7, #4]
   10b5e:	f7ff ff5e 	bl	10a1e <extract_width>
   10b62:	6038      	str	r0, [r7, #0]
	sp = extract_prec(conv, sp);
   10b64:	6839      	ldr	r1, [r7, #0]
   10b66:	6878      	ldr	r0, [r7, #4]
   10b68:	f7ff ff94 	bl	10a94 <extract_prec>
   10b6c:	6038      	str	r0, [r7, #0]
	sp = extract_length(conv, sp);
   10b6e:	6839      	ldr	r1, [r7, #0]
   10b70:	6878      	ldr	r0, [r7, #4]
   10b72:	f7f0 fb21 	bl	11b8 <extract_length>
   10b76:	6038      	str	r0, [r7, #0]
	sp = extract_specifier(conv, sp);
   10b78:	6839      	ldr	r1, [r7, #0]
   10b7a:	6878      	ldr	r0, [r7, #4]
   10b7c:	f7f0 fbf2 	bl	1364 <extract_specifier>
   10b80:	6038      	str	r0, [r7, #0]
	return sp;
   10b82:	683b      	ldr	r3, [r7, #0]
}
   10b84:	4618      	mov	r0, r3
   10b86:	3718      	adds	r7, #24
   10b88:	46bd      	mov	sp, r7
   10b8a:	bd80      	pop	{r7, pc}

00010b8c <conversion_radix>:
{
   10b8c:	b480      	push	{r7}
   10b8e:	b083      	sub	sp, #12
   10b90:	af00      	add	r7, sp, #0
   10b92:	4603      	mov	r3, r0
   10b94:	71fb      	strb	r3, [r7, #7]
	switch (specifier) {
   10b96:	79fb      	ldrb	r3, [r7, #7]
   10b98:	2b78      	cmp	r3, #120	; 0x78
   10b9a:	d00d      	beq.n	10bb8 <conversion_radix+0x2c>
   10b9c:	2b78      	cmp	r3, #120	; 0x78
   10b9e:	dc07      	bgt.n	10bb0 <conversion_radix+0x24>
   10ba0:	2b70      	cmp	r3, #112	; 0x70
   10ba2:	d009      	beq.n	10bb8 <conversion_radix+0x2c>
   10ba4:	2b70      	cmp	r3, #112	; 0x70
   10ba6:	dc03      	bgt.n	10bb0 <conversion_radix+0x24>
   10ba8:	2b58      	cmp	r3, #88	; 0x58
   10baa:	d005      	beq.n	10bb8 <conversion_radix+0x2c>
   10bac:	2b6f      	cmp	r3, #111	; 0x6f
   10bae:	d001      	beq.n	10bb4 <conversion_radix+0x28>
		return 10;
   10bb0:	230a      	movs	r3, #10
   10bb2:	e002      	b.n	10bba <conversion_radix+0x2e>
		return 8;
   10bb4:	2308      	movs	r3, #8
   10bb6:	e000      	b.n	10bba <conversion_radix+0x2e>
		return 16;
   10bb8:	2310      	movs	r3, #16
}
   10bba:	4618      	mov	r0, r3
   10bbc:	370c      	adds	r7, #12
   10bbe:	46bd      	mov	sp, r7
   10bc0:	bc80      	pop	{r7}
   10bc2:	4770      	bx	lr

00010bc4 <encode_uint>:
{
   10bc4:	b580      	push	{r7, lr}
   10bc6:	b088      	sub	sp, #32
   10bc8:	af00      	add	r7, sp, #0
   10bca:	e9c7 0102 	strd	r0, r1, [r7, #8]
   10bce:	607a      	str	r2, [r7, #4]
   10bd0:	603b      	str	r3, [r7, #0]
	bool upcase = isupper((int)conv->specifier);
   10bd2:	687b      	ldr	r3, [r7, #4]
   10bd4:	78db      	ldrb	r3, [r3, #3]
   10bd6:	4618      	mov	r0, r3
   10bd8:	f7ff feda 	bl	10990 <isupper>
   10bdc:	4603      	mov	r3, r0
   10bde:	2b00      	cmp	r3, #0
   10be0:	bf14      	ite	ne
   10be2:	2301      	movne	r3, #1
   10be4:	2300      	moveq	r3, #0
   10be6:	76fb      	strb	r3, [r7, #27]
	const unsigned int radix = conversion_radix(conv->specifier);
   10be8:	687b      	ldr	r3, [r7, #4]
   10bea:	78db      	ldrb	r3, [r3, #3]
   10bec:	4618      	mov	r0, r3
   10bee:	f7ff ffcd 	bl	10b8c <conversion_radix>
   10bf2:	6178      	str	r0, [r7, #20]
	char *bp = bps + (bpe - bps);
   10bf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   10bf6:	61fb      	str	r3, [r7, #28]
		unsigned int lsv = (unsigned int)(value % radix);
   10bf8:	697b      	ldr	r3, [r7, #20]
   10bfa:	461a      	mov	r2, r3
   10bfc:	f04f 0300 	mov.w	r3, #0
   10c00:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
   10c04:	f7ef fa9e 	bl	144 <__aeabi_uldivmod>
   10c08:	4613      	mov	r3, r2
   10c0a:	613b      	str	r3, [r7, #16]
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10c0c:	693b      	ldr	r3, [r7, #16]
   10c0e:	2b09      	cmp	r3, #9
   10c10:	d804      	bhi.n	10c1c <encode_uint+0x58>
   10c12:	693b      	ldr	r3, [r7, #16]
   10c14:	b2db      	uxtb	r3, r3
   10c16:	3330      	adds	r3, #48	; 0x30
   10c18:	b2db      	uxtb	r3, r3
   10c1a:	e00b      	b.n	10c34 <encode_uint+0x70>
   10c1c:	7efb      	ldrb	r3, [r7, #27]
   10c1e:	2b00      	cmp	r3, #0
   10c20:	d004      	beq.n	10c2c <encode_uint+0x68>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   10c22:	693b      	ldr	r3, [r7, #16]
   10c24:	b2db      	uxtb	r3, r3
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10c26:	3337      	adds	r3, #55	; 0x37
   10c28:	b2db      	uxtb	r3, r3
   10c2a:	e003      	b.n	10c34 <encode_uint+0x70>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   10c2c:	693b      	ldr	r3, [r7, #16]
   10c2e:	b2db      	uxtb	r3, r3
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10c30:	3357      	adds	r3, #87	; 0x57
   10c32:	b2db      	uxtb	r3, r3
   10c34:	69fa      	ldr	r2, [r7, #28]
   10c36:	3a01      	subs	r2, #1
   10c38:	61fa      	str	r2, [r7, #28]
   10c3a:	69fa      	ldr	r2, [r7, #28]
   10c3c:	7013      	strb	r3, [r2, #0]
		value /= radix;
   10c3e:	697b      	ldr	r3, [r7, #20]
   10c40:	461a      	mov	r2, r3
   10c42:	f04f 0300 	mov.w	r3, #0
   10c46:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
   10c4a:	f7ef fa7b 	bl	144 <__aeabi_uldivmod>
   10c4e:	4602      	mov	r2, r0
   10c50:	460b      	mov	r3, r1
   10c52:	e9c7 2302 	strd	r2, r3, [r7, #8]
	} while ((value != 0) && (bps < bp));
   10c56:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   10c5a:	4313      	orrs	r3, r2
   10c5c:	d003      	beq.n	10c66 <encode_uint+0xa2>
   10c5e:	683a      	ldr	r2, [r7, #0]
   10c60:	69fb      	ldr	r3, [r7, #28]
   10c62:	429a      	cmp	r2, r3
   10c64:	d3c8      	bcc.n	10bf8 <encode_uint+0x34>
	if (conv->flag_hash) {
   10c66:	687b      	ldr	r3, [r7, #4]
   10c68:	781b      	ldrb	r3, [r3, #0]
   10c6a:	f003 0320 	and.w	r3, r3, #32
   10c6e:	b2db      	uxtb	r3, r3
   10c70:	2b00      	cmp	r3, #0
   10c72:	d010      	beq.n	10c96 <encode_uint+0xd2>
		if (radix == 8) {
   10c74:	697b      	ldr	r3, [r7, #20]
   10c76:	2b08      	cmp	r3, #8
   10c78:	d105      	bne.n	10c86 <encode_uint+0xc2>
			conv->altform_0 = true;
   10c7a:	687a      	ldr	r2, [r7, #4]
   10c7c:	7893      	ldrb	r3, [r2, #2]
   10c7e:	f043 0308 	orr.w	r3, r3, #8
   10c82:	7093      	strb	r3, [r2, #2]
   10c84:	e007      	b.n	10c96 <encode_uint+0xd2>
		} else if (radix == 16) {
   10c86:	697b      	ldr	r3, [r7, #20]
   10c88:	2b10      	cmp	r3, #16
   10c8a:	d104      	bne.n	10c96 <encode_uint+0xd2>
			conv->altform_0c = true;
   10c8c:	687a      	ldr	r2, [r7, #4]
   10c8e:	7893      	ldrb	r3, [r2, #2]
   10c90:	f043 0310 	orr.w	r3, r3, #16
   10c94:	7093      	strb	r3, [r2, #2]
	return bp;
   10c96:	69fb      	ldr	r3, [r7, #28]
}
   10c98:	4618      	mov	r0, r3
   10c9a:	3720      	adds	r7, #32
   10c9c:	46bd      	mov	sp, r7
   10c9e:	bd80      	pop	{r7, pc}

00010ca0 <outs>:
{
   10ca0:	b580      	push	{r7, lr}
   10ca2:	b086      	sub	sp, #24
   10ca4:	af00      	add	r7, sp, #0
   10ca6:	60f8      	str	r0, [r7, #12]
   10ca8:	60b9      	str	r1, [r7, #8]
   10caa:	607a      	str	r2, [r7, #4]
   10cac:	603b      	str	r3, [r7, #0]
	size_t count = 0;
   10cae:	2300      	movs	r3, #0
   10cb0:	617b      	str	r3, [r7, #20]
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   10cb2:	e011      	b.n	10cd8 <outs+0x38>
		int rc = out((int)*sp++, ctx);
   10cb4:	687b      	ldr	r3, [r7, #4]
   10cb6:	1c5a      	adds	r2, r3, #1
   10cb8:	607a      	str	r2, [r7, #4]
   10cba:	781b      	ldrb	r3, [r3, #0]
   10cbc:	461a      	mov	r2, r3
   10cbe:	68fb      	ldr	r3, [r7, #12]
   10cc0:	68b9      	ldr	r1, [r7, #8]
   10cc2:	4610      	mov	r0, r2
   10cc4:	4798      	blx	r3
   10cc6:	6138      	str	r0, [r7, #16]
		if (rc < 0) {
   10cc8:	693b      	ldr	r3, [r7, #16]
   10cca:	2b00      	cmp	r3, #0
   10ccc:	da01      	bge.n	10cd2 <outs+0x32>
			return rc;
   10cce:	693b      	ldr	r3, [r7, #16]
   10cd0:	e00e      	b.n	10cf0 <outs+0x50>
		++count;
   10cd2:	697b      	ldr	r3, [r7, #20]
   10cd4:	3301      	adds	r3, #1
   10cd6:	617b      	str	r3, [r7, #20]
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   10cd8:	687a      	ldr	r2, [r7, #4]
   10cda:	683b      	ldr	r3, [r7, #0]
   10cdc:	429a      	cmp	r2, r3
   10cde:	d3e9      	bcc.n	10cb4 <outs+0x14>
   10ce0:	683b      	ldr	r3, [r7, #0]
   10ce2:	2b00      	cmp	r3, #0
   10ce4:	d103      	bne.n	10cee <outs+0x4e>
   10ce6:	687b      	ldr	r3, [r7, #4]
   10ce8:	781b      	ldrb	r3, [r3, #0]
   10cea:	2b00      	cmp	r3, #0
   10cec:	d1e2      	bne.n	10cb4 <outs+0x14>
	return (int)count;
   10cee:	697b      	ldr	r3, [r7, #20]
}
   10cf0:	4618      	mov	r0, r3
   10cf2:	3718      	adds	r7, #24
   10cf4:	46bd      	mov	sp, r7
   10cf6:	bd80      	pop	{r7, pc}

00010cf8 <assert_post_action>:
#ifdef CONFIG_ASSERT_NO_FILE_INFO
__weak void assert_post_action(void)
#else
__weak void assert_post_action(const char *file, unsigned int line)
#endif
{
   10cf8:	b480      	push	{r7}
   10cfa:	b083      	sub	sp, #12
   10cfc:	af00      	add	r7, sp, #0
   10cfe:	6078      	str	r0, [r7, #4]
   10d00:	6039      	str	r1, [r7, #0]
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   10d02:	4040      	eors	r0, r0
   10d04:	f380 8811 	msr	BASEPRI, r0
   10d08:	f04f 0004 	mov.w	r0, #4
   10d0c:	df02      	svc	2
}
   10d0e:	bf00      	nop
   10d10:	370c      	adds	r7, #12
   10d12:	46bd      	mov	sp, r7
   10d14:	bc80      	pop	{r7}
   10d16:	4770      	bx	lr

00010d18 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
   10d18:	b480      	push	{r7}
   10d1a:	af00      	add	r7, sp, #0
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   10d1c:	bf00      	nop
   10d1e:	46bd      	mov	sp, r7
   10d20:	bc80      	pop	{r7}
   10d22:	4770      	bx	lr

00010d24 <arch_busy_wait>:

void arch_busy_wait(uint32_t time_us)
{
   10d24:	b580      	push	{r7, lr}
   10d26:	b082      	sub	sp, #8
   10d28:	af00      	add	r7, sp, #0
   10d2a:	6078      	str	r0, [r7, #4]
	nrfx_coredep_delay_us(time_us);
   10d2c:	6878      	ldr	r0, [r7, #4]
   10d2e:	f7f1 f8bd 	bl	1eac <nrfx_coredep_delay_us>
}
   10d32:	bf00      	nop
   10d34:	3708      	adds	r7, #8
   10d36:	46bd      	mov	sp, r7
   10d38:	bd80      	pop	{r7, pc}

00010d3a <z_platform_init>:

void z_platform_init(void)
{
   10d3a:	b580      	push	{r7, lr}
   10d3c:	af00      	add	r7, sp, #0
	SystemInit();
   10d3e:	f7f8 fd57 	bl	97f0 <SystemInit>
}
   10d42:	bf00      	nop
   10d44:	bd80      	pop	{r7, pc}

00010d46 <log_list_init>:
 */

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
   10d46:	b480      	push	{r7}
   10d48:	b083      	sub	sp, #12
   10d4a:	af00      	add	r7, sp, #0
   10d4c:	6078      	str	r0, [r7, #4]
	list->tail = NULL;
   10d4e:	687b      	ldr	r3, [r7, #4]
   10d50:	2200      	movs	r2, #0
   10d52:	605a      	str	r2, [r3, #4]
	list->head = NULL;
   10d54:	687b      	ldr	r3, [r7, #4]
   10d56:	2200      	movs	r2, #0
   10d58:	601a      	str	r2, [r3, #0]
}
   10d5a:	bf00      	nop
   10d5c:	370c      	adds	r7, #12
   10d5e:	46bd      	mov	sp, r7
   10d60:	bc80      	pop	{r7}
   10d62:	4770      	bx	lr

00010d64 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
   10d64:	b480      	push	{r7}
   10d66:	b083      	sub	sp, #12
   10d68:	af00      	add	r7, sp, #0
   10d6a:	6078      	str	r0, [r7, #4]
   10d6c:	6039      	str	r1, [r7, #0]
	if (list->head == NULL) {
   10d6e:	687b      	ldr	r3, [r7, #4]
   10d70:	681b      	ldr	r3, [r3, #0]
   10d72:	2b00      	cmp	r3, #0
   10d74:	d103      	bne.n	10d7e <log_list_add_tail+0x1a>
		list->head = msg;
   10d76:	687b      	ldr	r3, [r7, #4]
   10d78:	683a      	ldr	r2, [r7, #0]
   10d7a:	601a      	str	r2, [r3, #0]
   10d7c:	e003      	b.n	10d86 <log_list_add_tail+0x22>
	} else {
		list->tail->next = msg;
   10d7e:	687b      	ldr	r3, [r7, #4]
   10d80:	685b      	ldr	r3, [r3, #4]
   10d82:	683a      	ldr	r2, [r7, #0]
   10d84:	601a      	str	r2, [r3, #0]
	}

	list->tail = msg;
   10d86:	687b      	ldr	r3, [r7, #4]
   10d88:	683a      	ldr	r2, [r7, #0]
   10d8a:	605a      	str	r2, [r3, #4]
	msg->next = NULL;
   10d8c:	683b      	ldr	r3, [r7, #0]
   10d8e:	2200      	movs	r2, #0
   10d90:	601a      	str	r2, [r3, #0]
}
   10d92:	bf00      	nop
   10d94:	370c      	adds	r7, #12
   10d96:	46bd      	mov	sp, r7
   10d98:	bc80      	pop	{r7}
   10d9a:	4770      	bx	lr

00010d9c <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
   10d9c:	b480      	push	{r7}
   10d9e:	b083      	sub	sp, #12
   10da0:	af00      	add	r7, sp, #0
   10da2:	6078      	str	r0, [r7, #4]
	return list->head;
   10da4:	687b      	ldr	r3, [r7, #4]
   10da6:	681b      	ldr	r3, [r3, #0]
}
   10da8:	4618      	mov	r0, r3
   10daa:	370c      	adds	r7, #12
   10dac:	46bd      	mov	sp, r7
   10dae:	bc80      	pop	{r7}
   10db0:	4770      	bx	lr

00010db2 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   10db2:	b480      	push	{r7}
   10db4:	b085      	sub	sp, #20
   10db6:	af00      	add	r7, sp, #0
   10db8:	6078      	str	r0, [r7, #4]
	struct log_msg *msg = list->head;
   10dba:	687b      	ldr	r3, [r7, #4]
   10dbc:	681b      	ldr	r3, [r3, #0]
   10dbe:	60fb      	str	r3, [r7, #12]

	if (list->head != NULL) {
   10dc0:	687b      	ldr	r3, [r7, #4]
   10dc2:	681b      	ldr	r3, [r3, #0]
   10dc4:	2b00      	cmp	r3, #0
   10dc6:	d004      	beq.n	10dd2 <log_list_head_get+0x20>
		list->head = list->head->next;
   10dc8:	687b      	ldr	r3, [r7, #4]
   10dca:	681b      	ldr	r3, [r3, #0]
   10dcc:	681a      	ldr	r2, [r3, #0]
   10dce:	687b      	ldr	r3, [r7, #4]
   10dd0:	601a      	str	r2, [r3, #0]
	}

	return msg;
   10dd2:	68fb      	ldr	r3, [r7, #12]
}
   10dd4:	4618      	mov	r0, r3
   10dd6:	3714      	adds	r7, #20
   10dd8:	46bd      	mov	sp, r7
   10dda:	bc80      	pop	{r7}
   10ddc:	4770      	bx	lr

00010dde <atomic_add>:
 *
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
   10dde:	b480      	push	{r7}
   10de0:	b083      	sub	sp, #12
   10de2:	af00      	add	r7, sp, #0
   10de4:	6078      	str	r0, [r7, #4]
   10de6:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   10de8:	683a      	ldr	r2, [r7, #0]
   10dea:	687b      	ldr	r3, [r7, #4]
   10dec:	e8d3 1fef 	ldaex	r1, [r3]
   10df0:	eb01 0002 	add.w	r0, r1, r2
   10df4:	e8c3 0fec 	stlex	ip, r0, [r3]
   10df8:	f1bc 0f00 	cmp.w	ip, #0
   10dfc:	d1f6      	bne.n	10dec <atomic_add+0xe>
   10dfe:	460b      	mov	r3, r1
}
   10e00:	4618      	mov	r0, r3
   10e02:	370c      	adds	r7, #12
   10e04:	46bd      	mov	sp, r7
   10e06:	bc80      	pop	{r7}
   10e08:	4770      	bx	lr

00010e0a <atomic_sub>:
 *
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
   10e0a:	b480      	push	{r7}
   10e0c:	b083      	sub	sp, #12
   10e0e:	af00      	add	r7, sp, #0
   10e10:	6078      	str	r0, [r7, #4]
   10e12:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   10e14:	683a      	ldr	r2, [r7, #0]
   10e16:	687b      	ldr	r3, [r7, #4]
   10e18:	e8d3 1fef 	ldaex	r1, [r3]
   10e1c:	eba1 0002 	sub.w	r0, r1, r2
   10e20:	e8c3 0fec 	stlex	ip, r0, [r3]
   10e24:	f1bc 0f00 	cmp.w	ip, #0
   10e28:	d1f6      	bne.n	10e18 <atomic_sub+0xe>
   10e2a:	460b      	mov	r3, r1
}
   10e2c:	4618      	mov	r0, r3
   10e2e:	370c      	adds	r7, #12
   10e30:	46bd      	mov	sp, r7
   10e32:	bc80      	pop	{r7}
   10e34:	4770      	bx	lr

00010e36 <atomic_inc>:
 *
 * @return Previous value of @a target.
 */
#if defined(CONFIG_ATOMIC_OPERATIONS_BUILTIN) || defined (CONFIG_ATOMIC_OPERATIONS_C)
static inline atomic_val_t atomic_inc(atomic_t *target)
{
   10e36:	b580      	push	{r7, lr}
   10e38:	b082      	sub	sp, #8
   10e3a:	af00      	add	r7, sp, #0
   10e3c:	6078      	str	r0, [r7, #4]
	return atomic_add(target, 1);
   10e3e:	2101      	movs	r1, #1
   10e40:	6878      	ldr	r0, [r7, #4]
   10e42:	f7ff ffcc 	bl	10dde <atomic_add>
   10e46:	4603      	mov	r3, r0
}
   10e48:	4618      	mov	r0, r3
   10e4a:	3708      	adds	r7, #8
   10e4c:	46bd      	mov	sp, r7
   10e4e:	bd80      	pop	{r7, pc}

00010e50 <atomic_dec>:
 *
 * @return Previous value of @a target.
 */
#if defined(CONFIG_ATOMIC_OPERATIONS_BUILTIN) || defined (CONFIG_ATOMIC_OPERATIONS_C)
static inline atomic_val_t atomic_dec(atomic_t *target)
{
   10e50:	b580      	push	{r7, lr}
   10e52:	b082      	sub	sp, #8
   10e54:	af00      	add	r7, sp, #0
   10e56:	6078      	str	r0, [r7, #4]
	return atomic_sub(target, 1);
   10e58:	2101      	movs	r1, #1
   10e5a:	6878      	ldr	r0, [r7, #4]
   10e5c:	f7ff ffd5 	bl	10e0a <atomic_sub>
   10e60:	4603      	mov	r3, r0
}
   10e62:	4618      	mov	r0, r3
   10e64:	3708      	adds	r7, #8
   10e66:	46bd      	mov	sp, r7
   10e68:	bd80      	pop	{r7, pc}

00010e6a <atomic_set>:
 *
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_set(atomic_t *target, atomic_val_t value)
{
   10e6a:	b480      	push	{r7}
   10e6c:	b083      	sub	sp, #12
   10e6e:	af00      	add	r7, sp, #0
   10e70:	6078      	str	r0, [r7, #4]
   10e72:	6039      	str	r1, [r7, #0]
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   10e74:	683a      	ldr	r2, [r7, #0]
   10e76:	687b      	ldr	r3, [r7, #4]
   10e78:	e8d3 1fef 	ldaex	r1, [r3]
   10e7c:	e8c3 2fe0 	stlex	r0, r2, [r3]
   10e80:	2800      	cmp	r0, #0
   10e82:	d1f9      	bne.n	10e78 <atomic_set+0xe>
   10e84:	460b      	mov	r3, r1
}
   10e86:	4618      	mov	r0, r3
   10e88:	370c      	adds	r7, #12
   10e8a:	46bd      	mov	sp, r7
   10e8c:	bc80      	pop	{r7}
   10e8e:	4770      	bx	lr

00010e90 <log_msg_source_id_get>:
 * @param msg Message
 *
 * @return Source ID.
 */
static inline uint32_t log_msg_source_id_get(struct log_msg *msg)
{
   10e90:	b480      	push	{r7}
   10e92:	b083      	sub	sp, #12
   10e94:	af00      	add	r7, sp, #0
   10e96:	6078      	str	r0, [r7, #4]
	return msg->hdr.ids.source_id;
   10e98:	687b      	ldr	r3, [r7, #4]
   10e9a:	895b      	ldrh	r3, [r3, #10]
   10e9c:	f3c3 1389 	ubfx	r3, r3, #6, #10
   10ea0:	b29b      	uxth	r3, r3
}
   10ea2:	4618      	mov	r0, r3
   10ea4:	370c      	adds	r7, #12
   10ea6:	46bd      	mov	sp, r7
   10ea8:	bc80      	pop	{r7}
   10eaa:	4770      	bx	lr

00010eac <log_msg_is_std>:
 *
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
   10eac:	b480      	push	{r7}
   10eae:	b083      	sub	sp, #12
   10eb0:	af00      	add	r7, sp, #0
   10eb2:	6078      	str	r0, [r7, #4]
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   10eb4:	687b      	ldr	r3, [r7, #4]
   10eb6:	7a1b      	ldrb	r3, [r3, #8]
   10eb8:	f003 0301 	and.w	r3, r3, #1
   10ebc:	b2db      	uxtb	r3, r3
   10ebe:	2b00      	cmp	r3, #0
   10ec0:	bf0c      	ite	eq
   10ec2:	2301      	moveq	r3, #1
   10ec4:	2300      	movne	r3, #0
   10ec6:	b2db      	uxtb	r3, r3
}
   10ec8:	4618      	mov	r0, r3
   10eca:	370c      	adds	r7, #12
   10ecc:	46bd      	mov	sp, r7
   10ece:	bc80      	pop	{r7}
   10ed0:	4770      	bx	lr

00010ed2 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   10ed2:	b580      	push	{r7, lr}
   10ed4:	b082      	sub	sp, #8
   10ed6:	af00      	add	r7, sp, #0
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   10ed8:	f7f1 fdb2 	bl	2a40 <log_msg_chunk_alloc>
   10edc:	6078      	str	r0, [r7, #4]

	if (msg != NULL) {
   10ede:	687b      	ldr	r3, [r7, #4]
   10ee0:	2b00      	cmp	r3, #0
   10ee2:	d00a      	beq.n	10efa <z_log_msg_std_alloc+0x28>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   10ee4:	687b      	ldr	r3, [r7, #4]
   10ee6:	2201      	movs	r2, #1
   10ee8:	605a      	str	r2, [r3, #4]
		msg->hdr.params.raw = 0U;
   10eea:	687b      	ldr	r3, [r7, #4]
   10eec:	2200      	movs	r2, #0
   10eee:	811a      	strh	r2, [r3, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
   10ef0:	687a      	ldr	r2, [r7, #4]
   10ef2:	7a13      	ldrb	r3, [r2, #8]
   10ef4:	f36f 0300 	bfc	r3, #0, #1
   10ef8:	7213      	strb	r3, [r2, #8]
			msg->hdr.ids.domain_id = 0;
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
   10efa:	687b      	ldr	r3, [r7, #4]
}
   10efc:	4618      	mov	r0, r3
   10efe:	3708      	adds	r7, #8
   10f00:	46bd      	mov	sp, r7
   10f02:	bd80      	pop	{r7, pc}

00010f04 <log_msg_create_0>:
 *		- string pointer
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
   10f04:	b580      	push	{r7, lr}
   10f06:	b084      	sub	sp, #16
   10f08:	af00      	add	r7, sp, #0
   10f0a:	6078      	str	r0, [r7, #4]
	struct log_msg *msg = z_log_msg_std_alloc();
   10f0c:	f7ff ffe1 	bl	10ed2 <z_log_msg_std_alloc>
   10f10:	60f8      	str	r0, [r7, #12]

	if (msg != NULL) {
   10f12:	68fb      	ldr	r3, [r7, #12]
   10f14:	2b00      	cmp	r3, #0
   10f16:	d002      	beq.n	10f1e <log_msg_create_0+0x1a>
		msg->str = str;
   10f18:	68fb      	ldr	r3, [r7, #12]
   10f1a:	687a      	ldr	r2, [r7, #4]
   10f1c:	611a      	str	r2, [r3, #16]
	}

	return msg;
   10f1e:	68fb      	ldr	r3, [r7, #12]
}
   10f20:	4618      	mov	r0, r3
   10f22:	3710      	adds	r7, #16
   10f24:	46bd      	mov	sp, r7
   10f26:	bd80      	pop	{r7, pc}

00010f28 <log_msg_create_1>:
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
   10f28:	b580      	push	{r7, lr}
   10f2a:	b084      	sub	sp, #16
   10f2c:	af00      	add	r7, sp, #0
   10f2e:	6078      	str	r0, [r7, #4]
   10f30:	6039      	str	r1, [r7, #0]
	struct  log_msg *msg = z_log_msg_std_alloc();
   10f32:	f7ff ffce 	bl	10ed2 <z_log_msg_std_alloc>
   10f36:	60f8      	str	r0, [r7, #12]

	if (msg != NULL) {
   10f38:	68fb      	ldr	r3, [r7, #12]
   10f3a:	2b00      	cmp	r3, #0
   10f3c:	d00b      	beq.n	10f56 <log_msg_create_1+0x2e>
		msg->str = str;
   10f3e:	68fb      	ldr	r3, [r7, #12]
   10f40:	687a      	ldr	r2, [r7, #4]
   10f42:	611a      	str	r2, [r3, #16]
		msg->hdr.params.std.nargs = 1U;
   10f44:	68fa      	ldr	r2, [r7, #12]
   10f46:	7a53      	ldrb	r3, [r2, #9]
   10f48:	2101      	movs	r1, #1
   10f4a:	f361 1307 	bfi	r3, r1, #4, #4
   10f4e:	7253      	strb	r3, [r2, #9]
		msg->payload.single.args[0] = arg1;
   10f50:	68fb      	ldr	r3, [r7, #12]
   10f52:	683a      	ldr	r2, [r7, #0]
   10f54:	615a      	str	r2, [r3, #20]
	}

	return msg;
   10f56:	68fb      	ldr	r3, [r7, #12]
}
   10f58:	4618      	mov	r0, r3
   10f5a:	3710      	adds	r7, #16
   10f5c:	46bd      	mov	sp, r7
   10f5e:	bd80      	pop	{r7, pc}

00010f60 <log_msg_create_2>:
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
   10f60:	b580      	push	{r7, lr}
   10f62:	b086      	sub	sp, #24
   10f64:	af00      	add	r7, sp, #0
   10f66:	60f8      	str	r0, [r7, #12]
   10f68:	60b9      	str	r1, [r7, #8]
   10f6a:	607a      	str	r2, [r7, #4]
	struct  log_msg *msg = z_log_msg_std_alloc();
   10f6c:	f7ff ffb1 	bl	10ed2 <z_log_msg_std_alloc>
   10f70:	6178      	str	r0, [r7, #20]

	if (msg != NULL) {
   10f72:	697b      	ldr	r3, [r7, #20]
   10f74:	2b00      	cmp	r3, #0
   10f76:	d00e      	beq.n	10f96 <log_msg_create_2+0x36>
		msg->str = str;
   10f78:	697b      	ldr	r3, [r7, #20]
   10f7a:	68fa      	ldr	r2, [r7, #12]
   10f7c:	611a      	str	r2, [r3, #16]
		msg->hdr.params.std.nargs = 2U;
   10f7e:	697a      	ldr	r2, [r7, #20]
   10f80:	7a53      	ldrb	r3, [r2, #9]
   10f82:	2102      	movs	r1, #2
   10f84:	f361 1307 	bfi	r3, r1, #4, #4
   10f88:	7253      	strb	r3, [r2, #9]
		msg->payload.single.args[0] = arg1;
   10f8a:	697b      	ldr	r3, [r7, #20]
   10f8c:	68ba      	ldr	r2, [r7, #8]
   10f8e:	615a      	str	r2, [r3, #20]
		msg->payload.single.args[1] = arg2;
   10f90:	697b      	ldr	r3, [r7, #20]
   10f92:	687a      	ldr	r2, [r7, #4]
   10f94:	619a      	str	r2, [r3, #24]
	}

	return msg;
   10f96:	697b      	ldr	r3, [r7, #20]
}
   10f98:	4618      	mov	r0, r3
   10f9a:	3718      	adds	r7, #24
   10f9c:	46bd      	mov	sp, r7
   10f9e:	bd80      	pop	{r7, pc}

00010fa0 <log_msg_create_3>:
 */
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
   10fa0:	b580      	push	{r7, lr}
   10fa2:	b086      	sub	sp, #24
   10fa4:	af00      	add	r7, sp, #0
   10fa6:	60f8      	str	r0, [r7, #12]
   10fa8:	60b9      	str	r1, [r7, #8]
   10faa:	607a      	str	r2, [r7, #4]
   10fac:	603b      	str	r3, [r7, #0]
	struct  log_msg *msg = z_log_msg_std_alloc();
   10fae:	f7ff ff90 	bl	10ed2 <z_log_msg_std_alloc>
   10fb2:	6178      	str	r0, [r7, #20]

	if (msg != NULL) {
   10fb4:	697b      	ldr	r3, [r7, #20]
   10fb6:	2b00      	cmp	r3, #0
   10fb8:	d011      	beq.n	10fde <log_msg_create_3+0x3e>
		msg->str = str;
   10fba:	697b      	ldr	r3, [r7, #20]
   10fbc:	68fa      	ldr	r2, [r7, #12]
   10fbe:	611a      	str	r2, [r3, #16]
		msg->hdr.params.std.nargs = 3U;
   10fc0:	697a      	ldr	r2, [r7, #20]
   10fc2:	7a53      	ldrb	r3, [r2, #9]
   10fc4:	2103      	movs	r1, #3
   10fc6:	f361 1307 	bfi	r3, r1, #4, #4
   10fca:	7253      	strb	r3, [r2, #9]
		msg->payload.single.args[0] = arg1;
   10fcc:	697b      	ldr	r3, [r7, #20]
   10fce:	68ba      	ldr	r2, [r7, #8]
   10fd0:	615a      	str	r2, [r3, #20]
		msg->payload.single.args[1] = arg2;
   10fd2:	697b      	ldr	r3, [r7, #20]
   10fd4:	687a      	ldr	r2, [r7, #4]
   10fd6:	619a      	str	r2, [r3, #24]
		msg->payload.single.args[2] = arg3;
   10fd8:	697b      	ldr	r3, [r7, #20]
   10fda:	683a      	ldr	r2, [r7, #0]
   10fdc:	61da      	str	r2, [r3, #28]
	}

	return msg;
   10fde:	697b      	ldr	r3, [r7, #20]
}
   10fe0:	4618      	mov	r0, r3
   10fe2:	3718      	adds	r7, #24
   10fe4:	46bd      	mov	sp, r7
   10fe6:	bd80      	pop	{r7, pc}

00010fe8 <_is_user_context>:
 * Indicate whether the CPU is currently in user mode
 *
 * @return true if the CPU is currently running with user permissions
 */
static inline bool _is_user_context(void)
{
   10fe8:	b480      	push	{r7}
   10fea:	af00      	add	r7, sp, #0
#ifdef CONFIG_USERSPACE
	return arch_is_user_context();
#else
	return false;
   10fec:	2300      	movs	r3, #0
#endif
}
   10fee:	4618      	mov	r0, r3
   10ff0:	46bd      	mov	sp, r7
   10ff2:	bc80      	pop	{r7}
   10ff4:	4770      	bx	lr

00010ff6 <arch_k_cycle_get_32>:

#ifndef _ASMLANGUAGE
extern uint32_t z_timer_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
   10ff6:	b580      	push	{r7, lr}
   10ff8:	af00      	add	r7, sp, #0
	return z_timer_cycle_get_32();
   10ffa:	f7f3 fb39 	bl	4670 <z_timer_cycle_get_32>
   10ffe:	4603      	mov	r3, r0
}
   11000:	4618      	mov	r0, r3
   11002:	bd80      	pop	{r7, pc}

00011004 <sys_clock_hw_cycles_per_sec>:
{
   11004:	b480      	push	{r7}
   11006:	af00      	add	r7, sp, #0
	return CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
   11008:	f44f 4300 	mov.w	r3, #32768	; 0x8000
}
   1100c:	4618      	mov	r0, r3
   1100e:	46bd      	mov	sp, r7
   11010:	bc80      	pop	{r7}
   11012:	4770      	bx	lr

00011014 <k_ms_to_ticks_ceil64>:
{
   11014:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   11018:	b08c      	sub	sp, #48	; 0x30
   1101a:	af00      	add	r7, sp, #0
   1101c:	e9c7 0100 	strd	r0, r1, [r7]
   11020:	e9d7 2300 	ldrd	r2, r3, [r7]
   11024:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   11028:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1102c:	627b      	str	r3, [r7, #36]	; 0x24
   1102e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   11032:	623b      	str	r3, [r7, #32]
   11034:	2301      	movs	r3, #1
   11036:	77fb      	strb	r3, [r7, #31]
   11038:	2300      	movs	r3, #0
   1103a:	77bb      	strb	r3, [r7, #30]
   1103c:	2301      	movs	r3, #1
   1103e:	777b      	strb	r3, [r7, #29]
   11040:	2300      	movs	r3, #0
   11042:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   11044:	7ffb      	ldrb	r3, [r7, #31]
   11046:	2b00      	cmp	r3, #0
   11048:	d00f      	beq.n	1106a <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   1104a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1104c:	6a3b      	ldr	r3, [r7, #32]
   1104e:	429a      	cmp	r2, r3
   11050:	d20b      	bcs.n	1106a <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   11052:	6a3b      	ldr	r3, [r7, #32]
   11054:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11056:	fbb3 f2f2 	udiv	r2, r3, r2
   1105a:	6a79      	ldr	r1, [r7, #36]	; 0x24
   1105c:	fb01 f202 	mul.w	r2, r1, r2
   11060:	1a9b      	subs	r3, r3, r2
   11062:	2b00      	cmp	r3, #0
   11064:	d101      	bne.n	1106a <k_ms_to_ticks_ceil64+0x56>
   11066:	2301      	movs	r3, #1
   11068:	e000      	b.n	1106c <k_ms_to_ticks_ceil64+0x58>
   1106a:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   1106c:	76fb      	strb	r3, [r7, #27]
   1106e:	7efb      	ldrb	r3, [r7, #27]
   11070:	f003 0301 	and.w	r3, r3, #1
   11074:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   11076:	7ffb      	ldrb	r3, [r7, #31]
   11078:	2b00      	cmp	r3, #0
   1107a:	d00f      	beq.n	1109c <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   1107c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1107e:	6a3b      	ldr	r3, [r7, #32]
   11080:	429a      	cmp	r2, r3
   11082:	d90b      	bls.n	1109c <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   11084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11086:	6a3a      	ldr	r2, [r7, #32]
   11088:	fbb3 f2f2 	udiv	r2, r3, r2
   1108c:	6a39      	ldr	r1, [r7, #32]
   1108e:	fb01 f202 	mul.w	r2, r1, r2
   11092:	1a9b      	subs	r3, r3, r2
   11094:	2b00      	cmp	r3, #0
   11096:	d101      	bne.n	1109c <k_ms_to_ticks_ceil64+0x88>
   11098:	2301      	movs	r3, #1
   1109a:	e000      	b.n	1109e <k_ms_to_ticks_ceil64+0x8a>
   1109c:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   1109e:	76bb      	strb	r3, [r7, #26]
   110a0:	7ebb      	ldrb	r3, [r7, #26]
   110a2:	f003 0301 	and.w	r3, r3, #1
   110a6:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   110a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   110aa:	6a3b      	ldr	r3, [r7, #32]
   110ac:	429a      	cmp	r2, r3
   110ae:	d10a      	bne.n	110c6 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   110b0:	7fbb      	ldrb	r3, [r7, #30]
   110b2:	2b00      	cmp	r3, #0
   110b4:	d004      	beq.n	110c0 <k_ms_to_ticks_ceil64+0xac>
   110b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   110b8:	461a      	mov	r2, r3
   110ba:	f04f 0300 	mov.w	r3, #0
   110be:	e0c8      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
   110c0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   110c4:	e0c5      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   110c6:	f04f 0200 	mov.w	r2, #0
   110ca:	f04f 0300 	mov.w	r3, #0
   110ce:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   110d2:	7efb      	ldrb	r3, [r7, #27]
   110d4:	f083 0301 	eor.w	r3, r3, #1
   110d8:	b2db      	uxtb	r3, r3
   110da:	2b00      	cmp	r3, #0
   110dc:	d01e      	beq.n	1111c <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   110de:	7ebb      	ldrb	r3, [r7, #26]
   110e0:	2b00      	cmp	r3, #0
   110e2:	d004      	beq.n	110ee <k_ms_to_ticks_ceil64+0xda>
   110e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   110e6:	6a3b      	ldr	r3, [r7, #32]
   110e8:	fbb2 f3f3 	udiv	r3, r2, r3
   110ec:	e000      	b.n	110f0 <k_ms_to_ticks_ceil64+0xdc>
   110ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   110f0:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   110f2:	7f7b      	ldrb	r3, [r7, #29]
   110f4:	2b00      	cmp	r3, #0
   110f6:	d007      	beq.n	11108 <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   110f8:	68fb      	ldr	r3, [r7, #12]
   110fa:	3b01      	subs	r3, #1
   110fc:	461a      	mov	r2, r3
   110fe:	f04f 0300 	mov.w	r3, #0
   11102:	e9c7 2304 	strd	r2, r3, [r7, #16]
   11106:	e009      	b.n	1111c <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   11108:	7f3b      	ldrb	r3, [r7, #28]
   1110a:	2b00      	cmp	r3, #0
   1110c:	d006      	beq.n	1111c <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   1110e:	68fb      	ldr	r3, [r7, #12]
   11110:	085b      	lsrs	r3, r3, #1
   11112:	461a      	mov	r2, r3
   11114:	f04f 0300 	mov.w	r3, #0
   11118:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   1111c:	7ebb      	ldrb	r3, [r7, #26]
   1111e:	2b00      	cmp	r3, #0
   11120:	d02a      	beq.n	11178 <k_ms_to_ticks_ceil64+0x164>
		t += off;
   11122:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   11126:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   1112a:	1884      	adds	r4, r0, r2
   1112c:	eb41 0503 	adc.w	r5, r1, r3
   11130:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   11134:	7fbb      	ldrb	r3, [r7, #30]
   11136:	2b00      	cmp	r3, #0
   11138:	d010      	beq.n	1115c <k_ms_to_ticks_ceil64+0x148>
   1113a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   1113e:	2b01      	cmp	r3, #1
   11140:	bf08      	it	eq
   11142:	2a00      	cmpeq	r2, #0
   11144:	d20a      	bcs.n	1115c <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   11146:	6aba      	ldr	r2, [r7, #40]	; 0x28
   11148:	6a79      	ldr	r1, [r7, #36]	; 0x24
   1114a:	6a3b      	ldr	r3, [r7, #32]
   1114c:	fbb1 f3f3 	udiv	r3, r1, r3
   11150:	fbb2 f3f3 	udiv	r3, r2, r3
   11154:	461a      	mov	r2, r3
   11156:	f04f 0300 	mov.w	r3, #0
   1115a:	e07a      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   1115c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1115e:	6a3b      	ldr	r3, [r7, #32]
   11160:	fbb2 f3f3 	udiv	r3, r2, r3
   11164:	461a      	mov	r2, r3
   11166:	f04f 0300 	mov.w	r3, #0
   1116a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   1116e:	f7ee ffe9 	bl	144 <__aeabi_uldivmod>
   11172:	4602      	mov	r2, r0
   11174:	460b      	mov	r3, r1
   11176:	e06c      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   11178:	7efb      	ldrb	r3, [r7, #27]
   1117a:	2b00      	cmp	r3, #0
   1117c:	d021      	beq.n	111c2 <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   1117e:	7fbb      	ldrb	r3, [r7, #30]
   11180:	2b00      	cmp	r3, #0
   11182:	d00a      	beq.n	1119a <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   11184:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11186:	6a39      	ldr	r1, [r7, #32]
   11188:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1118a:	fbb1 f2f2 	udiv	r2, r1, r2
   1118e:	fb02 f303 	mul.w	r3, r2, r3
   11192:	461a      	mov	r2, r3
   11194:	f04f 0300 	mov.w	r3, #0
   11198:	e05b      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   1119a:	6a3a      	ldr	r2, [r7, #32]
   1119c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1119e:	fbb2 f3f3 	udiv	r3, r2, r3
   111a2:	461a      	mov	r2, r3
   111a4:	f04f 0300 	mov.w	r3, #0
   111a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   111aa:	fb03 f001 	mul.w	r0, r3, r1
   111ae:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   111b0:	fb02 f101 	mul.w	r1, r2, r1
   111b4:	4401      	add	r1, r0
   111b6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   111b8:	fba0 2302 	umull	r2, r3, r0, r2
   111bc:	4419      	add	r1, r3
   111be:	460b      	mov	r3, r1
   111c0:	e047      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   111c2:	7fbb      	ldrb	r3, [r7, #30]
   111c4:	2b00      	cmp	r3, #0
   111c6:	d024      	beq.n	11212 <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   111c8:	6a3b      	ldr	r3, [r7, #32]
   111ca:	461a      	mov	r2, r3
   111cc:	f04f 0300 	mov.w	r3, #0
   111d0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   111d2:	fb03 f001 	mul.w	r0, r3, r1
   111d6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   111d8:	fb02 f101 	mul.w	r1, r2, r1
   111dc:	4401      	add	r1, r0
   111de:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   111e0:	fba0 2302 	umull	r2, r3, r0, r2
   111e4:	4419      	add	r1, r3
   111e6:	460b      	mov	r3, r1
   111e8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   111ec:	eb12 0a00 	adds.w	sl, r2, r0
   111f0:	eb43 0b01 	adc.w	fp, r3, r1
   111f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   111f6:	461a      	mov	r2, r3
   111f8:	f04f 0300 	mov.w	r3, #0
   111fc:	4650      	mov	r0, sl
   111fe:	4659      	mov	r1, fp
   11200:	f7ee ffa0 	bl	144 <__aeabi_uldivmod>
   11204:	4602      	mov	r2, r0
   11206:	460b      	mov	r3, r1
   11208:	4613      	mov	r3, r2
   1120a:	461a      	mov	r2, r3
   1120c:	f04f 0300 	mov.w	r3, #0
   11210:	e01f      	b.n	11252 <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   11212:	6a3b      	ldr	r3, [r7, #32]
   11214:	461a      	mov	r2, r3
   11216:	f04f 0300 	mov.w	r3, #0
   1121a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1121c:	fb03 f001 	mul.w	r0, r3, r1
   11220:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   11222:	fb02 f101 	mul.w	r1, r2, r1
   11226:	4401      	add	r1, r0
   11228:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1122a:	fba0 2302 	umull	r2, r3, r0, r2
   1122e:	4419      	add	r1, r3
   11230:	460b      	mov	r3, r1
   11232:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   11236:	eb12 0800 	adds.w	r8, r2, r0
   1123a:	eb43 0901 	adc.w	r9, r3, r1
   1123e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11240:	461a      	mov	r2, r3
   11242:	f04f 0300 	mov.w	r3, #0
   11246:	4640      	mov	r0, r8
   11248:	4649      	mov	r1, r9
   1124a:	f7ee ff7b 	bl	144 <__aeabi_uldivmod>
   1124e:	4602      	mov	r2, r0
   11250:	460b      	mov	r3, r1
}
   11252:	4610      	mov	r0, r2
   11254:	4619      	mov	r1, r3
   11256:	3730      	adds	r7, #48	; 0x30
   11258:	46bd      	mov	sp, r7
   1125a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0001125e <k_ticks_to_ms_floor64>:
 * Truncates to the next lowest output unit.
 *
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint64_t k_ticks_to_ms_floor64(uint64_t t)
{
   1125e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   11262:	b08c      	sub	sp, #48	; 0x30
   11264:	af00      	add	r7, sp, #0
   11266:	e9c7 0100 	strd	r0, r1, [r7]
   1126a:	e9d7 2300 	ldrd	r2, r3, [r7]
   1126e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   11272:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   11276:	627b      	str	r3, [r7, #36]	; 0x24
   11278:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1127c:	623b      	str	r3, [r7, #32]
   1127e:	2301      	movs	r3, #1
   11280:	77fb      	strb	r3, [r7, #31]
   11282:	2300      	movs	r3, #0
   11284:	77bb      	strb	r3, [r7, #30]
   11286:	2300      	movs	r3, #0
   11288:	777b      	strb	r3, [r7, #29]
   1128a:	2300      	movs	r3, #0
   1128c:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1128e:	7ffb      	ldrb	r3, [r7, #31]
   11290:	2b00      	cmp	r3, #0
   11292:	d00f      	beq.n	112b4 <k_ticks_to_ms_floor64+0x56>
	bool mul_ratio = const_hz &&
   11294:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11296:	6a3b      	ldr	r3, [r7, #32]
   11298:	429a      	cmp	r2, r3
   1129a:	d20b      	bcs.n	112b4 <k_ticks_to_ms_floor64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1129c:	6a3b      	ldr	r3, [r7, #32]
   1129e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   112a0:	fbb3 f2f2 	udiv	r2, r3, r2
   112a4:	6a79      	ldr	r1, [r7, #36]	; 0x24
   112a6:	fb01 f202 	mul.w	r2, r1, r2
   112aa:	1a9b      	subs	r3, r3, r2
   112ac:	2b00      	cmp	r3, #0
   112ae:	d101      	bne.n	112b4 <k_ticks_to_ms_floor64+0x56>
   112b0:	2301      	movs	r3, #1
   112b2:	e000      	b.n	112b6 <k_ticks_to_ms_floor64+0x58>
   112b4:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   112b6:	76fb      	strb	r3, [r7, #27]
   112b8:	7efb      	ldrb	r3, [r7, #27]
   112ba:	f003 0301 	and.w	r3, r3, #1
   112be:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   112c0:	7ffb      	ldrb	r3, [r7, #31]
   112c2:	2b00      	cmp	r3, #0
   112c4:	d00f      	beq.n	112e6 <k_ticks_to_ms_floor64+0x88>
	bool div_ratio = const_hz &&
   112c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   112c8:	6a3b      	ldr	r3, [r7, #32]
   112ca:	429a      	cmp	r2, r3
   112cc:	d90b      	bls.n	112e6 <k_ticks_to_ms_floor64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   112ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   112d0:	6a3a      	ldr	r2, [r7, #32]
   112d2:	fbb3 f2f2 	udiv	r2, r3, r2
   112d6:	6a39      	ldr	r1, [r7, #32]
   112d8:	fb01 f202 	mul.w	r2, r1, r2
   112dc:	1a9b      	subs	r3, r3, r2
   112de:	2b00      	cmp	r3, #0
   112e0:	d101      	bne.n	112e6 <k_ticks_to_ms_floor64+0x88>
   112e2:	2301      	movs	r3, #1
   112e4:	e000      	b.n	112e8 <k_ticks_to_ms_floor64+0x8a>
   112e6:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   112e8:	76bb      	strb	r3, [r7, #26]
   112ea:	7ebb      	ldrb	r3, [r7, #26]
   112ec:	f003 0301 	and.w	r3, r3, #1
   112f0:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   112f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   112f4:	6a3b      	ldr	r3, [r7, #32]
   112f6:	429a      	cmp	r2, r3
   112f8:	d10a      	bne.n	11310 <k_ticks_to_ms_floor64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   112fa:	7fbb      	ldrb	r3, [r7, #30]
   112fc:	2b00      	cmp	r3, #0
   112fe:	d004      	beq.n	1130a <k_ticks_to_ms_floor64+0xac>
   11300:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11302:	461a      	mov	r2, r3
   11304:	f04f 0300 	mov.w	r3, #0
   11308:	e0c8      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
   1130a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   1130e:	e0c5      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
	uint64_t off = 0;
   11310:	f04f 0200 	mov.w	r2, #0
   11314:	f04f 0300 	mov.w	r3, #0
   11318:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   1131c:	7efb      	ldrb	r3, [r7, #27]
   1131e:	f083 0301 	eor.w	r3, r3, #1
   11322:	b2db      	uxtb	r3, r3
   11324:	2b00      	cmp	r3, #0
   11326:	d01e      	beq.n	11366 <k_ticks_to_ms_floor64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   11328:	7ebb      	ldrb	r3, [r7, #26]
   1132a:	2b00      	cmp	r3, #0
   1132c:	d004      	beq.n	11338 <k_ticks_to_ms_floor64+0xda>
   1132e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11330:	6a3b      	ldr	r3, [r7, #32]
   11332:	fbb2 f3f3 	udiv	r3, r2, r3
   11336:	e000      	b.n	1133a <k_ticks_to_ms_floor64+0xdc>
   11338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1133a:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   1133c:	7f7b      	ldrb	r3, [r7, #29]
   1133e:	2b00      	cmp	r3, #0
   11340:	d007      	beq.n	11352 <k_ticks_to_ms_floor64+0xf4>
			off = rdivisor - 1U;
   11342:	68fb      	ldr	r3, [r7, #12]
   11344:	3b01      	subs	r3, #1
   11346:	461a      	mov	r2, r3
   11348:	f04f 0300 	mov.w	r3, #0
   1134c:	e9c7 2304 	strd	r2, r3, [r7, #16]
   11350:	e009      	b.n	11366 <k_ticks_to_ms_floor64+0x108>
		} else if (round_off) {
   11352:	7f3b      	ldrb	r3, [r7, #28]
   11354:	2b00      	cmp	r3, #0
   11356:	d006      	beq.n	11366 <k_ticks_to_ms_floor64+0x108>
			off = rdivisor / 2U;
   11358:	68fb      	ldr	r3, [r7, #12]
   1135a:	085b      	lsrs	r3, r3, #1
   1135c:	461a      	mov	r2, r3
   1135e:	f04f 0300 	mov.w	r3, #0
   11362:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   11366:	7ebb      	ldrb	r3, [r7, #26]
   11368:	2b00      	cmp	r3, #0
   1136a:	d02a      	beq.n	113c2 <k_ticks_to_ms_floor64+0x164>
		t += off;
   1136c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   11370:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   11374:	1884      	adds	r4, r0, r2
   11376:	eb41 0503 	adc.w	r5, r1, r3
   1137a:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   1137e:	7fbb      	ldrb	r3, [r7, #30]
   11380:	2b00      	cmp	r3, #0
   11382:	d010      	beq.n	113a6 <k_ticks_to_ms_floor64+0x148>
   11384:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   11388:	2b01      	cmp	r3, #1
   1138a:	bf08      	it	eq
   1138c:	2a00      	cmpeq	r2, #0
   1138e:	d20a      	bcs.n	113a6 <k_ticks_to_ms_floor64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   11390:	6aba      	ldr	r2, [r7, #40]	; 0x28
   11392:	6a79      	ldr	r1, [r7, #36]	; 0x24
   11394:	6a3b      	ldr	r3, [r7, #32]
   11396:	fbb1 f3f3 	udiv	r3, r1, r3
   1139a:	fbb2 f3f3 	udiv	r3, r2, r3
   1139e:	461a      	mov	r2, r3
   113a0:	f04f 0300 	mov.w	r3, #0
   113a4:	e07a      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
			return t / (from_hz / to_hz);
   113a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   113a8:	6a3b      	ldr	r3, [r7, #32]
   113aa:	fbb2 f3f3 	udiv	r3, r2, r3
   113ae:	461a      	mov	r2, r3
   113b0:	f04f 0300 	mov.w	r3, #0
   113b4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   113b8:	f7ee fec4 	bl	144 <__aeabi_uldivmod>
   113bc:	4602      	mov	r2, r0
   113be:	460b      	mov	r3, r1
   113c0:	e06c      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
	} else if (mul_ratio) {
   113c2:	7efb      	ldrb	r3, [r7, #27]
   113c4:	2b00      	cmp	r3, #0
   113c6:	d021      	beq.n	1140c <k_ticks_to_ms_floor64+0x1ae>
		if (result32) {
   113c8:	7fbb      	ldrb	r3, [r7, #30]
   113ca:	2b00      	cmp	r3, #0
   113cc:	d00a      	beq.n	113e4 <k_ticks_to_ms_floor64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   113ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
   113d0:	6a39      	ldr	r1, [r7, #32]
   113d2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   113d4:	fbb1 f2f2 	udiv	r2, r1, r2
   113d8:	fb02 f303 	mul.w	r3, r2, r3
   113dc:	461a      	mov	r2, r3
   113de:	f04f 0300 	mov.w	r3, #0
   113e2:	e05b      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
			return t * (to_hz / from_hz);
   113e4:	6a3a      	ldr	r2, [r7, #32]
   113e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   113e8:	fbb2 f3f3 	udiv	r3, r2, r3
   113ec:	461a      	mov	r2, r3
   113ee:	f04f 0300 	mov.w	r3, #0
   113f2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   113f4:	fb03 f001 	mul.w	r0, r3, r1
   113f8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   113fa:	fb02 f101 	mul.w	r1, r2, r1
   113fe:	4401      	add	r1, r0
   11400:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   11402:	fba0 2302 	umull	r2, r3, r0, r2
   11406:	4419      	add	r1, r3
   11408:	460b      	mov	r3, r1
   1140a:	e047      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
		if (result32) {
   1140c:	7fbb      	ldrb	r3, [r7, #30]
   1140e:	2b00      	cmp	r3, #0
   11410:	d024      	beq.n	1145c <k_ticks_to_ms_floor64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   11412:	6a3b      	ldr	r3, [r7, #32]
   11414:	461a      	mov	r2, r3
   11416:	f04f 0300 	mov.w	r3, #0
   1141a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1141c:	fb03 f001 	mul.w	r0, r3, r1
   11420:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   11422:	fb02 f101 	mul.w	r1, r2, r1
   11426:	4401      	add	r1, r0
   11428:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1142a:	fba0 2302 	umull	r2, r3, r0, r2
   1142e:	4419      	add	r1, r3
   11430:	460b      	mov	r3, r1
   11432:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   11436:	eb12 0a00 	adds.w	sl, r2, r0
   1143a:	eb43 0b01 	adc.w	fp, r3, r1
   1143e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11440:	461a      	mov	r2, r3
   11442:	f04f 0300 	mov.w	r3, #0
   11446:	4650      	mov	r0, sl
   11448:	4659      	mov	r1, fp
   1144a:	f7ee fe7b 	bl	144 <__aeabi_uldivmod>
   1144e:	4602      	mov	r2, r0
   11450:	460b      	mov	r3, r1
   11452:	4613      	mov	r3, r2
   11454:	461a      	mov	r2, r3
   11456:	f04f 0300 	mov.w	r3, #0
   1145a:	e01f      	b.n	1149c <k_ticks_to_ms_floor64+0x23e>
			return (t * to_hz + off) / from_hz;
   1145c:	6a3b      	ldr	r3, [r7, #32]
   1145e:	461a      	mov	r2, r3
   11460:	f04f 0300 	mov.w	r3, #0
   11464:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   11466:	fb03 f001 	mul.w	r0, r3, r1
   1146a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   1146c:	fb02 f101 	mul.w	r1, r2, r1
   11470:	4401      	add	r1, r0
   11472:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   11474:	fba0 2302 	umull	r2, r3, r0, r2
   11478:	4419      	add	r1, r3
   1147a:	460b      	mov	r3, r1
   1147c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   11480:	eb12 0800 	adds.w	r8, r2, r0
   11484:	eb43 0901 	adc.w	r9, r3, r1
   11488:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1148a:	461a      	mov	r2, r3
   1148c:	f04f 0300 	mov.w	r3, #0
   11490:	4640      	mov	r0, r8
   11492:	4649      	mov	r1, r9
   11494:	f7ee fe56 	bl	144 <__aeabi_uldivmod>
   11498:	4602      	mov	r2, r0
   1149a:	460b      	mov	r3, r1
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ms, true, false, false, false);
}
   1149c:	4610      	mov	r0, r2
   1149e:	4619      	mov	r1, r3
   114a0:	3730      	adds	r7, #48	; 0x30
   114a2:	46bd      	mov	sp, r7
   114a4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

000114a8 <k_uptime_get>:
 *    @option{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.
 *
 * @return Current uptime in milliseconds.
 */
static inline int64_t k_uptime_get(void)
{
   114a8:	b580      	push	{r7, lr}
   114aa:	af00      	add	r7, sp, #0
	return k_ticks_to_ms_floor64(k_uptime_ticks());
   114ac:	f000 f86e 	bl	1158c <k_uptime_ticks>
   114b0:	4602      	mov	r2, r0
   114b2:	460b      	mov	r3, r1
   114b4:	4610      	mov	r0, r2
   114b6:	4619      	mov	r1, r3
   114b8:	f7ff fed1 	bl	1125e <k_ticks_to_ms_floor64>
   114bc:	4602      	mov	r2, r0
   114be:	460b      	mov	r3, r1
}
   114c0:	4610      	mov	r0, r2
   114c2:	4619      	mov	r1, r3
   114c4:	bd80      	pop	{r7, pc}

000114c6 <k_uptime_get_32>:
 *    @option{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
   114c6:	b580      	push	{r7, lr}
   114c8:	af00      	add	r7, sp, #0
	return (uint32_t)k_uptime_get();
   114ca:	f7ff ffed 	bl	114a8 <k_uptime_get>
   114ce:	4602      	mov	r2, r0
   114d0:	460b      	mov	r3, r1
   114d2:	4613      	mov	r3, r2
}
   114d4:	4618      	mov	r0, r3
   114d6:	bd80      	pop	{r7, pc}

000114d8 <k_cycle_get_32>:
 * clock.
 *
 * @return Current hardware clock up-counter (in cycles).
 */
static inline uint32_t k_cycle_get_32(void)
{
   114d8:	b580      	push	{r7, lr}
   114da:	af00      	add	r7, sp, #0
	return arch_k_cycle_get_32();
   114dc:	f7ff fd8b 	bl	10ff6 <arch_k_cycle_get_32>
   114e0:	4603      	mov	r3, r0
}
   114e2:	4618      	mov	r0, r3
   114e4:	bd80      	pop	{r7, pc}

000114e6 <k_thread_create>:
{
   114e6:	b580      	push	{r7, lr}
   114e8:	b08c      	sub	sp, #48	; 0x30
   114ea:	af08      	add	r7, sp, #32
   114ec:	60f8      	str	r0, [r7, #12]
   114ee:	60b9      	str	r1, [r7, #8]
   114f0:	607a      	str	r2, [r7, #4]
   114f2:	603b      	str	r3, [r7, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   114f4:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
   114f8:	e9cd 2306 	strd	r2, r3, [sp, #24]
   114fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   114fe:	9304      	str	r3, [sp, #16]
   11500:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11502:	9303      	str	r3, [sp, #12]
   11504:	6a3b      	ldr	r3, [r7, #32]
   11506:	9302      	str	r3, [sp, #8]
   11508:	69fb      	ldr	r3, [r7, #28]
   1150a:	9301      	str	r3, [sp, #4]
   1150c:	69bb      	ldr	r3, [r7, #24]
   1150e:	9300      	str	r3, [sp, #0]
   11510:	683b      	ldr	r3, [r7, #0]
   11512:	687a      	ldr	r2, [r7, #4]
   11514:	68b9      	ldr	r1, [r7, #8]
   11516:	68f8      	ldr	r0, [r7, #12]
   11518:	f7fd f9b4 	bl	e884 <z_impl_k_thread_create>
   1151c:	4603      	mov	r3, r0
}
   1151e:	4618      	mov	r0, r3
   11520:	3710      	adds	r7, #16
   11522:	46bd      	mov	sp, r7
   11524:	bd80      	pop	{r7, pc}

00011526 <k_current_get>:
{
   11526:	b580      	push	{r7, lr}
   11528:	af00      	add	r7, sp, #0
	return z_impl_k_current_get();
   1152a:	f7fc ff09 	bl	e340 <z_impl_k_current_get>
   1152e:	4603      	mov	r3, r0
}
   11530:	4618      	mov	r0, r3
   11532:	bd80      	pop	{r7, pc}

00011534 <k_thread_name_set>:
}


extern int z_impl_k_thread_name_set(k_tid_t thread_id, const char * value);
static inline int k_thread_name_set(k_tid_t thread_id, const char * value)
{
   11534:	b580      	push	{r7, lr}
   11536:	b082      	sub	sp, #8
   11538:	af00      	add	r7, sp, #0
   1153a:	6078      	str	r0, [r7, #4]
   1153c:	6039      	str	r1, [r7, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread_id, *(uintptr_t *)&value, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread_id, value);
   1153e:	6839      	ldr	r1, [r7, #0]
   11540:	6878      	ldr	r0, [r7, #4]
   11542:	f006 fd6f 	bl	18024 <z_impl_k_thread_name_set>
   11546:	4603      	mov	r3, r0
}
   11548:	4618      	mov	r0, r3
   1154a:	3708      	adds	r7, #8
   1154c:	46bd      	mov	sp, r7
   1154e:	bd80      	pop	{r7, pc}

00011550 <k_timer_start>:
}


extern void z_impl_k_timer_start(struct k_timer * timer, k_timeout_t duration, k_timeout_t period);
static inline void k_timer_start(struct k_timer * timer, k_timeout_t duration, k_timeout_t period)
{
   11550:	b580      	push	{r7, lr}
   11552:	b086      	sub	sp, #24
   11554:	af02      	add	r7, sp, #8
   11556:	60f8      	str	r0, [r7, #12]
   11558:	e9c7 2300 	strd	r2, r3, [r7]
		arch_syscall_invoke5(*(uintptr_t *)&timer, parm0.split.lo, parm0.split.hi, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_TIMER_START);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_start(timer, duration, period);
   1155c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
   11560:	e9cd 2300 	strd	r2, r3, [sp]
   11564:	e9d7 2300 	ldrd	r2, r3, [r7]
   11568:	68f8      	ldr	r0, [r7, #12]
   1156a:	f7fe f8ab 	bl	f6c4 <z_impl_k_timer_start>
}
   1156e:	bf00      	nop
   11570:	3710      	adds	r7, #16
   11572:	46bd      	mov	sp, r7
   11574:	bd80      	pop	{r7, pc}

00011576 <k_timer_stop>:


extern void z_impl_k_timer_stop(struct k_timer * timer);
static inline void k_timer_stop(struct k_timer * timer)
{
   11576:	b580      	push	{r7, lr}
   11578:	b082      	sub	sp, #8
   1157a:	af00      	add	r7, sp, #0
   1157c:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&timer, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
   1157e:	6878      	ldr	r0, [r7, #4]
   11580:	f006 ff63 	bl	1844a <z_impl_k_timer_stop>
}
   11584:	bf00      	nop
   11586:	3708      	adds	r7, #8
   11588:	46bd      	mov	sp, r7
   1158a:	bd80      	pop	{r7, pc}

0001158c <k_uptime_ticks>:
}


extern int64_t z_impl_k_uptime_ticks();
static inline int64_t k_uptime_ticks()
{
   1158c:	b580      	push	{r7, lr}
   1158e:	af00      	add	r7, sp, #0
		(void)arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_TICKS);
		return (int64_t)ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
   11590:	f006 fe98 	bl	182c4 <z_impl_k_uptime_ticks>
   11594:	4602      	mov	r2, r0
   11596:	460b      	mov	r3, r1
}
   11598:	4610      	mov	r0, r2
   1159a:	4619      	mov	r1, r3
   1159c:	bd80      	pop	{r7, pc}

0001159e <k_sem_take>:
}


extern int z_impl_k_sem_take(struct k_sem * sem, k_timeout_t timeout);
static inline int k_sem_take(struct k_sem * sem, k_timeout_t timeout)
{
   1159e:	b580      	push	{r7, lr}
   115a0:	b084      	sub	sp, #16
   115a2:	af00      	add	r7, sp, #0
   115a4:	60f8      	str	r0, [r7, #12]
   115a6:	e9c7 2300 	strd	r2, r3, [r7]
		parm0.val = timeout;
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
   115aa:	e9d7 2300 	ldrd	r2, r3, [r7]
   115ae:	68f8      	ldr	r0, [r7, #12]
   115b0:	f7fc ff3a 	bl	e428 <z_impl_k_sem_take>
   115b4:	4603      	mov	r3, r0
}
   115b6:	4618      	mov	r0, r3
   115b8:	3710      	adds	r7, #16
   115ba:	46bd      	mov	sp, r7
   115bc:	bd80      	pop	{r7, pc}

000115be <k_sem_give>:


extern void z_impl_k_sem_give(struct k_sem * sem);
static inline void k_sem_give(struct k_sem * sem)
{
   115be:	b580      	push	{r7, lr}
   115c0:	b082      	sub	sp, #8
   115c2:	af00      	add	r7, sp, #0
   115c4:	6078      	str	r0, [r7, #4]
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   115c6:	6878      	ldr	r0, [r7, #4]
   115c8:	f7fc fec8 	bl	e35c <z_impl_k_sem_give>
}
   115cc:	bf00      	nop
   115ce:	3708      	adds	r7, #8
   115d0:	46bd      	mov	sp, r7
   115d2:	bd80      	pop	{r7, pc}

000115d4 <log_process>:
}


extern bool z_impl_log_process(bool bypass);
static inline bool log_process(bool bypass)
{
   115d4:	b580      	push	{r7, lr}
   115d6:	b082      	sub	sp, #8
   115d8:	af00      	add	r7, sp, #0
   115da:	4603      	mov	r3, r0
   115dc:	71fb      	strb	r3, [r7, #7]
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   115de:	79fb      	ldrb	r3, [r7, #7]
   115e0:	4618      	mov	r0, r3
   115e2:	f7f1 f873 	bl	26cc <z_impl_log_process>
   115e6:	4603      	mov	r3, r0
}
   115e8:	4618      	mov	r0, r3
   115ea:	3708      	adds	r7, #8
   115ec:	46bd      	mov	sp, r7
   115ee:	bd80      	pop	{r7, pc}

000115f0 <isalpha>:
{
   115f0:	b480      	push	{r7}
   115f2:	b083      	sub	sp, #12
   115f4:	af00      	add	r7, sp, #0
   115f6:	6078      	str	r0, [r7, #4]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   115f8:	687b      	ldr	r3, [r7, #4]
   115fa:	f043 0320 	orr.w	r3, r3, #32
   115fe:	3b61      	subs	r3, #97	; 0x61
   11600:	2b19      	cmp	r3, #25
   11602:	bf94      	ite	ls
   11604:	2301      	movls	r3, #1
   11606:	2300      	movhi	r3, #0
   11608:	b2db      	uxtb	r3, r3
}
   1160a:	4618      	mov	r0, r3
   1160c:	370c      	adds	r7, #12
   1160e:	46bd      	mov	sp, r7
   11610:	bc80      	pop	{r7}
   11612:	4770      	bx	lr

00011614 <dummy_timestamp>:
{
   11614:	b480      	push	{r7}
   11616:	af00      	add	r7, sp, #0
	return 0;
   11618:	2300      	movs	r3, #0
}
   1161a:	4618      	mov	r0, r3
   1161c:	46bd      	mov	sp, r7
   1161e:	bc80      	pop	{r7}
   11620:	4770      	bx	lr

00011622 <log_0>:
{
   11622:	b580      	push	{r7, lr}
   11624:	b084      	sub	sp, #16
   11626:	af00      	add	r7, sp, #0
   11628:	6078      	str	r0, [r7, #4]
   1162a:	8039      	strh	r1, [r7, #0]
		struct log_msg *msg = log_msg_create_0(str);
   1162c:	6878      	ldr	r0, [r7, #4]
   1162e:	f7ff fc69 	bl	10f04 <log_msg_create_0>
   11632:	60f8      	str	r0, [r7, #12]
		if (msg == NULL) {
   11634:	68fb      	ldr	r3, [r7, #12]
   11636:	2b00      	cmp	r3, #0
   11638:	d004      	beq.n	11644 <log_0+0x22>
		msg_finalize(msg, src_level);
   1163a:	8839      	ldrh	r1, [r7, #0]
   1163c:	68f8      	ldr	r0, [r7, #12]
   1163e:	f7f0 fe83 	bl	2348 <msg_finalize>
   11642:	e000      	b.n	11646 <log_0+0x24>
			return;
   11644:	bf00      	nop
}
   11646:	3710      	adds	r7, #16
   11648:	46bd      	mov	sp, r7
   1164a:	bd80      	pop	{r7, pc}

0001164c <log_1>:
{
   1164c:	b580      	push	{r7, lr}
   1164e:	b086      	sub	sp, #24
   11650:	af00      	add	r7, sp, #0
   11652:	60f8      	str	r0, [r7, #12]
   11654:	60b9      	str	r1, [r7, #8]
   11656:	80ba      	strh	r2, [r7, #4]
		struct log_msg *msg = log_msg_create_1(str, arg0);
   11658:	68b9      	ldr	r1, [r7, #8]
   1165a:	68f8      	ldr	r0, [r7, #12]
   1165c:	f7ff fc64 	bl	10f28 <log_msg_create_1>
   11660:	6178      	str	r0, [r7, #20]
		if (msg == NULL) {
   11662:	697b      	ldr	r3, [r7, #20]
   11664:	2b00      	cmp	r3, #0
   11666:	d004      	beq.n	11672 <log_1+0x26>
		msg_finalize(msg, src_level);
   11668:	88b9      	ldrh	r1, [r7, #4]
   1166a:	6978      	ldr	r0, [r7, #20]
   1166c:	f7f0 fe6c 	bl	2348 <msg_finalize>
   11670:	e000      	b.n	11674 <log_1+0x28>
			return;
   11672:	bf00      	nop
}
   11674:	3718      	adds	r7, #24
   11676:	46bd      	mov	sp, r7
   11678:	bd80      	pop	{r7, pc}

0001167a <log_2>:
{
   1167a:	b580      	push	{r7, lr}
   1167c:	b086      	sub	sp, #24
   1167e:	af00      	add	r7, sp, #0
   11680:	60f8      	str	r0, [r7, #12]
   11682:	60b9      	str	r1, [r7, #8]
   11684:	607a      	str	r2, [r7, #4]
   11686:	803b      	strh	r3, [r7, #0]
		struct log_msg *msg = log_msg_create_2(str, arg0, arg1);
   11688:	687a      	ldr	r2, [r7, #4]
   1168a:	68b9      	ldr	r1, [r7, #8]
   1168c:	68f8      	ldr	r0, [r7, #12]
   1168e:	f7ff fc67 	bl	10f60 <log_msg_create_2>
   11692:	6178      	str	r0, [r7, #20]
		if (msg == NULL) {
   11694:	697b      	ldr	r3, [r7, #20]
   11696:	2b00      	cmp	r3, #0
   11698:	d004      	beq.n	116a4 <log_2+0x2a>
		msg_finalize(msg, src_level);
   1169a:	8839      	ldrh	r1, [r7, #0]
   1169c:	6978      	ldr	r0, [r7, #20]
   1169e:	f7f0 fe53 	bl	2348 <msg_finalize>
   116a2:	e000      	b.n	116a6 <log_2+0x2c>
			return;
   116a4:	bf00      	nop
}
   116a6:	3718      	adds	r7, #24
   116a8:	46bd      	mov	sp, r7
   116aa:	bd80      	pop	{r7, pc}

000116ac <log_3>:
{
   116ac:	b580      	push	{r7, lr}
   116ae:	b086      	sub	sp, #24
   116b0:	af00      	add	r7, sp, #0
   116b2:	60f8      	str	r0, [r7, #12]
   116b4:	60b9      	str	r1, [r7, #8]
   116b6:	607a      	str	r2, [r7, #4]
   116b8:	603b      	str	r3, [r7, #0]
		struct log_msg *msg = log_msg_create_3(str, arg0, arg1, arg2);
   116ba:	683b      	ldr	r3, [r7, #0]
   116bc:	687a      	ldr	r2, [r7, #4]
   116be:	68b9      	ldr	r1, [r7, #8]
   116c0:	68f8      	ldr	r0, [r7, #12]
   116c2:	f7ff fc6d 	bl	10fa0 <log_msg_create_3>
   116c6:	6178      	str	r0, [r7, #20]
		if (msg == NULL) {
   116c8:	697b      	ldr	r3, [r7, #20]
   116ca:	2b00      	cmp	r3, #0
   116cc:	d004      	beq.n	116d8 <log_3+0x2c>
		msg_finalize(msg, src_level);
   116ce:	8c39      	ldrh	r1, [r7, #32]
   116d0:	6978      	ldr	r0, [r7, #20]
   116d2:	f7f0 fe39 	bl	2348 <msg_finalize>
   116d6:	e000      	b.n	116da <log_3+0x2e>
			return;
   116d8:	bf00      	nop
}
   116da:	3718      	adds	r7, #24
   116dc:	46bd      	mov	sp, r7
   116de:	bd80      	pop	{r7, pc}

000116e0 <log_n>:
{
   116e0:	b580      	push	{r7, lr}
   116e2:	b086      	sub	sp, #24
   116e4:	af00      	add	r7, sp, #0
   116e6:	60f8      	str	r0, [r7, #12]
   116e8:	60b9      	str	r1, [r7, #8]
   116ea:	607a      	str	r2, [r7, #4]
   116ec:	803b      	strh	r3, [r7, #0]
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   116ee:	687a      	ldr	r2, [r7, #4]
   116f0:	68b9      	ldr	r1, [r7, #8]
   116f2:	68f8      	ldr	r0, [r7, #12]
   116f4:	f7f1 fa6c 	bl	2bd0 <log_msg_create_n>
   116f8:	6178      	str	r0, [r7, #20]
		if (msg == NULL) {
   116fa:	697b      	ldr	r3, [r7, #20]
   116fc:	2b00      	cmp	r3, #0
   116fe:	d004      	beq.n	1170a <log_n+0x2a>
		msg_finalize(msg, src_level);
   11700:	8839      	ldrh	r1, [r7, #0]
   11702:	6978      	ldr	r0, [r7, #20]
   11704:	f7f0 fe20 	bl	2348 <msg_finalize>
   11708:	e000      	b.n	1170c <log_n+0x2c>
			return;
   1170a:	bf00      	nop
}
   1170c:	3718      	adds	r7, #24
   1170e:	46bd      	mov	sp, r7
   11710:	bd80      	pop	{r7, pc}

00011712 <k_cycle_get_32_wrapper>:
{
   11712:	b580      	push	{r7, lr}
   11714:	af00      	add	r7, sp, #0
	return k_cycle_get_32();
   11716:	f7ff fedf 	bl	114d8 <k_cycle_get_32>
   1171a:	4603      	mov	r3, r0
}
   1171c:	4618      	mov	r0, r3
   1171e:	bd80      	pop	{r7, pc}

00011720 <msg_filter_check>:
{
   11720:	b480      	push	{r7}
   11722:	b083      	sub	sp, #12
   11724:	af00      	add	r7, sp, #0
   11726:	6078      	str	r0, [r7, #4]
   11728:	6039      	str	r1, [r7, #0]
		return true;
   1172a:	2301      	movs	r3, #1
}
   1172c:	4618      	mov	r0, r3
   1172e:	370c      	adds	r7, #12
   11730:	46bd      	mov	sp, r7
   11732:	bc80      	pop	{r7}
   11734:	4770      	bx	lr

00011736 <log_source_name_get>:
{
   11736:	b580      	push	{r7, lr}
   11738:	b082      	sub	sp, #8
   1173a:	af00      	add	r7, sp, #0
   1173c:	6078      	str	r0, [r7, #4]
   1173e:	6039      	str	r1, [r7, #0]
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   11740:	f7f0 fc10 	bl	1f64 <log_sources_count>
   11744:	4602      	mov	r2, r0
   11746:	683b      	ldr	r3, [r7, #0]
   11748:	4293      	cmp	r3, r2
   1174a:	d204      	bcs.n	11756 <log_source_name_get+0x20>
   1174c:	6838      	ldr	r0, [r7, #0]
   1174e:	f7f0 fbe9 	bl	1f24 <log_name_get>
   11752:	4603      	mov	r3, r0
   11754:	e000      	b.n	11758 <log_source_name_get+0x22>
   11756:	2300      	movs	r3, #0
}
   11758:	4618      	mov	r0, r3
   1175a:	3708      	adds	r7, #8
   1175c:	46bd      	mov	sp, r7
   1175e:	bd80      	pop	{r7, pc}

00011760 <backend_filter_set>:
{
   11760:	b480      	push	{r7}
   11762:	b083      	sub	sp, #12
   11764:	af00      	add	r7, sp, #0
   11766:	6078      	str	r0, [r7, #4]
   11768:	6039      	str	r1, [r7, #0]
}
   1176a:	bf00      	nop
   1176c:	370c      	adds	r7, #12
   1176e:	46bd      	mov	sp, r7
   11770:	bc80      	pop	{r7}
   11772:	4770      	bx	lr

00011774 <atomic_add>:
{
   11774:	b480      	push	{r7}
   11776:	b083      	sub	sp, #12
   11778:	af00      	add	r7, sp, #0
   1177a:	6078      	str	r0, [r7, #4]
   1177c:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1177e:	683a      	ldr	r2, [r7, #0]
   11780:	687b      	ldr	r3, [r7, #4]
   11782:	e8d3 1fef 	ldaex	r1, [r3]
   11786:	eb01 0002 	add.w	r0, r1, r2
   1178a:	e8c3 0fec 	stlex	ip, r0, [r3]
   1178e:	f1bc 0f00 	cmp.w	ip, #0
   11792:	d1f6      	bne.n	11782 <atomic_add+0xe>
   11794:	460b      	mov	r3, r1
}
   11796:	4618      	mov	r0, r3
   11798:	370c      	adds	r7, #12
   1179a:	46bd      	mov	sp, r7
   1179c:	bc80      	pop	{r7}
   1179e:	4770      	bx	lr

000117a0 <atomic_sub>:
{
   117a0:	b480      	push	{r7}
   117a2:	b083      	sub	sp, #12
   117a4:	af00      	add	r7, sp, #0
   117a6:	6078      	str	r0, [r7, #4]
   117a8:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   117aa:	683a      	ldr	r2, [r7, #0]
   117ac:	687b      	ldr	r3, [r7, #4]
   117ae:	e8d3 1fef 	ldaex	r1, [r3]
   117b2:	eba1 0002 	sub.w	r0, r1, r2
   117b6:	e8c3 0fec 	stlex	ip, r0, [r3]
   117ba:	f1bc 0f00 	cmp.w	ip, #0
   117be:	d1f6      	bne.n	117ae <atomic_sub+0xe>
   117c0:	460b      	mov	r3, r1
}
   117c2:	4618      	mov	r0, r3
   117c4:	370c      	adds	r7, #12
   117c6:	46bd      	mov	sp, r7
   117c8:	bc80      	pop	{r7}
   117ca:	4770      	bx	lr

000117cc <atomic_inc>:
{
   117cc:	b580      	push	{r7, lr}
   117ce:	b082      	sub	sp, #8
   117d0:	af00      	add	r7, sp, #0
   117d2:	6078      	str	r0, [r7, #4]
	return atomic_add(target, 1);
   117d4:	2101      	movs	r1, #1
   117d6:	6878      	ldr	r0, [r7, #4]
   117d8:	f7ff ffcc 	bl	11774 <atomic_add>
   117dc:	4603      	mov	r3, r0
}
   117de:	4618      	mov	r0, r3
   117e0:	3708      	adds	r7, #8
   117e2:	46bd      	mov	sp, r7
   117e4:	bd80      	pop	{r7, pc}

000117e6 <atomic_dec>:
{
   117e6:	b580      	push	{r7, lr}
   117e8:	b082      	sub	sp, #8
   117ea:	af00      	add	r7, sp, #0
   117ec:	6078      	str	r0, [r7, #4]
	return atomic_sub(target, 1);
   117ee:	2101      	movs	r1, #1
   117f0:	6878      	ldr	r0, [r7, #4]
   117f2:	f7ff ffd5 	bl	117a0 <atomic_sub>
   117f6:	4603      	mov	r3, r0
}
   117f8:	4618      	mov	r0, r3
   117fa:	3708      	adds	r7, #8
   117fc:	46bd      	mov	sp, r7
   117fe:	bd80      	pop	{r7, pc}

00011800 <k_ms_to_ticks_ceil64>:
{
   11800:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   11804:	b08c      	sub	sp, #48	; 0x30
   11806:	af00      	add	r7, sp, #0
   11808:	e9c7 0100 	strd	r0, r1, [r7]
   1180c:	e9d7 2300 	ldrd	r2, r3, [r7]
   11810:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   11814:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   11818:	627b      	str	r3, [r7, #36]	; 0x24
   1181a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   1181e:	623b      	str	r3, [r7, #32]
   11820:	2301      	movs	r3, #1
   11822:	77fb      	strb	r3, [r7, #31]
   11824:	2300      	movs	r3, #0
   11826:	77bb      	strb	r3, [r7, #30]
   11828:	2301      	movs	r3, #1
   1182a:	777b      	strb	r3, [r7, #29]
   1182c:	2300      	movs	r3, #0
   1182e:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   11830:	7ffb      	ldrb	r3, [r7, #31]
   11832:	2b00      	cmp	r3, #0
   11834:	d00f      	beq.n	11856 <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   11836:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11838:	6a3b      	ldr	r3, [r7, #32]
   1183a:	429a      	cmp	r2, r3
   1183c:	d20b      	bcs.n	11856 <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1183e:	6a3b      	ldr	r3, [r7, #32]
   11840:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11842:	fbb3 f2f2 	udiv	r2, r3, r2
   11846:	6a79      	ldr	r1, [r7, #36]	; 0x24
   11848:	fb01 f202 	mul.w	r2, r1, r2
   1184c:	1a9b      	subs	r3, r3, r2
   1184e:	2b00      	cmp	r3, #0
   11850:	d101      	bne.n	11856 <k_ms_to_ticks_ceil64+0x56>
   11852:	2301      	movs	r3, #1
   11854:	e000      	b.n	11858 <k_ms_to_ticks_ceil64+0x58>
   11856:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   11858:	76fb      	strb	r3, [r7, #27]
   1185a:	7efb      	ldrb	r3, [r7, #27]
   1185c:	f003 0301 	and.w	r3, r3, #1
   11860:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   11862:	7ffb      	ldrb	r3, [r7, #31]
   11864:	2b00      	cmp	r3, #0
   11866:	d00f      	beq.n	11888 <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   11868:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1186a:	6a3b      	ldr	r3, [r7, #32]
   1186c:	429a      	cmp	r2, r3
   1186e:	d90b      	bls.n	11888 <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   11870:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11872:	6a3a      	ldr	r2, [r7, #32]
   11874:	fbb3 f2f2 	udiv	r2, r3, r2
   11878:	6a39      	ldr	r1, [r7, #32]
   1187a:	fb01 f202 	mul.w	r2, r1, r2
   1187e:	1a9b      	subs	r3, r3, r2
   11880:	2b00      	cmp	r3, #0
   11882:	d101      	bne.n	11888 <k_ms_to_ticks_ceil64+0x88>
   11884:	2301      	movs	r3, #1
   11886:	e000      	b.n	1188a <k_ms_to_ticks_ceil64+0x8a>
   11888:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   1188a:	76bb      	strb	r3, [r7, #26]
   1188c:	7ebb      	ldrb	r3, [r7, #26]
   1188e:	f003 0301 	and.w	r3, r3, #1
   11892:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   11894:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11896:	6a3b      	ldr	r3, [r7, #32]
   11898:	429a      	cmp	r2, r3
   1189a:	d10a      	bne.n	118b2 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   1189c:	7fbb      	ldrb	r3, [r7, #30]
   1189e:	2b00      	cmp	r3, #0
   118a0:	d004      	beq.n	118ac <k_ms_to_ticks_ceil64+0xac>
   118a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   118a4:	461a      	mov	r2, r3
   118a6:	f04f 0300 	mov.w	r3, #0
   118aa:	e0c8      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
   118ac:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   118b0:	e0c5      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   118b2:	f04f 0200 	mov.w	r2, #0
   118b6:	f04f 0300 	mov.w	r3, #0
   118ba:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   118be:	7efb      	ldrb	r3, [r7, #27]
   118c0:	f083 0301 	eor.w	r3, r3, #1
   118c4:	b2db      	uxtb	r3, r3
   118c6:	2b00      	cmp	r3, #0
   118c8:	d01e      	beq.n	11908 <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   118ca:	7ebb      	ldrb	r3, [r7, #26]
   118cc:	2b00      	cmp	r3, #0
   118ce:	d004      	beq.n	118da <k_ms_to_ticks_ceil64+0xda>
   118d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   118d2:	6a3b      	ldr	r3, [r7, #32]
   118d4:	fbb2 f3f3 	udiv	r3, r2, r3
   118d8:	e000      	b.n	118dc <k_ms_to_ticks_ceil64+0xdc>
   118da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   118dc:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   118de:	7f7b      	ldrb	r3, [r7, #29]
   118e0:	2b00      	cmp	r3, #0
   118e2:	d007      	beq.n	118f4 <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   118e4:	68fb      	ldr	r3, [r7, #12]
   118e6:	3b01      	subs	r3, #1
   118e8:	461a      	mov	r2, r3
   118ea:	f04f 0300 	mov.w	r3, #0
   118ee:	e9c7 2304 	strd	r2, r3, [r7, #16]
   118f2:	e009      	b.n	11908 <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   118f4:	7f3b      	ldrb	r3, [r7, #28]
   118f6:	2b00      	cmp	r3, #0
   118f8:	d006      	beq.n	11908 <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   118fa:	68fb      	ldr	r3, [r7, #12]
   118fc:	085b      	lsrs	r3, r3, #1
   118fe:	461a      	mov	r2, r3
   11900:	f04f 0300 	mov.w	r3, #0
   11904:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   11908:	7ebb      	ldrb	r3, [r7, #26]
   1190a:	2b00      	cmp	r3, #0
   1190c:	d02a      	beq.n	11964 <k_ms_to_ticks_ceil64+0x164>
		t += off;
   1190e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   11912:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   11916:	1884      	adds	r4, r0, r2
   11918:	eb41 0503 	adc.w	r5, r1, r3
   1191c:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   11920:	7fbb      	ldrb	r3, [r7, #30]
   11922:	2b00      	cmp	r3, #0
   11924:	d010      	beq.n	11948 <k_ms_to_ticks_ceil64+0x148>
   11926:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   1192a:	2b01      	cmp	r3, #1
   1192c:	bf08      	it	eq
   1192e:	2a00      	cmpeq	r2, #0
   11930:	d20a      	bcs.n	11948 <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   11932:	6aba      	ldr	r2, [r7, #40]	; 0x28
   11934:	6a79      	ldr	r1, [r7, #36]	; 0x24
   11936:	6a3b      	ldr	r3, [r7, #32]
   11938:	fbb1 f3f3 	udiv	r3, r1, r3
   1193c:	fbb2 f3f3 	udiv	r3, r2, r3
   11940:	461a      	mov	r2, r3
   11942:	f04f 0300 	mov.w	r3, #0
   11946:	e07a      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   11948:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1194a:	6a3b      	ldr	r3, [r7, #32]
   1194c:	fbb2 f3f3 	udiv	r3, r2, r3
   11950:	461a      	mov	r2, r3
   11952:	f04f 0300 	mov.w	r3, #0
   11956:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   1195a:	f7ee fbf3 	bl	144 <__aeabi_uldivmod>
   1195e:	4602      	mov	r2, r0
   11960:	460b      	mov	r3, r1
   11962:	e06c      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   11964:	7efb      	ldrb	r3, [r7, #27]
   11966:	2b00      	cmp	r3, #0
   11968:	d021      	beq.n	119ae <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   1196a:	7fbb      	ldrb	r3, [r7, #30]
   1196c:	2b00      	cmp	r3, #0
   1196e:	d00a      	beq.n	11986 <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   11970:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11972:	6a39      	ldr	r1, [r7, #32]
   11974:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11976:	fbb1 f2f2 	udiv	r2, r1, r2
   1197a:	fb02 f303 	mul.w	r3, r2, r3
   1197e:	461a      	mov	r2, r3
   11980:	f04f 0300 	mov.w	r3, #0
   11984:	e05b      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   11986:	6a3a      	ldr	r2, [r7, #32]
   11988:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1198a:	fbb2 f3f3 	udiv	r3, r2, r3
   1198e:	461a      	mov	r2, r3
   11990:	f04f 0300 	mov.w	r3, #0
   11994:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   11996:	fb03 f001 	mul.w	r0, r3, r1
   1199a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   1199c:	fb02 f101 	mul.w	r1, r2, r1
   119a0:	4401      	add	r1, r0
   119a2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   119a4:	fba0 2302 	umull	r2, r3, r0, r2
   119a8:	4419      	add	r1, r3
   119aa:	460b      	mov	r3, r1
   119ac:	e047      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   119ae:	7fbb      	ldrb	r3, [r7, #30]
   119b0:	2b00      	cmp	r3, #0
   119b2:	d024      	beq.n	119fe <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   119b4:	6a3b      	ldr	r3, [r7, #32]
   119b6:	461a      	mov	r2, r3
   119b8:	f04f 0300 	mov.w	r3, #0
   119bc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   119be:	fb03 f001 	mul.w	r0, r3, r1
   119c2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   119c4:	fb02 f101 	mul.w	r1, r2, r1
   119c8:	4401      	add	r1, r0
   119ca:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   119cc:	fba0 2302 	umull	r2, r3, r0, r2
   119d0:	4419      	add	r1, r3
   119d2:	460b      	mov	r3, r1
   119d4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   119d8:	eb12 0a00 	adds.w	sl, r2, r0
   119dc:	eb43 0b01 	adc.w	fp, r3, r1
   119e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   119e2:	461a      	mov	r2, r3
   119e4:	f04f 0300 	mov.w	r3, #0
   119e8:	4650      	mov	r0, sl
   119ea:	4659      	mov	r1, fp
   119ec:	f7ee fbaa 	bl	144 <__aeabi_uldivmod>
   119f0:	4602      	mov	r2, r0
   119f2:	460b      	mov	r3, r1
   119f4:	4613      	mov	r3, r2
   119f6:	461a      	mov	r2, r3
   119f8:	f04f 0300 	mov.w	r3, #0
   119fc:	e01f      	b.n	11a3e <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   119fe:	6a3b      	ldr	r3, [r7, #32]
   11a00:	461a      	mov	r2, r3
   11a02:	f04f 0300 	mov.w	r3, #0
   11a06:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   11a08:	fb03 f001 	mul.w	r0, r3, r1
   11a0c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   11a0e:	fb02 f101 	mul.w	r1, r2, r1
   11a12:	4401      	add	r1, r0
   11a14:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   11a16:	fba0 2302 	umull	r2, r3, r0, r2
   11a1a:	4419      	add	r1, r3
   11a1c:	460b      	mov	r3, r1
   11a1e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   11a22:	eb12 0800 	adds.w	r8, r2, r0
   11a26:	eb43 0901 	adc.w	r9, r3, r1
   11a2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11a2c:	461a      	mov	r2, r3
   11a2e:	f04f 0300 	mov.w	r3, #0
   11a32:	4640      	mov	r0, r8
   11a34:	4649      	mov	r1, r9
   11a36:	f7ee fb85 	bl	144 <__aeabi_uldivmod>
   11a3a:	4602      	mov	r2, r0
   11a3c:	460b      	mov	r3, r1
}
   11a3e:	4610      	mov	r0, r2
   11a40:	4619      	mov	r1, r3
   11a42:	3730      	adds	r7, #48	; 0x30
   11a44:	46bd      	mov	sp, r7
   11a46:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

00011a4a <log_msg_is_std>:
{
   11a4a:	b480      	push	{r7}
   11a4c:	b083      	sub	sp, #12
   11a4e:	af00      	add	r7, sp, #0
   11a50:	6078      	str	r0, [r7, #4]
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   11a52:	687b      	ldr	r3, [r7, #4]
   11a54:	7a1b      	ldrb	r3, [r3, #8]
   11a56:	f003 0301 	and.w	r3, r3, #1
   11a5a:	b2db      	uxtb	r3, r3
   11a5c:	2b00      	cmp	r3, #0
   11a5e:	bf0c      	ite	eq
   11a60:	2301      	moveq	r3, #1
   11a62:	2300      	movne	r3, #0
   11a64:	b2db      	uxtb	r3, r3
}
   11a66:	4618      	mov	r0, r3
   11a68:	370c      	adds	r7, #12
   11a6a:	46bd      	mov	sp, r7
   11a6c:	bc80      	pop	{r7}
   11a6e:	4770      	bx	lr

00011a70 <z_log_msg_std_alloc>:
{
   11a70:	b580      	push	{r7, lr}
   11a72:	b082      	sub	sp, #8
   11a74:	af00      	add	r7, sp, #0
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   11a76:	f7f0 ffe3 	bl	2a40 <log_msg_chunk_alloc>
   11a7a:	6078      	str	r0, [r7, #4]
	if (msg != NULL) {
   11a7c:	687b      	ldr	r3, [r7, #4]
   11a7e:	2b00      	cmp	r3, #0
   11a80:	d00a      	beq.n	11a98 <z_log_msg_std_alloc+0x28>
		msg->hdr.ref_cnt = 1;
   11a82:	687b      	ldr	r3, [r7, #4]
   11a84:	2201      	movs	r2, #1
   11a86:	605a      	str	r2, [r3, #4]
		msg->hdr.params.raw = 0U;
   11a88:	687b      	ldr	r3, [r7, #4]
   11a8a:	2200      	movs	r2, #0
   11a8c:	811a      	strh	r2, [r3, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
   11a8e:	687a      	ldr	r2, [r7, #4]
   11a90:	7a13      	ldrb	r3, [r2, #8]
   11a92:	f36f 0300 	bfc	r3, #0, #1
   11a96:	7213      	strb	r3, [r2, #8]
	return msg;
   11a98:	687b      	ldr	r3, [r7, #4]
}
   11a9a:	4618      	mov	r0, r3
   11a9c:	3708      	adds	r7, #8
   11a9e:	46bd      	mov	sp, r7
   11aa0:	bd80      	pop	{r7, pc}

00011aa2 <log_process>:
{
   11aa2:	b580      	push	{r7, lr}
   11aa4:	b082      	sub	sp, #8
   11aa6:	af00      	add	r7, sp, #0
   11aa8:	4603      	mov	r3, r0
   11aaa:	71fb      	strb	r3, [r7, #7]
	return z_impl_log_process(bypass);
   11aac:	79fb      	ldrb	r3, [r7, #7]
   11aae:	4618      	mov	r0, r3
   11ab0:	f7f0 fe0c 	bl	26cc <z_impl_log_process>
   11ab4:	4603      	mov	r3, r0
}
   11ab6:	4618      	mov	r0, r3
   11ab8:	3708      	adds	r7, #8
   11aba:	46bd      	mov	sp, r7
   11abc:	bd80      	pop	{r7, pc}

00011abe <block_on_alloc>:
{
   11abe:	b480      	push	{r7}
   11ac0:	af00      	add	r7, sp, #0
		return false;
   11ac2:	2300      	movs	r3, #0
}
   11ac4:	4618      	mov	r0, r3
   11ac6:	46bd      	mov	sp, r7
   11ac8:	bc80      	pop	{r7}
   11aca:	4770      	bx	lr

00011acc <log_msg_get>:
{
   11acc:	b580      	push	{r7, lr}
   11ace:	b082      	sub	sp, #8
   11ad0:	af00      	add	r7, sp, #0
   11ad2:	6078      	str	r0, [r7, #4]
	atomic_inc(&msg->hdr.ref_cnt);
   11ad4:	687b      	ldr	r3, [r7, #4]
   11ad6:	3304      	adds	r3, #4
   11ad8:	4618      	mov	r0, r3
   11ada:	f7ff fe77 	bl	117cc <atomic_inc>
}
   11ade:	bf00      	nop
   11ae0:	3708      	adds	r7, #8
   11ae2:	46bd      	mov	sp, r7
   11ae4:	bd80      	pop	{r7, pc}

00011ae6 <log_msg_put>:
{
   11ae6:	b580      	push	{r7, lr}
   11ae8:	b082      	sub	sp, #8
   11aea:	af00      	add	r7, sp, #0
   11aec:	6078      	str	r0, [r7, #4]
	atomic_dec(&msg->hdr.ref_cnt);
   11aee:	687b      	ldr	r3, [r7, #4]
   11af0:	3304      	adds	r3, #4
   11af2:	4618      	mov	r0, r3
   11af4:	f7ff fe77 	bl	117e6 <atomic_dec>
	if (msg->hdr.ref_cnt == 0) {
   11af8:	687b      	ldr	r3, [r7, #4]
   11afa:	685b      	ldr	r3, [r3, #4]
   11afc:	2b00      	cmp	r3, #0
   11afe:	d102      	bne.n	11b06 <log_msg_put+0x20>
		msg_free(msg);
   11b00:	6878      	ldr	r0, [r7, #4]
   11b02:	f7f0 ffe1 	bl	2ac8 <msg_free>
}
   11b06:	bf00      	nop
   11b08:	3708      	adds	r7, #8
   11b0a:	46bd      	mov	sp, r7
   11b0c:	bd80      	pop	{r7, pc}

00011b0e <log_msg_nargs_get>:
{
   11b0e:	b480      	push	{r7}
   11b10:	b083      	sub	sp, #12
   11b12:	af00      	add	r7, sp, #0
   11b14:	6078      	str	r0, [r7, #4]
	return msg->hdr.params.std.nargs;
   11b16:	687b      	ldr	r3, [r7, #4]
   11b18:	7a5b      	ldrb	r3, [r3, #9]
   11b1a:	f3c3 1303 	ubfx	r3, r3, #4, #4
   11b1e:	b2db      	uxtb	r3, r3
}
   11b20:	4618      	mov	r0, r3
   11b22:	370c      	adds	r7, #12
   11b24:	46bd      	mov	sp, r7
   11b26:	bc80      	pop	{r7}
   11b28:	4770      	bx	lr

00011b2a <cont_arg_get>:
{
   11b2a:	b480      	push	{r7}
   11b2c:	b085      	sub	sp, #20
   11b2e:	af00      	add	r7, sp, #0
   11b30:	6078      	str	r0, [r7, #4]
   11b32:	6039      	str	r1, [r7, #0]
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   11b34:	683b      	ldr	r3, [r7, #0]
   11b36:	2b01      	cmp	r3, #1
   11b38:	d806      	bhi.n	11b48 <cont_arg_get+0x1e>
		return msg->payload.ext.data.args[arg_idx];
   11b3a:	687a      	ldr	r2, [r7, #4]
   11b3c:	683b      	ldr	r3, [r7, #0]
   11b3e:	3304      	adds	r3, #4
   11b40:	009b      	lsls	r3, r3, #2
   11b42:	4413      	add	r3, r2
   11b44:	689b      	ldr	r3, [r3, #8]
   11b46:	e014      	b.n	11b72 <cont_arg_get+0x48>
	cont = msg->payload.ext.next;
   11b48:	687b      	ldr	r3, [r7, #4]
   11b4a:	695b      	ldr	r3, [r3, #20]
   11b4c:	60fb      	str	r3, [r7, #12]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   11b4e:	683b      	ldr	r3, [r7, #0]
   11b50:	3b02      	subs	r3, #2
   11b52:	603b      	str	r3, [r7, #0]
	while (arg_idx >= ARGS_CONT_MSG) {
   11b54:	e005      	b.n	11b62 <cont_arg_get+0x38>
		arg_idx -= ARGS_CONT_MSG;
   11b56:	683b      	ldr	r3, [r7, #0]
   11b58:	3b07      	subs	r3, #7
   11b5a:	603b      	str	r3, [r7, #0]
		cont = cont->next;
   11b5c:	68fb      	ldr	r3, [r7, #12]
   11b5e:	681b      	ldr	r3, [r3, #0]
   11b60:	60fb      	str	r3, [r7, #12]
	while (arg_idx >= ARGS_CONT_MSG) {
   11b62:	683b      	ldr	r3, [r7, #0]
   11b64:	2b06      	cmp	r3, #6
   11b66:	d8f6      	bhi.n	11b56 <cont_arg_get+0x2c>
	return cont->payload.args[arg_idx];
   11b68:	68fa      	ldr	r2, [r7, #12]
   11b6a:	683b      	ldr	r3, [r7, #0]
   11b6c:	009b      	lsls	r3, r3, #2
   11b6e:	4413      	add	r3, r2
   11b70:	685b      	ldr	r3, [r3, #4]
}
   11b72:	4618      	mov	r0, r3
   11b74:	3714      	adds	r7, #20
   11b76:	46bd      	mov	sp, r7
   11b78:	bc80      	pop	{r7}
   11b7a:	4770      	bx	lr

00011b7c <log_msg_arg_get>:
{
   11b7c:	b580      	push	{r7, lr}
   11b7e:	b084      	sub	sp, #16
   11b80:	af00      	add	r7, sp, #0
   11b82:	6078      	str	r0, [r7, #4]
   11b84:	6039      	str	r1, [r7, #0]
	if (arg_idx >= msg->hdr.params.std.nargs) {
   11b86:	687b      	ldr	r3, [r7, #4]
   11b88:	7a5b      	ldrb	r3, [r3, #9]
   11b8a:	f3c3 1303 	ubfx	r3, r3, #4, #4
   11b8e:	b2db      	uxtb	r3, r3
   11b90:	461a      	mov	r2, r3
   11b92:	683b      	ldr	r3, [r7, #0]
   11b94:	4293      	cmp	r3, r2
   11b96:	d301      	bcc.n	11b9c <log_msg_arg_get+0x20>
		return 0;
   11b98:	2300      	movs	r3, #0
   11b9a:	e014      	b.n	11bc6 <log_msg_arg_get+0x4a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   11b9c:	687b      	ldr	r3, [r7, #4]
   11b9e:	7a5b      	ldrb	r3, [r3, #9]
   11ba0:	f3c3 1303 	ubfx	r3, r3, #4, #4
   11ba4:	b2db      	uxtb	r3, r3
   11ba6:	2b03      	cmp	r3, #3
   11ba8:	d807      	bhi.n	11bba <log_msg_arg_get+0x3e>
		arg = msg->payload.single.args[arg_idx];
   11baa:	687a      	ldr	r2, [r7, #4]
   11bac:	683b      	ldr	r3, [r7, #0]
   11bae:	3304      	adds	r3, #4
   11bb0:	009b      	lsls	r3, r3, #2
   11bb2:	4413      	add	r3, r2
   11bb4:	685b      	ldr	r3, [r3, #4]
   11bb6:	60fb      	str	r3, [r7, #12]
   11bb8:	e004      	b.n	11bc4 <log_msg_arg_get+0x48>
		arg = cont_arg_get(msg, arg_idx);
   11bba:	6839      	ldr	r1, [r7, #0]
   11bbc:	6878      	ldr	r0, [r7, #4]
   11bbe:	f7ff ffb4 	bl	11b2a <cont_arg_get>
   11bc2:	60f8      	str	r0, [r7, #12]
	return arg;
   11bc4:	68fb      	ldr	r3, [r7, #12]
}
   11bc6:	4618      	mov	r0, r3
   11bc8:	3710      	adds	r7, #16
   11bca:	46bd      	mov	sp, r7
   11bcc:	bd80      	pop	{r7, pc}

00011bce <log_msg_str_get>:
{
   11bce:	b480      	push	{r7}
   11bd0:	b083      	sub	sp, #12
   11bd2:	af00      	add	r7, sp, #0
   11bd4:	6078      	str	r0, [r7, #4]
	return msg->str;
   11bd6:	687b      	ldr	r3, [r7, #4]
   11bd8:	691b      	ldr	r3, [r3, #16]
}
   11bda:	4618      	mov	r0, r3
   11bdc:	370c      	adds	r7, #12
   11bde:	46bd      	mov	sp, r7
   11be0:	bc80      	pop	{r7}
   11be2:	4770      	bx	lr

00011be4 <msg_alloc>:
{
   11be4:	b580      	push	{r7, lr}
   11be6:	b086      	sub	sp, #24
   11be8:	af00      	add	r7, sp, #0
   11bea:	6078      	str	r0, [r7, #4]
	struct  log_msg *msg = z_log_msg_std_alloc();
   11bec:	f7ff ff40 	bl	11a70 <z_log_msg_std_alloc>
   11bf0:	60f8      	str	r0, [r7, #12]
	int n = (int)nargs;
   11bf2:	687b      	ldr	r3, [r7, #4]
   11bf4:	613b      	str	r3, [r7, #16]
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   11bf6:	68fb      	ldr	r3, [r7, #12]
   11bf8:	2b00      	cmp	r3, #0
   11bfa:	d002      	beq.n	11c02 <msg_alloc+0x1e>
   11bfc:	687b      	ldr	r3, [r7, #4]
   11bfe:	2b03      	cmp	r3, #3
   11c00:	d801      	bhi.n	11c06 <msg_alloc+0x22>
		return msg;
   11c02:	68fb      	ldr	r3, [r7, #12]
   11c04:	e02d      	b.n	11c62 <msg_alloc+0x7e>
	msg->hdr.params.std.nargs = 0U;
   11c06:	68fa      	ldr	r2, [r7, #12]
   11c08:	7a53      	ldrb	r3, [r2, #9]
   11c0a:	f36f 1307 	bfc	r3, #4, #4
   11c0e:	7253      	strb	r3, [r2, #9]
	msg->hdr.params.generic.ext = 1;
   11c10:	68fa      	ldr	r2, [r7, #12]
   11c12:	7a13      	ldrb	r3, [r2, #8]
   11c14:	f043 0302 	orr.w	r3, r3, #2
   11c18:	7213      	strb	r3, [r2, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   11c1a:	693b      	ldr	r3, [r7, #16]
   11c1c:	3b02      	subs	r3, #2
   11c1e:	613b      	str	r3, [r7, #16]
	next = &msg->payload.ext.next;
   11c20:	68fb      	ldr	r3, [r7, #12]
   11c22:	3314      	adds	r3, #20
   11c24:	617b      	str	r3, [r7, #20]
	*next = NULL;
   11c26:	697b      	ldr	r3, [r7, #20]
   11c28:	2200      	movs	r2, #0
   11c2a:	601a      	str	r2, [r3, #0]
	while (n > 0) {
   11c2c:	e015      	b.n	11c5a <msg_alloc+0x76>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   11c2e:	f7f0 ff07 	bl	2a40 <log_msg_chunk_alloc>
   11c32:	60b8      	str	r0, [r7, #8]
		if (cont == NULL) {
   11c34:	68bb      	ldr	r3, [r7, #8]
   11c36:	2b00      	cmp	r3, #0
   11c38:	d104      	bne.n	11c44 <msg_alloc+0x60>
			msg_free(msg);
   11c3a:	68f8      	ldr	r0, [r7, #12]
   11c3c:	f7f0 ff44 	bl	2ac8 <msg_free>
			return NULL;
   11c40:	2300      	movs	r3, #0
   11c42:	e00e      	b.n	11c62 <msg_alloc+0x7e>
		*next = cont;
   11c44:	697b      	ldr	r3, [r7, #20]
   11c46:	68ba      	ldr	r2, [r7, #8]
   11c48:	601a      	str	r2, [r3, #0]
		cont->next = NULL;
   11c4a:	68bb      	ldr	r3, [r7, #8]
   11c4c:	2200      	movs	r2, #0
   11c4e:	601a      	str	r2, [r3, #0]
		next = &cont->next;
   11c50:	68bb      	ldr	r3, [r7, #8]
   11c52:	617b      	str	r3, [r7, #20]
		n -= ARGS_CONT_MSG;
   11c54:	693b      	ldr	r3, [r7, #16]
   11c56:	3b07      	subs	r3, #7
   11c58:	613b      	str	r3, [r7, #16]
	while (n > 0) {
   11c5a:	693b      	ldr	r3, [r7, #16]
   11c5c:	2b00      	cmp	r3, #0
   11c5e:	dce6      	bgt.n	11c2e <msg_alloc+0x4a>
	return msg;
   11c60:	68fb      	ldr	r3, [r7, #12]
}
   11c62:	4618      	mov	r0, r3
   11c64:	3718      	adds	r7, #24
   11c66:	46bd      	mov	sp, r7
   11c68:	bd80      	pop	{r7, pc}

00011c6a <copy_args_to_msg>:
{
   11c6a:	b580      	push	{r7, lr}
   11c6c:	b086      	sub	sp, #24
   11c6e:	af00      	add	r7, sp, #0
   11c70:	60f8      	str	r0, [r7, #12]
   11c72:	60b9      	str	r1, [r7, #8]
   11c74:	607a      	str	r2, [r7, #4]
	struct log_msg_cont *cont = msg->payload.ext.next;
   11c76:	68fb      	ldr	r3, [r7, #12]
   11c78:	695b      	ldr	r3, [r3, #20]
   11c7a:	617b      	str	r3, [r7, #20]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   11c7c:	687b      	ldr	r3, [r7, #4]
   11c7e:	2b03      	cmp	r3, #3
   11c80:	d90d      	bls.n	11c9e <copy_args_to_msg+0x34>
		(void)memcpy(msg->payload.ext.data.args, args,
   11c82:	68fb      	ldr	r3, [r7, #12]
   11c84:	3318      	adds	r3, #24
   11c86:	2208      	movs	r2, #8
   11c88:	68b9      	ldr	r1, [r7, #8]
   11c8a:	4618      	mov	r0, r3
   11c8c:	f001 fa50 	bl	13130 <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   11c90:	687b      	ldr	r3, [r7, #4]
   11c92:	3b02      	subs	r3, #2
   11c94:	607b      	str	r3, [r7, #4]
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   11c96:	68bb      	ldr	r3, [r7, #8]
   11c98:	3308      	adds	r3, #8
   11c9a:	60bb      	str	r3, [r7, #8]
   11c9c:	e024      	b.n	11ce8 <copy_args_to_msg+0x7e>
		(void)memcpy(msg->payload.single.args, args,
   11c9e:	68fb      	ldr	r3, [r7, #12]
   11ca0:	f103 0014 	add.w	r0, r3, #20
   11ca4:	687b      	ldr	r3, [r7, #4]
   11ca6:	009b      	lsls	r3, r3, #2
   11ca8:	461a      	mov	r2, r3
   11caa:	68b9      	ldr	r1, [r7, #8]
   11cac:	f001 fa40 	bl	13130 <memcpy>
		nargs  = 0U;
   11cb0:	2300      	movs	r3, #0
   11cb2:	607b      	str	r3, [r7, #4]
	while (nargs != 0U) {
   11cb4:	e018      	b.n	11ce8 <copy_args_to_msg+0x7e>
		uint32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   11cb6:	687b      	ldr	r3, [r7, #4]
   11cb8:	2b07      	cmp	r3, #7
   11cba:	bf28      	it	cs
   11cbc:	2307      	movcs	r3, #7
   11cbe:	613b      	str	r3, [r7, #16]
		(void)memcpy(cont->payload.args, args,
   11cc0:	697b      	ldr	r3, [r7, #20]
   11cc2:	1d18      	adds	r0, r3, #4
   11cc4:	693b      	ldr	r3, [r7, #16]
   11cc6:	009b      	lsls	r3, r3, #2
   11cc8:	461a      	mov	r2, r3
   11cca:	68b9      	ldr	r1, [r7, #8]
   11ccc:	f001 fa30 	bl	13130 <memcpy>
		nargs -= cpy_args;
   11cd0:	687a      	ldr	r2, [r7, #4]
   11cd2:	693b      	ldr	r3, [r7, #16]
   11cd4:	1ad3      	subs	r3, r2, r3
   11cd6:	607b      	str	r3, [r7, #4]
		args += cpy_args;
   11cd8:	693b      	ldr	r3, [r7, #16]
   11cda:	009b      	lsls	r3, r3, #2
   11cdc:	68ba      	ldr	r2, [r7, #8]
   11cde:	4413      	add	r3, r2
   11ce0:	60bb      	str	r3, [r7, #8]
		cont = cont->next;
   11ce2:	697b      	ldr	r3, [r7, #20]
   11ce4:	681b      	ldr	r3, [r3, #0]
   11ce6:	617b      	str	r3, [r7, #20]
	while (nargs != 0U) {
   11ce8:	687b      	ldr	r3, [r7, #4]
   11cea:	2b00      	cmp	r3, #0
   11cec:	d1e3      	bne.n	11cb6 <copy_args_to_msg+0x4c>
}
   11cee:	bf00      	nop
   11cf0:	bf00      	nop
   11cf2:	3718      	adds	r7, #24
   11cf4:	46bd      	mov	sp, r7
   11cf6:	bd80      	pop	{r7, pc}

00011cf8 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   11cf8:	b580      	push	{r7, lr}
   11cfa:	b08a      	sub	sp, #40	; 0x28
   11cfc:	af00      	add	r7, sp, #0
   11cfe:	60f8      	str	r0, [r7, #12]
   11d00:	60b9      	str	r1, [r7, #8]
   11d02:	607a      	str	r2, [r7, #4]
   11d04:	603b      	str	r3, [r7, #0]
	uint32_t available_len = msg->hdr.params.hexdump.length;
   11d06:	68fb      	ldr	r3, [r7, #12]
   11d08:	891b      	ldrh	r3, [r3, #8]
   11d0a:	f3c3 038d 	ubfx	r3, r3, #2, #14
   11d0e:	b29b      	uxth	r3, r3
   11d10:	617b      	str	r3, [r7, #20]
	struct log_msg_cont *cont = NULL;
   11d12:	2300      	movs	r3, #0
   11d14:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   11d16:	683a      	ldr	r2, [r7, #0]
   11d18:	697b      	ldr	r3, [r7, #20]
   11d1a:	429a      	cmp	r2, r3
   11d1c:	d303      	bcc.n	11d26 <log_msg_hexdump_data_op+0x2e>
		*length = 0;
   11d1e:	687b      	ldr	r3, [r7, #4]
   11d20:	2200      	movs	r2, #0
   11d22:	601a      	str	r2, [r3, #0]
		return;
   11d24:	e094      	b.n	11e50 <log_msg_hexdump_data_op+0x158>
	}

	if ((offset + *length) > available_len) {
   11d26:	687b      	ldr	r3, [r7, #4]
   11d28:	681a      	ldr	r2, [r3, #0]
   11d2a:	683b      	ldr	r3, [r7, #0]
   11d2c:	4413      	add	r3, r2
   11d2e:	697a      	ldr	r2, [r7, #20]
   11d30:	429a      	cmp	r2, r3
   11d32:	d204      	bcs.n	11d3e <log_msg_hexdump_data_op+0x46>
		*length = available_len - offset;
   11d34:	697a      	ldr	r2, [r7, #20]
   11d36:	683b      	ldr	r3, [r7, #0]
   11d38:	1ad2      	subs	r2, r2, r3
   11d3a:	687b      	ldr	r3, [r7, #4]
   11d3c:	601a      	str	r2, [r3, #0]
	}

	req_len = *length;
   11d3e:	687b      	ldr	r3, [r7, #4]
   11d40:	681b      	ldr	r3, [r3, #0]
   11d42:	61bb      	str	r3, [r7, #24]

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   11d44:	697b      	ldr	r3, [r7, #20]
   11d46:	2b0c      	cmp	r3, #12
   11d48:	d908      	bls.n	11d5c <log_msg_hexdump_data_op+0x64>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   11d4a:	2308      	movs	r3, #8
   11d4c:	61fb      	str	r3, [r7, #28]
		head_data = msg->payload.ext.data.bytes;
   11d4e:	68fb      	ldr	r3, [r7, #12]
   11d50:	3318      	adds	r3, #24
   11d52:	623b      	str	r3, [r7, #32]
		cont = msg->payload.ext.next;
   11d54:	68fb      	ldr	r3, [r7, #12]
   11d56:	695b      	ldr	r3, [r3, #20]
   11d58:	627b      	str	r3, [r7, #36]	; 0x24
   11d5a:	e004      	b.n	11d66 <log_msg_hexdump_data_op+0x6e>
	} else {
		head_data = msg->payload.single.bytes;
   11d5c:	68fb      	ldr	r3, [r7, #12]
   11d5e:	3314      	adds	r3, #20
   11d60:	623b      	str	r3, [r7, #32]
		chunk_len = available_len;
   11d62:	697b      	ldr	r3, [r7, #20]
   11d64:	61fb      	str	r3, [r7, #28]

	}

	if (offset < chunk_len) {
   11d66:	683a      	ldr	r2, [r7, #0]
   11d68:	69fb      	ldr	r3, [r7, #28]
   11d6a:	429a      	cmp	r2, r3
   11d6c:	d223      	bcs.n	11db6 <log_msg_hexdump_data_op+0xbe>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   11d6e:	69ba      	ldr	r2, [r7, #24]
   11d70:	69fb      	ldr	r3, [r7, #28]
   11d72:	4293      	cmp	r3, r2
   11d74:	bf28      	it	cs
   11d76:	4613      	movcs	r3, r2
   11d78:	613b      	str	r3, [r7, #16]

		if (put_op) {
   11d7a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
   11d7e:	2b00      	cmp	r3, #0
   11d80:	d008      	beq.n	11d94 <log_msg_hexdump_data_op+0x9c>
			(void)memcpy(&head_data[offset], data, cpy_len);
   11d82:	6a3a      	ldr	r2, [r7, #32]
   11d84:	683b      	ldr	r3, [r7, #0]
   11d86:	4413      	add	r3, r2
   11d88:	693a      	ldr	r2, [r7, #16]
   11d8a:	68b9      	ldr	r1, [r7, #8]
   11d8c:	4618      	mov	r0, r3
   11d8e:	f001 f9cf 	bl	13130 <memcpy>
   11d92:	e007      	b.n	11da4 <log_msg_hexdump_data_op+0xac>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
   11d94:	6a3a      	ldr	r2, [r7, #32]
   11d96:	683b      	ldr	r3, [r7, #0]
   11d98:	4413      	add	r3, r2
   11d9a:	693a      	ldr	r2, [r7, #16]
   11d9c:	4619      	mov	r1, r3
   11d9e:	68b8      	ldr	r0, [r7, #8]
   11da0:	f001 f9c6 	bl	13130 <memcpy>
		}

		req_len -= cpy_len;
   11da4:	69ba      	ldr	r2, [r7, #24]
   11da6:	693b      	ldr	r3, [r7, #16]
   11da8:	1ad3      	subs	r3, r2, r3
   11daa:	61bb      	str	r3, [r7, #24]
		data += cpy_len;
   11dac:	68ba      	ldr	r2, [r7, #8]
   11dae:	693b      	ldr	r3, [r7, #16]
   11db0:	4413      	add	r3, r2
   11db2:	60bb      	str	r3, [r7, #8]
   11db4:	e046      	b.n	11e44 <log_msg_hexdump_data_op+0x14c>
	} else {
		offset -= chunk_len;
   11db6:	683a      	ldr	r2, [r7, #0]
   11db8:	69fb      	ldr	r3, [r7, #28]
   11dba:	1ad3      	subs	r3, r2, r3
   11dbc:	603b      	str	r3, [r7, #0]
		chunk_len = HEXDUMP_BYTES_CONT_MSG;
   11dbe:	231c      	movs	r3, #28
   11dc0:	61fb      	str	r3, [r7, #28]
		if (cont == NULL) {
   11dc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11dc4:	2b00      	cmp	r3, #0
   11dc6:	d10a      	bne.n	11dde <log_msg_hexdump_data_op+0xe6>
			cont = msg->payload.ext.next;
   11dc8:	68fb      	ldr	r3, [r7, #12]
   11dca:	695b      	ldr	r3, [r3, #20]
   11dcc:	627b      	str	r3, [r7, #36]	; 0x24
		}

		while (offset >= chunk_len) {
   11dce:	e006      	b.n	11dde <log_msg_hexdump_data_op+0xe6>
			cont = cont->next;
   11dd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11dd2:	681b      	ldr	r3, [r3, #0]
   11dd4:	627b      	str	r3, [r7, #36]	; 0x24
			offset -= chunk_len;
   11dd6:	683a      	ldr	r2, [r7, #0]
   11dd8:	69fb      	ldr	r3, [r7, #28]
   11dda:	1ad3      	subs	r3, r2, r3
   11ddc:	603b      	str	r3, [r7, #0]
		while (offset >= chunk_len) {
   11dde:	683a      	ldr	r2, [r7, #0]
   11de0:	69fb      	ldr	r3, [r7, #28]
   11de2:	429a      	cmp	r2, r3
   11de4:	d2f4      	bcs.n	11dd0 <log_msg_hexdump_data_op+0xd8>
		}
	}

	while ((req_len > 0) && (cont != NULL)) {
   11de6:	e02d      	b.n	11e44 <log_msg_hexdump_data_op+0x14c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   11de8:	683b      	ldr	r3, [r7, #0]
   11dea:	f1c3 031c 	rsb	r3, r3, #28
   11dee:	61fb      	str	r3, [r7, #28]
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   11df0:	69ba      	ldr	r2, [r7, #24]
   11df2:	69fb      	ldr	r3, [r7, #28]
   11df4:	4293      	cmp	r3, r2
   11df6:	bf28      	it	cs
   11df8:	4613      	movcs	r3, r2
   11dfa:	613b      	str	r3, [r7, #16]

		if (put_op) {
   11dfc:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
   11e00:	2b00      	cmp	r3, #0
   11e02:	d009      	beq.n	11e18 <log_msg_hexdump_data_op+0x120>
			(void)memcpy(&cont->payload.bytes[offset],
   11e04:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11e06:	683b      	ldr	r3, [r7, #0]
   11e08:	4413      	add	r3, r2
   11e0a:	3304      	adds	r3, #4
   11e0c:	693a      	ldr	r2, [r7, #16]
   11e0e:	68b9      	ldr	r1, [r7, #8]
   11e10:	4618      	mov	r0, r3
   11e12:	f001 f98d 	bl	13130 <memcpy>
   11e16:	e008      	b.n	11e2a <log_msg_hexdump_data_op+0x132>
				     data, cpy_len);
		} else {
			(void)memcpy(data, &cont->payload.bytes[offset],
   11e18:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   11e1a:	683b      	ldr	r3, [r7, #0]
   11e1c:	4413      	add	r3, r2
   11e1e:	3304      	adds	r3, #4
   11e20:	693a      	ldr	r2, [r7, #16]
   11e22:	4619      	mov	r1, r3
   11e24:	68b8      	ldr	r0, [r7, #8]
   11e26:	f001 f983 	bl	13130 <memcpy>
				     cpy_len);
		}

		offset = 0;
   11e2a:	2300      	movs	r3, #0
   11e2c:	603b      	str	r3, [r7, #0]
		cont = cont->next;
   11e2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11e30:	681b      	ldr	r3, [r3, #0]
   11e32:	627b      	str	r3, [r7, #36]	; 0x24
		req_len -= cpy_len;
   11e34:	69ba      	ldr	r2, [r7, #24]
   11e36:	693b      	ldr	r3, [r7, #16]
   11e38:	1ad3      	subs	r3, r2, r3
   11e3a:	61bb      	str	r3, [r7, #24]
		data += cpy_len;
   11e3c:	68ba      	ldr	r2, [r7, #8]
   11e3e:	693b      	ldr	r3, [r7, #16]
   11e40:	4413      	add	r3, r2
   11e42:	60bb      	str	r3, [r7, #8]
	while ((req_len > 0) && (cont != NULL)) {
   11e44:	69bb      	ldr	r3, [r7, #24]
   11e46:	2b00      	cmp	r3, #0
   11e48:	d002      	beq.n	11e50 <log_msg_hexdump_data_op+0x158>
   11e4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11e4c:	2b00      	cmp	r3, #0
   11e4e:	d1cb      	bne.n	11de8 <log_msg_hexdump_data_op+0xf0>
	}
}
   11e50:	3728      	adds	r7, #40	; 0x28
   11e52:	46bd      	mov	sp, r7
   11e54:	bd80      	pop	{r7, pc}

00011e56 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   11e56:	b580      	push	{r7, lr}
   11e58:	b086      	sub	sp, #24
   11e5a:	af02      	add	r7, sp, #8
   11e5c:	60f8      	str	r0, [r7, #12]
   11e5e:	60b9      	str	r1, [r7, #8]
   11e60:	607a      	str	r2, [r7, #4]
   11e62:	603b      	str	r3, [r7, #0]
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   11e64:	2300      	movs	r3, #0
   11e66:	9300      	str	r3, [sp, #0]
   11e68:	683b      	ldr	r3, [r7, #0]
   11e6a:	687a      	ldr	r2, [r7, #4]
   11e6c:	68b9      	ldr	r1, [r7, #8]
   11e6e:	68f8      	ldr	r0, [r7, #12]
   11e70:	f7ff ff42 	bl	11cf8 <log_msg_hexdump_data_op>
}
   11e74:	bf00      	nop
   11e76:	3710      	adds	r7, #16
   11e78:	46bd      	mov	sp, r7
   11e7a:	bd80      	pop	{r7, pc}

00011e7c <atomic_add>:
{
   11e7c:	b480      	push	{r7}
   11e7e:	b083      	sub	sp, #12
   11e80:	af00      	add	r7, sp, #0
   11e82:	6078      	str	r0, [r7, #4]
   11e84:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   11e86:	683a      	ldr	r2, [r7, #0]
   11e88:	687b      	ldr	r3, [r7, #4]
   11e8a:	e8d3 1fef 	ldaex	r1, [r3]
   11e8e:	eb01 0002 	add.w	r0, r1, r2
   11e92:	e8c3 0fec 	stlex	ip, r0, [r3]
   11e96:	f1bc 0f00 	cmp.w	ip, #0
   11e9a:	d1f6      	bne.n	11e8a <atomic_add+0xe>
   11e9c:	460b      	mov	r3, r1
}
   11e9e:	4618      	mov	r0, r3
   11ea0:	370c      	adds	r7, #12
   11ea2:	46bd      	mov	sp, r7
   11ea4:	bc80      	pop	{r7}
   11ea6:	4770      	bx	lr

00011ea8 <atomic_inc>:
{
   11ea8:	b580      	push	{r7, lr}
   11eaa:	b082      	sub	sp, #8
   11eac:	af00      	add	r7, sp, #0
   11eae:	6078      	str	r0, [r7, #4]
	return atomic_add(target, 1);
   11eb0:	2101      	movs	r1, #1
   11eb2:	6878      	ldr	r0, [r7, #4]
   11eb4:	f7ff ffe2 	bl	11e7c <atomic_add>
   11eb8:	4603      	mov	r3, r0
}
   11eba:	4618      	mov	r0, r3
   11ebc:	3708      	adds	r7, #8
   11ebe:	46bd      	mov	sp, r7
   11ec0:	bd80      	pop	{r7, pc}

00011ec2 <log_msg_domain_id_get>:
{
   11ec2:	b480      	push	{r7}
   11ec4:	b083      	sub	sp, #12
   11ec6:	af00      	add	r7, sp, #0
   11ec8:	6078      	str	r0, [r7, #4]
	return msg->hdr.ids.domain_id;
   11eca:	687b      	ldr	r3, [r7, #4]
   11ecc:	7a9b      	ldrb	r3, [r3, #10]
   11ece:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   11ed2:	b2db      	uxtb	r3, r3
}
   11ed4:	4618      	mov	r0, r3
   11ed6:	370c      	adds	r7, #12
   11ed8:	46bd      	mov	sp, r7
   11eda:	bc80      	pop	{r7}
   11edc:	4770      	bx	lr

00011ede <log_msg_source_id_get>:
{
   11ede:	b480      	push	{r7}
   11ee0:	b083      	sub	sp, #12
   11ee2:	af00      	add	r7, sp, #0
   11ee4:	6078      	str	r0, [r7, #4]
	return msg->hdr.ids.source_id;
   11ee6:	687b      	ldr	r3, [r7, #4]
   11ee8:	895b      	ldrh	r3, [r3, #10]
   11eea:	f3c3 1389 	ubfx	r3, r3, #6, #10
   11eee:	b29b      	uxth	r3, r3
}
   11ef0:	4618      	mov	r0, r3
   11ef2:	370c      	adds	r7, #12
   11ef4:	46bd      	mov	sp, r7
   11ef6:	bc80      	pop	{r7}
   11ef8:	4770      	bx	lr

00011efa <log_msg_level_get>:
{
   11efa:	b480      	push	{r7}
   11efc:	b083      	sub	sp, #12
   11efe:	af00      	add	r7, sp, #0
   11f00:	6078      	str	r0, [r7, #4]
	return msg->hdr.ids.level;
   11f02:	687b      	ldr	r3, [r7, #4]
   11f04:	7a9b      	ldrb	r3, [r3, #10]
   11f06:	f3c3 0302 	ubfx	r3, r3, #0, #3
   11f0a:	b2db      	uxtb	r3, r3
}
   11f0c:	4618      	mov	r0, r3
   11f0e:	370c      	adds	r7, #12
   11f10:	46bd      	mov	sp, r7
   11f12:	bc80      	pop	{r7}
   11f14:	4770      	bx	lr

00011f16 <log_msg_timestamp_get>:
{
   11f16:	b480      	push	{r7}
   11f18:	b083      	sub	sp, #12
   11f1a:	af00      	add	r7, sp, #0
   11f1c:	6078      	str	r0, [r7, #4]
	return msg->hdr.timestamp;
   11f1e:	687b      	ldr	r3, [r7, #4]
   11f20:	68db      	ldr	r3, [r3, #12]
}
   11f22:	4618      	mov	r0, r3
   11f24:	370c      	adds	r7, #12
   11f26:	46bd      	mov	sp, r7
   11f28:	bc80      	pop	{r7}
   11f2a:	4770      	bx	lr

00011f2c <log_msg_is_std>:
{
   11f2c:	b480      	push	{r7}
   11f2e:	b083      	sub	sp, #12
   11f30:	af00      	add	r7, sp, #0
   11f32:	6078      	str	r0, [r7, #4]
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   11f34:	687b      	ldr	r3, [r7, #4]
   11f36:	7a1b      	ldrb	r3, [r3, #8]
   11f38:	f003 0301 	and.w	r3, r3, #1
   11f3c:	b2db      	uxtb	r3, r3
   11f3e:	2b00      	cmp	r3, #0
   11f40:	bf0c      	ite	eq
   11f42:	2301      	moveq	r3, #1
   11f44:	2300      	movne	r3, #0
   11f46:	b2db      	uxtb	r3, r3
}
   11f48:	4618      	mov	r0, r3
   11f4a:	370c      	adds	r7, #12
   11f4c:	46bd      	mov	sp, r7
   11f4e:	bc80      	pop	{r7}
   11f50:	4770      	bx	lr

00011f52 <isprint>:
{
   11f52:	b480      	push	{r7}
   11f54:	b083      	sub	sp, #12
   11f56:	af00      	add	r7, sp, #0
   11f58:	6078      	str	r0, [r7, #4]
	return (int)((((unsigned)c) >= ' ') &&
   11f5a:	687b      	ldr	r3, [r7, #4]
   11f5c:	2b1f      	cmp	r3, #31
   11f5e:	d904      	bls.n	11f6a <isprint+0x18>
			(((unsigned)c) <= (unsigned)'~'));
   11f60:	687b      	ldr	r3, [r7, #4]
	return (int)((((unsigned)c) >= ' ') &&
   11f62:	2b7e      	cmp	r3, #126	; 0x7e
   11f64:	d801      	bhi.n	11f6a <isprint+0x18>
   11f66:	2301      	movs	r3, #1
   11f68:	e000      	b.n	11f6c <isprint+0x1a>
   11f6a:	2300      	movs	r3, #0
}
   11f6c:	4618      	mov	r0, r3
   11f6e:	370c      	adds	r7, #12
   11f70:	46bd      	mov	sp, r7
   11f72:	bc80      	pop	{r7}
   11f74:	4770      	bx	lr

00011f76 <buffer_write>:
{
   11f76:	b580      	push	{r7, lr}
   11f78:	b086      	sub	sp, #24
   11f7a:	af00      	add	r7, sp, #0
   11f7c:	60f8      	str	r0, [r7, #12]
   11f7e:	60b9      	str	r1, [r7, #8]
   11f80:	607a      	str	r2, [r7, #4]
   11f82:	603b      	str	r3, [r7, #0]
		processed = outf(buf, len, ctx);
   11f84:	68fb      	ldr	r3, [r7, #12]
   11f86:	683a      	ldr	r2, [r7, #0]
   11f88:	6879      	ldr	r1, [r7, #4]
   11f8a:	68b8      	ldr	r0, [r7, #8]
   11f8c:	4798      	blx	r3
   11f8e:	6178      	str	r0, [r7, #20]
		len -= processed;
   11f90:	697b      	ldr	r3, [r7, #20]
   11f92:	687a      	ldr	r2, [r7, #4]
   11f94:	1ad3      	subs	r3, r2, r3
   11f96:	607b      	str	r3, [r7, #4]
		buf += processed;
   11f98:	697b      	ldr	r3, [r7, #20]
   11f9a:	68ba      	ldr	r2, [r7, #8]
   11f9c:	4413      	add	r3, r2
   11f9e:	60bb      	str	r3, [r7, #8]
	} while (len != 0);
   11fa0:	687b      	ldr	r3, [r7, #4]
   11fa2:	2b00      	cmp	r3, #0
   11fa4:	d1ee      	bne.n	11f84 <buffer_write+0xe>
}
   11fa6:	bf00      	nop
   11fa8:	bf00      	nop
   11faa:	3718      	adds	r7, #24
   11fac:	46bd      	mov	sp, r7
   11fae:	bd80      	pop	{r7, pc}

00011fb0 <log_output_flush>:
{
   11fb0:	b580      	push	{r7, lr}
   11fb2:	b082      	sub	sp, #8
   11fb4:	af00      	add	r7, sp, #0
   11fb6:	6078      	str	r0, [r7, #4]
	buffer_write(log_output->func, log_output->buf,
   11fb8:	687b      	ldr	r3, [r7, #4]
   11fba:	6818      	ldr	r0, [r3, #0]
   11fbc:	687b      	ldr	r3, [r7, #4]
   11fbe:	6899      	ldr	r1, [r3, #8]
		     log_output->control_block->offset,
   11fc0:	687b      	ldr	r3, [r7, #4]
   11fc2:	685b      	ldr	r3, [r3, #4]
   11fc4:	681b      	ldr	r3, [r3, #0]
	buffer_write(log_output->func, log_output->buf,
   11fc6:	461a      	mov	r2, r3
		     log_output->control_block->ctx);
   11fc8:	687b      	ldr	r3, [r7, #4]
   11fca:	685b      	ldr	r3, [r3, #4]
	buffer_write(log_output->func, log_output->buf,
   11fcc:	685b      	ldr	r3, [r3, #4]
   11fce:	f7ff ffd2 	bl	11f76 <buffer_write>
	log_output->control_block->offset = 0;
   11fd2:	687b      	ldr	r3, [r7, #4]
   11fd4:	685b      	ldr	r3, [r3, #4]
   11fd6:	2200      	movs	r2, #0
   11fd8:	601a      	str	r2, [r3, #0]
}
   11fda:	bf00      	nop
   11fdc:	3708      	adds	r7, #8
   11fde:	46bd      	mov	sp, r7
   11fe0:	bd80      	pop	{r7, pc}

00011fe2 <color_prefix>:
{
   11fe2:	b580      	push	{r7, lr}
   11fe4:	b084      	sub	sp, #16
   11fe6:	af00      	add	r7, sp, #0
   11fe8:	60f8      	str	r0, [r7, #12]
   11fea:	460b      	mov	r3, r1
   11fec:	607a      	str	r2, [r7, #4]
   11fee:	72fb      	strb	r3, [r7, #11]
	color_print(log_output, color, true, level);
   11ff0:	7af9      	ldrb	r1, [r7, #11]
   11ff2:	687b      	ldr	r3, [r7, #4]
   11ff4:	2201      	movs	r2, #1
   11ff6:	68f8      	ldr	r0, [r7, #12]
   11ff8:	f7f0 ff10 	bl	2e1c <color_print>
}
   11ffc:	bf00      	nop
   11ffe:	3710      	adds	r7, #16
   12000:	46bd      	mov	sp, r7
   12002:	bd80      	pop	{r7, pc}

00012004 <color_postfix>:
{
   12004:	b580      	push	{r7, lr}
   12006:	b084      	sub	sp, #16
   12008:	af00      	add	r7, sp, #0
   1200a:	60f8      	str	r0, [r7, #12]
   1200c:	460b      	mov	r3, r1
   1200e:	607a      	str	r2, [r7, #4]
   12010:	72fb      	strb	r3, [r7, #11]
	color_print(log_output, color, false, level);
   12012:	7af9      	ldrb	r1, [r7, #11]
   12014:	687b      	ldr	r3, [r7, #4]
   12016:	2200      	movs	r2, #0
   12018:	68f8      	ldr	r0, [r7, #12]
   1201a:	f7f0 feff 	bl	2e1c <color_print>
}
   1201e:	bf00      	nop
   12020:	3710      	adds	r7, #16
   12022:	46bd      	mov	sp, r7
   12024:	bd80      	pop	{r7, pc}

00012026 <prefix_print>:
{
   12026:	b590      	push	{r4, r7, lr}
   12028:	b089      	sub	sp, #36	; 0x24
   1202a:	af02      	add	r7, sp, #8
   1202c:	60f8      	str	r0, [r7, #12]
   1202e:	60b9      	str	r1, [r7, #8]
   12030:	603b      	str	r3, [r7, #0]
   12032:	4613      	mov	r3, r2
   12034:	71fb      	strb	r3, [r7, #7]
	uint32_t length = 0U;
   12036:	2300      	movs	r3, #0
   12038:	613b      	str	r3, [r7, #16]
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   1203a:	68bb      	ldr	r3, [r7, #8]
   1203c:	f003 0302 	and.w	r3, r3, #2
   12040:	2b00      	cmp	r3, #0
   12042:	bf14      	ite	ne
   12044:	2301      	movne	r3, #1
   12046:	2300      	moveq	r3, #0
   12048:	75fb      	strb	r3, [r7, #23]
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   1204a:	68bb      	ldr	r3, [r7, #8]
   1204c:	f003 0301 	and.w	r3, r3, #1
   12050:	2b00      	cmp	r3, #0
   12052:	bf14      	ite	ne
   12054:	2301      	movne	r3, #1
   12056:	2300      	moveq	r3, #0
   12058:	75bb      	strb	r3, [r7, #22]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   1205a:	68bb      	ldr	r3, [r7, #8]
   1205c:	f003 0308 	and.w	r3, r3, #8
   12060:	2b00      	cmp	r3, #0
   12062:	bf14      	ite	ne
   12064:	2301      	movne	r3, #1
   12066:	2300      	moveq	r3, #0
   12068:	757b      	strb	r3, [r7, #21]
	if (stamp) {
   1206a:	7dfb      	ldrb	r3, [r7, #23]
   1206c:	2b00      	cmp	r3, #0
   1206e:	d009      	beq.n	12084 <prefix_print+0x5e>
		length += timestamp_print(log_output, flags, timestamp);
   12070:	683a      	ldr	r2, [r7, #0]
   12072:	68b9      	ldr	r1, [r7, #8]
   12074:	68f8      	ldr	r0, [r7, #12]
   12076:	f7f0 fe3d 	bl	2cf4 <timestamp_print>
   1207a:	4603      	mov	r3, r0
   1207c:	461a      	mov	r2, r3
   1207e:	693b      	ldr	r3, [r7, #16]
   12080:	4413      	add	r3, r2
   12082:	613b      	str	r3, [r7, #16]
		color_prefix(log_output, colors_on, level);
   12084:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
   12088:	7dbb      	ldrb	r3, [r7, #22]
   1208a:	4619      	mov	r1, r3
   1208c:	68f8      	ldr	r0, [r7, #12]
   1208e:	f7ff ffa8 	bl	11fe2 <color_prefix>
	length += ids_print(log_output, level_on, func_on,
   12092:	f897 402c 	ldrb.w	r4, [r7, #44]	; 0x2c
   12096:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
   12098:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
   1209c:	79f8      	ldrb	r0, [r7, #7]
   1209e:	7d79      	ldrb	r1, [r7, #21]
   120a0:	9201      	str	r2, [sp, #4]
   120a2:	9300      	str	r3, [sp, #0]
   120a4:	4623      	mov	r3, r4
   120a6:	4602      	mov	r2, r0
   120a8:	68f8      	ldr	r0, [r7, #12]
   120aa:	f7f0 fee3 	bl	2e74 <ids_print>
   120ae:	4603      	mov	r3, r0
   120b0:	461a      	mov	r2, r3
   120b2:	693b      	ldr	r3, [r7, #16]
   120b4:	4413      	add	r3, r2
   120b6:	613b      	str	r3, [r7, #16]
	return length;
   120b8:	693b      	ldr	r3, [r7, #16]
}
   120ba:	4618      	mov	r0, r3
   120bc:	371c      	adds	r7, #28
   120be:	46bd      	mov	sp, r7
   120c0:	bd90      	pop	{r4, r7, pc}

000120c2 <postfix_print>:
{
   120c2:	b580      	push	{r7, lr}
   120c4:	b084      	sub	sp, #16
   120c6:	af00      	add	r7, sp, #0
   120c8:	60f8      	str	r0, [r7, #12]
   120ca:	60b9      	str	r1, [r7, #8]
   120cc:	4613      	mov	r3, r2
   120ce:	71fb      	strb	r3, [r7, #7]
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
   120d0:	68bb      	ldr	r3, [r7, #8]
   120d2:	f003 0301 	and.w	r3, r3, #1
   120d6:	2b00      	cmp	r3, #0
   120d8:	bf14      	ite	ne
   120da:	2301      	movne	r3, #1
   120dc:	2300      	moveq	r3, #0
   120de:	b2db      	uxtb	r3, r3
   120e0:	79fa      	ldrb	r2, [r7, #7]
   120e2:	4619      	mov	r1, r3
   120e4:	68f8      	ldr	r0, [r7, #12]
   120e6:	f7ff ff8d 	bl	12004 <color_postfix>
	newline_print(log_output, flags);
   120ea:	68b9      	ldr	r1, [r7, #8]
   120ec:	68f8      	ldr	r0, [r7, #12]
   120ee:	f7f0 ff05 	bl	2efc <newline_print>
}
   120f2:	bf00      	nop
   120f4:	3710      	adds	r7, #16
   120f6:	46bd      	mov	sp, r7
   120f8:	bd80      	pop	{r7, pc}

000120fa <log_output_msg_process>:
{
   120fa:	b580      	push	{r7, lr}
   120fc:	b08e      	sub	sp, #56	; 0x38
   120fe:	af04      	add	r7, sp, #16
   12100:	60f8      	str	r0, [r7, #12]
   12102:	60b9      	str	r1, [r7, #8]
   12104:	607a      	str	r2, [r7, #4]
	bool std_msg = log_msg_is_std(msg);
   12106:	68b8      	ldr	r0, [r7, #8]
   12108:	f7ff ff10 	bl	11f2c <log_msg_is_std>
   1210c:	4603      	mov	r3, r0
   1210e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	uint32_t timestamp = log_msg_timestamp_get(msg);
   12112:	68b8      	ldr	r0, [r7, #8]
   12114:	f7ff feff 	bl	11f16 <log_msg_timestamp_get>
   12118:	6238      	str	r0, [r7, #32]
	uint8_t level = (uint8_t)log_msg_level_get(msg);
   1211a:	68b8      	ldr	r0, [r7, #8]
   1211c:	f7ff feed 	bl	11efa <log_msg_level_get>
   12120:	4603      	mov	r3, r0
   12122:	77fb      	strb	r3, [r7, #31]
	uint8_t domain_id = (uint8_t)log_msg_domain_id_get(msg);
   12124:	68b8      	ldr	r0, [r7, #8]
   12126:	f7ff fecc 	bl	11ec2 <log_msg_domain_id_get>
   1212a:	4603      	mov	r3, r0
   1212c:	77bb      	strb	r3, [r7, #30]
	uint16_t source_id = (uint16_t)log_msg_source_id_get(msg);
   1212e:	68b8      	ldr	r0, [r7, #8]
   12130:	f7ff fed5 	bl	11ede <log_msg_source_id_get>
   12134:	4603      	mov	r3, r0
   12136:	83bb      	strh	r3, [r7, #28]
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
   12138:	7ffb      	ldrb	r3, [r7, #31]
   1213a:	2b00      	cmp	r3, #0
   1213c:	bf0c      	ite	eq
   1213e:	2301      	moveq	r3, #1
   12140:	2300      	movne	r3, #0
   12142:	76fb      	strb	r3, [r7, #27]
			0 : prefix_print(log_output, flags, std_msg, timestamp,
   12144:	7efb      	ldrb	r3, [r7, #27]
   12146:	2b00      	cmp	r3, #0
   12148:	d10e      	bne.n	12168 <log_output_msg_process+0x6e>
   1214a:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
   1214e:	8bbb      	ldrh	r3, [r7, #28]
   12150:	9302      	str	r3, [sp, #8]
   12152:	7fbb      	ldrb	r3, [r7, #30]
   12154:	9301      	str	r3, [sp, #4]
   12156:	7ffb      	ldrb	r3, [r7, #31]
   12158:	9300      	str	r3, [sp, #0]
   1215a:	6a3b      	ldr	r3, [r7, #32]
   1215c:	6879      	ldr	r1, [r7, #4]
   1215e:	68f8      	ldr	r0, [r7, #12]
   12160:	f7ff ff61 	bl	12026 <prefix_print>
   12164:	4603      	mov	r3, r0
   12166:	e000      	b.n	1216a <log_output_msg_process+0x70>
   12168:	2300      	movs	r3, #0
	prefix_offset = raw_string ?
   1216a:	617b      	str	r3, [r7, #20]
	if (log_msg_is_std(msg)) {
   1216c:	68b8      	ldr	r0, [r7, #8]
   1216e:	f7ff fedd 	bl	11f2c <log_msg_is_std>
   12172:	4603      	mov	r3, r0
   12174:	2b00      	cmp	r3, #0
   12176:	d004      	beq.n	12182 <log_output_msg_process+0x88>
		std_print(msg, log_output);
   12178:	68f9      	ldr	r1, [r7, #12]
   1217a:	68b8      	ldr	r0, [r7, #8]
   1217c:	f7f0 fee0 	bl	2f40 <std_print>
   12180:	e00d      	b.n	1219e <log_output_msg_process+0xa4>
	} else if (raw_string) {
   12182:	7efb      	ldrb	r3, [r7, #27]
   12184:	2b00      	cmp	r3, #0
   12186:	d004      	beq.n	12192 <log_output_msg_process+0x98>
		raw_string_print(msg, log_output);
   12188:	68f9      	ldr	r1, [r7, #12]
   1218a:	68b8      	ldr	r0, [r7, #8]
   1218c:	f7f1 fa5a 	bl	3644 <raw_string_print>
   12190:	e005      	b.n	1219e <log_output_msg_process+0xa4>
		hexdump_print(msg, log_output, prefix_offset, flags);
   12192:	687b      	ldr	r3, [r7, #4]
   12194:	697a      	ldr	r2, [r7, #20]
   12196:	68f9      	ldr	r1, [r7, #12]
   12198:	68b8      	ldr	r0, [r7, #8]
   1219a:	f7f1 fa1f 	bl	35dc <hexdump_print>
	if (!raw_string) {
   1219e:	7efb      	ldrb	r3, [r7, #27]
   121a0:	f083 0301 	eor.w	r3, r3, #1
   121a4:	b2db      	uxtb	r3, r3
   121a6:	2b00      	cmp	r3, #0
   121a8:	d005      	beq.n	121b6 <log_output_msg_process+0xbc>
		postfix_print(log_output, flags, level);
   121aa:	7ffb      	ldrb	r3, [r7, #31]
   121ac:	461a      	mov	r2, r3
   121ae:	6879      	ldr	r1, [r7, #4]
   121b0:	68f8      	ldr	r0, [r7, #12]
   121b2:	f7ff ff86 	bl	120c2 <postfix_print>
	log_output_flush(log_output);
   121b6:	68f8      	ldr	r0, [r7, #12]
   121b8:	f7ff fefa 	bl	11fb0 <log_output_flush>
}
   121bc:	3728      	adds	r7, #40	; 0x28
   121be:	46bd      	mov	sp, r7
   121c0:	bd80      	pop	{r7, pc}

000121c2 <log_backend_std_put>:
 * @param msg		Log message.
 */
static inline void
log_backend_std_put(const struct log_output *const log_output, uint32_t flags,
		    struct log_msg *msg)
{
   121c2:	b580      	push	{r7, lr}
   121c4:	b084      	sub	sp, #16
   121c6:	af00      	add	r7, sp, #0
   121c8:	60f8      	str	r0, [r7, #12]
   121ca:	60b9      	str	r1, [r7, #8]
   121cc:	607a      	str	r2, [r7, #4]
	log_msg_get(msg);
   121ce:	6878      	ldr	r0, [r7, #4]
   121d0:	f7ff fc7c 	bl	11acc <log_msg_get>

	flags |= (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
   121d4:	68bb      	ldr	r3, [r7, #8]
   121d6:	f043 030a 	orr.w	r3, r3, #10
   121da:	60bb      	str	r3, [r7, #8]

	if (IS_ENABLED(CONFIG_LOG_BACKEND_SHOW_COLOR)) {
		flags |= LOG_OUTPUT_FLAG_COLORS;
   121dc:	68bb      	ldr	r3, [r7, #8]
   121de:	f043 0301 	orr.w	r3, r3, #1
   121e2:	60bb      	str	r3, [r7, #8]
	}

	if (IS_ENABLED(CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP)) {
		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
   121e4:	68bb      	ldr	r3, [r7, #8]
   121e6:	f043 0304 	orr.w	r3, r3, #4
   121ea:	60bb      	str	r3, [r7, #8]
	}

	log_output_msg_process(log_output, msg, flags);
   121ec:	68ba      	ldr	r2, [r7, #8]
   121ee:	6879      	ldr	r1, [r7, #4]
   121f0:	68f8      	ldr	r0, [r7, #12]
   121f2:	f7ff ff82 	bl	120fa <log_output_msg_process>

	log_msg_put(msg);
   121f6:	6878      	ldr	r0, [r7, #4]
   121f8:	f7ff fc75 	bl	11ae6 <log_msg_put>
}
   121fc:	bf00      	nop
   121fe:	3710      	adds	r7, #16
   12200:	46bd      	mov	sp, r7
   12202:	bd80      	pop	{r7, pc}

00012204 <log_backend_std_panic>:
 *
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
   12204:	b580      	push	{r7, lr}
   12206:	b082      	sub	sp, #8
   12208:	af00      	add	r7, sp, #0
   1220a:	6078      	str	r0, [r7, #4]
	log_output_flush(log_output);
   1220c:	6878      	ldr	r0, [r7, #4]
   1220e:	f7ff fecf 	bl	11fb0 <log_output_flush>
}
   12212:	bf00      	nop
   12214:	3708      	adds	r7, #8
   12216:	46bd      	mov	sp, r7
   12218:	bd80      	pop	{r7, pc}

0001221a <log_backend_std_dropped>:
 * @param log_output	Log output instance.
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, uint32_t cnt)
{
   1221a:	b580      	push	{r7, lr}
   1221c:	b082      	sub	sp, #8
   1221e:	af00      	add	r7, sp, #0
   12220:	6078      	str	r0, [r7, #4]
   12222:	6039      	str	r1, [r7, #0]
	log_output_dropped_process(log_output, cnt);
   12224:	6839      	ldr	r1, [r7, #0]
   12226:	6878      	ldr	r0, [r7, #4]
   12228:	f7f1 fa60 	bl	36ec <log_output_dropped_process>
}
   1222c:	bf00      	nop
   1222e:	3708      	adds	r7, #8
   12230:	46bd      	mov	sp, r7
   12232:	bd80      	pop	{r7, pc}

00012234 <device_get_binding>:
{
   12234:	b580      	push	{r7, lr}
   12236:	b082      	sub	sp, #8
   12238:	af00      	add	r7, sp, #0
   1223a:	6078      	str	r0, [r7, #4]
	return z_impl_device_get_binding(name);
   1223c:	6878      	ldr	r0, [r7, #4]
   1223e:	f7f8 fc57 	bl	aaf0 <z_impl_device_get_binding>
   12242:	4603      	mov	r3, r0
}
   12244:	4618      	mov	r0, r3
   12246:	3708      	adds	r7, #8
   12248:	46bd      	mov	sp, r7
   1224a:	bd80      	pop	{r7, pc}

0001224c <z_impl_uart_poll_out>:
{
   1224c:	b580      	push	{r7, lr}
   1224e:	b084      	sub	sp, #16
   12250:	af00      	add	r7, sp, #0
   12252:	6078      	str	r0, [r7, #4]
   12254:	460b      	mov	r3, r1
   12256:	70fb      	strb	r3, [r7, #3]
	const struct uart_driver_api *api =
   12258:	687b      	ldr	r3, [r7, #4]
   1225a:	689b      	ldr	r3, [r3, #8]
   1225c:	60fb      	str	r3, [r7, #12]
	api->poll_out(dev, out_char);
   1225e:	68fb      	ldr	r3, [r7, #12]
   12260:	69db      	ldr	r3, [r3, #28]
   12262:	78fa      	ldrb	r2, [r7, #3]
   12264:	4611      	mov	r1, r2
   12266:	6878      	ldr	r0, [r7, #4]
   12268:	4798      	blx	r3
}
   1226a:	bf00      	nop
   1226c:	3710      	adds	r7, #16
   1226e:	46bd      	mov	sp, r7
   12270:	bd80      	pop	{r7, pc}

00012272 <uart_poll_out>:
{
   12272:	b580      	push	{r7, lr}
   12274:	b082      	sub	sp, #8
   12276:	af00      	add	r7, sp, #0
   12278:	6078      	str	r0, [r7, #4]
   1227a:	460b      	mov	r3, r1
   1227c:	70fb      	strb	r3, [r7, #3]
	z_impl_uart_poll_out(dev, out_char);
   1227e:	78fb      	ldrb	r3, [r7, #3]
   12280:	4619      	mov	r1, r3
   12282:	6878      	ldr	r0, [r7, #4]
   12284:	f7ff ffe2 	bl	1224c <z_impl_uart_poll_out>
}
   12288:	bf00      	nop
   1228a:	3708      	adds	r7, #8
   1228c:	46bd      	mov	sp, r7
   1228e:	bd80      	pop	{r7, pc}

00012290 <k_cpu_idle>:
 * unconditionally.
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
   12290:	b580      	push	{r7, lr}
   12292:	af00      	add	r7, sp, #0
	arch_cpu_idle();
   12294:	f7f2 fcc2 	bl	4c1c <arch_cpu_idle>
}
   12298:	bf00      	nop
   1229a:	bd80      	pop	{r7, pc}

0001229c <device_get_binding>:
{
   1229c:	b580      	push	{r7, lr}
   1229e:	b082      	sub	sp, #8
   122a0:	af00      	add	r7, sp, #0
   122a2:	6078      	str	r0, [r7, #4]
	return z_impl_device_get_binding(name);
   122a4:	6878      	ldr	r0, [r7, #4]
   122a6:	f7f8 fc23 	bl	aaf0 <z_impl_device_get_binding>
   122aa:	4603      	mov	r3, r0
}
   122ac:	4618      	mov	r0, r3
   122ae:	3708      	adds	r7, #8
   122b0:	46bd      	mov	sp, r7
   122b2:	bd80      	pop	{r7, pc}

000122b4 <z_impl_uart_poll_out>:
{
   122b4:	b580      	push	{r7, lr}
   122b6:	b084      	sub	sp, #16
   122b8:	af00      	add	r7, sp, #0
   122ba:	6078      	str	r0, [r7, #4]
   122bc:	460b      	mov	r3, r1
   122be:	70fb      	strb	r3, [r7, #3]
	const struct uart_driver_api *api =
   122c0:	687b      	ldr	r3, [r7, #4]
   122c2:	689b      	ldr	r3, [r3, #8]
   122c4:	60fb      	str	r3, [r7, #12]
	api->poll_out(dev, out_char);
   122c6:	68fb      	ldr	r3, [r7, #12]
   122c8:	69db      	ldr	r3, [r3, #28]
   122ca:	78fa      	ldrb	r2, [r7, #3]
   122cc:	4611      	mov	r1, r2
   122ce:	6878      	ldr	r0, [r7, #4]
   122d0:	4798      	blx	r3
}
   122d2:	bf00      	nop
   122d4:	3710      	adds	r7, #16
   122d6:	46bd      	mov	sp, r7
   122d8:	bd80      	pop	{r7, pc}

000122da <uart_poll_out>:
{
   122da:	b580      	push	{r7, lr}
   122dc:	b082      	sub	sp, #8
   122de:	af00      	add	r7, sp, #0
   122e0:	6078      	str	r0, [r7, #4]
   122e2:	460b      	mov	r3, r1
   122e4:	70fb      	strb	r3, [r7, #3]
	z_impl_uart_poll_out(dev, out_char);
   122e6:	78fb      	ldrb	r3, [r7, #3]
   122e8:	4619      	mov	r1, r3
   122ea:	6878      	ldr	r0, [r7, #4]
   122ec:	f7ff ffe2 	bl	122b4 <z_impl_uart_poll_out>
}
   122f0:	bf00      	nop
   122f2:	3708      	adds	r7, #8
   122f4:	46bd      	mov	sp, r7
   122f6:	bd80      	pop	{r7, pc}

000122f8 <atomic_set>:
{
   122f8:	b480      	push	{r7}
   122fa:	b083      	sub	sp, #12
   122fc:	af00      	add	r7, sp, #0
   122fe:	6078      	str	r0, [r7, #4]
   12300:	6039      	str	r1, [r7, #0]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   12302:	683a      	ldr	r2, [r7, #0]
   12304:	687b      	ldr	r3, [r7, #4]
   12306:	e8d3 1fef 	ldaex	r1, [r3]
   1230a:	e8c3 2fe0 	stlex	r0, r2, [r3]
   1230e:	2800      	cmp	r0, #0
   12310:	d1f9      	bne.n	12306 <atomic_set+0xe>
   12312:	460b      	mov	r3, r1
}
   12314:	4618      	mov	r0, r3
   12316:	370c      	adds	r7, #12
   12318:	46bd      	mov	sp, r7
   1231a:	bc80      	pop	{r7}
   1231c:	4770      	bx	lr

0001231e <atomic_and>:
 *
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
   1231e:	b480      	push	{r7}
   12320:	b083      	sub	sp, #12
   12322:	af00      	add	r7, sp, #0
   12324:	6078      	str	r0, [r7, #4]
   12326:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   12328:	683a      	ldr	r2, [r7, #0]
   1232a:	687b      	ldr	r3, [r7, #4]
   1232c:	e8d3 1fef 	ldaex	r1, [r3]
   12330:	ea01 0002 	and.w	r0, r1, r2
   12334:	e8c3 0fec 	stlex	ip, r0, [r3]
   12338:	f1bc 0f00 	cmp.w	ip, #0
   1233c:	d1f6      	bne.n	1232c <atomic_and+0xe>
   1233e:	460b      	mov	r3, r1
}
   12340:	4618      	mov	r0, r3
   12342:	370c      	adds	r7, #12
   12344:	46bd      	mov	sp, r7
   12346:	bc80      	pop	{r7}
   12348:	4770      	bx	lr

0001234a <nrf_event_readback>:
#endif

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
   1234a:	b480      	push	{r7}
   1234c:	b083      	sub	sp, #12
   1234e:	af00      	add	r7, sp, #0
   12350:	6078      	str	r0, [r7, #4]
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   12352:	687b      	ldr	r3, [r7, #4]
   12354:	681b      	ldr	r3, [r3, #0]
#else
    (void)p_event_reg;
#endif
}
   12356:	bf00      	nop
   12358:	370c      	adds	r7, #12
   1235a:	46bd      	mov	sp, r7
   1235c:	bc80      	pop	{r7}
   1235e:	4770      	bx	lr

00012360 <_is_user_context>:
{
   12360:	b480      	push	{r7}
   12362:	af00      	add	r7, sp, #0
	return false;
   12364:	2300      	movs	r3, #0
}
   12366:	4618      	mov	r0, r3
   12368:	46bd      	mov	sp, r7
   1236a:	bc80      	pop	{r7}
   1236c:	4770      	bx	lr

0001236e <k_ms_to_ticks_ceil64>:
{
   1236e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   12372:	b08c      	sub	sp, #48	; 0x30
   12374:	af00      	add	r7, sp, #0
   12376:	e9c7 0100 	strd	r0, r1, [r7]
   1237a:	e9d7 2300 	ldrd	r2, r3, [r7]
   1237e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   12382:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   12386:	627b      	str	r3, [r7, #36]	; 0x24
   12388:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   1238c:	623b      	str	r3, [r7, #32]
   1238e:	2301      	movs	r3, #1
   12390:	77fb      	strb	r3, [r7, #31]
   12392:	2300      	movs	r3, #0
   12394:	77bb      	strb	r3, [r7, #30]
   12396:	2301      	movs	r3, #1
   12398:	777b      	strb	r3, [r7, #29]
   1239a:	2300      	movs	r3, #0
   1239c:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1239e:	7ffb      	ldrb	r3, [r7, #31]
   123a0:	2b00      	cmp	r3, #0
   123a2:	d00f      	beq.n	123c4 <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   123a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   123a6:	6a3b      	ldr	r3, [r7, #32]
   123a8:	429a      	cmp	r2, r3
   123aa:	d20b      	bcs.n	123c4 <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   123ac:	6a3b      	ldr	r3, [r7, #32]
   123ae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   123b0:	fbb3 f2f2 	udiv	r2, r3, r2
   123b4:	6a79      	ldr	r1, [r7, #36]	; 0x24
   123b6:	fb01 f202 	mul.w	r2, r1, r2
   123ba:	1a9b      	subs	r3, r3, r2
   123bc:	2b00      	cmp	r3, #0
   123be:	d101      	bne.n	123c4 <k_ms_to_ticks_ceil64+0x56>
   123c0:	2301      	movs	r3, #1
   123c2:	e000      	b.n	123c6 <k_ms_to_ticks_ceil64+0x58>
   123c4:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   123c6:	76fb      	strb	r3, [r7, #27]
   123c8:	7efb      	ldrb	r3, [r7, #27]
   123ca:	f003 0301 	and.w	r3, r3, #1
   123ce:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   123d0:	7ffb      	ldrb	r3, [r7, #31]
   123d2:	2b00      	cmp	r3, #0
   123d4:	d00f      	beq.n	123f6 <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   123d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   123d8:	6a3b      	ldr	r3, [r7, #32]
   123da:	429a      	cmp	r2, r3
   123dc:	d90b      	bls.n	123f6 <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   123de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   123e0:	6a3a      	ldr	r2, [r7, #32]
   123e2:	fbb3 f2f2 	udiv	r2, r3, r2
   123e6:	6a39      	ldr	r1, [r7, #32]
   123e8:	fb01 f202 	mul.w	r2, r1, r2
   123ec:	1a9b      	subs	r3, r3, r2
   123ee:	2b00      	cmp	r3, #0
   123f0:	d101      	bne.n	123f6 <k_ms_to_ticks_ceil64+0x88>
   123f2:	2301      	movs	r3, #1
   123f4:	e000      	b.n	123f8 <k_ms_to_ticks_ceil64+0x8a>
   123f6:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   123f8:	76bb      	strb	r3, [r7, #26]
   123fa:	7ebb      	ldrb	r3, [r7, #26]
   123fc:	f003 0301 	and.w	r3, r3, #1
   12400:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   12402:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   12404:	6a3b      	ldr	r3, [r7, #32]
   12406:	429a      	cmp	r2, r3
   12408:	d10a      	bne.n	12420 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   1240a:	7fbb      	ldrb	r3, [r7, #30]
   1240c:	2b00      	cmp	r3, #0
   1240e:	d004      	beq.n	1241a <k_ms_to_ticks_ceil64+0xac>
   12410:	6abb      	ldr	r3, [r7, #40]	; 0x28
   12412:	461a      	mov	r2, r3
   12414:	f04f 0300 	mov.w	r3, #0
   12418:	e0c8      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
   1241a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   1241e:	e0c5      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   12420:	f04f 0200 	mov.w	r2, #0
   12424:	f04f 0300 	mov.w	r3, #0
   12428:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   1242c:	7efb      	ldrb	r3, [r7, #27]
   1242e:	f083 0301 	eor.w	r3, r3, #1
   12432:	b2db      	uxtb	r3, r3
   12434:	2b00      	cmp	r3, #0
   12436:	d01e      	beq.n	12476 <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   12438:	7ebb      	ldrb	r3, [r7, #26]
   1243a:	2b00      	cmp	r3, #0
   1243c:	d004      	beq.n	12448 <k_ms_to_ticks_ceil64+0xda>
   1243e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   12440:	6a3b      	ldr	r3, [r7, #32]
   12442:	fbb2 f3f3 	udiv	r3, r2, r3
   12446:	e000      	b.n	1244a <k_ms_to_ticks_ceil64+0xdc>
   12448:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1244a:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   1244c:	7f7b      	ldrb	r3, [r7, #29]
   1244e:	2b00      	cmp	r3, #0
   12450:	d007      	beq.n	12462 <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   12452:	68fb      	ldr	r3, [r7, #12]
   12454:	3b01      	subs	r3, #1
   12456:	461a      	mov	r2, r3
   12458:	f04f 0300 	mov.w	r3, #0
   1245c:	e9c7 2304 	strd	r2, r3, [r7, #16]
   12460:	e009      	b.n	12476 <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   12462:	7f3b      	ldrb	r3, [r7, #28]
   12464:	2b00      	cmp	r3, #0
   12466:	d006      	beq.n	12476 <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   12468:	68fb      	ldr	r3, [r7, #12]
   1246a:	085b      	lsrs	r3, r3, #1
   1246c:	461a      	mov	r2, r3
   1246e:	f04f 0300 	mov.w	r3, #0
   12472:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   12476:	7ebb      	ldrb	r3, [r7, #26]
   12478:	2b00      	cmp	r3, #0
   1247a:	d02a      	beq.n	124d2 <k_ms_to_ticks_ceil64+0x164>
		t += off;
   1247c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   12480:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   12484:	1884      	adds	r4, r0, r2
   12486:	eb41 0503 	adc.w	r5, r1, r3
   1248a:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   1248e:	7fbb      	ldrb	r3, [r7, #30]
   12490:	2b00      	cmp	r3, #0
   12492:	d010      	beq.n	124b6 <k_ms_to_ticks_ceil64+0x148>
   12494:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   12498:	2b01      	cmp	r3, #1
   1249a:	bf08      	it	eq
   1249c:	2a00      	cmpeq	r2, #0
   1249e:	d20a      	bcs.n	124b6 <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   124a0:	6aba      	ldr	r2, [r7, #40]	; 0x28
   124a2:	6a79      	ldr	r1, [r7, #36]	; 0x24
   124a4:	6a3b      	ldr	r3, [r7, #32]
   124a6:	fbb1 f3f3 	udiv	r3, r1, r3
   124aa:	fbb2 f3f3 	udiv	r3, r2, r3
   124ae:	461a      	mov	r2, r3
   124b0:	f04f 0300 	mov.w	r3, #0
   124b4:	e07a      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   124b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   124b8:	6a3b      	ldr	r3, [r7, #32]
   124ba:	fbb2 f3f3 	udiv	r3, r2, r3
   124be:	461a      	mov	r2, r3
   124c0:	f04f 0300 	mov.w	r3, #0
   124c4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   124c8:	f7ed fe3c 	bl	144 <__aeabi_uldivmod>
   124cc:	4602      	mov	r2, r0
   124ce:	460b      	mov	r3, r1
   124d0:	e06c      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   124d2:	7efb      	ldrb	r3, [r7, #27]
   124d4:	2b00      	cmp	r3, #0
   124d6:	d021      	beq.n	1251c <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   124d8:	7fbb      	ldrb	r3, [r7, #30]
   124da:	2b00      	cmp	r3, #0
   124dc:	d00a      	beq.n	124f4 <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   124de:	6abb      	ldr	r3, [r7, #40]	; 0x28
   124e0:	6a39      	ldr	r1, [r7, #32]
   124e2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   124e4:	fbb1 f2f2 	udiv	r2, r1, r2
   124e8:	fb02 f303 	mul.w	r3, r2, r3
   124ec:	461a      	mov	r2, r3
   124ee:	f04f 0300 	mov.w	r3, #0
   124f2:	e05b      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   124f4:	6a3a      	ldr	r2, [r7, #32]
   124f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   124f8:	fbb2 f3f3 	udiv	r3, r2, r3
   124fc:	461a      	mov	r2, r3
   124fe:	f04f 0300 	mov.w	r3, #0
   12502:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   12504:	fb03 f001 	mul.w	r0, r3, r1
   12508:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   1250a:	fb02 f101 	mul.w	r1, r2, r1
   1250e:	4401      	add	r1, r0
   12510:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   12512:	fba0 2302 	umull	r2, r3, r0, r2
   12516:	4419      	add	r1, r3
   12518:	460b      	mov	r3, r1
   1251a:	e047      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   1251c:	7fbb      	ldrb	r3, [r7, #30]
   1251e:	2b00      	cmp	r3, #0
   12520:	d024      	beq.n	1256c <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   12522:	6a3b      	ldr	r3, [r7, #32]
   12524:	461a      	mov	r2, r3
   12526:	f04f 0300 	mov.w	r3, #0
   1252a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1252c:	fb03 f001 	mul.w	r0, r3, r1
   12530:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   12532:	fb02 f101 	mul.w	r1, r2, r1
   12536:	4401      	add	r1, r0
   12538:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1253a:	fba0 2302 	umull	r2, r3, r0, r2
   1253e:	4419      	add	r1, r3
   12540:	460b      	mov	r3, r1
   12542:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   12546:	eb12 0a00 	adds.w	sl, r2, r0
   1254a:	eb43 0b01 	adc.w	fp, r3, r1
   1254e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   12550:	461a      	mov	r2, r3
   12552:	f04f 0300 	mov.w	r3, #0
   12556:	4650      	mov	r0, sl
   12558:	4659      	mov	r1, fp
   1255a:	f7ed fdf3 	bl	144 <__aeabi_uldivmod>
   1255e:	4602      	mov	r2, r0
   12560:	460b      	mov	r3, r1
   12562:	4613      	mov	r3, r2
   12564:	461a      	mov	r2, r3
   12566:	f04f 0300 	mov.w	r3, #0
   1256a:	e01f      	b.n	125ac <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   1256c:	6a3b      	ldr	r3, [r7, #32]
   1256e:	461a      	mov	r2, r3
   12570:	f04f 0300 	mov.w	r3, #0
   12574:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   12576:	fb03 f001 	mul.w	r0, r3, r1
   1257a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   1257c:	fb02 f101 	mul.w	r1, r2, r1
   12580:	4401      	add	r1, r0
   12582:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   12584:	fba0 2302 	umull	r2, r3, r0, r2
   12588:	4419      	add	r1, r3
   1258a:	460b      	mov	r3, r1
   1258c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   12590:	eb12 0800 	adds.w	r8, r2, r0
   12594:	eb43 0901 	adc.w	r9, r3, r1
   12598:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1259a:	461a      	mov	r2, r3
   1259c:	f04f 0300 	mov.w	r3, #0
   125a0:	4640      	mov	r0, r8
   125a2:	4649      	mov	r1, r9
   125a4:	f7ed fdce 	bl	144 <__aeabi_uldivmod>
   125a8:	4602      	mov	r2, r0
   125aa:	460b      	mov	r3, r1
}
   125ac:	4610      	mov	r0, r2
   125ae:	4619      	mov	r1, r3
   125b0:	3730      	adds	r7, #48	; 0x30
   125b2:	46bd      	mov	sp, r7
   125b4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

000125b8 <k_msleep>:
{
   125b8:	b580      	push	{r7, lr}
   125ba:	b082      	sub	sp, #8
   125bc:	af00      	add	r7, sp, #0
   125be:	6078      	str	r0, [r7, #4]
	return k_sleep(Z_TIMEOUT_MS(ms));
   125c0:	687b      	ldr	r3, [r7, #4]
   125c2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   125c6:	461a      	mov	r2, r3
   125c8:	ea4f 73e2 	mov.w	r3, r2, asr #31
   125cc:	4610      	mov	r0, r2
   125ce:	4619      	mov	r1, r3
   125d0:	f7ff fecd 	bl	1236e <k_ms_to_ticks_ceil64>
   125d4:	4602      	mov	r2, r0
   125d6:	460b      	mov	r3, r1
   125d8:	4610      	mov	r0, r2
   125da:	4619      	mov	r1, r3
   125dc:	f000 f811 	bl	12602 <k_sleep>
   125e0:	4601      	mov	r1, r0
   125e2:	460b      	mov	r3, r1
}
   125e4:	4618      	mov	r0, r3
   125e6:	3708      	adds	r7, #8
   125e8:	46bd      	mov	sp, r7
   125ea:	bd80      	pop	{r7, pc}

000125ec <k_cpu_atomic_idle>:
 * @param key Interrupt locking key obtained from irq_lock().
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
   125ec:	b580      	push	{r7, lr}
   125ee:	b082      	sub	sp, #8
   125f0:	af00      	add	r7, sp, #0
   125f2:	6078      	str	r0, [r7, #4]
	arch_cpu_atomic_idle(key);
   125f4:	6878      	ldr	r0, [r7, #4]
   125f6:	f7f2 fb1f 	bl	4c38 <arch_cpu_atomic_idle>
}
   125fa:	bf00      	nop
   125fc:	3708      	adds	r7, #8
   125fe:	46bd      	mov	sp, r7
   12600:	bd80      	pop	{r7, pc}

00012602 <k_sleep>:
{
   12602:	b580      	push	{r7, lr}
   12604:	b082      	sub	sp, #8
   12606:	af00      	add	r7, sp, #0
   12608:	e9c7 0100 	strd	r0, r1, [r7]
	return z_impl_k_sleep(timeout);
   1260c:	e9d7 0100 	ldrd	r0, r1, [r7]
   12610:	f7fb fe40 	bl	e294 <z_impl_k_sleep>
   12614:	4603      	mov	r3, r0
}
   12616:	4618      	mov	r0, r3
   12618:	3708      	adds	r7, #8
   1261a:	46bd      	mov	sp, r7
   1261c:	bd80      	pop	{r7, pc}

0001261e <k_sem_take>:
{
   1261e:	b580      	push	{r7, lr}
   12620:	b084      	sub	sp, #16
   12622:	af00      	add	r7, sp, #0
   12624:	60f8      	str	r0, [r7, #12]
   12626:	e9c7 2300 	strd	r2, r3, [r7]
	return z_impl_k_sem_take(sem, timeout);
   1262a:	e9d7 2300 	ldrd	r2, r3, [r7]
   1262e:	68f8      	ldr	r0, [r7, #12]
   12630:	f7fb fefa 	bl	e428 <z_impl_k_sem_take>
   12634:	4603      	mov	r3, r0
}
   12636:	4618      	mov	r0, r3
   12638:	3710      	adds	r7, #16
   1263a:	46bd      	mov	sp, r7
   1263c:	bd80      	pop	{r7, pc}

0001263e <k_sem_give>:
{
   1263e:	b580      	push	{r7, lr}
   12640:	b082      	sub	sp, #8
   12642:	af00      	add	r7, sp, #0
   12644:	6078      	str	r0, [r7, #4]
	z_impl_k_sem_give(sem);
   12646:	6878      	ldr	r0, [r7, #4]
   12648:	f7fb fe88 	bl	e35c <z_impl_k_sem_give>
}
   1264c:	bf00      	nop
   1264e:	3708      	adds	r7, #8
   12650:	46bd      	mov	sp, r7
   12652:	bd80      	pop	{r7, pc}

00012654 <nrf_clock_int_enable>:
{
   12654:	b480      	push	{r7}
   12656:	b083      	sub	sp, #12
   12658:	af00      	add	r7, sp, #0
   1265a:	6078      	str	r0, [r7, #4]
   1265c:	6039      	str	r1, [r7, #0]
    p_reg->INTENSET = mask;
   1265e:	687b      	ldr	r3, [r7, #4]
   12660:	683a      	ldr	r2, [r7, #0]
   12662:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12666:	bf00      	nop
   12668:	370c      	adds	r7, #12
   1266a:	46bd      	mov	sp, r7
   1266c:	bc80      	pop	{r7}
   1266e:	4770      	bx	lr

00012670 <nrf_clock_int_disable>:
{
   12670:	b480      	push	{r7}
   12672:	b083      	sub	sp, #12
   12674:	af00      	add	r7, sp, #0
   12676:	6078      	str	r0, [r7, #4]
   12678:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   1267a:	687b      	ldr	r3, [r7, #4]
   1267c:	683a      	ldr	r2, [r7, #0]
   1267e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   12682:	bf00      	nop
   12684:	370c      	adds	r7, #12
   12686:	46bd      	mov	sp, r7
   12688:	bc80      	pop	{r7}
   1268a:	4770      	bx	lr

0001268c <nrf_clock_task_trigger>:
{
   1268c:	b480      	push	{r7}
   1268e:	b083      	sub	sp, #12
   12690:	af00      	add	r7, sp, #0
   12692:	6078      	str	r0, [r7, #4]
   12694:	460b      	mov	r3, r1
   12696:	70fb      	strb	r3, [r7, #3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12698:	78fb      	ldrb	r3, [r7, #3]
   1269a:	687a      	ldr	r2, [r7, #4]
   1269c:	4413      	add	r3, r2
   1269e:	2201      	movs	r2, #1
   126a0:	601a      	str	r2, [r3, #0]
}
   126a2:	bf00      	nop
   126a4:	370c      	adds	r7, #12
   126a6:	46bd      	mov	sp, r7
   126a8:	bc80      	pop	{r7}
   126aa:	4770      	bx	lr

000126ac <nrf_clock_event_clear>:
{
   126ac:	b580      	push	{r7, lr}
   126ae:	b082      	sub	sp, #8
   126b0:	af00      	add	r7, sp, #0
   126b2:	6078      	str	r0, [r7, #4]
   126b4:	460b      	mov	r3, r1
   126b6:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   126b8:	887b      	ldrh	r3, [r7, #2]
   126ba:	687a      	ldr	r2, [r7, #4]
   126bc:	4413      	add	r3, r2
   126be:	2200      	movs	r2, #0
   126c0:	601a      	str	r2, [r3, #0]
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
   126c2:	887b      	ldrh	r3, [r7, #2]
   126c4:	687a      	ldr	r2, [r7, #4]
   126c6:	4413      	add	r3, r2
   126c8:	4618      	mov	r0, r3
   126ca:	f7ff fe3e 	bl	1234a <nrf_event_readback>
}
   126ce:	bf00      	nop
   126d0:	3708      	adds	r7, #8
   126d2:	46bd      	mov	sp, r7
   126d4:	bd80      	pop	{r7, pc}

000126d6 <nrf_clock_event_check>:
{
   126d6:	b480      	push	{r7}
   126d8:	b083      	sub	sp, #12
   126da:	af00      	add	r7, sp, #0
   126dc:	6078      	str	r0, [r7, #4]
   126de:	460b      	mov	r3, r1
   126e0:	807b      	strh	r3, [r7, #2]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   126e2:	887b      	ldrh	r3, [r7, #2]
   126e4:	687a      	ldr	r2, [r7, #4]
   126e6:	4413      	add	r3, r2
   126e8:	681b      	ldr	r3, [r3, #0]
   126ea:	2b00      	cmp	r3, #0
   126ec:	bf14      	ite	ne
   126ee:	2301      	movne	r3, #1
   126f0:	2300      	moveq	r3, #0
   126f2:	b2db      	uxtb	r3, r3
}
   126f4:	4618      	mov	r0, r3
   126f6:	370c      	adds	r7, #12
   126f8:	46bd      	mov	sp, r7
   126fa:	bc80      	pop	{r7}
   126fc:	4770      	bx	lr

000126fe <nrf_clock_lf_src_set>:

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
   126fe:	b480      	push	{r7}
   12700:	b083      	sub	sp, #12
   12702:	af00      	add	r7, sp, #0
   12704:	6078      	str	r0, [r7, #4]
   12706:	460b      	mov	r3, r1
   12708:	70fb      	strb	r3, [r7, #3]
    p_reg->LFCLKSRC = (uint32_t)(source);
   1270a:	78fa      	ldrb	r2, [r7, #3]
   1270c:	687b      	ldr	r3, [r7, #4]
   1270e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   12712:	bf00      	nop
   12714:	370c      	adds	r7, #12
   12716:	46bd      	mov	sp, r7
   12718:	bc80      	pop	{r7}
   1271a:	4770      	bx	lr

0001271c <nrf_clock_lf_src_get>:

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_src_get(NRF_CLOCK_Type const * p_reg)
{
   1271c:	b480      	push	{r7}
   1271e:	b083      	sub	sp, #12
   12720:	af00      	add	r7, sp, #0
   12722:	6078      	str	r0, [r7, #4]
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   12724:	687b      	ldr	r3, [r7, #4]
   12726:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
   1272a:	b2db      	uxtb	r3, r3
}
   1272c:	4618      	mov	r0, r3
   1272e:	370c      	adds	r7, #12
   12730:	46bd      	mov	sp, r7
   12732:	bc80      	pop	{r7}
   12734:	4770      	bx	lr

00012736 <nrf_clock_lf_srccopy_get>:
    (void)nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_LFCLK, &clk_src);
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
   12736:	b480      	push	{r7}
   12738:	b083      	sub	sp, #12
   1273a:	af00      	add	r7, sp, #0
   1273c:	6078      	str	r0, [r7, #4]
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1273e:	687b      	ldr	r3, [r7, #4]
   12740:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   12744:	b2db      	uxtb	r3, r3
   12746:	f003 0303 	and.w	r3, r3, #3
   1274a:	b2db      	uxtb	r3, r3
                                >> CLOCK_LFCLKSRCCOPY_SRC_Pos);
}
   1274c:	4618      	mov	r0, r3
   1274e:	370c      	adds	r7, #12
   12750:	46bd      	mov	sp, r7
   12752:	bc80      	pop	{r7}
   12754:	4770      	bx	lr

00012756 <nrfx_clock_lfclk_start>:
    }
}
#endif // NRF_CLOCK_HAS_HFCLK_DIV || NRF_CLOCK_HAS_HFCLK_192M

NRFX_STATIC_INLINE void nrfx_clock_lfclk_start(void)
{
   12756:	b580      	push	{r7, lr}
   12758:	af00      	add	r7, sp, #0
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   1275a:	2000      	movs	r0, #0
   1275c:	f7f7 fb06 	bl	9d6c <nrfx_clock_start>
}
   12760:	bf00      	nop
   12762:	bd80      	pop	{r7, pc}

00012764 <nrfx_clock_lfclk_stop>:

NRFX_STATIC_INLINE void nrfx_clock_lfclk_stop(void)
{
   12764:	b580      	push	{r7, lr}
   12766:	af00      	add	r7, sp, #0
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   12768:	2000      	movs	r0, #0
   1276a:	f7f7 fb73 	bl	9e54 <nrfx_clock_stop>
}
   1276e:	bf00      	nop
   12770:	bd80      	pop	{r7, pc}

00012772 <nrfx_clock_hfclk_start>:

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
   12772:	b580      	push	{r7, lr}
   12774:	af00      	add	r7, sp, #0
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   12776:	2001      	movs	r0, #1
   12778:	f7f7 faf8 	bl	9d6c <nrfx_clock_start>
}
   1277c:	bf00      	nop
   1277e:	bd80      	pop	{r7, pc}

00012780 <nrfx_clock_hfclk_stop>:

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
   12780:	b580      	push	{r7, lr}
   12782:	af00      	add	r7, sp, #0
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   12784:	2001      	movs	r0, #1
   12786:	f7f7 fb65 	bl	9e54 <nrfx_clock_stop>
}
   1278a:	bf00      	nop
   1278c:	bd80      	pop	{r7, pc}

0001278e <nrfx_clock_is_running>:
{
    return nrf_clock_event_address_get(NRF_CLOCK, event);
}

NRFX_STATIC_INLINE bool nrfx_clock_is_running(nrf_clock_domain_t domain, void * p_clk_src)
{
   1278e:	b580      	push	{r7, lr}
   12790:	b082      	sub	sp, #8
   12792:	af00      	add	r7, sp, #0
   12794:	4603      	mov	r3, r0
   12796:	6039      	str	r1, [r7, #0]
   12798:	71fb      	strb	r3, [r7, #7]
    return nrf_clock_is_running(NRF_CLOCK, domain, p_clk_src);
   1279a:	79fb      	ldrb	r3, [r7, #7]
   1279c:	683a      	ldr	r2, [r7, #0]
   1279e:	4619      	mov	r1, r3
   127a0:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
   127a4:	f7f1 f924 	bl	39f0 <nrf_clock_is_running>
   127a8:	4603      	mov	r3, r0
}
   127aa:	4618      	mov	r0, r3
   127ac:	3708      	adds	r7, #8
   127ae:	46bd      	mov	sp, r7
   127b0:	bd80      	pop	{r7, pc}

000127b2 <get_sub_data>:
{
   127b2:	b480      	push	{r7}
   127b4:	b085      	sub	sp, #20
   127b6:	af00      	add	r7, sp, #0
   127b8:	6078      	str	r0, [r7, #4]
   127ba:	460b      	mov	r3, r1
   127bc:	70fb      	strb	r3, [r7, #3]
	struct nrf_clock_control_data *data = dev->data;
   127be:	687b      	ldr	r3, [r7, #4]
   127c0:	68db      	ldr	r3, [r3, #12]
   127c2:	60fb      	str	r3, [r7, #12]
	return &data->subsys[type];
   127c4:	78fa      	ldrb	r2, [r7, #3]
   127c6:	4613      	mov	r3, r2
   127c8:	005b      	lsls	r3, r3, #1
   127ca:	4413      	add	r3, r2
   127cc:	009b      	lsls	r3, r3, #2
   127ce:	3340      	adds	r3, #64	; 0x40
   127d0:	68fa      	ldr	r2, [r7, #12]
   127d2:	4413      	add	r3, r2
}
   127d4:	4618      	mov	r0, r3
   127d6:	3714      	adds	r7, #20
   127d8:	46bd      	mov	sp, r7
   127da:	bc80      	pop	{r7}
   127dc:	4770      	bx	lr

000127de <get_sub_config>:
{
   127de:	b480      	push	{r7}
   127e0:	b085      	sub	sp, #20
   127e2:	af00      	add	r7, sp, #0
   127e4:	6078      	str	r0, [r7, #4]
   127e6:	460b      	mov	r3, r1
   127e8:	70fb      	strb	r3, [r7, #3]
	const struct nrf_clock_control_config *config =
   127ea:	687b      	ldr	r3, [r7, #4]
   127ec:	685b      	ldr	r3, [r3, #4]
   127ee:	60fb      	str	r3, [r7, #12]
	return &config->subsys[type];
   127f0:	78fa      	ldrb	r2, [r7, #3]
   127f2:	4613      	mov	r3, r2
   127f4:	005b      	lsls	r3, r3, #1
   127f6:	4413      	add	r3, r2
   127f8:	009b      	lsls	r3, r3, #2
   127fa:	68fa      	ldr	r2, [r7, #12]
   127fc:	4413      	add	r3, r2
}
   127fe:	4618      	mov	r0, r3
   12800:	3714      	adds	r7, #20
   12802:	46bd      	mov	sp, r7
   12804:	bc80      	pop	{r7}
   12806:	4770      	bx	lr

00012808 <get_onoff_manager>:
{
   12808:	b480      	push	{r7}
   1280a:	b085      	sub	sp, #20
   1280c:	af00      	add	r7, sp, #0
   1280e:	6078      	str	r0, [r7, #4]
   12810:	460b      	mov	r3, r1
   12812:	70fb      	strb	r3, [r7, #3]
	struct nrf_clock_control_data *data = dev->data;
   12814:	687b      	ldr	r3, [r7, #4]
   12816:	68db      	ldr	r3, [r3, #12]
   12818:	60fb      	str	r3, [r7, #12]
	return &data->mgr[type];
   1281a:	78fb      	ldrb	r3, [r7, #3]
   1281c:	015b      	lsls	r3, r3, #5
   1281e:	68fa      	ldr	r2, [r7, #12]
   12820:	4413      	add	r3, r2
}
   12822:	4618      	mov	r0, r3
   12824:	3714      	adds	r7, #20
   12826:	46bd      	mov	sp, r7
   12828:	bc80      	pop	{r7}
   1282a:	4770      	bx	lr

0001282c <set_off_state>:
{
   1282c:	b480      	push	{r7}
   1282e:	b089      	sub	sp, #36	; 0x24
   12830:	af00      	add	r7, sp, #0
   12832:	6078      	str	r0, [r7, #4]
   12834:	6039      	str	r1, [r7, #0]
	int err = 0;
   12836:	2300      	movs	r3, #0
   12838:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
   1283a:	f04f 0320 	mov.w	r3, #32
   1283e:	f3ef 8211 	mrs	r2, BASEPRI
   12842:	f383 8811 	msr	BASEPRI, r3
   12846:	f3bf 8f6f 	isb	sy
   1284a:	613a      	str	r2, [r7, #16]
   1284c:	60fb      	str	r3, [r7, #12]
	return key;
   1284e:	693b      	ldr	r3, [r7, #16]
	int key = irq_lock();
   12850:	61bb      	str	r3, [r7, #24]
	uint32_t current_ctx = GET_CTX(*flags);
   12852:	687b      	ldr	r3, [r7, #4]
   12854:	681b      	ldr	r3, [r3, #0]
   12856:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1285a:	617b      	str	r3, [r7, #20]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   1285c:	697b      	ldr	r3, [r7, #20]
   1285e:	2b00      	cmp	r3, #0
   12860:	d007      	beq.n	12872 <set_off_state+0x46>
   12862:	697a      	ldr	r2, [r7, #20]
   12864:	683b      	ldr	r3, [r7, #0]
   12866:	429a      	cmp	r2, r3
   12868:	d003      	beq.n	12872 <set_off_state+0x46>
		err = -EPERM;
   1286a:	f04f 33ff 	mov.w	r3, #4294967295
   1286e:	61fb      	str	r3, [r7, #28]
   12870:	e002      	b.n	12878 <set_off_state+0x4c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   12872:	687b      	ldr	r3, [r7, #4]
   12874:	2201      	movs	r2, #1
   12876:	601a      	str	r2, [r3, #0]
	irq_unlock(key);
   12878:	69bb      	ldr	r3, [r7, #24]
   1287a:	60bb      	str	r3, [r7, #8]
	__asm__ volatile(
   1287c:	68bb      	ldr	r3, [r7, #8]
   1287e:	f383 8811 	msr	BASEPRI, r3
   12882:	f3bf 8f6f 	isb	sy
}
   12886:	bf00      	nop
	return err;
   12888:	69fb      	ldr	r3, [r7, #28]
}
   1288a:	4618      	mov	r0, r3
   1288c:	3724      	adds	r7, #36	; 0x24
   1288e:	46bd      	mov	sp, r7
   12890:	bc80      	pop	{r7}
   12892:	4770      	bx	lr

00012894 <set_starting_state>:
{
   12894:	b480      	push	{r7}
   12896:	b089      	sub	sp, #36	; 0x24
   12898:	af00      	add	r7, sp, #0
   1289a:	6078      	str	r0, [r7, #4]
   1289c:	6039      	str	r1, [r7, #0]
	int err = 0;
   1289e:	2300      	movs	r3, #0
   128a0:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
   128a2:	f04f 0320 	mov.w	r3, #32
   128a6:	f3ef 8211 	mrs	r2, BASEPRI
   128aa:	f383 8811 	msr	BASEPRI, r3
   128ae:	f3bf 8f6f 	isb	sy
   128b2:	613a      	str	r2, [r7, #16]
   128b4:	60fb      	str	r3, [r7, #12]
	return key;
   128b6:	693b      	ldr	r3, [r7, #16]
	int key = irq_lock();
   128b8:	61bb      	str	r3, [r7, #24]
	uint32_t current_ctx = GET_CTX(*flags);
   128ba:	687b      	ldr	r3, [r7, #4]
   128bc:	681b      	ldr	r3, [r3, #0]
   128be:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   128c2:	617b      	str	r3, [r7, #20]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   128c4:	687b      	ldr	r3, [r7, #4]
   128c6:	681b      	ldr	r3, [r3, #0]
   128c8:	f003 0307 	and.w	r3, r3, #7
   128cc:	2b01      	cmp	r3, #1
   128ce:	d103      	bne.n	128d8 <set_starting_state+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   128d0:	687b      	ldr	r3, [r7, #4]
   128d2:	683a      	ldr	r2, [r7, #0]
   128d4:	601a      	str	r2, [r3, #0]
   128d6:	e00a      	b.n	128ee <set_starting_state+0x5a>
	} else if (current_ctx != ctx) {
   128d8:	697a      	ldr	r2, [r7, #20]
   128da:	683b      	ldr	r3, [r7, #0]
   128dc:	429a      	cmp	r2, r3
   128de:	d003      	beq.n	128e8 <set_starting_state+0x54>
		err = -EPERM;
   128e0:	f04f 33ff 	mov.w	r3, #4294967295
   128e4:	61fb      	str	r3, [r7, #28]
   128e6:	e002      	b.n	128ee <set_starting_state+0x5a>
		err = -EALREADY;
   128e8:	f06f 0344 	mvn.w	r3, #68	; 0x44
   128ec:	61fb      	str	r3, [r7, #28]
	irq_unlock(key);
   128ee:	69bb      	ldr	r3, [r7, #24]
   128f0:	60bb      	str	r3, [r7, #8]
	__asm__ volatile(
   128f2:	68bb      	ldr	r3, [r7, #8]
   128f4:	f383 8811 	msr	BASEPRI, r3
   128f8:	f3bf 8f6f 	isb	sy
}
   128fc:	bf00      	nop
	return err;
   128fe:	69fb      	ldr	r3, [r7, #28]
}
   12900:	4618      	mov	r0, r3
   12902:	3724      	adds	r7, #36	; 0x24
   12904:	46bd      	mov	sp, r7
   12906:	bc80      	pop	{r7}
   12908:	4770      	bx	lr

0001290a <set_on_state>:
{
   1290a:	b480      	push	{r7}
   1290c:	b087      	sub	sp, #28
   1290e:	af00      	add	r7, sp, #0
   12910:	6078      	str	r0, [r7, #4]
	__asm__ volatile(
   12912:	f04f 0320 	mov.w	r3, #32
   12916:	f3ef 8211 	mrs	r2, BASEPRI
   1291a:	f383 8811 	msr	BASEPRI, r3
   1291e:	f3bf 8f6f 	isb	sy
   12922:	60fa      	str	r2, [r7, #12]
   12924:	60bb      	str	r3, [r7, #8]
	return key;
   12926:	68fb      	ldr	r3, [r7, #12]
	int key = irq_lock();
   12928:	617b      	str	r3, [r7, #20]
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   1292a:	687b      	ldr	r3, [r7, #4]
   1292c:	681b      	ldr	r3, [r3, #0]
   1292e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   12932:	f043 0202 	orr.w	r2, r3, #2
   12936:	687b      	ldr	r3, [r7, #4]
   12938:	601a      	str	r2, [r3, #0]
	irq_unlock(key);
   1293a:	697b      	ldr	r3, [r7, #20]
   1293c:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
   1293e:	693b      	ldr	r3, [r7, #16]
   12940:	f383 8811 	msr	BASEPRI, r3
   12944:	f3bf 8f6f 	isb	sy
}
   12948:	bf00      	nop
}
   1294a:	bf00      	nop
   1294c:	371c      	adds	r7, #28
   1294e:	46bd      	mov	sp, r7
   12950:	bc80      	pop	{r7}
   12952:	4770      	bx	lr

00012954 <lfclk_start>:
{
   12954:	b580      	push	{r7, lr}
   12956:	af00      	add	r7, sp, #0
	nrfx_clock_lfclk_start();
   12958:	f7ff fefd 	bl	12756 <nrfx_clock_lfclk_start>
}
   1295c:	bf00      	nop
   1295e:	bd80      	pop	{r7, pc}

00012960 <lfclk_stop>:
{
   12960:	b580      	push	{r7, lr}
   12962:	af00      	add	r7, sp, #0
	nrfx_clock_lfclk_stop();
   12964:	f7ff fefe 	bl	12764 <nrfx_clock_lfclk_stop>
}
   12968:	bf00      	nop
   1296a:	bd80      	pop	{r7, pc}

0001296c <hfclk_start>:
{
   1296c:	b580      	push	{r7, lr}
   1296e:	af00      	add	r7, sp, #0
	nrfx_clock_hfclk_start();
   12970:	f7ff feff 	bl	12772 <nrfx_clock_hfclk_start>
}
   12974:	bf00      	nop
   12976:	bd80      	pop	{r7, pc}

00012978 <hfclk_stop>:
{
   12978:	b580      	push	{r7, lr}
   1297a:	af00      	add	r7, sp, #0
	nrfx_clock_hfclk_stop();
   1297c:	f7ff ff00 	bl	12780 <nrfx_clock_hfclk_stop>
}
   12980:	bf00      	nop
   12982:	bd80      	pop	{r7, pc}

00012984 <api_stop>:
{
   12984:	b580      	push	{r7, lr}
   12986:	b082      	sub	sp, #8
   12988:	af00      	add	r7, sp, #0
   1298a:	6078      	str	r0, [r7, #4]
   1298c:	6039      	str	r1, [r7, #0]
	return stop(dev, subsys, CTX_API);
   1298e:	2280      	movs	r2, #128	; 0x80
   12990:	6839      	ldr	r1, [r7, #0]
   12992:	6878      	ldr	r0, [r7, #4]
   12994:	f7f1 f992 	bl	3cbc <stop>
   12998:	4603      	mov	r3, r0
}
   1299a:	4618      	mov	r0, r3
   1299c:	3708      	adds	r7, #8
   1299e:	46bd      	mov	sp, r7
   129a0:	bd80      	pop	{r7, pc}

000129a2 <async_start>:
{
   129a2:	b580      	push	{r7, lr}
   129a4:	b088      	sub	sp, #32
   129a6:	af00      	add	r7, sp, #0
   129a8:	60f8      	str	r0, [r7, #12]
   129aa:	60b9      	str	r1, [r7, #8]
   129ac:	607a      	str	r2, [r7, #4]
   129ae:	603b      	str	r3, [r7, #0]
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   129b0:	68bb      	ldr	r3, [r7, #8]
   129b2:	77fb      	strb	r3, [r7, #31]
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   129b4:	7ffb      	ldrb	r3, [r7, #31]
   129b6:	4619      	mov	r1, r3
   129b8:	68f8      	ldr	r0, [r7, #12]
   129ba:	f7ff fefa 	bl	127b2 <get_sub_data>
   129be:	61b8      	str	r0, [r7, #24]
	err = set_starting_state(&subdata->flags, ctx);
   129c0:	69bb      	ldr	r3, [r7, #24]
   129c2:	3308      	adds	r3, #8
   129c4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   129c6:	4618      	mov	r0, r3
   129c8:	f7ff ff64 	bl	12894 <set_starting_state>
   129cc:	6178      	str	r0, [r7, #20]
	if (err < 0) {
   129ce:	697b      	ldr	r3, [r7, #20]
   129d0:	2b00      	cmp	r3, #0
   129d2:	da01      	bge.n	129d8 <async_start+0x36>
		return err;
   129d4:	697b      	ldr	r3, [r7, #20]
   129d6:	e00e      	b.n	129f6 <async_start+0x54>
	subdata->cb = cb;
   129d8:	69bb      	ldr	r3, [r7, #24]
   129da:	687a      	ldr	r2, [r7, #4]
   129dc:	601a      	str	r2, [r3, #0]
	subdata->user_data = user_data;
   129de:	69bb      	ldr	r3, [r7, #24]
   129e0:	683a      	ldr	r2, [r7, #0]
   129e2:	605a      	str	r2, [r3, #4]
	 get_sub_config(dev, type)->start();
   129e4:	7ffb      	ldrb	r3, [r7, #31]
   129e6:	4619      	mov	r1, r3
   129e8:	68f8      	ldr	r0, [r7, #12]
   129ea:	f7ff fef8 	bl	127de <get_sub_config>
   129ee:	4603      	mov	r3, r0
   129f0:	681b      	ldr	r3, [r3, #0]
   129f2:	4798      	blx	r3
	return 0;
   129f4:	2300      	movs	r3, #0
}
   129f6:	4618      	mov	r0, r3
   129f8:	3720      	adds	r7, #32
   129fa:	46bd      	mov	sp, r7
   129fc:	bd80      	pop	{r7, pc}

000129fe <api_start>:
{
   129fe:	b580      	push	{r7, lr}
   12a00:	b086      	sub	sp, #24
   12a02:	af02      	add	r7, sp, #8
   12a04:	60f8      	str	r0, [r7, #12]
   12a06:	60b9      	str	r1, [r7, #8]
   12a08:	607a      	str	r2, [r7, #4]
   12a0a:	603b      	str	r3, [r7, #0]
	return async_start(dev, subsys, cb, user_data, CTX_API);
   12a0c:	2380      	movs	r3, #128	; 0x80
   12a0e:	9300      	str	r3, [sp, #0]
   12a10:	683b      	ldr	r3, [r7, #0]
   12a12:	687a      	ldr	r2, [r7, #4]
   12a14:	68b9      	ldr	r1, [r7, #8]
   12a16:	68f8      	ldr	r0, [r7, #12]
   12a18:	f7ff ffc3 	bl	129a2 <async_start>
   12a1c:	4603      	mov	r3, r0
}
   12a1e:	4618      	mov	r0, r3
   12a20:	3710      	adds	r7, #16
   12a22:	46bd      	mov	sp, r7
   12a24:	bd80      	pop	{r7, pc}

00012a26 <blocking_start_callback>:
{
   12a26:	b580      	push	{r7, lr}
   12a28:	b086      	sub	sp, #24
   12a2a:	af00      	add	r7, sp, #0
   12a2c:	60f8      	str	r0, [r7, #12]
   12a2e:	60b9      	str	r1, [r7, #8]
   12a30:	607a      	str	r2, [r7, #4]
	struct k_sem *sem = user_data;
   12a32:	687b      	ldr	r3, [r7, #4]
   12a34:	617b      	str	r3, [r7, #20]
	k_sem_give(sem);
   12a36:	6978      	ldr	r0, [r7, #20]
   12a38:	f7ff fe01 	bl	1263e <k_sem_give>
}
   12a3c:	bf00      	nop
   12a3e:	3718      	adds	r7, #24
   12a40:	46bd      	mov	sp, r7
   12a42:	bd80      	pop	{r7, pc}

00012a44 <onoff_started_callback>:
{
   12a44:	b580      	push	{r7, lr}
   12a46:	b088      	sub	sp, #32
   12a48:	af00      	add	r7, sp, #0
   12a4a:	60f8      	str	r0, [r7, #12]
   12a4c:	60b9      	str	r1, [r7, #8]
   12a4e:	607a      	str	r2, [r7, #4]
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)sys;
   12a50:	68bb      	ldr	r3, [r7, #8]
   12a52:	77fb      	strb	r3, [r7, #31]
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
   12a54:	7ffb      	ldrb	r3, [r7, #31]
   12a56:	4619      	mov	r1, r3
   12a58:	68f8      	ldr	r0, [r7, #12]
   12a5a:	f7ff fed5 	bl	12808 <get_onoff_manager>
   12a5e:	61b8      	str	r0, [r7, #24]
	onoff_notify_fn notify = user_data;
   12a60:	687b      	ldr	r3, [r7, #4]
   12a62:	617b      	str	r3, [r7, #20]
	notify(mgr, 0);
   12a64:	697b      	ldr	r3, [r7, #20]
   12a66:	2100      	movs	r1, #0
   12a68:	69b8      	ldr	r0, [r7, #24]
   12a6a:	4798      	blx	r3
}
   12a6c:	bf00      	nop
   12a6e:	3720      	adds	r7, #32
   12a70:	46bd      	mov	sp, r7
   12a72:	bd80      	pop	{r7, pc}

00012a74 <z_clock_idle_exit>:
void __weak z_clock_set_timeout(int32_t ticks, bool idle)
{
}

void __weak z_clock_idle_exit(void)
{
   12a74:	b480      	push	{r7}
   12a76:	af00      	add	r7, sp, #0
}
   12a78:	bf00      	nop
   12a7a:	46bd      	mov	sp, r7
   12a7c:	bc80      	pop	{r7}
   12a7e:	4770      	bx	lr

00012a80 <sys_clock_disable>:

void __weak sys_clock_disable(void)
{
   12a80:	b480      	push	{r7}
   12a82:	af00      	add	r7, sp, #0
}
   12a84:	bf00      	nop
   12a86:	46bd      	mov	sp, r7
   12a88:	bc80      	pop	{r7}
   12a8a:	4770      	bx	lr

00012a8c <nrf_event_readback>:
{
   12a8c:	b480      	push	{r7}
   12a8e:	b083      	sub	sp, #12
   12a90:	af00      	add	r7, sp, #0
   12a92:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   12a94:	687b      	ldr	r3, [r7, #4]
   12a96:	681b      	ldr	r3, [r3, #0]
}
   12a98:	bf00      	nop
   12a9a:	370c      	adds	r7, #12
   12a9c:	46bd      	mov	sp, r7
   12a9e:	bc80      	pop	{r7}
   12aa0:	4770      	bx	lr

00012aa2 <sys_clock_hw_cycles_per_sec>:
{
   12aa2:	b480      	push	{r7}
   12aa4:	af00      	add	r7, sp, #0
	return CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
   12aa6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
}
   12aaa:	4618      	mov	r0, r3
   12aac:	46bd      	mov	sp, r7
   12aae:	bc80      	pop	{r7}
   12ab0:	4770      	bx	lr

00012ab2 <k_busy_wait>:
{
   12ab2:	b580      	push	{r7, lr}
   12ab4:	b082      	sub	sp, #8
   12ab6:	af00      	add	r7, sp, #0
   12ab8:	6078      	str	r0, [r7, #4]
	z_impl_k_busy_wait(usec_to_wait);
   12aba:	6878      	ldr	r0, [r7, #4]
   12abc:	f005 faa3 	bl	18006 <z_impl_k_busy_wait>
}
   12ac0:	bf00      	nop
   12ac2:	3708      	adds	r7, #8
   12ac4:	46bd      	mov	sp, r7
   12ac6:	bd80      	pop	{r7, pc}

00012ac8 <nrf_rtc_cc_set>:
{
   12ac8:	b480      	push	{r7}
   12aca:	b085      	sub	sp, #20
   12acc:	af00      	add	r7, sp, #0
   12ace:	60f8      	str	r0, [r7, #12]
   12ad0:	60b9      	str	r1, [r7, #8]
   12ad2:	607a      	str	r2, [r7, #4]
    p_reg->CC[ch] = cc_val;
   12ad4:	68fb      	ldr	r3, [r7, #12]
   12ad6:	68ba      	ldr	r2, [r7, #8]
   12ad8:	f502 72a8 	add.w	r2, r2, #336	; 0x150
   12adc:	6879      	ldr	r1, [r7, #4]
   12ade:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   12ae2:	bf00      	nop
   12ae4:	3714      	adds	r7, #20
   12ae6:	46bd      	mov	sp, r7
   12ae8:	bc80      	pop	{r7}
   12aea:	4770      	bx	lr

00012aec <nrf_rtc_cc_get>:
{
   12aec:	b480      	push	{r7}
   12aee:	b083      	sub	sp, #12
   12af0:	af00      	add	r7, sp, #0
   12af2:	6078      	str	r0, [r7, #4]
   12af4:	6039      	str	r1, [r7, #0]
    return p_reg->CC[ch];
   12af6:	687b      	ldr	r3, [r7, #4]
   12af8:	683a      	ldr	r2, [r7, #0]
   12afa:	f502 72a8 	add.w	r2, r2, #336	; 0x150
   12afe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
   12b02:	4618      	mov	r0, r3
   12b04:	370c      	adds	r7, #12
   12b06:	46bd      	mov	sp, r7
   12b08:	bc80      	pop	{r7}
   12b0a:	4770      	bx	lr

00012b0c <nrf_rtc_int_enable>:
{
   12b0c:	b480      	push	{r7}
   12b0e:	b083      	sub	sp, #12
   12b10:	af00      	add	r7, sp, #0
   12b12:	6078      	str	r0, [r7, #4]
   12b14:	6039      	str	r1, [r7, #0]
    p_reg->INTENSET = mask;
   12b16:	687b      	ldr	r3, [r7, #4]
   12b18:	683a      	ldr	r2, [r7, #0]
   12b1a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12b1e:	bf00      	nop
   12b20:	370c      	adds	r7, #12
   12b22:	46bd      	mov	sp, r7
   12b24:	bc80      	pop	{r7}
   12b26:	4770      	bx	lr

00012b28 <nrf_rtc_int_disable>:
{
   12b28:	b480      	push	{r7}
   12b2a:	b083      	sub	sp, #12
   12b2c:	af00      	add	r7, sp, #0
   12b2e:	6078      	str	r0, [r7, #4]
   12b30:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   12b32:	687b      	ldr	r3, [r7, #4]
   12b34:	683a      	ldr	r2, [r7, #0]
   12b36:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   12b3a:	bf00      	nop
   12b3c:	370c      	adds	r7, #12
   12b3e:	46bd      	mov	sp, r7
   12b40:	bc80      	pop	{r7}
   12b42:	4770      	bx	lr

00012b44 <nrf_rtc_event_clear>:
{
   12b44:	b580      	push	{r7, lr}
   12b46:	b082      	sub	sp, #8
   12b48:	af00      	add	r7, sp, #0
   12b4a:	6078      	str	r0, [r7, #4]
   12b4c:	460b      	mov	r3, r1
   12b4e:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   12b50:	887b      	ldrh	r3, [r7, #2]
   12b52:	687a      	ldr	r2, [r7, #4]
   12b54:	4413      	add	r3, r2
   12b56:	2200      	movs	r2, #0
   12b58:	601a      	str	r2, [r3, #0]
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
   12b5a:	887b      	ldrh	r3, [r7, #2]
   12b5c:	687a      	ldr	r2, [r7, #4]
   12b5e:	4413      	add	r3, r2
   12b60:	4618      	mov	r0, r3
   12b62:	f7ff ff93 	bl	12a8c <nrf_event_readback>
}
   12b66:	bf00      	nop
   12b68:	3708      	adds	r7, #8
   12b6a:	46bd      	mov	sp, r7
   12b6c:	bd80      	pop	{r7, pc}

00012b6e <nrf_rtc_counter_get>:
{
   12b6e:	b480      	push	{r7}
   12b70:	b083      	sub	sp, #12
   12b72:	af00      	add	r7, sp, #0
   12b74:	6078      	str	r0, [r7, #4]
     return p_reg->COUNTER;
   12b76:	687b      	ldr	r3, [r7, #4]
   12b78:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
}
   12b7c:	4618      	mov	r0, r3
   12b7e:	370c      	adds	r7, #12
   12b80:	46bd      	mov	sp, r7
   12b82:	bc80      	pop	{r7}
   12b84:	4770      	bx	lr

00012b86 <nrf_rtc_task_trigger>:
{
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
   12b86:	b480      	push	{r7}
   12b88:	b083      	sub	sp, #12
   12b8a:	af00      	add	r7, sp, #0
   12b8c:	6078      	str	r0, [r7, #4]
   12b8e:	460b      	mov	r3, r1
   12b90:	70fb      	strb	r3, [r7, #3]
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   12b92:	78fa      	ldrb	r2, [r7, #3]
   12b94:	687b      	ldr	r3, [r7, #4]
   12b96:	4413      	add	r3, r2
   12b98:	461a      	mov	r2, r3
   12b9a:	2301      	movs	r3, #1
   12b9c:	6013      	str	r3, [r2, #0]
}
   12b9e:	bf00      	nop
   12ba0:	370c      	adds	r7, #12
   12ba2:	46bd      	mov	sp, r7
   12ba4:	bc80      	pop	{r7}
   12ba6:	4770      	bx	lr

00012ba8 <nrf_rtc_event_enable>:

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
   12ba8:	b480      	push	{r7}
   12baa:	b083      	sub	sp, #12
   12bac:	af00      	add	r7, sp, #0
   12bae:	6078      	str	r0, [r7, #4]
   12bb0:	6039      	str	r1, [r7, #0]
    p_reg->EVTENSET = mask;
   12bb2:	687b      	ldr	r3, [r7, #4]
   12bb4:	683a      	ldr	r2, [r7, #0]
   12bb6:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
}
   12bba:	bf00      	nop
   12bbc:	370c      	adds	r7, #12
   12bbe:	46bd      	mov	sp, r7
   12bc0:	bc80      	pop	{r7}
   12bc2:	4770      	bx	lr

00012bc4 <counter_sub>:
{
   12bc4:	b480      	push	{r7}
   12bc6:	b083      	sub	sp, #12
   12bc8:	af00      	add	r7, sp, #0
   12bca:	6078      	str	r0, [r7, #4]
   12bcc:	6039      	str	r1, [r7, #0]
	return (a - b) & COUNTER_MAX;
   12bce:	687a      	ldr	r2, [r7, #4]
   12bd0:	683b      	ldr	r3, [r7, #0]
   12bd2:	1ad3      	subs	r3, r2, r3
   12bd4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
   12bd8:	4618      	mov	r0, r3
   12bda:	370c      	adds	r7, #12
   12bdc:	46bd      	mov	sp, r7
   12bde:	bc80      	pop	{r7}
   12be0:	4770      	bx	lr

00012be2 <prevent_false_prev_evt>:
{
   12be2:	b580      	push	{r7, lr}
   12be4:	b082      	sub	sp, #8
   12be6:	af00      	add	r7, sp, #0
	uint32_t now = counter();
   12be8:	f7f1 fb5c 	bl	42a4 <counter>
   12bec:	6078      	str	r0, [r7, #4]
	prev_val = get_comparator();
   12bee:	f7f1 fb1d 	bl	422c <get_comparator>
   12bf2:	6038      	str	r0, [r7, #0]
	event_clear();
   12bf4:	f7f1 fb26 	bl	4244 <event_clear>
	set_comparator(now);
   12bf8:	6878      	ldr	r0, [r7, #4]
   12bfa:	f7f1 fb05 	bl	4208 <set_comparator>
	event_enable();
   12bfe:	f7f1 fb2d 	bl	425c <event_enable>
	if (counter_sub(prev_val, now) == 1) {
   12c02:	6879      	ldr	r1, [r7, #4]
   12c04:	6838      	ldr	r0, [r7, #0]
   12c06:	f7ff ffdd 	bl	12bc4 <counter_sub>
   12c0a:	4603      	mov	r3, r0
   12c0c:	2b01      	cmp	r3, #1
   12c0e:	d104      	bne.n	12c1a <prevent_false_prev_evt+0x38>
		k_busy_wait(15);
   12c10:	200f      	movs	r0, #15
   12c12:	f7ff ff4e 	bl	12ab2 <k_busy_wait>
		event_clear();
   12c16:	f7f1 fb15 	bl	4244 <event_clear>
	NVIC_ClearPendingIRQ(RTC_IRQn);
   12c1a:	2015      	movs	r0, #21
   12c1c:	f7f1 fab2 	bl	4184 <__NVIC_ClearPendingIRQ>
}
   12c20:	bf00      	nop
   12c22:	3708      	adds	r7, #8
   12c24:	46bd      	mov	sp, r7
   12c26:	bd80      	pop	{r7, pc}

00012c28 <handle_next_cycle_case>:
{
   12c28:	b580      	push	{r7, lr}
   12c2a:	b082      	sub	sp, #8
   12c2c:	af00      	add	r7, sp, #0
   12c2e:	6078      	str	r0, [r7, #4]
	set_comparator(t + 2);
   12c30:	687b      	ldr	r3, [r7, #4]
   12c32:	3302      	adds	r3, #2
   12c34:	4618      	mov	r0, r3
   12c36:	f7f1 fae7 	bl	4208 <set_comparator>
	while (t != counter()) {
   12c3a:	e007      	b.n	12c4c <handle_next_cycle_case+0x24>
		t = counter();
   12c3c:	f7f1 fb32 	bl	42a4 <counter>
   12c40:	6078      	str	r0, [r7, #4]
		set_comparator(t + 2);
   12c42:	687b      	ldr	r3, [r7, #4]
   12c44:	3302      	adds	r3, #2
   12c46:	4618      	mov	r0, r3
   12c48:	f7f1 fade 	bl	4208 <set_comparator>
	while (t != counter()) {
   12c4c:	f7f1 fb2a 	bl	42a4 <counter>
   12c50:	4602      	mov	r2, r0
   12c52:	687b      	ldr	r3, [r7, #4]
   12c54:	4293      	cmp	r3, r2
   12c56:	d1f1      	bne.n	12c3c <handle_next_cycle_case+0x14>
}
   12c58:	bf00      	nop
   12c5a:	bf00      	nop
   12c5c:	3708      	adds	r7, #8
   12c5e:	46bd      	mov	sp, r7
   12c60:	bd80      	pop	{r7, pc}

00012c62 <set_absolute_alarm>:
{
   12c62:	b590      	push	{r4, r7, lr}
   12c64:	b085      	sub	sp, #20
   12c66:	af00      	add	r7, sp, #0
   12c68:	6078      	str	r0, [r7, #4]
	uint32_t t = counter();
   12c6a:	f7f1 fb1b 	bl	42a4 <counter>
   12c6e:	60f8      	str	r0, [r7, #12]
	diff = counter_sub(abs_val, t);
   12c70:	68f9      	ldr	r1, [r7, #12]
   12c72:	6878      	ldr	r0, [r7, #4]
   12c74:	f7ff ffa6 	bl	12bc4 <counter_sub>
   12c78:	60b8      	str	r0, [r7, #8]
	if (diff == 1) {
   12c7a:	68bb      	ldr	r3, [r7, #8]
   12c7c:	2b01      	cmp	r3, #1
   12c7e:	d103      	bne.n	12c88 <set_absolute_alarm+0x26>
		handle_next_cycle_case(t);
   12c80:	68f8      	ldr	r0, [r7, #12]
   12c82:	f7ff ffd1 	bl	12c28 <handle_next_cycle_case>
		return;
   12c86:	e033      	b.n	12cf0 <set_absolute_alarm+0x8e>
	set_comparator(abs_val);
   12c88:	6878      	ldr	r0, [r7, #4]
   12c8a:	f7f1 fabd 	bl	4208 <set_comparator>
	t = counter();
   12c8e:	f7f1 fb09 	bl	42a4 <counter>
   12c92:	60f8      	str	r0, [r7, #12]
	diff = counter_sub(abs_val - 2, t);
   12c94:	687b      	ldr	r3, [r7, #4]
   12c96:	3b02      	subs	r3, #2
   12c98:	68f9      	ldr	r1, [r7, #12]
   12c9a:	4618      	mov	r0, r3
   12c9c:	f7ff ff92 	bl	12bc4 <counter_sub>
   12ca0:	60b8      	str	r0, [r7, #8]
	if (diff > MAX_CYCLES) {
   12ca2:	f7ff fefe 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
   12ca6:	4603      	mov	r3, r0
   12ca8:	2b00      	cmp	r3, #0
   12caa:	da02      	bge.n	12cb2 <set_absolute_alarm+0x50>
   12cac:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
   12cb0:	337f      	adds	r3, #127	; 0x7f
   12cb2:	13db      	asrs	r3, r3, #15
   12cb4:	f5c3 0400 	rsb	r4, r3, #8388608	; 0x800000
   12cb8:	f7ff fef3 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
   12cbc:	4603      	mov	r3, r0
   12cbe:	2b00      	cmp	r3, #0
   12cc0:	da02      	bge.n	12cc8 <set_absolute_alarm+0x66>
   12cc2:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
   12cc6:	337f      	adds	r3, #127	; 0x7f
   12cc8:	13db      	asrs	r3, r3, #15
   12cca:	fbb4 f4f3 	udiv	r4, r4, r3
   12cce:	f7ff fee8 	bl	12aa2 <sys_clock_hw_cycles_per_sec>
   12cd2:	4603      	mov	r3, r0
   12cd4:	2b00      	cmp	r3, #0
   12cd6:	da02      	bge.n	12cde <set_absolute_alarm+0x7c>
   12cd8:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
   12cdc:	337f      	adds	r3, #127	; 0x7f
   12cde:	13db      	asrs	r3, r3, #15
   12ce0:	fb03 f304 	mul.w	r3, r3, r4
   12ce4:	68ba      	ldr	r2, [r7, #8]
   12ce6:	429a      	cmp	r2, r3
   12ce8:	d902      	bls.n	12cf0 <set_absolute_alarm+0x8e>
		handle_next_cycle_case(t);
   12cea:	68f8      	ldr	r0, [r7, #12]
   12cec:	f7ff ff9c 	bl	12c28 <handle_next_cycle_case>
}
   12cf0:	3714      	adds	r7, #20
   12cf2:	46bd      	mov	sp, r7
   12cf4:	bd90      	pop	{r4, r7, pc}

00012cf6 <set_protected_absolute_alarm>:
{
   12cf6:	b580      	push	{r7, lr}
   12cf8:	b082      	sub	sp, #8
   12cfa:	af00      	add	r7, sp, #0
   12cfc:	6078      	str	r0, [r7, #4]
	int_disable();
   12cfe:	f7f1 fab9 	bl	4274 <int_disable>
	prevent_false_prev_evt();
   12d02:	f7ff ff6e 	bl	12be2 <prevent_false_prev_evt>
	set_absolute_alarm(cycles);
   12d06:	6878      	ldr	r0, [r7, #4]
   12d08:	f7ff ffab 	bl	12c62 <set_absolute_alarm>
	int_enable();
   12d0c:	f7f1 fabe 	bl	428c <int_enable>
}
   12d10:	bf00      	nop
   12d12:	3708      	adds	r7, #8
   12d14:	46bd      	mov	sp, r7
   12d16:	bd80      	pop	{r7, pc}

00012d18 <abort_function>:
{
   12d18:	b580      	push	{r7, lr}
   12d1a:	b082      	sub	sp, #8
   12d1c:	af00      	add	r7, sp, #0
   12d1e:	6078      	str	r0, [r7, #4]
	sys_reboot(SYS_REBOOT_WARM);
   12d20:	2000      	movs	r0, #0
   12d22:	f7f0 fdb1 	bl	3888 <sys_reboot>
}
   12d26:	bf00      	nop
   12d28:	3708      	adds	r7, #8
   12d2a:	46bd      	mov	sp, r7
   12d2c:	bd80      	pop	{r7, pc}

00012d2e <k_mutex_init>:
{
   12d2e:	b580      	push	{r7, lr}
   12d30:	b082      	sub	sp, #8
   12d32:	af00      	add	r7, sp, #0
   12d34:	6078      	str	r0, [r7, #4]
	return z_impl_k_mutex_init(mutex);
   12d36:	6878      	ldr	r0, [r7, #4]
   12d38:	f004 f9d1 	bl	170de <z_impl_k_mutex_init>
   12d3c:	4603      	mov	r3, r0
}
   12d3e:	4618      	mov	r0, r3
   12d40:	3708      	adds	r7, #8
   12d42:	46bd      	mov	sp, r7
   12d44:	bd80      	pop	{r7, pc}

00012d46 <k_mutex_lock>:
{
   12d46:	b580      	push	{r7, lr}
   12d48:	b084      	sub	sp, #16
   12d4a:	af00      	add	r7, sp, #0
   12d4c:	60f8      	str	r0, [r7, #12]
   12d4e:	e9c7 2300 	strd	r2, r3, [r7]
	return z_impl_k_mutex_lock(mutex, timeout);
   12d52:	e9d7 2300 	ldrd	r2, r3, [r7]
   12d56:	68f8      	ldr	r0, [r7, #12]
   12d58:	f7f8 fd96 	bl	b888 <z_impl_k_mutex_lock>
   12d5c:	4603      	mov	r3, r0
}
   12d5e:	4618      	mov	r0, r3
   12d60:	3710      	adds	r7, #16
   12d62:	46bd      	mov	sp, r7
   12d64:	bd80      	pop	{r7, pc}

00012d66 <k_mutex_unlock>:
{
   12d66:	b580      	push	{r7, lr}
   12d68:	b082      	sub	sp, #8
   12d6a:	af00      	add	r7, sp, #0
   12d6c:	6078      	str	r0, [r7, #4]
	return z_impl_k_mutex_unlock(mutex);
   12d6e:	6878      	ldr	r0, [r7, #4]
   12d70:	f7f9 f914 	bl	bf9c <z_impl_k_mutex_unlock>
   12d74:	4603      	mov	r3, r0
}
   12d76:	4618      	mov	r0, r3
   12d78:	3708      	adds	r7, #8
   12d7a:	46bd      	mov	sp, r7
   12d7c:	bd80      	pop	{r7, pc}

00012d7e <arch_irq_enable>:
{
   12d7e:	b580      	push	{r7, lr}
   12d80:	b082      	sub	sp, #8
   12d82:	af00      	add	r7, sp, #0
   12d84:	6078      	str	r0, [r7, #4]
	NVIC_EnableIRQ((IRQn_Type)irq);
   12d86:	687b      	ldr	r3, [r7, #4]
   12d88:	b25b      	sxtb	r3, r3
   12d8a:	4618      	mov	r0, r3
   12d8c:	f7f1 fe38 	bl	4a00 <__NVIC_EnableIRQ>
}
   12d90:	bf00      	nop
   12d92:	3708      	adds	r7, #8
   12d94:	46bd      	mov	sp, r7
   12d96:	bd80      	pop	{r7, pc}

00012d98 <arch_irq_disable>:
{
   12d98:	b580      	push	{r7, lr}
   12d9a:	b082      	sub	sp, #8
   12d9c:	af00      	add	r7, sp, #0
   12d9e:	6078      	str	r0, [r7, #4]
	NVIC_DisableIRQ((IRQn_Type)irq);
   12da0:	687b      	ldr	r3, [r7, #4]
   12da2:	b25b      	sxtb	r3, r3
   12da4:	4618      	mov	r0, r3
   12da6:	f7f1 fe47 	bl	4a38 <__NVIC_DisableIRQ>
}
   12daa:	bf00      	nop
   12dac:	3708      	adds	r7, #8
   12dae:	46bd      	mov	sp, r7
   12db0:	bd80      	pop	{r7, pc}

00012db2 <z_irq_spurious>:
 * called.
 *
 * @return N/A
 */
void z_irq_spurious(const void *unused)
{
   12db2:	b580      	push	{r7, lr}
   12db4:	b082      	sub	sp, #8
   12db6:	af00      	add	r7, sp, #0
   12db8:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   12dba:	2100      	movs	r1, #0
   12dbc:	2001      	movs	r0, #1
   12dbe:	f000 f823 	bl	12e08 <z_arm_fatal_error>
}
   12dc2:	bf00      	nop
   12dc4:	3708      	adds	r7, #8
   12dc6:	46bd      	mov	sp, r7
   12dc8:	bd80      	pop	{r7, pc}

00012dca <configure_builtin_stack_guard>:
{
   12dca:	b480      	push	{r7}
   12dcc:	b085      	sub	sp, #20
   12dce:	af00      	add	r7, sp, #0
   12dd0:	6078      	str	r0, [r7, #4]
	uint32_t guard_start = thread->stack_info.start;
   12dd2:	687b      	ldr	r3, [r7, #4]
   12dd4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   12dd6:	60fb      	str	r3, [r7, #12]
   12dd8:	68fb      	ldr	r3, [r7, #12]
   12dda:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   12ddc:	68bb      	ldr	r3, [r7, #8]
   12dde:	f383 880b 	msr	PSPLIM, r3
}
   12de2:	bf00      	nop
}
   12de4:	bf00      	nop
   12de6:	3714      	adds	r7, #20
   12de8:	46bd      	mov	sp, r7
   12dea:	bc80      	pop	{r7}
   12dec:	4770      	bx	lr

00012dee <z_arm_prepare_switch_to_main>:
{
   12dee:	b580      	push	{r7, lr}
   12df0:	af00      	add	r7, sp, #0
	z_arm_configure_static_mpu_regions();
   12df2:	f7f3 f9b5 	bl	6160 <z_arm_configure_static_mpu_regions>
}
   12df6:	bf00      	nop
   12df8:	bd80      	pop	{r7, pc}

00012dfa <_is_user_context>:
{
   12dfa:	b480      	push	{r7}
   12dfc:	af00      	add	r7, sp, #0
	return false;
   12dfe:	2300      	movs	r3, #0
}
   12e00:	4618      	mov	r0, r3
   12e02:	46bd      	mov	sp, r7
   12e04:	bc80      	pop	{r7}
   12e06:	4770      	bx	lr

00012e08 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   12e08:	b580      	push	{r7, lr}
   12e0a:	b082      	sub	sp, #8
   12e0c:	af00      	add	r7, sp, #0
   12e0e:	6078      	str	r0, [r7, #4]
   12e10:	6039      	str	r1, [r7, #0]

	if (esf != NULL) {
   12e12:	683b      	ldr	r3, [r7, #0]
   12e14:	2b00      	cmp	r3, #0
   12e16:	d002      	beq.n	12e1e <z_arm_fatal_error+0x16>
		esf_dump(esf);
   12e18:	6838      	ldr	r0, [r7, #0]
   12e1a:	f7f1 ff27 	bl	4c6c <esf_dump>
	}
	z_fatal_error(reason, esf);
   12e1e:	6839      	ldr	r1, [r7, #0]
   12e20:	6878      	ldr	r0, [r7, #4]
   12e22:	f7f7 ff31 	bl	ac88 <z_fatal_error>
}
   12e26:	bf00      	nop
   12e28:	3708      	adds	r7, #8
   12e2a:	46bd      	mov	sp, r7
   12e2c:	bd80      	pop	{r7, pc}

00012e2e <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   12e2e:	b580      	push	{r7, lr}
   12e30:	b084      	sub	sp, #16
   12e32:	af00      	add	r7, sp, #0
   12e34:	6078      	str	r0, [r7, #4]
	/* Stacked R0 holds the exception reason. */
	unsigned int reason = esf->basic.r0;
   12e36:	687b      	ldr	r3, [r7, #4]
   12e38:	681b      	ldr	r3, [r3, #0]
   12e3a:	60fb      	str	r3, [r7, #12]
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   12e3c:	6879      	ldr	r1, [r7, #4]
   12e3e:	68f8      	ldr	r0, [r7, #12]
   12e40:	f7ff ffe2 	bl	12e08 <z_arm_fatal_error>

	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
   12e44:	bf00      	nop
   12e46:	3710      	adds	r7, #16
   12e48:	46bd      	mov	sp, r7
   12e4a:	bd80      	pop	{r7, pc}

00012e4c <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   12e4c:	b580      	push	{r7, lr}
   12e4e:	af00      	add	r7, sp, #0
	handler();
   12e50:	f7f2 f814 	bl	4e7c <z_SysNmiOnReset>
	z_arm_int_exit();
   12e54:	f7f3 f90c 	bl	6070 <z_arm_exc_exit>
}
   12e58:	bf00      	nop
   12e5a:	bd80      	pop	{r7, pc}

00012e5c <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   12e5c:	b580      	push	{r7, lr}
   12e5e:	af00      	add	r7, sp, #0
	relocate_vector_table();
   12e60:	f7f2 f810 	bl	4e84 <relocate_vector_table>
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
   12e64:	f7f2 f824 	bl	4eb0 <z_arm_floating_point_init>
#endif
	z_bss_zero();
   12e68:	f7f8 f91e 	bl	b0a8 <z_bss_zero>
	z_data_copy();
   12e6c:	f7f8 f92c 	bl	b0c8 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   12e70:	f000 f823 	bl	12eba <z_arm_interrupt_init>
	z_cstart();
   12e74:	f7f8 fa44 	bl	b300 <z_cstart>

00012e78 <_is_user_context>:
{
   12e78:	b480      	push	{r7}
   12e7a:	af00      	add	r7, sp, #0
	return false;
   12e7c:	2300      	movs	r3, #0
}
   12e7e:	4618      	mov	r0, r3
   12e80:	46bd      	mov	sp, r7
   12e82:	bc80      	pop	{r7}
   12e84:	4770      	bx	lr

00012e86 <fault_show>:
{
   12e86:	b480      	push	{r7}
   12e88:	b083      	sub	sp, #12
   12e8a:	af00      	add	r7, sp, #0
   12e8c:	6078      	str	r0, [r7, #4]
   12e8e:	6039      	str	r1, [r7, #0]
}
   12e90:	bf00      	nop
   12e92:	370c      	adds	r7, #12
   12e94:	46bd      	mov	sp, r7
   12e96:	bc80      	pop	{r7}
   12e98:	4770      	bx	lr

00012e9a <memory_fault_recoverable>:
{
   12e9a:	b480      	push	{r7}
   12e9c:	b083      	sub	sp, #12
   12e9e:	af00      	add	r7, sp, #0
   12ea0:	6078      	str	r0, [r7, #4]
	return false;
   12ea2:	2300      	movs	r3, #0
}
   12ea4:	4618      	mov	r0, r3
   12ea6:	370c      	adds	r7, #12
   12ea8:	46bd      	mov	sp, r7
   12eaa:	bc80      	pop	{r7}
   12eac:	4770      	bx	lr

00012eae <sys_arch_reboot>:
 *
 * @return N/A
 */

void __weak sys_arch_reboot(int type)
{
   12eae:	b580      	push	{r7, lr}
   12eb0:	b082      	sub	sp, #8
   12eb2:	af00      	add	r7, sp, #0
   12eb4:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(type);

	NVIC_SystemReset();
   12eb6:	f7f3 f8e9 	bl	608c <__NVIC_SystemReset>

00012eba <z_arm_interrupt_init>:
 *
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
   12eba:	b580      	push	{r7, lr}
   12ebc:	b082      	sub	sp, #8
   12ebe:	af00      	add	r7, sp, #0
	int irq = 0;
   12ec0:	2300      	movs	r3, #0
   12ec2:	607b      	str	r3, [r7, #4]

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   12ec4:	e008      	b.n	12ed8 <z_arm_interrupt_init+0x1e>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
   12ec6:	687b      	ldr	r3, [r7, #4]
   12ec8:	b25b      	sxtb	r3, r3
   12eca:	2101      	movs	r1, #1
   12ecc:	4618      	mov	r0, r3
   12ece:	f7f3 f8f3 	bl	60b8 <__NVIC_SetPriority>
	for (; irq < CONFIG_NUM_IRQS; irq++) {
   12ed2:	687b      	ldr	r3, [r7, #4]
   12ed4:	3301      	adds	r3, #1
   12ed6:	607b      	str	r3, [r7, #4]
   12ed8:	687b      	ldr	r3, [r7, #4]
   12eda:	2b40      	cmp	r3, #64	; 0x40
   12edc:	ddf3      	ble.n	12ec6 <z_arm_interrupt_init+0xc>
	}
}
   12ede:	bf00      	nop
   12ee0:	bf00      	nop
   12ee2:	3708      	adds	r7, #8
   12ee4:	46bd      	mov	sp, r7
   12ee6:	bd80      	pop	{r7, pc}

00012ee8 <z_reschedule_unlocked>:
{
   12ee8:	b580      	push	{r7, lr}
   12eea:	b082      	sub	sp, #8
   12eec:	af00      	add	r7, sp, #0
	__asm__ volatile(
   12eee:	f04f 0320 	mov.w	r3, #32
   12ef2:	f3ef 8211 	mrs	r2, BASEPRI
   12ef6:	f383 8811 	msr	BASEPRI, r3
   12efa:	f3bf 8f6f 	isb	sy
   12efe:	607a      	str	r2, [r7, #4]
   12f00:	603b      	str	r3, [r7, #0]
	return key;
   12f02:	687b      	ldr	r3, [r7, #4]
	(void) z_reschedule_irqlock(arch_irq_lock());
   12f04:	4618      	mov	r0, r3
   12f06:	f004 fe9f 	bl	17c48 <z_reschedule_irqlock>
}
   12f0a:	bf00      	nop
   12f0c:	3708      	adds	r7, #8
   12f0e:	46bd      	mov	sp, r7
   12f10:	bd80      	pop	{r7, pc}

00012f12 <_is_user_context>:
{
   12f12:	b480      	push	{r7}
   12f14:	af00      	add	r7, sp, #0
	return false;
   12f16:	2300      	movs	r3, #0
}
   12f18:	4618      	mov	r0, r3
   12f1a:	46bd      	mov	sp, r7
   12f1c:	bc80      	pop	{r7}
   12f1e:	4770      	bx	lr

00012f20 <ARM_MPU_SetRegionEx>:
{
   12f20:	b480      	push	{r7}
   12f22:	b085      	sub	sp, #20
   12f24:	af00      	add	r7, sp, #0
   12f26:	60f8      	str	r0, [r7, #12]
   12f28:	60b9      	str	r1, [r7, #8]
   12f2a:	607a      	str	r2, [r7, #4]
   12f2c:	603b      	str	r3, [r7, #0]
  mpu->RNR = rnr;
   12f2e:	68fb      	ldr	r3, [r7, #12]
   12f30:	68ba      	ldr	r2, [r7, #8]
   12f32:	609a      	str	r2, [r3, #8]
  mpu->RBAR = rbar;
   12f34:	68fb      	ldr	r3, [r7, #12]
   12f36:	687a      	ldr	r2, [r7, #4]
   12f38:	60da      	str	r2, [r3, #12]
  mpu->RLAR = rlar;
   12f3a:	68fb      	ldr	r3, [r7, #12]
   12f3c:	683a      	ldr	r2, [r7, #0]
   12f3e:	611a      	str	r2, [r3, #16]
}
   12f40:	bf00      	nop
   12f42:	3714      	adds	r7, #20
   12f44:	46bd      	mov	sp, r7
   12f46:	bc80      	pop	{r7}
   12f48:	4770      	bx	lr

00012f4a <get_num_regions>:
{
   12f4a:	b480      	push	{r7}
   12f4c:	af00      	add	r7, sp, #0
	return NUM_MPU_REGIONS;
   12f4e:	2310      	movs	r3, #16
}
   12f50:	4618      	mov	r0, r3
   12f52:	46bd      	mov	sp, r7
   12f54:	bc80      	pop	{r7}
   12f56:	4770      	bx	lr

00012f58 <mpu_partition_is_valid>:
{
   12f58:	b480      	push	{r7}
   12f5a:	b085      	sub	sp, #20
   12f5c:	af00      	add	r7, sp, #0
   12f5e:	6078      	str	r0, [r7, #4]
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
   12f60:	687b      	ldr	r3, [r7, #4]
   12f62:	685b      	ldr	r3, [r3, #4]
		&&
   12f64:	2b1f      	cmp	r3, #31
   12f66:	d90f      	bls.n	12f88 <mpu_partition_is_valid+0x30>
		((part->size &
   12f68:	687b      	ldr	r3, [r7, #4]
   12f6a:	685b      	ldr	r3, [r3, #4]
   12f6c:	f023 021f 	bic.w	r2, r3, #31
			== part->size)
   12f70:	687b      	ldr	r3, [r7, #4]
   12f72:	685b      	ldr	r3, [r3, #4]
		&&
   12f74:	429a      	cmp	r2, r3
   12f76:	d107      	bne.n	12f88 <mpu_partition_is_valid+0x30>
		((part->start &
   12f78:	687b      	ldr	r3, [r7, #4]
   12f7a:	681b      	ldr	r3, [r3, #0]
   12f7c:	f003 031f 	and.w	r3, r3, #31
		&&
   12f80:	2b00      	cmp	r3, #0
   12f82:	d101      	bne.n	12f88 <mpu_partition_is_valid+0x30>
   12f84:	2301      	movs	r3, #1
   12f86:	e000      	b.n	12f8a <mpu_partition_is_valid+0x32>
   12f88:	2300      	movs	r3, #0
	int partition_is_valid =
   12f8a:	60fb      	str	r3, [r7, #12]
	return partition_is_valid;
   12f8c:	68fb      	ldr	r3, [r7, #12]
}
   12f8e:	4618      	mov	r0, r3
   12f90:	3714      	adds	r7, #20
   12f92:	46bd      	mov	sp, r7
   12f94:	bc80      	pop	{r7}
   12f96:	4770      	bx	lr

00012f98 <get_region_index>:
{
   12f98:	b580      	push	{r7, lr}
   12f9a:	b084      	sub	sp, #16
   12f9c:	af00      	add	r7, sp, #0
   12f9e:	6078      	str	r0, [r7, #4]
   12fa0:	6039      	str	r1, [r7, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   12fa2:	6878      	ldr	r0, [r7, #4]
   12fa4:	f000 f841 	bl	1302a <arm_cmse_mpu_region_get>
   12fa8:	4603      	mov	r3, r0
   12faa:	60fb      	str	r3, [r7, #12]
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   12fac:	687a      	ldr	r2, [r7, #4]
   12fae:	683b      	ldr	r3, [r7, #0]
   12fb0:	4413      	add	r3, r2
   12fb2:	3b01      	subs	r3, #1
   12fb4:	4618      	mov	r0, r3
   12fb6:	f000 f838 	bl	1302a <arm_cmse_mpu_region_get>
   12fba:	4603      	mov	r3, r0
   12fbc:	60bb      	str	r3, [r7, #8]
	if (region_start_addr == region_end_addr) {
   12fbe:	68fa      	ldr	r2, [r7, #12]
   12fc0:	68bb      	ldr	r3, [r7, #8]
   12fc2:	429a      	cmp	r2, r3
   12fc4:	d101      	bne.n	12fca <get_region_index+0x32>
		return region_start_addr;
   12fc6:	68fb      	ldr	r3, [r7, #12]
   12fc8:	e001      	b.n	12fce <get_region_index+0x36>
	return -EINVAL;
   12fca:	f06f 0315 	mvn.w	r3, #21
}
   12fce:	4618      	mov	r0, r3
   12fd0:	3710      	adds	r7, #16
   12fd2:	46bd      	mov	sp, r7
   12fd4:	bd80      	pop	{r7, pc}

00012fd6 <get_region_attr_from_k_mem_partition_info>:
{
   12fd6:	b480      	push	{r7}
   12fd8:	b085      	sub	sp, #20
   12fda:	af00      	add	r7, sp, #0
   12fdc:	60f8      	str	r0, [r7, #12]
   12fde:	60b9      	str	r1, [r7, #8]
   12fe0:	607a      	str	r2, [r7, #4]
   12fe2:	603b      	str	r3, [r7, #0]
	p_attr->rbar = attr->rbar &
   12fe4:	68bb      	ldr	r3, [r7, #8]
   12fe6:	881b      	ldrh	r3, [r3, #0]
   12fe8:	f003 031f 	and.w	r3, r3, #31
   12fec:	b2d9      	uxtb	r1, r3
   12fee:	68fa      	ldr	r2, [r7, #12]
   12ff0:	7813      	ldrb	r3, [r2, #0]
   12ff2:	f361 0304 	bfi	r3, r1, #0, #5
   12ff6:	7013      	strb	r3, [r2, #0]
	p_attr->mair_idx = attr->mair_idx;
   12ff8:	68bb      	ldr	r3, [r7, #8]
   12ffa:	885b      	ldrh	r3, [r3, #2]
   12ffc:	f003 0307 	and.w	r3, r3, #7
   13000:	b2d9      	uxtb	r1, r3
   13002:	68fa      	ldr	r2, [r7, #12]
   13004:	7813      	ldrb	r3, [r2, #0]
   13006:	f361 1347 	bfi	r3, r1, #5, #3
   1300a:	7013      	strb	r3, [r2, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1300c:	687b      	ldr	r3, [r7, #4]
   1300e:	f023 021f 	bic.w	r2, r3, #31
   13012:	683b      	ldr	r3, [r7, #0]
   13014:	4413      	add	r3, r2
   13016:	3b01      	subs	r3, #1
   13018:	f023 021f 	bic.w	r2, r3, #31
   1301c:	68fb      	ldr	r3, [r7, #12]
   1301e:	605a      	str	r2, [r3, #4]
}
   13020:	bf00      	nop
   13022:	3714      	adds	r7, #20
   13024:	46bd      	mov	sp, r7
   13026:	bc80      	pop	{r7}
   13028:	4770      	bx	lr

0001302a <arm_cmse_mpu_region_get>:

#include <zephyr.h>
#include <aarch32/cortex_m/cmse.h>

int arm_cmse_mpu_region_get(uint32_t addr)
{
   1302a:	b480      	push	{r7}
   1302c:	b087      	sub	sp, #28
   1302e:	af00      	add	r7, sp, #0
   13030:	6078      	str	r0, [r7, #4]
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);
   13032:	687b      	ldr	r3, [r7, #4]
   13034:	617b      	str	r3, [r7, #20]
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   13036:	697b      	ldr	r3, [r7, #20]
   13038:	e843 f300 	tt	r3, r3
   1303c:	60fb      	str	r3, [r7, #12]
   1303e:	68fb      	ldr	r3, [r7, #12]
   13040:	613b      	str	r3, [r7, #16]

	if (addr_info.flags.mpu_region_valid) {
   13042:	7cbb      	ldrb	r3, [r7, #18]
   13044:	f003 0301 	and.w	r3, r3, #1
   13048:	b2db      	uxtb	r3, r3
   1304a:	2b00      	cmp	r3, #0
   1304c:	d001      	beq.n	13052 <arm_cmse_mpu_region_get+0x28>
		return addr_info.flags.mpu_region;
   1304e:	7c3b      	ldrb	r3, [r7, #16]
   13050:	e001      	b.n	13056 <arm_cmse_mpu_region_get+0x2c>
	}

	return -EINVAL;
   13052:	f06f 0315 	mvn.w	r3, #21
}
   13056:	4618      	mov	r0, r3
   13058:	371c      	adds	r7, #28
   1305a:	46bd      	mov	sp, r7
   1305c:	bc80      	pop	{r7}
   1305e:	4770      	bx	lr

00013060 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
   13060:	b480      	push	{r7}
   13062:	b087      	sub	sp, #28
   13064:	af00      	add	r7, sp, #0
   13066:	60f8      	str	r0, [r7, #12]
   13068:	60b9      	str	r1, [r7, #8]
   1306a:	607a      	str	r2, [r7, #4]
	char *dest = d;
   1306c:	68fb      	ldr	r3, [r7, #12]
   1306e:	617b      	str	r3, [r7, #20]

	while ((n > 0) && *s != '\0') {
   13070:	e00c      	b.n	1308c <strncpy+0x2c>
		*d = *s;
   13072:	68bb      	ldr	r3, [r7, #8]
   13074:	781a      	ldrb	r2, [r3, #0]
   13076:	68fb      	ldr	r3, [r7, #12]
   13078:	701a      	strb	r2, [r3, #0]
		s++;
   1307a:	68bb      	ldr	r3, [r7, #8]
   1307c:	3301      	adds	r3, #1
   1307e:	60bb      	str	r3, [r7, #8]
		d++;
   13080:	68fb      	ldr	r3, [r7, #12]
   13082:	3301      	adds	r3, #1
   13084:	60fb      	str	r3, [r7, #12]
		n--;
   13086:	687b      	ldr	r3, [r7, #4]
   13088:	3b01      	subs	r3, #1
   1308a:	607b      	str	r3, [r7, #4]
	while ((n > 0) && *s != '\0') {
   1308c:	687b      	ldr	r3, [r7, #4]
   1308e:	2b00      	cmp	r3, #0
   13090:	d00d      	beq.n	130ae <strncpy+0x4e>
   13092:	68bb      	ldr	r3, [r7, #8]
   13094:	781b      	ldrb	r3, [r3, #0]
   13096:	2b00      	cmp	r3, #0
   13098:	d1eb      	bne.n	13072 <strncpy+0x12>
	}

	while (n > 0) {
   1309a:	e008      	b.n	130ae <strncpy+0x4e>
		*d = '\0';
   1309c:	68fb      	ldr	r3, [r7, #12]
   1309e:	2200      	movs	r2, #0
   130a0:	701a      	strb	r2, [r3, #0]
		d++;
   130a2:	68fb      	ldr	r3, [r7, #12]
   130a4:	3301      	adds	r3, #1
   130a6:	60fb      	str	r3, [r7, #12]
		n--;
   130a8:	687b      	ldr	r3, [r7, #4]
   130aa:	3b01      	subs	r3, #1
   130ac:	607b      	str	r3, [r7, #4]
	while (n > 0) {
   130ae:	687b      	ldr	r3, [r7, #4]
   130b0:	2b00      	cmp	r3, #0
   130b2:	d1f3      	bne.n	1309c <strncpy+0x3c>
	}

	return dest;
   130b4:	697b      	ldr	r3, [r7, #20]
}
   130b6:	4618      	mov	r0, r3
   130b8:	371c      	adds	r7, #28
   130ba:	46bd      	mov	sp, r7
   130bc:	bc80      	pop	{r7}
   130be:	4770      	bx	lr

000130c0 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   130c0:	b480      	push	{r7}
   130c2:	b085      	sub	sp, #20
   130c4:	af00      	add	r7, sp, #0
   130c6:	6078      	str	r0, [r7, #4]
	size_t n = 0;
   130c8:	2300      	movs	r3, #0
   130ca:	60fb      	str	r3, [r7, #12]

	while (*s != '\0') {
   130cc:	e005      	b.n	130da <strlen+0x1a>
		s++;
   130ce:	687b      	ldr	r3, [r7, #4]
   130d0:	3301      	adds	r3, #1
   130d2:	607b      	str	r3, [r7, #4]
		n++;
   130d4:	68fb      	ldr	r3, [r7, #12]
   130d6:	3301      	adds	r3, #1
   130d8:	60fb      	str	r3, [r7, #12]
	while (*s != '\0') {
   130da:	687b      	ldr	r3, [r7, #4]
   130dc:	781b      	ldrb	r3, [r3, #0]
   130de:	2b00      	cmp	r3, #0
   130e0:	d1f5      	bne.n	130ce <strlen+0xe>
	}

	return n;
   130e2:	68fb      	ldr	r3, [r7, #12]
}
   130e4:	4618      	mov	r0, r3
   130e6:	3714      	adds	r7, #20
   130e8:	46bd      	mov	sp, r7
   130ea:	bc80      	pop	{r7}
   130ec:	4770      	bx	lr

000130ee <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
   130ee:	b480      	push	{r7}
   130f0:	b083      	sub	sp, #12
   130f2:	af00      	add	r7, sp, #0
   130f4:	6078      	str	r0, [r7, #4]
   130f6:	6039      	str	r1, [r7, #0]
	while ((*s1 == *s2) && (*s1 != '\0')) {
   130f8:	e005      	b.n	13106 <strcmp+0x18>
		s1++;
   130fa:	687b      	ldr	r3, [r7, #4]
   130fc:	3301      	adds	r3, #1
   130fe:	607b      	str	r3, [r7, #4]
		s2++;
   13100:	683b      	ldr	r3, [r7, #0]
   13102:	3301      	adds	r3, #1
   13104:	603b      	str	r3, [r7, #0]
	while ((*s1 == *s2) && (*s1 != '\0')) {
   13106:	687b      	ldr	r3, [r7, #4]
   13108:	781a      	ldrb	r2, [r3, #0]
   1310a:	683b      	ldr	r3, [r7, #0]
   1310c:	781b      	ldrb	r3, [r3, #0]
   1310e:	429a      	cmp	r2, r3
   13110:	d103      	bne.n	1311a <strcmp+0x2c>
   13112:	687b      	ldr	r3, [r7, #4]
   13114:	781b      	ldrb	r3, [r3, #0]
   13116:	2b00      	cmp	r3, #0
   13118:	d1ef      	bne.n	130fa <strcmp+0xc>
	}

	return *s1 - *s2;
   1311a:	687b      	ldr	r3, [r7, #4]
   1311c:	781b      	ldrb	r3, [r3, #0]
   1311e:	461a      	mov	r2, r3
   13120:	683b      	ldr	r3, [r7, #0]
   13122:	781b      	ldrb	r3, [r3, #0]
   13124:	1ad3      	subs	r3, r2, r3
}
   13126:	4618      	mov	r0, r3
   13128:	370c      	adds	r7, #12
   1312a:	46bd      	mov	sp, r7
   1312c:	bc80      	pop	{r7}
   1312e:	4770      	bx	lr

00013130 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   13130:	b480      	push	{r7}
   13132:	b08b      	sub	sp, #44	; 0x2c
   13134:	af00      	add	r7, sp, #0
   13136:	60f8      	str	r0, [r7, #12]
   13138:	60b9      	str	r1, [r7, #8]
   1313a:	607a      	str	r2, [r7, #4]
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
   1313c:	68fb      	ldr	r3, [r7, #12]
   1313e:	627b      	str	r3, [r7, #36]	; 0x24
	const unsigned char *s_byte = (const unsigned char *)s;
   13140:	68bb      	ldr	r3, [r7, #8]
   13142:	623b      	str	r3, [r7, #32]
	const uintptr_t mask = sizeof(mem_word_t) - 1;
   13144:	2303      	movs	r3, #3
   13146:	617b      	str	r3, [r7, #20]

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   13148:	68fa      	ldr	r2, [r7, #12]
   1314a:	6a3b      	ldr	r3, [r7, #32]
   1314c:	405a      	eors	r2, r3
   1314e:	697b      	ldr	r3, [r7, #20]
   13150:	4013      	ands	r3, r2
   13152:	2b00      	cmp	r3, #0
   13154:	d138      	bne.n	131c8 <memcpy+0x98>

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
   13156:	e00f      	b.n	13178 <memcpy+0x48>
			if (n == 0) {
   13158:	687b      	ldr	r3, [r7, #4]
   1315a:	2b00      	cmp	r3, #0
   1315c:	d101      	bne.n	13162 <memcpy+0x32>
				return d;
   1315e:	68fb      	ldr	r3, [r7, #12]
   13160:	e036      	b.n	131d0 <memcpy+0xa0>
			}
			*(d_byte++) = *(s_byte++);
   13162:	6a3a      	ldr	r2, [r7, #32]
   13164:	1c53      	adds	r3, r2, #1
   13166:	623b      	str	r3, [r7, #32]
   13168:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1316a:	1c59      	adds	r1, r3, #1
   1316c:	6279      	str	r1, [r7, #36]	; 0x24
   1316e:	7812      	ldrb	r2, [r2, #0]
   13170:	701a      	strb	r2, [r3, #0]
			n--;
   13172:	687b      	ldr	r3, [r7, #4]
   13174:	3b01      	subs	r3, #1
   13176:	607b      	str	r3, [r7, #4]
		while (((uintptr_t)d_byte) & mask) {
   13178:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1317a:	697b      	ldr	r3, [r7, #20]
   1317c:	4013      	ands	r3, r2
   1317e:	2b00      	cmp	r3, #0
   13180:	d1ea      	bne.n	13158 <memcpy+0x28>
		};

		/* do word-sized copying as long as possible */

		mem_word_t *d_word = (mem_word_t *)d_byte;
   13182:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13184:	61fb      	str	r3, [r7, #28]
		const mem_word_t *s_word = (const mem_word_t *)s_byte;
   13186:	6a3b      	ldr	r3, [r7, #32]
   13188:	61bb      	str	r3, [r7, #24]

		while (n >= sizeof(mem_word_t)) {
   1318a:	e00a      	b.n	131a2 <memcpy+0x72>
			*(d_word++) = *(s_word++);
   1318c:	69ba      	ldr	r2, [r7, #24]
   1318e:	1d13      	adds	r3, r2, #4
   13190:	61bb      	str	r3, [r7, #24]
   13192:	69fb      	ldr	r3, [r7, #28]
   13194:	1d19      	adds	r1, r3, #4
   13196:	61f9      	str	r1, [r7, #28]
   13198:	6812      	ldr	r2, [r2, #0]
   1319a:	601a      	str	r2, [r3, #0]
			n -= sizeof(mem_word_t);
   1319c:	687b      	ldr	r3, [r7, #4]
   1319e:	3b04      	subs	r3, #4
   131a0:	607b      	str	r3, [r7, #4]
		while (n >= sizeof(mem_word_t)) {
   131a2:	687b      	ldr	r3, [r7, #4]
   131a4:	2b03      	cmp	r3, #3
   131a6:	d8f1      	bhi.n	1318c <memcpy+0x5c>
		}

		d_byte = (unsigned char *)d_word;
   131a8:	69fb      	ldr	r3, [r7, #28]
   131aa:	627b      	str	r3, [r7, #36]	; 0x24
		s_byte = (unsigned char *)s_word;
   131ac:	69bb      	ldr	r3, [r7, #24]
   131ae:	623b      	str	r3, [r7, #32]
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   131b0:	e00a      	b.n	131c8 <memcpy+0x98>
		*(d_byte++) = *(s_byte++);
   131b2:	6a3a      	ldr	r2, [r7, #32]
   131b4:	1c53      	adds	r3, r2, #1
   131b6:	623b      	str	r3, [r7, #32]
   131b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   131ba:	1c59      	adds	r1, r3, #1
   131bc:	6279      	str	r1, [r7, #36]	; 0x24
   131be:	7812      	ldrb	r2, [r2, #0]
   131c0:	701a      	strb	r2, [r3, #0]
		n--;
   131c2:	687b      	ldr	r3, [r7, #4]
   131c4:	3b01      	subs	r3, #1
   131c6:	607b      	str	r3, [r7, #4]
	while (n > 0) {
   131c8:	687b      	ldr	r3, [r7, #4]
   131ca:	2b00      	cmp	r3, #0
   131cc:	d1f1      	bne.n	131b2 <memcpy+0x82>
	}

	return d;
   131ce:	68fb      	ldr	r3, [r7, #12]
}
   131d0:	4618      	mov	r0, r3
   131d2:	372c      	adds	r7, #44	; 0x2c
   131d4:	46bd      	mov	sp, r7
   131d6:	bc80      	pop	{r7}
   131d8:	4770      	bx	lr

000131da <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
   131da:	b480      	push	{r7}
   131dc:	b089      	sub	sp, #36	; 0x24
   131de:	af00      	add	r7, sp, #0
   131e0:	60f8      	str	r0, [r7, #12]
   131e2:	60b9      	str	r1, [r7, #8]
   131e4:	607a      	str	r2, [r7, #4]
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   131e6:	68fb      	ldr	r3, [r7, #12]
   131e8:	61fb      	str	r3, [r7, #28]
	unsigned char c_byte = (unsigned char)c;
   131ea:	68bb      	ldr	r3, [r7, #8]
   131ec:	75fb      	strb	r3, [r7, #23]

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   131ee:	e00c      	b.n	1320a <memset+0x30>
		if (n == 0) {
   131f0:	687b      	ldr	r3, [r7, #4]
   131f2:	2b00      	cmp	r3, #0
   131f4:	d101      	bne.n	131fa <memset+0x20>
			return buf;
   131f6:	68fb      	ldr	r3, [r7, #12]
   131f8:	e035      	b.n	13266 <memset+0x8c>
		}
		*(d_byte++) = c_byte;
   131fa:	69fb      	ldr	r3, [r7, #28]
   131fc:	1c5a      	adds	r2, r3, #1
   131fe:	61fa      	str	r2, [r7, #28]
   13200:	7dfa      	ldrb	r2, [r7, #23]
   13202:	701a      	strb	r2, [r3, #0]
		n--;
   13204:	687b      	ldr	r3, [r7, #4]
   13206:	3b01      	subs	r3, #1
   13208:	607b      	str	r3, [r7, #4]
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   1320a:	69fb      	ldr	r3, [r7, #28]
   1320c:	f003 0303 	and.w	r3, r3, #3
   13210:	2b00      	cmp	r3, #0
   13212:	d1ed      	bne.n	131f0 <memset+0x16>
	};

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
   13214:	69fb      	ldr	r3, [r7, #28]
   13216:	61bb      	str	r3, [r7, #24]
	mem_word_t c_word = (mem_word_t)c_byte;
   13218:	7dfb      	ldrb	r3, [r7, #23]
   1321a:	613b      	str	r3, [r7, #16]

	c_word |= c_word << 8;
   1321c:	693b      	ldr	r3, [r7, #16]
   1321e:	021b      	lsls	r3, r3, #8
   13220:	693a      	ldr	r2, [r7, #16]
   13222:	4313      	orrs	r3, r2
   13224:	613b      	str	r3, [r7, #16]
	c_word |= c_word << 16;
   13226:	693b      	ldr	r3, [r7, #16]
   13228:	041b      	lsls	r3, r3, #16
   1322a:	693a      	ldr	r2, [r7, #16]
   1322c:	4313      	orrs	r3, r2
   1322e:	613b      	str	r3, [r7, #16]
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   13230:	e007      	b.n	13242 <memset+0x68>
		*(d_word++) = c_word;
   13232:	69bb      	ldr	r3, [r7, #24]
   13234:	1d1a      	adds	r2, r3, #4
   13236:	61ba      	str	r2, [r7, #24]
   13238:	693a      	ldr	r2, [r7, #16]
   1323a:	601a      	str	r2, [r3, #0]
		n -= sizeof(mem_word_t);
   1323c:	687b      	ldr	r3, [r7, #4]
   1323e:	3b04      	subs	r3, #4
   13240:	607b      	str	r3, [r7, #4]
	while (n >= sizeof(mem_word_t)) {
   13242:	687b      	ldr	r3, [r7, #4]
   13244:	2b03      	cmp	r3, #3
   13246:	d8f4      	bhi.n	13232 <memset+0x58>
	}

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
   13248:	69bb      	ldr	r3, [r7, #24]
   1324a:	61fb      	str	r3, [r7, #28]

	while (n > 0) {
   1324c:	e007      	b.n	1325e <memset+0x84>
		*(d_byte++) = c_byte;
   1324e:	69fb      	ldr	r3, [r7, #28]
   13250:	1c5a      	adds	r2, r3, #1
   13252:	61fa      	str	r2, [r7, #28]
   13254:	7dfa      	ldrb	r2, [r7, #23]
   13256:	701a      	strb	r2, [r3, #0]
		n--;
   13258:	687b      	ldr	r3, [r7, #4]
   1325a:	3b01      	subs	r3, #1
   1325c:	607b      	str	r3, [r7, #4]
	while (n > 0) {
   1325e:	687b      	ldr	r3, [r7, #4]
   13260:	2b00      	cmp	r3, #0
   13262:	d1f4      	bne.n	1324e <memset+0x74>
	}

	return buf;
   13264:	68fb      	ldr	r3, [r7, #12]
}
   13266:	4618      	mov	r0, r3
   13268:	3724      	adds	r7, #36	; 0x24
   1326a:	46bd      	mov	sp, r7
   1326c:	bc80      	pop	{r7}
   1326e:	4770      	bx	lr

00013270 <_stdout_hook_default>:
{
   13270:	b480      	push	{r7}
   13272:	b083      	sub	sp, #12
   13274:	af00      	add	r7, sp, #0
   13276:	6078      	str	r0, [r7, #4]
	return EOF;
   13278:	f04f 33ff 	mov.w	r3, #4294967295
}
   1327c:	4618      	mov	r0, r3
   1327e:	370c      	adds	r7, #12
   13280:	46bd      	mov	sp, r7
   13282:	bc80      	pop	{r7}
   13284:	4770      	bx	lr

00013286 <z_snode_next_peek>:
{
   13286:	b480      	push	{r7}
   13288:	b083      	sub	sp, #12
   1328a:	af00      	add	r7, sp, #0
   1328c:	6078      	str	r0, [r7, #4]
	return node->next;
   1328e:	687b      	ldr	r3, [r7, #4]
   13290:	681b      	ldr	r3, [r3, #0]
}
   13292:	4618      	mov	r0, r3
   13294:	370c      	adds	r7, #12
   13296:	46bd      	mov	sp, r7
   13298:	bc80      	pop	{r7}
   1329a:	4770      	bx	lr

0001329c <z_snode_next_set>:
{
   1329c:	b480      	push	{r7}
   1329e:	b083      	sub	sp, #12
   132a0:	af00      	add	r7, sp, #0
   132a2:	6078      	str	r0, [r7, #4]
   132a4:	6039      	str	r1, [r7, #0]
	parent->next = child;
   132a6:	687b      	ldr	r3, [r7, #4]
   132a8:	683a      	ldr	r2, [r7, #0]
   132aa:	601a      	str	r2, [r3, #0]
}
   132ac:	bf00      	nop
   132ae:	370c      	adds	r7, #12
   132b0:	46bd      	mov	sp, r7
   132b2:	bc80      	pop	{r7}
   132b4:	4770      	bx	lr

000132b6 <z_slist_head_set>:
{
   132b6:	b480      	push	{r7}
   132b8:	b083      	sub	sp, #12
   132ba:	af00      	add	r7, sp, #0
   132bc:	6078      	str	r0, [r7, #4]
   132be:	6039      	str	r1, [r7, #0]
	list->head = node;
   132c0:	687b      	ldr	r3, [r7, #4]
   132c2:	683a      	ldr	r2, [r7, #0]
   132c4:	601a      	str	r2, [r3, #0]
}
   132c6:	bf00      	nop
   132c8:	370c      	adds	r7, #12
   132ca:	46bd      	mov	sp, r7
   132cc:	bc80      	pop	{r7}
   132ce:	4770      	bx	lr

000132d0 <z_slist_tail_set>:
{
   132d0:	b480      	push	{r7}
   132d2:	b083      	sub	sp, #12
   132d4:	af00      	add	r7, sp, #0
   132d6:	6078      	str	r0, [r7, #4]
   132d8:	6039      	str	r1, [r7, #0]
	list->tail = node;
   132da:	687b      	ldr	r3, [r7, #4]
   132dc:	683a      	ldr	r2, [r7, #0]
   132de:	605a      	str	r2, [r3, #4]
}
   132e0:	bf00      	nop
   132e2:	370c      	adds	r7, #12
   132e4:	46bd      	mov	sp, r7
   132e6:	bc80      	pop	{r7}
   132e8:	4770      	bx	lr

000132ea <sys_slist_peek_head>:
{
   132ea:	b480      	push	{r7}
   132ec:	b083      	sub	sp, #12
   132ee:	af00      	add	r7, sp, #0
   132f0:	6078      	str	r0, [r7, #4]
	return list->head;
   132f2:	687b      	ldr	r3, [r7, #4]
   132f4:	681b      	ldr	r3, [r3, #0]
}
   132f6:	4618      	mov	r0, r3
   132f8:	370c      	adds	r7, #12
   132fa:	46bd      	mov	sp, r7
   132fc:	bc80      	pop	{r7}
   132fe:	4770      	bx	lr

00013300 <sys_slist_peek_tail>:
{
   13300:	b480      	push	{r7}
   13302:	b083      	sub	sp, #12
   13304:	af00      	add	r7, sp, #0
   13306:	6078      	str	r0, [r7, #4]
	return list->tail;
   13308:	687b      	ldr	r3, [r7, #4]
   1330a:	685b      	ldr	r3, [r3, #4]
}
   1330c:	4618      	mov	r0, r3
   1330e:	370c      	adds	r7, #12
   13310:	46bd      	mov	sp, r7
   13312:	bc80      	pop	{r7}
   13314:	4770      	bx	lr

00013316 <sys_slist_is_empty>:
Z_GENLIST_IS_EMPTY(slist)
   13316:	b580      	push	{r7, lr}
   13318:	b082      	sub	sp, #8
   1331a:	af00      	add	r7, sp, #0
   1331c:	6078      	str	r0, [r7, #4]
   1331e:	6878      	ldr	r0, [r7, #4]
   13320:	f7ff ffe3 	bl	132ea <sys_slist_peek_head>
   13324:	4603      	mov	r3, r0
   13326:	2b00      	cmp	r3, #0
   13328:	bf0c      	ite	eq
   1332a:	2301      	moveq	r3, #1
   1332c:	2300      	movne	r3, #0
   1332e:	b2db      	uxtb	r3, r3
   13330:	4618      	mov	r0, r3
   13332:	3708      	adds	r7, #8
   13334:	46bd      	mov	sp, r7
   13336:	bd80      	pop	{r7, pc}

00013338 <sys_slist_peek_next_no_check>:
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13338:	b580      	push	{r7, lr}
   1333a:	b082      	sub	sp, #8
   1333c:	af00      	add	r7, sp, #0
   1333e:	6078      	str	r0, [r7, #4]
   13340:	6878      	ldr	r0, [r7, #4]
   13342:	f7ff ffa0 	bl	13286 <z_snode_next_peek>
   13346:	4603      	mov	r3, r0
   13348:	4618      	mov	r0, r3
   1334a:	3708      	adds	r7, #8
   1334c:	46bd      	mov	sp, r7
   1334e:	bd80      	pop	{r7, pc}

00013350 <sys_slist_peek_next>:
Z_GENLIST_PEEK_NEXT(slist, snode)
   13350:	b580      	push	{r7, lr}
   13352:	b082      	sub	sp, #8
   13354:	af00      	add	r7, sp, #0
   13356:	6078      	str	r0, [r7, #4]
   13358:	687b      	ldr	r3, [r7, #4]
   1335a:	2b00      	cmp	r3, #0
   1335c:	d004      	beq.n	13368 <sys_slist_peek_next+0x18>
   1335e:	6878      	ldr	r0, [r7, #4]
   13360:	f7ff ffea 	bl	13338 <sys_slist_peek_next_no_check>
   13364:	4603      	mov	r3, r0
   13366:	e000      	b.n	1336a <sys_slist_peek_next+0x1a>
   13368:	2300      	movs	r3, #0
   1336a:	4618      	mov	r0, r3
   1336c:	3708      	adds	r7, #8
   1336e:	46bd      	mov	sp, r7
   13370:	bd80      	pop	{r7, pc}

00013372 <sys_slist_prepend>:
Z_GENLIST_PREPEND(slist, snode)
   13372:	b580      	push	{r7, lr}
   13374:	b082      	sub	sp, #8
   13376:	af00      	add	r7, sp, #0
   13378:	6078      	str	r0, [r7, #4]
   1337a:	6039      	str	r1, [r7, #0]
   1337c:	6878      	ldr	r0, [r7, #4]
   1337e:	f7ff ffb4 	bl	132ea <sys_slist_peek_head>
   13382:	4603      	mov	r3, r0
   13384:	4619      	mov	r1, r3
   13386:	6838      	ldr	r0, [r7, #0]
   13388:	f7ff ff88 	bl	1329c <z_snode_next_set>
   1338c:	6839      	ldr	r1, [r7, #0]
   1338e:	6878      	ldr	r0, [r7, #4]
   13390:	f7ff ff91 	bl	132b6 <z_slist_head_set>
   13394:	6878      	ldr	r0, [r7, #4]
   13396:	f7ff ffb3 	bl	13300 <sys_slist_peek_tail>
   1339a:	4603      	mov	r3, r0
   1339c:	2b00      	cmp	r3, #0
   1339e:	d107      	bne.n	133b0 <sys_slist_prepend+0x3e>
   133a0:	6878      	ldr	r0, [r7, #4]
   133a2:	f7ff ffa2 	bl	132ea <sys_slist_peek_head>
   133a6:	4603      	mov	r3, r0
   133a8:	4619      	mov	r1, r3
   133aa:	6878      	ldr	r0, [r7, #4]
   133ac:	f7ff ff90 	bl	132d0 <z_slist_tail_set>
   133b0:	bf00      	nop
   133b2:	3708      	adds	r7, #8
   133b4:	46bd      	mov	sp, r7
   133b6:	bd80      	pop	{r7, pc}

000133b8 <sys_slist_remove>:
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   133b8:	b580      	push	{r7, lr}
   133ba:	b084      	sub	sp, #16
   133bc:	af00      	add	r7, sp, #0
   133be:	60f8      	str	r0, [r7, #12]
   133c0:	60b9      	str	r1, [r7, #8]
   133c2:	607a      	str	r2, [r7, #4]
   133c4:	68bb      	ldr	r3, [r7, #8]
   133c6:	2b00      	cmp	r3, #0
   133c8:	d117      	bne.n	133fa <sys_slist_remove+0x42>
   133ca:	6878      	ldr	r0, [r7, #4]
   133cc:	f7ff ff5b 	bl	13286 <z_snode_next_peek>
   133d0:	4603      	mov	r3, r0
   133d2:	4619      	mov	r1, r3
   133d4:	68f8      	ldr	r0, [r7, #12]
   133d6:	f7ff ff6e 	bl	132b6 <z_slist_head_set>
   133da:	68f8      	ldr	r0, [r7, #12]
   133dc:	f7ff ff90 	bl	13300 <sys_slist_peek_tail>
   133e0:	4602      	mov	r2, r0
   133e2:	687b      	ldr	r3, [r7, #4]
   133e4:	4293      	cmp	r3, r2
   133e6:	d11b      	bne.n	13420 <sys_slist_remove+0x68>
   133e8:	68f8      	ldr	r0, [r7, #12]
   133ea:	f7ff ff7e 	bl	132ea <sys_slist_peek_head>
   133ee:	4603      	mov	r3, r0
   133f0:	4619      	mov	r1, r3
   133f2:	68f8      	ldr	r0, [r7, #12]
   133f4:	f7ff ff6c 	bl	132d0 <z_slist_tail_set>
   133f8:	e012      	b.n	13420 <sys_slist_remove+0x68>
   133fa:	6878      	ldr	r0, [r7, #4]
   133fc:	f7ff ff43 	bl	13286 <z_snode_next_peek>
   13400:	4603      	mov	r3, r0
   13402:	4619      	mov	r1, r3
   13404:	68b8      	ldr	r0, [r7, #8]
   13406:	f7ff ff49 	bl	1329c <z_snode_next_set>
   1340a:	68f8      	ldr	r0, [r7, #12]
   1340c:	f7ff ff78 	bl	13300 <sys_slist_peek_tail>
   13410:	4602      	mov	r2, r0
   13412:	687b      	ldr	r3, [r7, #4]
   13414:	4293      	cmp	r3, r2
   13416:	d103      	bne.n	13420 <sys_slist_remove+0x68>
   13418:	68b9      	ldr	r1, [r7, #8]
   1341a:	68f8      	ldr	r0, [r7, #12]
   1341c:	f7ff ff58 	bl	132d0 <z_slist_tail_set>
   13420:	2100      	movs	r1, #0
   13422:	6878      	ldr	r0, [r7, #4]
   13424:	f7ff ff3a 	bl	1329c <z_snode_next_set>
   13428:	bf00      	nop
   1342a:	3710      	adds	r7, #16
   1342c:	46bd      	mov	sp, r7
   1342e:	bd80      	pop	{r7, pc}

00013430 <sys_slist_find_and_remove>:
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   13430:	b580      	push	{r7, lr}
   13432:	b084      	sub	sp, #16
   13434:	af00      	add	r7, sp, #0
   13436:	6078      	str	r0, [r7, #4]
   13438:	6039      	str	r1, [r7, #0]
   1343a:	2300      	movs	r3, #0
   1343c:	60fb      	str	r3, [r7, #12]
   1343e:	6878      	ldr	r0, [r7, #4]
   13440:	f7ff ff53 	bl	132ea <sys_slist_peek_head>
   13444:	60b8      	str	r0, [r7, #8]
   13446:	e010      	b.n	1346a <sys_slist_find_and_remove+0x3a>
   13448:	68ba      	ldr	r2, [r7, #8]
   1344a:	683b      	ldr	r3, [r7, #0]
   1344c:	429a      	cmp	r2, r3
   1344e:	d106      	bne.n	1345e <sys_slist_find_and_remove+0x2e>
   13450:	683a      	ldr	r2, [r7, #0]
   13452:	68f9      	ldr	r1, [r7, #12]
   13454:	6878      	ldr	r0, [r7, #4]
   13456:	f7ff ffaf 	bl	133b8 <sys_slist_remove>
   1345a:	2301      	movs	r3, #1
   1345c:	e009      	b.n	13472 <sys_slist_find_and_remove+0x42>
   1345e:	68bb      	ldr	r3, [r7, #8]
   13460:	60fb      	str	r3, [r7, #12]
   13462:	68b8      	ldr	r0, [r7, #8]
   13464:	f7ff ff74 	bl	13350 <sys_slist_peek_next>
   13468:	60b8      	str	r0, [r7, #8]
   1346a:	68bb      	ldr	r3, [r7, #8]
   1346c:	2b00      	cmp	r3, #0
   1346e:	d1eb      	bne.n	13448 <sys_slist_find_and_remove+0x18>
   13470:	2300      	movs	r3, #0
   13472:	4618      	mov	r0, r3
   13474:	3710      	adds	r7, #16
   13476:	46bd      	mov	sp, r7
   13478:	bd80      	pop	{r7, pc}

0001347a <atomic_or>:
{
   1347a:	b480      	push	{r7}
   1347c:	b083      	sub	sp, #12
   1347e:	af00      	add	r7, sp, #0
   13480:	6078      	str	r0, [r7, #4]
   13482:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   13484:	683a      	ldr	r2, [r7, #0]
   13486:	687b      	ldr	r3, [r7, #4]
   13488:	e8d3 1fef 	ldaex	r1, [r3]
   1348c:	ea41 0002 	orr.w	r0, r1, r2
   13490:	e8c3 0fec 	stlex	ip, r0, [r3]
   13494:	f1bc 0f00 	cmp.w	ip, #0
   13498:	d1f6      	bne.n	13488 <atomic_or+0xe>
   1349a:	460b      	mov	r3, r1
}
   1349c:	4618      	mov	r0, r3
   1349e:	370c      	adds	r7, #12
   134a0:	46bd      	mov	sp, r7
   134a2:	bc80      	pop	{r7}
   134a4:	4770      	bx	lr

000134a6 <atomic_and>:
{
   134a6:	b480      	push	{r7}
   134a8:	b083      	sub	sp, #12
   134aa:	af00      	add	r7, sp, #0
   134ac:	6078      	str	r0, [r7, #4]
   134ae:	6039      	str	r1, [r7, #0]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   134b0:	683a      	ldr	r2, [r7, #0]
   134b2:	687b      	ldr	r3, [r7, #4]
   134b4:	e8d3 1fef 	ldaex	r1, [r3]
   134b8:	ea01 0002 	and.w	r0, r1, r2
   134bc:	e8c3 0fec 	stlex	ip, r0, [r3]
   134c0:	f1bc 0f00 	cmp.w	ip, #0
   134c4:	d1f6      	bne.n	134b4 <atomic_and+0xe>
   134c6:	460b      	mov	r3, r1
}
   134c8:	4618      	mov	r0, r3
   134ca:	370c      	adds	r7, #12
   134cc:	46bd      	mov	sp, r7
   134ce:	bc80      	pop	{r7}
   134d0:	4770      	bx	lr

000134d2 <nrf_event_readback>:
{
   134d2:	b480      	push	{r7}
   134d4:	b083      	sub	sp, #12
   134d6:	af00      	add	r7, sp, #0
   134d8:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   134da:	687b      	ldr	r3, [r7, #4]
   134dc:	681b      	ldr	r3, [r3, #0]
}
   134de:	bf00      	nop
   134e0:	370c      	adds	r7, #12
   134e2:	46bd      	mov	sp, r7
   134e4:	bc80      	pop	{r7}
   134e6:	4770      	bx	lr

000134e8 <nrf_gpio_cfg>:
    nrf_gpio_pin_dir_t   dir,
    nrf_gpio_pin_input_t input,
    nrf_gpio_pin_pull_t  pull,
    nrf_gpio_pin_drive_t drive,
    nrf_gpio_pin_sense_t sense)
{
   134e8:	b580      	push	{r7, lr}
   134ea:	b084      	sub	sp, #16
   134ec:	af00      	add	r7, sp, #0
   134ee:	6078      	str	r0, [r7, #4]
   134f0:	4608      	mov	r0, r1
   134f2:	4611      	mov	r1, r2
   134f4:	461a      	mov	r2, r3
   134f6:	4603      	mov	r3, r0
   134f8:	70fb      	strb	r3, [r7, #3]
   134fa:	460b      	mov	r3, r1
   134fc:	70bb      	strb	r3, [r7, #2]
   134fe:	4613      	mov	r3, r2
   13500:	707b      	strb	r3, [r7, #1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   13502:	1d3b      	adds	r3, r7, #4
   13504:	4618      	mov	r0, r3
   13506:	f7f3 fc13 	bl	6d30 <nrf_gpio_pin_port_decode>
   1350a:	60f8      	str	r0, [r7, #12]

    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1350c:	78fa      	ldrb	r2, [r7, #3]
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   1350e:	78bb      	ldrb	r3, [r7, #2]
   13510:	005b      	lsls	r3, r3, #1
   13512:	431a      	orrs	r2, r3
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   13514:	787b      	ldrb	r3, [r7, #1]
   13516:	009b      	lsls	r3, r3, #2
   13518:	431a      	orrs	r2, r3
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1351a:	7e3b      	ldrb	r3, [r7, #24]
   1351c:	021b      	lsls	r3, r3, #8
   1351e:	ea42 0103 	orr.w	r1, r2, r3
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   13522:	7f3b      	ldrb	r3, [r7, #28]
   13524:	041b      	lsls	r3, r3, #16
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   13526:	687a      	ldr	r2, [r7, #4]
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   13528:	4319      	orrs	r1, r3
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1352a:	68fb      	ldr	r3, [r7, #12]
   1352c:	3280      	adds	r2, #128	; 0x80
   1352e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   13532:	bf00      	nop
   13534:	3710      	adds	r7, #16
   13536:	46bd      	mov	sp, r7
   13538:	bd80      	pop	{r7, pc}

0001353a <nrf_gpio_cfg_sense_set>:
}


NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
   1353a:	b580      	push	{r7, lr}
   1353c:	b084      	sub	sp, #16
   1353e:	af00      	add	r7, sp, #0
   13540:	6078      	str	r0, [r7, #4]
   13542:	460b      	mov	r3, r1
   13544:	70fb      	strb	r3, [r7, #3]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   13546:	1d3b      	adds	r3, r7, #4
   13548:	4618      	mov	r0, r3
   1354a:	f7f3 fbf1 	bl	6d30 <nrf_gpio_pin_port_decode>
   1354e:	60f8      	str	r0, [r7, #12]
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   13550:	687a      	ldr	r2, [r7, #4]
   13552:	68fb      	ldr	r3, [r7, #12]
   13554:	3280      	adds	r2, #128	; 0x80
   13556:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1355a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   1355e:	60bb      	str	r3, [r7, #8]

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   13560:	78fb      	ldrb	r3, [r7, #3]
   13562:	041b      	lsls	r3, r3, #16
   13564:	4619      	mov	r1, r3
   13566:	687a      	ldr	r2, [r7, #4]
   13568:	68bb      	ldr	r3, [r7, #8]
   1356a:	4319      	orrs	r1, r3
   1356c:	68fb      	ldr	r3, [r7, #12]
   1356e:	3280      	adds	r2, #128	; 0x80
   13570:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   13574:	bf00      	nop
   13576:	3710      	adds	r7, #16
   13578:	46bd      	mov	sp, r7
   1357a:	bd80      	pop	{r7, pc}

0001357c <nrf_gpio_pin_dir_get>:
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
}


NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
   1357c:	b580      	push	{r7, lr}
   1357e:	b084      	sub	sp, #16
   13580:	af00      	add	r7, sp, #0
   13582:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   13584:	1d3b      	adds	r3, r7, #4
   13586:	4618      	mov	r0, r3
   13588:	f7f3 fbd2 	bl	6d30 <nrf_gpio_pin_port_decode>
   1358c:	60f8      	str	r0, [r7, #12]

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1358e:	687a      	ldr	r2, [r7, #4]
   13590:	68fb      	ldr	r3, [r7, #12]
   13592:	3280      	adds	r2, #128	; 0x80
   13594:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13598:	b2db      	uxtb	r3, r3
   1359a:	f003 0301 	and.w	r3, r3, #1
   1359e:	b2db      	uxtb	r3, r3
                                 GPIO_PIN_CNF_DIR_Msk) >> GPIO_PIN_CNF_DIR_Pos);
}
   135a0:	4618      	mov	r0, r3
   135a2:	3710      	adds	r7, #16
   135a4:	46bd      	mov	sp, r7
   135a6:	bd80      	pop	{r7, pc}

000135a8 <nrf_gpio_port_in_read>:
    return p_reg->DIR;
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
   135a8:	b480      	push	{r7}
   135aa:	b083      	sub	sp, #12
   135ac:	af00      	add	r7, sp, #0
   135ae:	6078      	str	r0, [r7, #4]
    return p_reg->IN;
   135b0:	687b      	ldr	r3, [r7, #4]
   135b2:	691b      	ldr	r3, [r3, #16]
}
   135b4:	4618      	mov	r0, r3
   135b6:	370c      	adds	r7, #12
   135b8:	46bd      	mov	sp, r7
   135ba:	bc80      	pop	{r7}
   135bc:	4770      	bx	lr

000135be <nrf_gpio_port_out_read>:


NRF_STATIC_INLINE uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg)
{
   135be:	b480      	push	{r7}
   135c0:	b083      	sub	sp, #12
   135c2:	af00      	add	r7, sp, #0
   135c4:	6078      	str	r0, [r7, #4]
    return p_reg->OUT;
   135c6:	687b      	ldr	r3, [r7, #4]
   135c8:	685b      	ldr	r3, [r3, #4]
}
   135ca:	4618      	mov	r0, r3
   135cc:	370c      	adds	r7, #12
   135ce:	46bd      	mov	sp, r7
   135d0:	bc80      	pop	{r7}
   135d2:	4770      	bx	lr

000135d4 <nrf_gpio_port_out_write>:


NRF_STATIC_INLINE void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value)
{
   135d4:	b480      	push	{r7}
   135d6:	b083      	sub	sp, #12
   135d8:	af00      	add	r7, sp, #0
   135da:	6078      	str	r0, [r7, #4]
   135dc:	6039      	str	r1, [r7, #0]
    p_reg->OUT = value;
   135de:	687b      	ldr	r3, [r7, #4]
   135e0:	683a      	ldr	r2, [r7, #0]
   135e2:	605a      	str	r2, [r3, #4]
}
   135e4:	bf00      	nop
   135e6:	370c      	adds	r7, #12
   135e8:	46bd      	mov	sp, r7
   135ea:	bc80      	pop	{r7}
   135ec:	4770      	bx	lr

000135ee <nrf_gpio_port_out_set>:


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
   135ee:	b480      	push	{r7}
   135f0:	b083      	sub	sp, #12
   135f2:	af00      	add	r7, sp, #0
   135f4:	6078      	str	r0, [r7, #4]
   135f6:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   135f8:	687b      	ldr	r3, [r7, #4]
   135fa:	683a      	ldr	r2, [r7, #0]
   135fc:	609a      	str	r2, [r3, #8]
}
   135fe:	bf00      	nop
   13600:	370c      	adds	r7, #12
   13602:	46bd      	mov	sp, r7
   13604:	bc80      	pop	{r7}
   13606:	4770      	bx	lr

00013608 <nrf_gpio_port_out_clear>:


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
   13608:	b480      	push	{r7}
   1360a:	b083      	sub	sp, #12
   1360c:	af00      	add	r7, sp, #0
   1360e:	6078      	str	r0, [r7, #4]
   13610:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   13612:	687b      	ldr	r3, [r7, #4]
   13614:	683a      	ldr	r2, [r7, #0]
   13616:	60da      	str	r2, [r3, #12]
}
   13618:	bf00      	nop
   1361a:	370c      	adds	r7, #12
   1361c:	46bd      	mov	sp, r7
   1361e:	bc80      	pop	{r7}
   13620:	4770      	bx	lr

00013622 <nrf_gpio_pin_present_check>:
    reg->PIN_CNF[pin_number] = cnf | (mcu << GPIO_PIN_CNF_MCUSEL_Pos);
}
#endif

NRF_STATIC_INLINE bool nrf_gpio_pin_present_check(uint32_t pin_number)
{
   13622:	b480      	push	{r7}
   13624:	b085      	sub	sp, #20
   13626:	af00      	add	r7, sp, #0
   13628:	6078      	str	r0, [r7, #4]
    uint32_t port = pin_number >> 5;
   1362a:	687b      	ldr	r3, [r7, #4]
   1362c:	095b      	lsrs	r3, r3, #5
   1362e:	60bb      	str	r3, [r7, #8]
    uint32_t mask = 0;
   13630:	2300      	movs	r3, #0
   13632:	60fb      	str	r3, [r7, #12]

    switch (port)
   13634:	68bb      	ldr	r3, [r7, #8]
   13636:	2b00      	cmp	r3, #0
   13638:	d103      	bne.n	13642 <nrf_gpio_pin_present_check+0x20>
    {
#ifdef P0_FEATURE_PINS_PRESENT
        case 0:
            mask = P0_FEATURE_PINS_PRESENT;
   1363a:	f04f 33ff 	mov.w	r3, #4294967295
   1363e:	60fb      	str	r3, [r7, #12]
             * - P0.24 - Button 3
             * - P0.25 - Button 4
             */
            mask |= 0x03003800;
#endif // defined(NRF52820_XXAA) && defined(DEVELOP_IN_NRF52833)
            break;
   13640:	bf00      	nop
            mask = P1_FEATURE_PINS_PRESENT;
            break;
#endif
    }

    pin_number &= 0x1F;
   13642:	687b      	ldr	r3, [r7, #4]
   13644:	f003 031f 	and.w	r3, r3, #31
   13648:	607b      	str	r3, [r7, #4]

    return (mask & (1UL << pin_number)) ? true : false;
   1364a:	68fa      	ldr	r2, [r7, #12]
   1364c:	687b      	ldr	r3, [r7, #4]
   1364e:	fa22 f303 	lsr.w	r3, r2, r3
   13652:	f003 0301 	and.w	r3, r3, #1
   13656:	2b00      	cmp	r3, #0
   13658:	bf14      	ite	ne
   1365a:	2301      	movne	r3, #1
   1365c:	2300      	moveq	r3, #0
   1365e:	b2db      	uxtb	r3, r3
}
   13660:	4618      	mov	r0, r3
   13662:	3714      	adds	r7, #20
   13664:	46bd      	mov	sp, r7
   13666:	bc80      	pop	{r7}
   13668:	4770      	bx	lr

0001366a <nrf_gpio_pin_port_number_extract>:

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
   1366a:	b480      	push	{r7}
   1366c:	b085      	sub	sp, #20
   1366e:	af00      	add	r7, sp, #0
   13670:	6078      	str	r0, [r7, #4]
    uint32_t pin_number = *p_pin;
   13672:	687b      	ldr	r3, [r7, #4]
   13674:	681b      	ldr	r3, [r3, #0]
   13676:	60fb      	str	r3, [r7, #12]
    *p_pin = pin_number & 0x1F;
   13678:	68fb      	ldr	r3, [r7, #12]
   1367a:	f003 021f 	and.w	r2, r3, #31
   1367e:	687b      	ldr	r3, [r7, #4]
   13680:	601a      	str	r2, [r3, #0]

    return pin_number >> 5;
   13682:	68fb      	ldr	r3, [r7, #12]
   13684:	095b      	lsrs	r3, r3, #5
}
   13686:	4618      	mov	r0, r3
   13688:	3714      	adds	r7, #20
   1368a:	46bd      	mov	sp, r7
   1368c:	bc80      	pop	{r7}
   1368e:	4770      	bx	lr

00013690 <nrf_gpiote_event_check>:
{
   13690:	b480      	push	{r7}
   13692:	b083      	sub	sp, #12
   13694:	af00      	add	r7, sp, #0
   13696:	6078      	str	r0, [r7, #4]
   13698:	460b      	mov	r3, r1
   1369a:	807b      	strh	r3, [r7, #2]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1369c:	887b      	ldrh	r3, [r7, #2]
   1369e:	687a      	ldr	r2, [r7, #4]
   136a0:	4413      	add	r3, r2
   136a2:	681b      	ldr	r3, [r3, #0]
   136a4:	2b00      	cmp	r3, #0
   136a6:	bf14      	ite	ne
   136a8:	2301      	movne	r3, #1
   136aa:	2300      	moveq	r3, #0
   136ac:	b2db      	uxtb	r3, r3
}
   136ae:	4618      	mov	r0, r3
   136b0:	370c      	adds	r7, #12
   136b2:	46bd      	mov	sp, r7
   136b4:	bc80      	pop	{r7}
   136b6:	4770      	bx	lr

000136b8 <nrf_gpiote_event_clear>:
{
   136b8:	b580      	push	{r7, lr}
   136ba:	b082      	sub	sp, #8
   136bc:	af00      	add	r7, sp, #0
   136be:	6078      	str	r0, [r7, #4]
   136c0:	460b      	mov	r3, r1
   136c2:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   136c4:	887b      	ldrh	r3, [r7, #2]
   136c6:	4619      	mov	r1, r3
   136c8:	6878      	ldr	r0, [r7, #4]
   136ca:	f000 f811 	bl	136f0 <nrf_gpiote_event_address_get>
   136ce:	4603      	mov	r3, r0
   136d0:	461a      	mov	r2, r3
   136d2:	2300      	movs	r3, #0
   136d4:	6013      	str	r3, [r2, #0]
    nrf_event_readback((void *)nrf_gpiote_event_address_get(p_reg, event));
   136d6:	887b      	ldrh	r3, [r7, #2]
   136d8:	4619      	mov	r1, r3
   136da:	6878      	ldr	r0, [r7, #4]
   136dc:	f000 f808 	bl	136f0 <nrf_gpiote_event_address_get>
   136e0:	4603      	mov	r3, r0
   136e2:	4618      	mov	r0, r3
   136e4:	f7ff fef5 	bl	134d2 <nrf_event_readback>
}
   136e8:	bf00      	nop
   136ea:	3708      	adds	r7, #8
   136ec:	46bd      	mov	sp, r7
   136ee:	bd80      	pop	{r7, pc}

000136f0 <nrf_gpiote_event_address_get>:
{
   136f0:	b480      	push	{r7}
   136f2:	b083      	sub	sp, #12
   136f4:	af00      	add	r7, sp, #0
   136f6:	6078      	str	r0, [r7, #4]
   136f8:	460b      	mov	r3, r1
   136fa:	807b      	strh	r3, [r7, #2]
    return ((uint32_t)p_reg + event);
   136fc:	887a      	ldrh	r2, [r7, #2]
   136fe:	687b      	ldr	r3, [r7, #4]
   13700:	4413      	add	r3, r2
}
   13702:	4618      	mov	r0, r3
   13704:	370c      	adds	r7, #12
   13706:	46bd      	mov	sp, r7
   13708:	bc80      	pop	{r7}
   1370a:	4770      	bx	lr

0001370c <nrf_gpiote_int_enable>:
{
   1370c:	b480      	push	{r7}
   1370e:	b083      	sub	sp, #12
   13710:	af00      	add	r7, sp, #0
   13712:	6078      	str	r0, [r7, #4]
   13714:	6039      	str	r1, [r7, #0]
    p_reg->INTENSET = mask;
   13716:	687b      	ldr	r3, [r7, #4]
   13718:	683a      	ldr	r2, [r7, #0]
   1371a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1371e:	bf00      	nop
   13720:	370c      	adds	r7, #12
   13722:	46bd      	mov	sp, r7
   13724:	bc80      	pop	{r7}
   13726:	4770      	bx	lr

00013728 <nrf_gpiote_int_disable>:
{
   13728:	b480      	push	{r7}
   1372a:	b083      	sub	sp, #12
   1372c:	af00      	add	r7, sp, #0
   1372e:	6078      	str	r0, [r7, #4]
   13730:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   13732:	687b      	ldr	r3, [r7, #4]
   13734:	683a      	ldr	r2, [r7, #0]
   13736:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   1373a:	bf00      	nop
   1373c:	370c      	adds	r7, #12
   1373e:	46bd      	mov	sp, r7
   13740:	bc80      	pop	{r7}
   13742:	4770      	bx	lr

00013744 <nrf_gpiote_int_enable_check>:
{
   13744:	b480      	push	{r7}
   13746:	b083      	sub	sp, #12
   13748:	af00      	add	r7, sp, #0
   1374a:	6078      	str	r0, [r7, #4]
   1374c:	6039      	str	r1, [r7, #0]
    return p_reg->INTENSET & mask;
   1374e:	687b      	ldr	r3, [r7, #4]
   13750:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
   13754:	683b      	ldr	r3, [r7, #0]
   13756:	4013      	ands	r3, r2
}
   13758:	4618      	mov	r0, r3
   1375a:	370c      	adds	r7, #12
   1375c:	46bd      	mov	sp, r7
   1375e:	bc80      	pop	{r7}
   13760:	4770      	bx	lr

00013762 <nrf_gpiote_event_enable>:
{
   13762:	b480      	push	{r7}
   13764:	b083      	sub	sp, #12
   13766:	af00      	add	r7, sp, #0
   13768:	6078      	str	r0, [r7, #4]
   1376a:	6039      	str	r1, [r7, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   1376c:	687b      	ldr	r3, [r7, #4]
   1376e:	683a      	ldr	r2, [r7, #0]
   13770:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   13774:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13778:	f043 0101 	orr.w	r1, r3, #1
   1377c:	687b      	ldr	r3, [r7, #4]
   1377e:	683a      	ldr	r2, [r7, #0]
   13780:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   13784:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   13788:	bf00      	nop
   1378a:	370c      	adds	r7, #12
   1378c:	46bd      	mov	sp, r7
   1378e:	bc80      	pop	{r7}
   13790:	4770      	bx	lr

00013792 <nrf_gpiote_event_disable>:
{
   13792:	b480      	push	{r7}
   13794:	b083      	sub	sp, #12
   13796:	af00      	add	r7, sp, #0
   13798:	6078      	str	r0, [r7, #4]
   1379a:	6039      	str	r1, [r7, #0]
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   1379c:	687b      	ldr	r3, [r7, #4]
   1379e:	683a      	ldr	r2, [r7, #0]
   137a0:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   137a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   137a8:	f023 0101 	bic.w	r1, r3, #1
   137ac:	687b      	ldr	r3, [r7, #4]
   137ae:	683a      	ldr	r2, [r7, #0]
   137b0:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   137b4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   137b8:	bf00      	nop
   137ba:	370c      	adds	r7, #12
   137bc:	46bd      	mov	sp, r7
   137be:	bc80      	pop	{r7}
   137c0:	4770      	bx	lr

000137c2 <nrf_gpiote_event_configure>:
{
   137c2:	b480      	push	{r7}
   137c4:	b085      	sub	sp, #20
   137c6:	af00      	add	r7, sp, #0
   137c8:	60f8      	str	r0, [r7, #12]
   137ca:	60b9      	str	r1, [r7, #8]
   137cc:	607a      	str	r2, [r7, #4]
   137ce:	70fb      	strb	r3, [r7, #3]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   137d0:	68fb      	ldr	r3, [r7, #12]
   137d2:	68ba      	ldr	r2, [r7, #8]
   137d4:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   137d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   137dc:	f423 3347 	bic.w	r3, r3, #203776	; 0x31c00
   137e0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   137e4:	68fa      	ldr	r2, [r7, #12]
   137e6:	68b9      	ldr	r1, [r7, #8]
   137e8:	f501 71a2 	add.w	r1, r1, #324	; 0x144
   137ec:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   137f0:	68fb      	ldr	r3, [r7, #12]
   137f2:	68ba      	ldr	r2, [r7, #8]
   137f4:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   137f8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   137fc:	687b      	ldr	r3, [r7, #4]
   137fe:	021b      	lsls	r3, r3, #8
   13800:	f403 51f8 	and.w	r1, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
   13804:	78fb      	ldrb	r3, [r7, #3]
   13806:	041b      	lsls	r3, r3, #16
   13808:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1380c:	430b      	orrs	r3, r1
   1380e:	ea42 0103 	orr.w	r1, r2, r3
   13812:	68fb      	ldr	r3, [r7, #12]
   13814:	68ba      	ldr	r2, [r7, #8]
   13816:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1381a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   1381e:	bf00      	nop
   13820:	3714      	adds	r7, #20
   13822:	46bd      	mov	sp, r7
   13824:	bc80      	pop	{r7}
   13826:	4770      	bx	lr

00013828 <nrf_gpiote_event_pin_get>:
{
   13828:	b480      	push	{r7}
   1382a:	b083      	sub	sp, #12
   1382c:	af00      	add	r7, sp, #0
   1382e:	6078      	str	r0, [r7, #4]
   13830:	6039      	str	r1, [r7, #0]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   13832:	687b      	ldr	r3, [r7, #4]
   13834:	683a      	ldr	r2, [r7, #0]
   13836:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1383a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1383e:	0a1b      	lsrs	r3, r3, #8
   13840:	f003 031f 	and.w	r3, r3, #31
}
   13844:	4618      	mov	r0, r3
   13846:	370c      	adds	r7, #12
   13848:	46bd      	mov	sp, r7
   1384a:	bc80      	pop	{r7}
   1384c:	4770      	bx	lr

0001384e <get_port_data>:
{
   1384e:	b480      	push	{r7}
   13850:	b083      	sub	sp, #12
   13852:	af00      	add	r7, sp, #0
   13854:	6078      	str	r0, [r7, #4]
	return port->data;
   13856:	687b      	ldr	r3, [r7, #4]
   13858:	68db      	ldr	r3, [r3, #12]
}
   1385a:	4618      	mov	r0, r3
   1385c:	370c      	adds	r7, #12
   1385e:	46bd      	mov	sp, r7
   13860:	bc80      	pop	{r7}
   13862:	4770      	bx	lr

00013864 <get_port_cfg>:
{
   13864:	b480      	push	{r7}
   13866:	b083      	sub	sp, #12
   13868:	af00      	add	r7, sp, #0
   1386a:	6078      	str	r0, [r7, #4]
	return port->config;
   1386c:	687b      	ldr	r3, [r7, #4]
   1386e:	685b      	ldr	r3, [r3, #4]
}
   13870:	4618      	mov	r0, r3
   13872:	370c      	adds	r7, #12
   13874:	46bd      	mov	sp, r7
   13876:	bc80      	pop	{r7}
   13878:	4770      	bx	lr

0001387a <sense_for_pin>:
{
   1387a:	b480      	push	{r7}
   1387c:	b083      	sub	sp, #12
   1387e:	af00      	add	r7, sp, #0
   13880:	6078      	str	r0, [r7, #4]
   13882:	6039      	str	r1, [r7, #0]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   13884:	687b      	ldr	r3, [r7, #4]
   13886:	691a      	ldr	r2, [r3, #16]
   13888:	683b      	ldr	r3, [r7, #0]
   1388a:	fa22 f303 	lsr.w	r3, r2, r3
   1388e:	f003 0301 	and.w	r3, r3, #1
   13892:	2b00      	cmp	r3, #0
   13894:	d001      	beq.n	1389a <sense_for_pin+0x20>
		return NRF_GPIO_PIN_SENSE_HIGH;
   13896:	2302      	movs	r3, #2
   13898:	e000      	b.n	1389c <sense_for_pin+0x22>
	return NRF_GPIO_PIN_SENSE_LOW;
   1389a:	2303      	movs	r3, #3
}
   1389c:	4618      	mov	r0, r3
   1389e:	370c      	adds	r7, #12
   138a0:	46bd      	mov	sp, r7
   138a2:	bc80      	pop	{r7}
   138a4:	4770      	bx	lr

000138a6 <gpio_nrfx_port_get_raw>:
{
   138a6:	b580      	push	{r7, lr}
   138a8:	b084      	sub	sp, #16
   138aa:	af00      	add	r7, sp, #0
   138ac:	6078      	str	r0, [r7, #4]
   138ae:	6039      	str	r1, [r7, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   138b0:	6878      	ldr	r0, [r7, #4]
   138b2:	f7ff ffd7 	bl	13864 <get_port_cfg>
   138b6:	4603      	mov	r3, r0
   138b8:	685b      	ldr	r3, [r3, #4]
   138ba:	60fb      	str	r3, [r7, #12]
	*value = nrf_gpio_port_in_read(reg);
   138bc:	68f8      	ldr	r0, [r7, #12]
   138be:	f7ff fe73 	bl	135a8 <nrf_gpio_port_in_read>
   138c2:	4602      	mov	r2, r0
   138c4:	683b      	ldr	r3, [r7, #0]
   138c6:	601a      	str	r2, [r3, #0]
	return 0;
   138c8:	2300      	movs	r3, #0
}
   138ca:	4618      	mov	r0, r3
   138cc:	3710      	adds	r7, #16
   138ce:	46bd      	mov	sp, r7
   138d0:	bd80      	pop	{r7, pc}

000138d2 <gpio_nrfx_port_set_masked_raw>:
{
   138d2:	b580      	push	{r7, lr}
   138d4:	b086      	sub	sp, #24
   138d6:	af00      	add	r7, sp, #0
   138d8:	60f8      	str	r0, [r7, #12]
   138da:	60b9      	str	r1, [r7, #8]
   138dc:	607a      	str	r2, [r7, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   138de:	68f8      	ldr	r0, [r7, #12]
   138e0:	f7ff ffc0 	bl	13864 <get_port_cfg>
   138e4:	4603      	mov	r3, r0
   138e6:	685b      	ldr	r3, [r3, #4]
   138e8:	617b      	str	r3, [r7, #20]
	value_tmp = nrf_gpio_port_out_read(reg) & ~mask;
   138ea:	6978      	ldr	r0, [r7, #20]
   138ec:	f7ff fe67 	bl	135be <nrf_gpio_port_out_read>
   138f0:	4602      	mov	r2, r0
   138f2:	68bb      	ldr	r3, [r7, #8]
   138f4:	43db      	mvns	r3, r3
   138f6:	4013      	ands	r3, r2
   138f8:	613b      	str	r3, [r7, #16]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   138fa:	68ba      	ldr	r2, [r7, #8]
   138fc:	687b      	ldr	r3, [r7, #4]
   138fe:	401a      	ands	r2, r3
   13900:	693b      	ldr	r3, [r7, #16]
   13902:	4313      	orrs	r3, r2
   13904:	4619      	mov	r1, r3
   13906:	6978      	ldr	r0, [r7, #20]
   13908:	f7ff fe64 	bl	135d4 <nrf_gpio_port_out_write>
	return 0;
   1390c:	2300      	movs	r3, #0
}
   1390e:	4618      	mov	r0, r3
   13910:	3718      	adds	r7, #24
   13912:	46bd      	mov	sp, r7
   13914:	bd80      	pop	{r7, pc}

00013916 <gpio_nrfx_port_set_bits_raw>:
{
   13916:	b580      	push	{r7, lr}
   13918:	b084      	sub	sp, #16
   1391a:	af00      	add	r7, sp, #0
   1391c:	6078      	str	r0, [r7, #4]
   1391e:	6039      	str	r1, [r7, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   13920:	6878      	ldr	r0, [r7, #4]
   13922:	f7ff ff9f 	bl	13864 <get_port_cfg>
   13926:	4603      	mov	r3, r0
   13928:	685b      	ldr	r3, [r3, #4]
   1392a:	60fb      	str	r3, [r7, #12]
	nrf_gpio_port_out_set(reg, mask);
   1392c:	6839      	ldr	r1, [r7, #0]
   1392e:	68f8      	ldr	r0, [r7, #12]
   13930:	f7ff fe5d 	bl	135ee <nrf_gpio_port_out_set>
	return 0;
   13934:	2300      	movs	r3, #0
}
   13936:	4618      	mov	r0, r3
   13938:	3710      	adds	r7, #16
   1393a:	46bd      	mov	sp, r7
   1393c:	bd80      	pop	{r7, pc}

0001393e <gpio_nrfx_port_clear_bits_raw>:
{
   1393e:	b580      	push	{r7, lr}
   13940:	b084      	sub	sp, #16
   13942:	af00      	add	r7, sp, #0
   13944:	6078      	str	r0, [r7, #4]
   13946:	6039      	str	r1, [r7, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   13948:	6878      	ldr	r0, [r7, #4]
   1394a:	f7ff ff8b 	bl	13864 <get_port_cfg>
   1394e:	4603      	mov	r3, r0
   13950:	685b      	ldr	r3, [r3, #4]
   13952:	60fb      	str	r3, [r7, #12]
	nrf_gpio_port_out_clear(reg, mask);
   13954:	6839      	ldr	r1, [r7, #0]
   13956:	68f8      	ldr	r0, [r7, #12]
   13958:	f7ff fe56 	bl	13608 <nrf_gpio_port_out_clear>
	return 0;
   1395c:	2300      	movs	r3, #0
}
   1395e:	4618      	mov	r0, r3
   13960:	3710      	adds	r7, #16
   13962:	46bd      	mov	sp, r7
   13964:	bd80      	pop	{r7, pc}

00013966 <gpio_nrfx_port_toggle_bits>:
{
   13966:	b580      	push	{r7, lr}
   13968:	b084      	sub	sp, #16
   1396a:	af00      	add	r7, sp, #0
   1396c:	6078      	str	r0, [r7, #4]
   1396e:	6039      	str	r1, [r7, #0]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   13970:	6878      	ldr	r0, [r7, #4]
   13972:	f7ff ff77 	bl	13864 <get_port_cfg>
   13976:	4603      	mov	r3, r0
   13978:	685b      	ldr	r3, [r3, #4]
   1397a:	60fb      	str	r3, [r7, #12]
	value = nrf_gpio_port_out_read(reg);
   1397c:	68f8      	ldr	r0, [r7, #12]
   1397e:	f7ff fe1e 	bl	135be <nrf_gpio_port_out_read>
   13982:	60b8      	str	r0, [r7, #8]
	nrf_gpio_port_out_write(reg, value ^ mask);
   13984:	68ba      	ldr	r2, [r7, #8]
   13986:	683b      	ldr	r3, [r7, #0]
   13988:	4053      	eors	r3, r2
   1398a:	4619      	mov	r1, r3
   1398c:	68f8      	ldr	r0, [r7, #12]
   1398e:	f7ff fe21 	bl	135d4 <nrf_gpio_port_out_write>
	return 0;
   13992:	2300      	movs	r3, #0
}
   13994:	4618      	mov	r0, r3
   13996:	3710      	adds	r7, #16
   13998:	46bd      	mov	sp, r7
   1399a:	bd80      	pop	{r7, pc}

0001399c <gpio_nrfx_pin_interrupt_configure>:
{
   1399c:	b580      	push	{r7, lr}
   1399e:	b086      	sub	sp, #24
   139a0:	af00      	add	r7, sp, #0
   139a2:	60f8      	str	r0, [r7, #12]
   139a4:	607a      	str	r2, [r7, #4]
   139a6:	603b      	str	r3, [r7, #0]
   139a8:	460b      	mov	r3, r1
   139aa:	72fb      	strb	r3, [r7, #11]
	struct gpio_nrfx_data *data = get_port_data(port);
   139ac:	68f8      	ldr	r0, [r7, #12]
   139ae:	f7ff ff4e 	bl	1384e <get_port_data>
   139b2:	6178      	str	r0, [r7, #20]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   139b4:	68f8      	ldr	r0, [r7, #12]
   139b6:	f7ff ff55 	bl	13864 <get_port_cfg>
   139ba:	4603      	mov	r3, r0
   139bc:	7a1b      	ldrb	r3, [r3, #8]
   139be:	015a      	lsls	r2, r3, #5
   139c0:	7afb      	ldrb	r3, [r7, #11]
   139c2:	f003 031f 	and.w	r3, r3, #31
   139c6:	4313      	orrs	r3, r2
   139c8:	613b      	str	r3, [r7, #16]
	if ((mode == GPIO_INT_MODE_EDGE) &&
   139ca:	687b      	ldr	r3, [r7, #4]
   139cc:	f5b3 3fa0 	cmp.w	r3, #81920	; 0x14000
   139d0:	d108      	bne.n	139e4 <gpio_nrfx_pin_interrupt_configure+0x48>
	    (nrf_gpio_pin_dir_get(abs_pin) == NRF_GPIO_PIN_DIR_OUTPUT)) {
   139d2:	6938      	ldr	r0, [r7, #16]
   139d4:	f7ff fdd2 	bl	1357c <nrf_gpio_pin_dir_get>
   139d8:	4603      	mov	r3, r0
	if ((mode == GPIO_INT_MODE_EDGE) &&
   139da:	2b01      	cmp	r3, #1
   139dc:	d102      	bne.n	139e4 <gpio_nrfx_pin_interrupt_configure+0x48>
		return -ENOTSUP;
   139de:	f06f 0322 	mvn.w	r3, #34	; 0x22
   139e2:	e05d      	b.n	13aa0 <gpio_nrfx_pin_interrupt_configure+0x104>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   139e4:	687b      	ldr	r3, [r7, #4]
   139e6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   139ea:	d007      	beq.n	139fc <gpio_nrfx_pin_interrupt_configure+0x60>
   139ec:	697b      	ldr	r3, [r7, #20]
   139ee:	68da      	ldr	r2, [r3, #12]
   139f0:	7afb      	ldrb	r3, [r7, #11]
   139f2:	2101      	movs	r1, #1
   139f4:	fa01 f303 	lsl.w	r3, r1, r3
   139f8:	4313      	orrs	r3, r2
   139fa:	e007      	b.n	13a0c <gpio_nrfx_pin_interrupt_configure+0x70>
   139fc:	697b      	ldr	r3, [r7, #20]
   139fe:	68da      	ldr	r2, [r3, #12]
   13a00:	7afb      	ldrb	r3, [r7, #11]
   13a02:	2101      	movs	r1, #1
   13a04:	fa01 f303 	lsl.w	r3, r1, r3
   13a08:	43db      	mvns	r3, r3
   13a0a:	4013      	ands	r3, r2
   13a0c:	697a      	ldr	r2, [r7, #20]
   13a0e:	60d3      	str	r3, [r2, #12]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
   13a10:	687b      	ldr	r3, [r7, #4]
   13a12:	f5b3 3fa0 	cmp.w	r3, #81920	; 0x14000
   13a16:	d107      	bne.n	13a28 <gpio_nrfx_pin_interrupt_configure+0x8c>
   13a18:	697b      	ldr	r3, [r7, #20]
   13a1a:	695a      	ldr	r2, [r3, #20]
   13a1c:	7afb      	ldrb	r3, [r7, #11]
   13a1e:	2101      	movs	r1, #1
   13a20:	fa01 f303 	lsl.w	r3, r1, r3
   13a24:	4313      	orrs	r3, r2
   13a26:	e007      	b.n	13a38 <gpio_nrfx_pin_interrupt_configure+0x9c>
   13a28:	697b      	ldr	r3, [r7, #20]
   13a2a:	695a      	ldr	r2, [r3, #20]
   13a2c:	7afb      	ldrb	r3, [r7, #11]
   13a2e:	2101      	movs	r1, #1
   13a30:	fa01 f303 	lsl.w	r3, r1, r3
   13a34:	43db      	mvns	r3, r3
   13a36:	4013      	ands	r3, r2
   13a38:	697a      	ldr	r2, [r7, #20]
   13a3a:	6153      	str	r3, [r2, #20]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
   13a3c:	683b      	ldr	r3, [r7, #0]
   13a3e:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   13a42:	d107      	bne.n	13a54 <gpio_nrfx_pin_interrupt_configure+0xb8>
   13a44:	697b      	ldr	r3, [r7, #20]
   13a46:	699a      	ldr	r2, [r3, #24]
   13a48:	7afb      	ldrb	r3, [r7, #11]
   13a4a:	2101      	movs	r1, #1
   13a4c:	fa01 f303 	lsl.w	r3, r1, r3
   13a50:	4313      	orrs	r3, r2
   13a52:	e007      	b.n	13a64 <gpio_nrfx_pin_interrupt_configure+0xc8>
   13a54:	697b      	ldr	r3, [r7, #20]
   13a56:	699a      	ldr	r2, [r3, #24]
   13a58:	7afb      	ldrb	r3, [r7, #11]
   13a5a:	2101      	movs	r1, #1
   13a5c:	fa01 f303 	lsl.w	r3, r1, r3
   13a60:	43db      	mvns	r3, r3
   13a62:	4013      	ands	r3, r2
   13a64:	697a      	ldr	r2, [r7, #20]
   13a66:	6193      	str	r3, [r2, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
   13a68:	683b      	ldr	r3, [r7, #0]
   13a6a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
   13a6e:	d107      	bne.n	13a80 <gpio_nrfx_pin_interrupt_configure+0xe4>
   13a70:	697b      	ldr	r3, [r7, #20]
   13a72:	691a      	ldr	r2, [r3, #16]
   13a74:	7afb      	ldrb	r3, [r7, #11]
   13a76:	2101      	movs	r1, #1
   13a78:	fa01 f303 	lsl.w	r3, r1, r3
   13a7c:	4313      	orrs	r3, r2
   13a7e:	e007      	b.n	13a90 <gpio_nrfx_pin_interrupt_configure+0xf4>
   13a80:	697b      	ldr	r3, [r7, #20]
   13a82:	691a      	ldr	r2, [r3, #16]
   13a84:	7afb      	ldrb	r3, [r7, #11]
   13a86:	2101      	movs	r1, #1
   13a88:	fa01 f303 	lsl.w	r3, r1, r3
   13a8c:	43db      	mvns	r3, r3
   13a8e:	4013      	ands	r3, r2
   13a90:	697a      	ldr	r2, [r7, #20]
   13a92:	6113      	str	r3, [r2, #16]
	return gpiote_pin_int_cfg(port, pin);
   13a94:	7afb      	ldrb	r3, [r7, #11]
   13a96:	4619      	mov	r1, r3
   13a98:	68f8      	ldr	r0, [r7, #12]
   13a9a:	f7f3 fad7 	bl	704c <gpiote_pin_int_cfg>
   13a9e:	4603      	mov	r3, r0
}
   13aa0:	4618      	mov	r0, r3
   13aa2:	3718      	adds	r7, #24
   13aa4:	46bd      	mov	sp, r7
   13aa6:	bd80      	pop	{r7, pc}

00013aa8 <gpio_nrfx_manage_callback>:
{
   13aa8:	b580      	push	{r7, lr}
   13aaa:	b084      	sub	sp, #16
   13aac:	af00      	add	r7, sp, #0
   13aae:	60f8      	str	r0, [r7, #12]
   13ab0:	60b9      	str	r1, [r7, #8]
   13ab2:	4613      	mov	r3, r2
   13ab4:	71fb      	strb	r3, [r7, #7]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   13ab6:	68f8      	ldr	r0, [r7, #12]
   13ab8:	f7ff fec9 	bl	1384e <get_port_data>
   13abc:	4603      	mov	r3, r0
   13abe:	3304      	adds	r3, #4
   13ac0:	79fa      	ldrb	r2, [r7, #7]
   13ac2:	68b9      	ldr	r1, [r7, #8]
   13ac4:	4618      	mov	r0, r3
   13ac6:	f7f3 f96f 	bl	6da8 <gpio_manage_callback>
   13aca:	4603      	mov	r3, r0
}
   13acc:	4618      	mov	r0, r3
   13ace:	3710      	adds	r7, #16
   13ad0:	46bd      	mov	sp, r7
   13ad2:	bd80      	pop	{r7, pc}

00013ad4 <get_level_pins>:
{
   13ad4:	b580      	push	{r7, lr}
   13ad6:	b084      	sub	sp, #16
   13ad8:	af00      	add	r7, sp, #0
   13ada:	6078      	str	r0, [r7, #4]
	struct gpio_nrfx_data *data = get_port_data(port);
   13adc:	6878      	ldr	r0, [r7, #4]
   13ade:	f7ff feb6 	bl	1384e <get_port_data>
   13ae2:	60f8      	str	r0, [r7, #12]
	uint32_t out = data->pin_int_en;
   13ae4:	68fb      	ldr	r3, [r7, #12]
   13ae6:	68db      	ldr	r3, [r3, #12]
   13ae8:	60bb      	str	r3, [r7, #8]
	out &= ~data->trig_edge & ~data->double_edge;
   13aea:	68fb      	ldr	r3, [r7, #12]
   13aec:	695a      	ldr	r2, [r3, #20]
   13aee:	68fb      	ldr	r3, [r7, #12]
   13af0:	699b      	ldr	r3, [r3, #24]
   13af2:	4313      	orrs	r3, r2
   13af4:	43db      	mvns	r3, r3
   13af6:	68ba      	ldr	r2, [r7, #8]
   13af8:	4013      	ands	r3, r2
   13afa:	60bb      	str	r3, [r7, #8]
	return out;
   13afc:	68bb      	ldr	r3, [r7, #8]
}
   13afe:	4618      	mov	r0, r3
   13b00:	3710      	adds	r7, #16
   13b02:	46bd      	mov	sp, r7
   13b04:	bd80      	pop	{r7, pc}

00013b06 <cfg_level_pins>:
{
   13b06:	b580      	push	{r7, lr}
   13b08:	b08a      	sub	sp, #40	; 0x28
   13b0a:	af00      	add	r7, sp, #0
   13b0c:	6078      	str	r0, [r7, #4]
	const struct gpio_nrfx_data *data = get_port_data(port);
   13b0e:	6878      	ldr	r0, [r7, #4]
   13b10:	f7ff fe9d 	bl	1384e <get_port_data>
   13b14:	61b8      	str	r0, [r7, #24]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   13b16:	6878      	ldr	r0, [r7, #4]
   13b18:	f7ff fea4 	bl	13864 <get_port_cfg>
   13b1c:	6178      	str	r0, [r7, #20]
	uint32_t pin = 0U;
   13b1e:	2300      	movs	r3, #0
   13b20:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t bit = 1U << pin;
   13b22:	2201      	movs	r2, #1
   13b24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13b26:	fa02 f303 	lsl.w	r3, r2, r3
   13b2a:	623b      	str	r3, [r7, #32]
	uint32_t level_pins = get_level_pins(port);
   13b2c:	6878      	ldr	r0, [r7, #4]
   13b2e:	f7ff ffd1 	bl	13ad4 <get_level_pins>
   13b32:	61f8      	str	r0, [r7, #28]
	while (level_pins) {
   13b34:	e023      	b.n	13b7e <cfg_level_pins+0x78>
		if (level_pins & bit) {
   13b36:	69fa      	ldr	r2, [r7, #28]
   13b38:	6a3b      	ldr	r3, [r7, #32]
   13b3a:	4013      	ands	r3, r2
   13b3c:	2b00      	cmp	r3, #0
   13b3e:	d018      	beq.n	13b72 <cfg_level_pins+0x6c>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   13b40:	697b      	ldr	r3, [r7, #20]
   13b42:	7a1b      	ldrb	r3, [r3, #8]
   13b44:	015b      	lsls	r3, r3, #5
   13b46:	461a      	mov	r2, r3
   13b48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13b4a:	f003 031f 	and.w	r3, r3, #31
   13b4e:	4313      	orrs	r3, r2
   13b50:	613b      	str	r3, [r7, #16]
			uint32_t sense = sense_for_pin(data, pin);
   13b52:	6a79      	ldr	r1, [r7, #36]	; 0x24
   13b54:	69b8      	ldr	r0, [r7, #24]
   13b56:	f7ff fe90 	bl	1387a <sense_for_pin>
   13b5a:	60f8      	str	r0, [r7, #12]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   13b5c:	68fb      	ldr	r3, [r7, #12]
   13b5e:	b2db      	uxtb	r3, r3
   13b60:	4619      	mov	r1, r3
   13b62:	6938      	ldr	r0, [r7, #16]
   13b64:	f7ff fce9 	bl	1353a <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   13b68:	6a3b      	ldr	r3, [r7, #32]
   13b6a:	43db      	mvns	r3, r3
   13b6c:	69fa      	ldr	r2, [r7, #28]
   13b6e:	4013      	ands	r3, r2
   13b70:	61fb      	str	r3, [r7, #28]
		++pin;
   13b72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13b74:	3301      	adds	r3, #1
   13b76:	627b      	str	r3, [r7, #36]	; 0x24
		bit <<= 1;
   13b78:	6a3b      	ldr	r3, [r7, #32]
   13b7a:	005b      	lsls	r3, r3, #1
   13b7c:	623b      	str	r3, [r7, #32]
	while (level_pins) {
   13b7e:	69fb      	ldr	r3, [r7, #28]
   13b80:	2b00      	cmp	r3, #0
   13b82:	d1d8      	bne.n	13b36 <cfg_level_pins+0x30>
}
   13b84:	bf00      	nop
   13b86:	bf00      	nop
   13b88:	3728      	adds	r7, #40	; 0x28
   13b8a:	46bd      	mov	sp, r7
   13b8c:	bd80      	pop	{r7, pc}

00013b8e <check_level_trigger_pins>:
{
   13b8e:	b580      	push	{r7, lr}
   13b90:	b08c      	sub	sp, #48	; 0x30
   13b92:	af00      	add	r7, sp, #0
   13b94:	6078      	str	r0, [r7, #4]
	struct gpio_nrfx_data *data = get_port_data(port);
   13b96:	6878      	ldr	r0, [r7, #4]
   13b98:	f7ff fe59 	bl	1384e <get_port_data>
   13b9c:	6238      	str	r0, [r7, #32]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   13b9e:	6878      	ldr	r0, [r7, #4]
   13ba0:	f7ff fe60 	bl	13864 <get_port_cfg>
   13ba4:	61f8      	str	r0, [r7, #28]
	uint32_t level_pins = get_level_pins(port);
   13ba6:	6878      	ldr	r0, [r7, #4]
   13ba8:	f7ff ff94 	bl	13ad4 <get_level_pins>
   13bac:	62f8      	str	r0, [r7, #44]	; 0x2c
	uint32_t port_in = nrf_gpio_port_in_read(cfg->port);
   13bae:	69fb      	ldr	r3, [r7, #28]
   13bb0:	685b      	ldr	r3, [r3, #4]
   13bb2:	4618      	mov	r0, r3
   13bb4:	f7ff fcf8 	bl	135a8 <nrf_gpio_port_in_read>
   13bb8:	61b8      	str	r0, [r7, #24]
	uint32_t pin_states = ~(port_in ^ data->int_active_level);
   13bba:	6a3b      	ldr	r3, [r7, #32]
   13bbc:	691a      	ldr	r2, [r3, #16]
   13bbe:	69bb      	ldr	r3, [r7, #24]
   13bc0:	4053      	eors	r3, r2
   13bc2:	43db      	mvns	r3, r3
   13bc4:	617b      	str	r3, [r7, #20]
	uint32_t out = pin_states & level_pins;
   13bc6:	697a      	ldr	r2, [r7, #20]
   13bc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13bca:	4013      	ands	r3, r2
   13bcc:	613b      	str	r3, [r7, #16]
	uint32_t pin = 0U;
   13bce:	2300      	movs	r3, #0
   13bd0:	62bb      	str	r3, [r7, #40]	; 0x28
	uint32_t bit = 1U << pin;
   13bd2:	2201      	movs	r2, #1
   13bd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13bd6:	fa02 f303 	lsl.w	r3, r2, r3
   13bda:	627b      	str	r3, [r7, #36]	; 0x24
	while (level_pins) {
   13bdc:	e01c      	b.n	13c18 <check_level_trigger_pins+0x8a>
		if (level_pins & bit) {
   13bde:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   13be0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13be2:	4013      	ands	r3, r2
   13be4:	2b00      	cmp	r3, #0
   13be6:	d011      	beq.n	13c0c <check_level_trigger_pins+0x7e>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   13be8:	69fb      	ldr	r3, [r7, #28]
   13bea:	7a1b      	ldrb	r3, [r3, #8]
   13bec:	015b      	lsls	r3, r3, #5
   13bee:	461a      	mov	r2, r3
   13bf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13bf2:	f003 031f 	and.w	r3, r3, #31
   13bf6:	4313      	orrs	r3, r2
   13bf8:	60fb      	str	r3, [r7, #12]
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   13bfa:	2100      	movs	r1, #0
   13bfc:	68f8      	ldr	r0, [r7, #12]
   13bfe:	f7ff fc9c 	bl	1353a <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   13c02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13c04:	43db      	mvns	r3, r3
   13c06:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   13c08:	4013      	ands	r3, r2
   13c0a:	62fb      	str	r3, [r7, #44]	; 0x2c
		++pin;
   13c0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13c0e:	3301      	adds	r3, #1
   13c10:	62bb      	str	r3, [r7, #40]	; 0x28
		bit <<= 1;
   13c12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13c14:	005b      	lsls	r3, r3, #1
   13c16:	627b      	str	r3, [r7, #36]	; 0x24
	while (level_pins) {
   13c18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13c1a:	2b00      	cmp	r3, #0
   13c1c:	d1df      	bne.n	13bde <check_level_trigger_pins+0x50>
	return out;
   13c1e:	693b      	ldr	r3, [r7, #16]
}
   13c20:	4618      	mov	r0, r3
   13c22:	3730      	adds	r7, #48	; 0x30
   13c24:	46bd      	mov	sp, r7
   13c26:	bd80      	pop	{r7, pc}

00013c28 <fire_callbacks>:
{
   13c28:	b580      	push	{r7, lr}
   13c2a:	b084      	sub	sp, #16
   13c2c:	af00      	add	r7, sp, #0
   13c2e:	6078      	str	r0, [r7, #4]
   13c30:	6039      	str	r1, [r7, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
   13c32:	6878      	ldr	r0, [r7, #4]
   13c34:	f7ff fe0b 	bl	1384e <get_port_data>
   13c38:	60f8      	str	r0, [r7, #12]
	sys_slist_t *list = &data->callbacks;
   13c3a:	68fb      	ldr	r3, [r7, #12]
   13c3c:	3304      	adds	r3, #4
   13c3e:	60bb      	str	r3, [r7, #8]
	gpio_fire_callbacks(list, port, pins);
   13c40:	683a      	ldr	r2, [r7, #0]
   13c42:	6879      	ldr	r1, [r7, #4]
   13c44:	68b8      	ldr	r0, [r7, #8]
   13c46:	f7f3 f90d 	bl	6e64 <gpio_fire_callbacks>
}
   13c4a:	bf00      	nop
   13c4c:	3710      	adds	r7, #16
   13c4e:	46bd      	mov	sp, r7
   13c50:	bd80      	pop	{r7, pc}

00013c52 <_is_user_context>:
{
   13c52:	b480      	push	{r7}
   13c54:	af00      	add	r7, sp, #0
	return false;
   13c56:	2300      	movs	r3, #0
}
   13c58:	4618      	mov	r0, r3
   13c5a:	46bd      	mov	sp, r7
   13c5c:	bc80      	pop	{r7}
   13c5e:	4770      	bx	lr

00013c60 <atomic_cas>:
{
   13c60:	b490      	push	{r4, r7}
   13c62:	b084      	sub	sp, #16
   13c64:	af00      	add	r7, sp, #0
   13c66:	60f8      	str	r0, [r7, #12]
   13c68:	60b9      	str	r1, [r7, #8]
   13c6a:	607a      	str	r2, [r7, #4]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   13c6c:	687c      	ldr	r4, [r7, #4]
   13c6e:	68fa      	ldr	r2, [r7, #12]
   13c70:	f107 0308 	add.w	r3, r7, #8
   13c74:	6818      	ldr	r0, [r3, #0]
   13c76:	e8d2 1fef 	ldaex	r1, [r2]
   13c7a:	4281      	cmp	r1, r0
   13c7c:	d106      	bne.n	13c8c <atomic_cas+0x2c>
   13c7e:	e8c2 4fec 	stlex	ip, r4, [r2]
   13c82:	f1bc 0f00 	cmp.w	ip, #0
   13c86:	f1bc 0f00 	cmp.w	ip, #0
   13c8a:	d1f4      	bne.n	13c76 <atomic_cas+0x16>
   13c8c:	bf0c      	ite	eq
   13c8e:	2201      	moveq	r2, #1
   13c90:	2200      	movne	r2, #0
   13c92:	2a00      	cmp	r2, #0
   13c94:	d100      	bne.n	13c98 <atomic_cas+0x38>
   13c96:	6019      	str	r1, [r3, #0]
   13c98:	4613      	mov	r3, r2
}
   13c9a:	4618      	mov	r0, r3
   13c9c:	3710      	adds	r7, #16
   13c9e:	46bd      	mov	sp, r7
   13ca0:	bc90      	pop	{r4, r7}
   13ca2:	4770      	bx	lr

00013ca4 <nrfx_is_in_ram>:


#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
   13ca4:	b480      	push	{r7}
   13ca6:	b083      	sub	sp, #12
   13ca8:	af00      	add	r7, sp, #0
   13caa:	6078      	str	r0, [r7, #4]
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   13cac:	687b      	ldr	r3, [r7, #4]
   13cae:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   13cb2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   13cb6:	bf0c      	ite	eq
   13cb8:	2301      	moveq	r3, #1
   13cba:	2300      	movne	r3, #0
   13cbc:	b2db      	uxtb	r3, r3
}
   13cbe:	4618      	mov	r0, r3
   13cc0:	370c      	adds	r7, #12
   13cc2:	46bd      	mov	sp, r7
   13cc4:	bc80      	pop	{r7}
   13cc6:	4770      	bx	lr

00013cc8 <nrf_event_readback>:
{
   13cc8:	b480      	push	{r7}
   13cca:	b083      	sub	sp, #12
   13ccc:	af00      	add	r7, sp, #0
   13cce:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   13cd0:	687b      	ldr	r3, [r7, #4]
   13cd2:	681b      	ldr	r3, [r3, #0]
}
   13cd4:	bf00      	nop
   13cd6:	370c      	adds	r7, #12
   13cd8:	46bd      	mov	sp, r7
   13cda:	bc80      	pop	{r7}
   13cdc:	4770      	bx	lr

00013cde <k_ms_to_ticks_ceil64>:
{
   13cde:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   13ce2:	b08c      	sub	sp, #48	; 0x30
   13ce4:	af00      	add	r7, sp, #0
   13ce6:	e9c7 0100 	strd	r0, r1, [r7]
   13cea:	e9d7 2300 	ldrd	r2, r3, [r7]
   13cee:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   13cf2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   13cf6:	627b      	str	r3, [r7, #36]	; 0x24
   13cf8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   13cfc:	623b      	str	r3, [r7, #32]
   13cfe:	2301      	movs	r3, #1
   13d00:	77fb      	strb	r3, [r7, #31]
   13d02:	2300      	movs	r3, #0
   13d04:	77bb      	strb	r3, [r7, #30]
   13d06:	2301      	movs	r3, #1
   13d08:	777b      	strb	r3, [r7, #29]
   13d0a:	2300      	movs	r3, #0
   13d0c:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   13d0e:	7ffb      	ldrb	r3, [r7, #31]
   13d10:	2b00      	cmp	r3, #0
   13d12:	d00f      	beq.n	13d34 <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   13d14:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13d16:	6a3b      	ldr	r3, [r7, #32]
   13d18:	429a      	cmp	r2, r3
   13d1a:	d20b      	bcs.n	13d34 <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   13d1c:	6a3b      	ldr	r3, [r7, #32]
   13d1e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13d20:	fbb3 f2f2 	udiv	r2, r3, r2
   13d24:	6a79      	ldr	r1, [r7, #36]	; 0x24
   13d26:	fb01 f202 	mul.w	r2, r1, r2
   13d2a:	1a9b      	subs	r3, r3, r2
   13d2c:	2b00      	cmp	r3, #0
   13d2e:	d101      	bne.n	13d34 <k_ms_to_ticks_ceil64+0x56>
   13d30:	2301      	movs	r3, #1
   13d32:	e000      	b.n	13d36 <k_ms_to_ticks_ceil64+0x58>
   13d34:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   13d36:	76fb      	strb	r3, [r7, #27]
   13d38:	7efb      	ldrb	r3, [r7, #27]
   13d3a:	f003 0301 	and.w	r3, r3, #1
   13d3e:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   13d40:	7ffb      	ldrb	r3, [r7, #31]
   13d42:	2b00      	cmp	r3, #0
   13d44:	d00f      	beq.n	13d66 <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   13d46:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13d48:	6a3b      	ldr	r3, [r7, #32]
   13d4a:	429a      	cmp	r2, r3
   13d4c:	d90b      	bls.n	13d66 <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   13d4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13d50:	6a3a      	ldr	r2, [r7, #32]
   13d52:	fbb3 f2f2 	udiv	r2, r3, r2
   13d56:	6a39      	ldr	r1, [r7, #32]
   13d58:	fb01 f202 	mul.w	r2, r1, r2
   13d5c:	1a9b      	subs	r3, r3, r2
   13d5e:	2b00      	cmp	r3, #0
   13d60:	d101      	bne.n	13d66 <k_ms_to_ticks_ceil64+0x88>
   13d62:	2301      	movs	r3, #1
   13d64:	e000      	b.n	13d68 <k_ms_to_ticks_ceil64+0x8a>
   13d66:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   13d68:	76bb      	strb	r3, [r7, #26]
   13d6a:	7ebb      	ldrb	r3, [r7, #26]
   13d6c:	f003 0301 	and.w	r3, r3, #1
   13d70:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   13d72:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13d74:	6a3b      	ldr	r3, [r7, #32]
   13d76:	429a      	cmp	r2, r3
   13d78:	d10a      	bne.n	13d90 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   13d7a:	7fbb      	ldrb	r3, [r7, #30]
   13d7c:	2b00      	cmp	r3, #0
   13d7e:	d004      	beq.n	13d8a <k_ms_to_ticks_ceil64+0xac>
   13d80:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13d82:	461a      	mov	r2, r3
   13d84:	f04f 0300 	mov.w	r3, #0
   13d88:	e0c8      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
   13d8a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   13d8e:	e0c5      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   13d90:	f04f 0200 	mov.w	r2, #0
   13d94:	f04f 0300 	mov.w	r3, #0
   13d98:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   13d9c:	7efb      	ldrb	r3, [r7, #27]
   13d9e:	f083 0301 	eor.w	r3, r3, #1
   13da2:	b2db      	uxtb	r3, r3
   13da4:	2b00      	cmp	r3, #0
   13da6:	d01e      	beq.n	13de6 <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   13da8:	7ebb      	ldrb	r3, [r7, #26]
   13daa:	2b00      	cmp	r3, #0
   13dac:	d004      	beq.n	13db8 <k_ms_to_ticks_ceil64+0xda>
   13dae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13db0:	6a3b      	ldr	r3, [r7, #32]
   13db2:	fbb2 f3f3 	udiv	r3, r2, r3
   13db6:	e000      	b.n	13dba <k_ms_to_ticks_ceil64+0xdc>
   13db8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13dba:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   13dbc:	7f7b      	ldrb	r3, [r7, #29]
   13dbe:	2b00      	cmp	r3, #0
   13dc0:	d007      	beq.n	13dd2 <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   13dc2:	68fb      	ldr	r3, [r7, #12]
   13dc4:	3b01      	subs	r3, #1
   13dc6:	461a      	mov	r2, r3
   13dc8:	f04f 0300 	mov.w	r3, #0
   13dcc:	e9c7 2304 	strd	r2, r3, [r7, #16]
   13dd0:	e009      	b.n	13de6 <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   13dd2:	7f3b      	ldrb	r3, [r7, #28]
   13dd4:	2b00      	cmp	r3, #0
   13dd6:	d006      	beq.n	13de6 <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   13dd8:	68fb      	ldr	r3, [r7, #12]
   13dda:	085b      	lsrs	r3, r3, #1
   13ddc:	461a      	mov	r2, r3
   13dde:	f04f 0300 	mov.w	r3, #0
   13de2:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   13de6:	7ebb      	ldrb	r3, [r7, #26]
   13de8:	2b00      	cmp	r3, #0
   13dea:	d02a      	beq.n	13e42 <k_ms_to_ticks_ceil64+0x164>
		t += off;
   13dec:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   13df0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   13df4:	1884      	adds	r4, r0, r2
   13df6:	eb41 0503 	adc.w	r5, r1, r3
   13dfa:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   13dfe:	7fbb      	ldrb	r3, [r7, #30]
   13e00:	2b00      	cmp	r3, #0
   13e02:	d010      	beq.n	13e26 <k_ms_to_ticks_ceil64+0x148>
   13e04:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   13e08:	2b01      	cmp	r3, #1
   13e0a:	bf08      	it	eq
   13e0c:	2a00      	cmpeq	r2, #0
   13e0e:	d20a      	bcs.n	13e26 <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   13e10:	6aba      	ldr	r2, [r7, #40]	; 0x28
   13e12:	6a79      	ldr	r1, [r7, #36]	; 0x24
   13e14:	6a3b      	ldr	r3, [r7, #32]
   13e16:	fbb1 f3f3 	udiv	r3, r1, r3
   13e1a:	fbb2 f3f3 	udiv	r3, r2, r3
   13e1e:	461a      	mov	r2, r3
   13e20:	f04f 0300 	mov.w	r3, #0
   13e24:	e07a      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   13e26:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13e28:	6a3b      	ldr	r3, [r7, #32]
   13e2a:	fbb2 f3f3 	udiv	r3, r2, r3
   13e2e:	461a      	mov	r2, r3
   13e30:	f04f 0300 	mov.w	r3, #0
   13e34:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   13e38:	f7ec f984 	bl	144 <__aeabi_uldivmod>
   13e3c:	4602      	mov	r2, r0
   13e3e:	460b      	mov	r3, r1
   13e40:	e06c      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   13e42:	7efb      	ldrb	r3, [r7, #27]
   13e44:	2b00      	cmp	r3, #0
   13e46:	d021      	beq.n	13e8c <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   13e48:	7fbb      	ldrb	r3, [r7, #30]
   13e4a:	2b00      	cmp	r3, #0
   13e4c:	d00a      	beq.n	13e64 <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   13e4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13e50:	6a39      	ldr	r1, [r7, #32]
   13e52:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   13e54:	fbb1 f2f2 	udiv	r2, r1, r2
   13e58:	fb02 f303 	mul.w	r3, r2, r3
   13e5c:	461a      	mov	r2, r3
   13e5e:	f04f 0300 	mov.w	r3, #0
   13e62:	e05b      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   13e64:	6a3a      	ldr	r2, [r7, #32]
   13e66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13e68:	fbb2 f3f3 	udiv	r3, r2, r3
   13e6c:	461a      	mov	r2, r3
   13e6e:	f04f 0300 	mov.w	r3, #0
   13e72:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   13e74:	fb03 f001 	mul.w	r0, r3, r1
   13e78:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   13e7a:	fb02 f101 	mul.w	r1, r2, r1
   13e7e:	4401      	add	r1, r0
   13e80:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   13e82:	fba0 2302 	umull	r2, r3, r0, r2
   13e86:	4419      	add	r1, r3
   13e88:	460b      	mov	r3, r1
   13e8a:	e047      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   13e8c:	7fbb      	ldrb	r3, [r7, #30]
   13e8e:	2b00      	cmp	r3, #0
   13e90:	d024      	beq.n	13edc <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   13e92:	6a3b      	ldr	r3, [r7, #32]
   13e94:	461a      	mov	r2, r3
   13e96:	f04f 0300 	mov.w	r3, #0
   13e9a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   13e9c:	fb03 f001 	mul.w	r0, r3, r1
   13ea0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   13ea2:	fb02 f101 	mul.w	r1, r2, r1
   13ea6:	4401      	add	r1, r0
   13ea8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   13eaa:	fba0 2302 	umull	r2, r3, r0, r2
   13eae:	4419      	add	r1, r3
   13eb0:	460b      	mov	r3, r1
   13eb2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   13eb6:	eb12 0a00 	adds.w	sl, r2, r0
   13eba:	eb43 0b01 	adc.w	fp, r3, r1
   13ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13ec0:	461a      	mov	r2, r3
   13ec2:	f04f 0300 	mov.w	r3, #0
   13ec6:	4650      	mov	r0, sl
   13ec8:	4659      	mov	r1, fp
   13eca:	f7ec f93b 	bl	144 <__aeabi_uldivmod>
   13ece:	4602      	mov	r2, r0
   13ed0:	460b      	mov	r3, r1
   13ed2:	4613      	mov	r3, r2
   13ed4:	461a      	mov	r2, r3
   13ed6:	f04f 0300 	mov.w	r3, #0
   13eda:	e01f      	b.n	13f1c <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   13edc:	6a3b      	ldr	r3, [r7, #32]
   13ede:	461a      	mov	r2, r3
   13ee0:	f04f 0300 	mov.w	r3, #0
   13ee4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   13ee6:	fb03 f001 	mul.w	r0, r3, r1
   13eea:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   13eec:	fb02 f101 	mul.w	r1, r2, r1
   13ef0:	4401      	add	r1, r0
   13ef2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   13ef4:	fba0 2302 	umull	r2, r3, r0, r2
   13ef8:	4419      	add	r1, r3
   13efa:	460b      	mov	r3, r1
   13efc:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   13f00:	eb12 0800 	adds.w	r8, r2, r0
   13f04:	eb43 0901 	adc.w	r9, r3, r1
   13f08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   13f0a:	461a      	mov	r2, r3
   13f0c:	f04f 0300 	mov.w	r3, #0
   13f10:	4640      	mov	r0, r8
   13f12:	4649      	mov	r1, r9
   13f14:	f7ec f916 	bl	144 <__aeabi_uldivmod>
   13f18:	4602      	mov	r2, r0
   13f1a:	460b      	mov	r3, r1
}
   13f1c:	4610      	mov	r0, r2
   13f1e:	4619      	mov	r1, r3
   13f20:	3730      	adds	r7, #48	; 0x30
   13f22:	46bd      	mov	sp, r7
   13f24:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

00013f28 <k_msleep>:
{
   13f28:	b580      	push	{r7, lr}
   13f2a:	b082      	sub	sp, #8
   13f2c:	af00      	add	r7, sp, #0
   13f2e:	6078      	str	r0, [r7, #4]
	return k_sleep(Z_TIMEOUT_MS(ms));
   13f30:	687b      	ldr	r3, [r7, #4]
   13f32:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   13f36:	461a      	mov	r2, r3
   13f38:	ea4f 73e2 	mov.w	r3, r2, asr #31
   13f3c:	4610      	mov	r0, r2
   13f3e:	4619      	mov	r1, r3
   13f40:	f7ff fecd 	bl	13cde <k_ms_to_ticks_ceil64>
   13f44:	4602      	mov	r2, r0
   13f46:	460b      	mov	r3, r1
   13f48:	4610      	mov	r0, r2
   13f4a:	4619      	mov	r1, r3
   13f4c:	f000 f81e 	bl	13f8c <k_sleep>
   13f50:	4601      	mov	r1, r0
   13f52:	460b      	mov	r3, r1
}
   13f54:	4618      	mov	r0, r3
   13f56:	3708      	adds	r7, #8
   13f58:	46bd      	mov	sp, r7
   13f5a:	bd80      	pop	{r7, pc}

00013f5c <z_impl_k_timer_user_data_set>:
{
   13f5c:	b480      	push	{r7}
   13f5e:	b083      	sub	sp, #12
   13f60:	af00      	add	r7, sp, #0
   13f62:	6078      	str	r0, [r7, #4]
   13f64:	6039      	str	r1, [r7, #0]
	timer->user_data = user_data;
   13f66:	687b      	ldr	r3, [r7, #4]
   13f68:	683a      	ldr	r2, [r7, #0]
   13f6a:	635a      	str	r2, [r3, #52]	; 0x34
}
   13f6c:	bf00      	nop
   13f6e:	370c      	adds	r7, #12
   13f70:	46bd      	mov	sp, r7
   13f72:	bc80      	pop	{r7}
   13f74:	4770      	bx	lr

00013f76 <z_impl_k_timer_user_data_get>:
{
   13f76:	b480      	push	{r7}
   13f78:	b083      	sub	sp, #12
   13f7a:	af00      	add	r7, sp, #0
   13f7c:	6078      	str	r0, [r7, #4]
	return timer->user_data;
   13f7e:	687b      	ldr	r3, [r7, #4]
   13f80:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
   13f82:	4618      	mov	r0, r3
   13f84:	370c      	adds	r7, #12
   13f86:	46bd      	mov	sp, r7
   13f88:	bc80      	pop	{r7}
   13f8a:	4770      	bx	lr

00013f8c <k_sleep>:
{
   13f8c:	b580      	push	{r7, lr}
   13f8e:	b082      	sub	sp, #8
   13f90:	af00      	add	r7, sp, #0
   13f92:	e9c7 0100 	strd	r0, r1, [r7]
	return z_impl_k_sleep(timeout);
   13f96:	e9d7 0100 	ldrd	r0, r1, [r7]
   13f9a:	f7fa f97b 	bl	e294 <z_impl_k_sleep>
   13f9e:	4603      	mov	r3, r0
}
   13fa0:	4618      	mov	r0, r3
   13fa2:	3708      	adds	r7, #8
   13fa4:	46bd      	mov	sp, r7
   13fa6:	bd80      	pop	{r7, pc}

00013fa8 <k_timer_start>:
{
   13fa8:	b580      	push	{r7, lr}
   13faa:	b086      	sub	sp, #24
   13fac:	af02      	add	r7, sp, #8
   13fae:	60f8      	str	r0, [r7, #12]
   13fb0:	e9c7 2300 	strd	r2, r3, [r7]
	z_impl_k_timer_start(timer, duration, period);
   13fb4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
   13fb8:	e9cd 2300 	strd	r2, r3, [sp]
   13fbc:	e9d7 2300 	ldrd	r2, r3, [r7]
   13fc0:	68f8      	ldr	r0, [r7, #12]
   13fc2:	f7fb fb7f 	bl	f6c4 <z_impl_k_timer_start>
}
   13fc6:	bf00      	nop
   13fc8:	3710      	adds	r7, #16
   13fca:	46bd      	mov	sp, r7
   13fcc:	bd80      	pop	{r7, pc}

00013fce <k_timer_stop>:
{
   13fce:	b580      	push	{r7, lr}
   13fd0:	b082      	sub	sp, #8
   13fd2:	af00      	add	r7, sp, #0
   13fd4:	6078      	str	r0, [r7, #4]
	z_impl_k_timer_stop(timer);
   13fd6:	6878      	ldr	r0, [r7, #4]
   13fd8:	f004 fa37 	bl	1844a <z_impl_k_timer_stop>
}
   13fdc:	bf00      	nop
   13fde:	3708      	adds	r7, #8
   13fe0:	46bd      	mov	sp, r7
   13fe2:	bd80      	pop	{r7, pc}

00013fe4 <k_timer_user_data_set>:
{
   13fe4:	b580      	push	{r7, lr}
   13fe6:	b082      	sub	sp, #8
   13fe8:	af00      	add	r7, sp, #0
   13fea:	6078      	str	r0, [r7, #4]
   13fec:	6039      	str	r1, [r7, #0]
	z_impl_k_timer_user_data_set(timer, user_data);
   13fee:	6839      	ldr	r1, [r7, #0]
   13ff0:	6878      	ldr	r0, [r7, #4]
   13ff2:	f7ff ffb3 	bl	13f5c <z_impl_k_timer_user_data_set>
}
   13ff6:	bf00      	nop
   13ff8:	3708      	adds	r7, #8
   13ffa:	46bd      	mov	sp, r7
   13ffc:	bd80      	pop	{r7, pc}

00013ffe <k_timer_user_data_get>:
{
   13ffe:	b580      	push	{r7, lr}
   14000:	b082      	sub	sp, #8
   14002:	af00      	add	r7, sp, #0
   14004:	6078      	str	r0, [r7, #4]
	return z_impl_k_timer_user_data_get(timer);
   14006:	6878      	ldr	r0, [r7, #4]
   14008:	f7ff ffb5 	bl	13f76 <z_impl_k_timer_user_data_get>
   1400c:	4603      	mov	r3, r0
}
   1400e:	4618      	mov	r0, r3
   14010:	3708      	adds	r7, #8
   14012:	46bd      	mov	sp, r7
   14014:	bd80      	pop	{r7, pc}

00014016 <nrf_gpio_cfg>:
{
   14016:	b580      	push	{r7, lr}
   14018:	b084      	sub	sp, #16
   1401a:	af00      	add	r7, sp, #0
   1401c:	6078      	str	r0, [r7, #4]
   1401e:	4608      	mov	r0, r1
   14020:	4611      	mov	r1, r2
   14022:	461a      	mov	r2, r3
   14024:	4603      	mov	r3, r0
   14026:	70fb      	strb	r3, [r7, #3]
   14028:	460b      	mov	r3, r1
   1402a:	70bb      	strb	r3, [r7, #2]
   1402c:	4613      	mov	r3, r2
   1402e:	707b      	strb	r3, [r7, #1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   14030:	1d3b      	adds	r3, r7, #4
   14032:	4618      	mov	r0, r3
   14034:	f7f3 f9ce 	bl	73d4 <nrf_gpio_pin_port_decode>
   14038:	60f8      	str	r0, [r7, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1403a:	78fa      	ldrb	r2, [r7, #3]
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   1403c:	78bb      	ldrb	r3, [r7, #2]
   1403e:	005b      	lsls	r3, r3, #1
   14040:	431a      	orrs	r2, r3
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   14042:	787b      	ldrb	r3, [r7, #1]
   14044:	009b      	lsls	r3, r3, #2
   14046:	431a      	orrs	r2, r3
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   14048:	7e3b      	ldrb	r3, [r7, #24]
   1404a:	021b      	lsls	r3, r3, #8
   1404c:	ea42 0103 	orr.w	r1, r2, r3
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   14050:	7f3b      	ldrb	r3, [r7, #28]
   14052:	041b      	lsls	r3, r3, #16
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   14054:	687a      	ldr	r2, [r7, #4]
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   14056:	4319      	orrs	r1, r3
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   14058:	68fb      	ldr	r3, [r7, #12]
   1405a:	3280      	adds	r2, #128	; 0x80
   1405c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   14060:	bf00      	nop
   14062:	3710      	adds	r7, #16
   14064:	46bd      	mov	sp, r7
   14066:	bd80      	pop	{r7, pc}

00014068 <nrf_gpio_cfg_output>:
{
   14068:	b580      	push	{r7, lr}
   1406a:	b084      	sub	sp, #16
   1406c:	af02      	add	r7, sp, #8
   1406e:	6078      	str	r0, [r7, #4]
    nrf_gpio_cfg(
   14070:	2300      	movs	r3, #0
   14072:	9301      	str	r3, [sp, #4]
   14074:	2300      	movs	r3, #0
   14076:	9300      	str	r3, [sp, #0]
   14078:	2300      	movs	r3, #0
   1407a:	2201      	movs	r2, #1
   1407c:	2101      	movs	r1, #1
   1407e:	6878      	ldr	r0, [r7, #4]
   14080:	f7ff ffc9 	bl	14016 <nrf_gpio_cfg>
}
   14084:	bf00      	nop
   14086:	3708      	adds	r7, #8
   14088:	46bd      	mov	sp, r7
   1408a:	bd80      	pop	{r7, pc}

0001408c <nrf_gpio_cfg_input>:
{
   1408c:	b580      	push	{r7, lr}
   1408e:	b084      	sub	sp, #16
   14090:	af02      	add	r7, sp, #8
   14092:	6078      	str	r0, [r7, #4]
   14094:	460b      	mov	r3, r1
   14096:	70fb      	strb	r3, [r7, #3]
    nrf_gpio_cfg(
   14098:	78fb      	ldrb	r3, [r7, #3]
   1409a:	2200      	movs	r2, #0
   1409c:	9201      	str	r2, [sp, #4]
   1409e:	2200      	movs	r2, #0
   140a0:	9200      	str	r2, [sp, #0]
   140a2:	2200      	movs	r2, #0
   140a4:	2100      	movs	r1, #0
   140a6:	6878      	ldr	r0, [r7, #4]
   140a8:	f7ff ffb5 	bl	14016 <nrf_gpio_cfg>
}
   140ac:	bf00      	nop
   140ae:	3708      	adds	r7, #8
   140b0:	46bd      	mov	sp, r7
   140b2:	bd80      	pop	{r7, pc}

000140b4 <nrf_gpio_pin_set>:
{
   140b4:	b580      	push	{r7, lr}
   140b6:	b084      	sub	sp, #16
   140b8:	af00      	add	r7, sp, #0
   140ba:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   140bc:	1d3b      	adds	r3, r7, #4
   140be:	4618      	mov	r0, r3
   140c0:	f7f3 f988 	bl	73d4 <nrf_gpio_pin_port_decode>
   140c4:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   140c6:	687b      	ldr	r3, [r7, #4]
   140c8:	2201      	movs	r2, #1
   140ca:	fa02 f303 	lsl.w	r3, r2, r3
   140ce:	4619      	mov	r1, r3
   140d0:	68f8      	ldr	r0, [r7, #12]
   140d2:	f000 f82c 	bl	1412e <nrf_gpio_port_out_set>
}
   140d6:	bf00      	nop
   140d8:	3710      	adds	r7, #16
   140da:	46bd      	mov	sp, r7
   140dc:	bd80      	pop	{r7, pc}

000140de <nrf_gpio_pin_clear>:
{
   140de:	b580      	push	{r7, lr}
   140e0:	b084      	sub	sp, #16
   140e2:	af00      	add	r7, sp, #0
   140e4:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   140e6:	1d3b      	adds	r3, r7, #4
   140e8:	4618      	mov	r0, r3
   140ea:	f7f3 f973 	bl	73d4 <nrf_gpio_pin_port_decode>
   140ee:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   140f0:	687b      	ldr	r3, [r7, #4]
   140f2:	2201      	movs	r2, #1
   140f4:	fa02 f303 	lsl.w	r3, r2, r3
   140f8:	4619      	mov	r1, r3
   140fa:	68f8      	ldr	r0, [r7, #12]
   140fc:	f000 f824 	bl	14148 <nrf_gpio_port_out_clear>
}
   14100:	bf00      	nop
   14102:	3710      	adds	r7, #16
   14104:	46bd      	mov	sp, r7
   14106:	bd80      	pop	{r7, pc}

00014108 <nrf_gpio_pin_write>:
{
   14108:	b580      	push	{r7, lr}
   1410a:	b082      	sub	sp, #8
   1410c:	af00      	add	r7, sp, #0
   1410e:	6078      	str	r0, [r7, #4]
   14110:	6039      	str	r1, [r7, #0]
    if (value == 0)
   14112:	683b      	ldr	r3, [r7, #0]
   14114:	2b00      	cmp	r3, #0
   14116:	d103      	bne.n	14120 <nrf_gpio_pin_write+0x18>
        nrf_gpio_pin_clear(pin_number);
   14118:	6878      	ldr	r0, [r7, #4]
   1411a:	f7ff ffe0 	bl	140de <nrf_gpio_pin_clear>
}
   1411e:	e002      	b.n	14126 <nrf_gpio_pin_write+0x1e>
        nrf_gpio_pin_set(pin_number);
   14120:	6878      	ldr	r0, [r7, #4]
   14122:	f7ff ffc7 	bl	140b4 <nrf_gpio_pin_set>
}
   14126:	bf00      	nop
   14128:	3708      	adds	r7, #8
   1412a:	46bd      	mov	sp, r7
   1412c:	bd80      	pop	{r7, pc}

0001412e <nrf_gpio_port_out_set>:
{
   1412e:	b480      	push	{r7}
   14130:	b083      	sub	sp, #12
   14132:	af00      	add	r7, sp, #0
   14134:	6078      	str	r0, [r7, #4]
   14136:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   14138:	687b      	ldr	r3, [r7, #4]
   1413a:	683a      	ldr	r2, [r7, #0]
   1413c:	609a      	str	r2, [r3, #8]
}
   1413e:	bf00      	nop
   14140:	370c      	adds	r7, #12
   14142:	46bd      	mov	sp, r7
   14144:	bc80      	pop	{r7}
   14146:	4770      	bx	lr

00014148 <nrf_gpio_port_out_clear>:
{
   14148:	b480      	push	{r7}
   1414a:	b083      	sub	sp, #12
   1414c:	af00      	add	r7, sp, #0
   1414e:	6078      	str	r0, [r7, #4]
   14150:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   14152:	687b      	ldr	r3, [r7, #4]
   14154:	683a      	ldr	r2, [r7, #0]
   14156:	60da      	str	r2, [r3, #12]
}
   14158:	bf00      	nop
   1415a:	370c      	adds	r7, #12
   1415c:	46bd      	mov	sp, r7
   1415e:	bc80      	pop	{r7}
   14160:	4770      	bx	lr

00014162 <nrf_gpio_pin_present_check>:
{
   14162:	b480      	push	{r7}
   14164:	b085      	sub	sp, #20
   14166:	af00      	add	r7, sp, #0
   14168:	6078      	str	r0, [r7, #4]
    uint32_t port = pin_number >> 5;
   1416a:	687b      	ldr	r3, [r7, #4]
   1416c:	095b      	lsrs	r3, r3, #5
   1416e:	60bb      	str	r3, [r7, #8]
    uint32_t mask = 0;
   14170:	2300      	movs	r3, #0
   14172:	60fb      	str	r3, [r7, #12]
    switch (port)
   14174:	68bb      	ldr	r3, [r7, #8]
   14176:	2b00      	cmp	r3, #0
   14178:	d103      	bne.n	14182 <nrf_gpio_pin_present_check+0x20>
            mask = P0_FEATURE_PINS_PRESENT;
   1417a:	f04f 33ff 	mov.w	r3, #4294967295
   1417e:	60fb      	str	r3, [r7, #12]
            break;
   14180:	bf00      	nop
    pin_number &= 0x1F;
   14182:	687b      	ldr	r3, [r7, #4]
   14184:	f003 031f 	and.w	r3, r3, #31
   14188:	607b      	str	r3, [r7, #4]
    return (mask & (1UL << pin_number)) ? true : false;
   1418a:	68fa      	ldr	r2, [r7, #12]
   1418c:	687b      	ldr	r3, [r7, #4]
   1418e:	fa22 f303 	lsr.w	r3, r2, r3
   14192:	f003 0301 	and.w	r3, r3, #1
   14196:	2b00      	cmp	r3, #0
   14198:	bf14      	ite	ne
   1419a:	2301      	movne	r3, #1
   1419c:	2300      	moveq	r3, #0
   1419e:	b2db      	uxtb	r3, r3
}
   141a0:	4618      	mov	r0, r3
   141a2:	3714      	adds	r7, #20
   141a4:	46bd      	mov	sp, r7
   141a6:	bc80      	pop	{r7}
   141a8:	4770      	bx	lr

000141aa <nrf_gpio_pin_port_number_extract>:
{
   141aa:	b480      	push	{r7}
   141ac:	b085      	sub	sp, #20
   141ae:	af00      	add	r7, sp, #0
   141b0:	6078      	str	r0, [r7, #4]
    uint32_t pin_number = *p_pin;
   141b2:	687b      	ldr	r3, [r7, #4]
   141b4:	681b      	ldr	r3, [r3, #0]
   141b6:	60fb      	str	r3, [r7, #12]
    *p_pin = pin_number & 0x1F;
   141b8:	68fb      	ldr	r3, [r7, #12]
   141ba:	f003 021f 	and.w	r2, r3, #31
   141be:	687b      	ldr	r3, [r7, #4]
   141c0:	601a      	str	r2, [r3, #0]
    return pin_number >> 5;
   141c2:	68fb      	ldr	r3, [r7, #12]
   141c4:	095b      	lsrs	r3, r3, #5
}
   141c6:	4618      	mov	r0, r3
   141c8:	3714      	adds	r7, #20
   141ca:	46bd      	mov	sp, r7
   141cc:	bc80      	pop	{r7}
   141ce:	4770      	bx	lr

000141d0 <nrf_uarte_event_clear>:
 */
NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg);

#ifndef NRF_DECLARE_ONLY
NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
{
   141d0:	b580      	push	{r7, lr}
   141d2:	b082      	sub	sp, #8
   141d4:	af00      	add	r7, sp, #0
   141d6:	6078      	str	r0, [r7, #4]
   141d8:	460b      	mov	r3, r1
   141da:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   141dc:	887b      	ldrh	r3, [r7, #2]
   141de:	687a      	ldr	r2, [r7, #4]
   141e0:	4413      	add	r3, r2
   141e2:	2200      	movs	r2, #0
   141e4:	601a      	str	r2, [r3, #0]
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
   141e6:	887b      	ldrh	r3, [r7, #2]
   141e8:	687a      	ldr	r2, [r7, #4]
   141ea:	4413      	add	r3, r2
   141ec:	4618      	mov	r0, r3
   141ee:	f7ff fd6b 	bl	13cc8 <nrf_event_readback>
}
   141f2:	bf00      	nop
   141f4:	3708      	adds	r7, #8
   141f6:	46bd      	mov	sp, r7
   141f8:	bd80      	pop	{r7, pc}

000141fa <nrf_uarte_event_check>:

NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
                                             nrf_uarte_event_t      event)
{
   141fa:	b480      	push	{r7}
   141fc:	b083      	sub	sp, #12
   141fe:	af00      	add	r7, sp, #0
   14200:	6078      	str	r0, [r7, #4]
   14202:	460b      	mov	r3, r1
   14204:	807b      	strh	r3, [r7, #2]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   14206:	887b      	ldrh	r3, [r7, #2]
   14208:	687a      	ldr	r2, [r7, #4]
   1420a:	4413      	add	r3, r2
   1420c:	681b      	ldr	r3, [r3, #0]
   1420e:	2b00      	cmp	r3, #0
   14210:	bf14      	ite	ne
   14212:	2301      	movne	r3, #1
   14214:	2300      	moveq	r3, #0
   14216:	b2db      	uxtb	r3, r3
}
   14218:	4618      	mov	r0, r3
   1421a:	370c      	adds	r7, #12
   1421c:	46bd      	mov	sp, r7
   1421e:	bc80      	pop	{r7}
   14220:	4770      	bx	lr

00014222 <nrf_uarte_event_address_get>:

NRF_STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type const * p_reg,
                                                       nrf_uarte_event_t      event)
{
   14222:	b480      	push	{r7}
   14224:	b083      	sub	sp, #12
   14226:	af00      	add	r7, sp, #0
   14228:	6078      	str	r0, [r7, #4]
   1422a:	460b      	mov	r3, r1
   1422c:	807b      	strh	r3, [r7, #2]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
   1422e:	887b      	ldrh	r3, [r7, #2]
   14230:	687a      	ldr	r2, [r7, #4]
   14232:	4413      	add	r3, r2
}
   14234:	4618      	mov	r0, r3
   14236:	370c      	adds	r7, #12
   14238:	46bd      	mov	sp, r7
   1423a:	bc80      	pop	{r7}
   1423c:	4770      	bx	lr

0001423e <nrf_uarte_shorts_enable>:

NRF_STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
{
   1423e:	b480      	push	{r7}
   14240:	b083      	sub	sp, #12
   14242:	af00      	add	r7, sp, #0
   14244:	6078      	str	r0, [r7, #4]
   14246:	6039      	str	r1, [r7, #0]
    p_reg->SHORTS |= mask;
   14248:	687b      	ldr	r3, [r7, #4]
   1424a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   1424e:	683b      	ldr	r3, [r7, #0]
   14250:	431a      	orrs	r2, r3
   14252:	687b      	ldr	r3, [r7, #4]
   14254:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   14258:	bf00      	nop
   1425a:	370c      	adds	r7, #12
   1425c:	46bd      	mov	sp, r7
   1425e:	bc80      	pop	{r7}
   14260:	4770      	bx	lr

00014262 <nrf_uarte_shorts_disable>:

NRF_STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
{
   14262:	b480      	push	{r7}
   14264:	b083      	sub	sp, #12
   14266:	af00      	add	r7, sp, #0
   14268:	6078      	str	r0, [r7, #4]
   1426a:	6039      	str	r1, [r7, #0]
    p_reg->SHORTS &= ~(mask);
   1426c:	687b      	ldr	r3, [r7, #4]
   1426e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   14272:	683b      	ldr	r3, [r7, #0]
   14274:	43db      	mvns	r3, r3
   14276:	401a      	ands	r2, r3
   14278:	687b      	ldr	r3, [r7, #4]
   1427a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   1427e:	bf00      	nop
   14280:	370c      	adds	r7, #12
   14282:	46bd      	mov	sp, r7
   14284:	bc80      	pop	{r7}
   14286:	4770      	bx	lr

00014288 <nrf_uarte_int_enable>:

NRF_STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
{
   14288:	b480      	push	{r7}
   1428a:	b083      	sub	sp, #12
   1428c:	af00      	add	r7, sp, #0
   1428e:	6078      	str	r0, [r7, #4]
   14290:	6039      	str	r1, [r7, #0]
    p_reg->INTENSET = mask;
   14292:	687b      	ldr	r3, [r7, #4]
   14294:	683a      	ldr	r2, [r7, #0]
   14296:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1429a:	bf00      	nop
   1429c:	370c      	adds	r7, #12
   1429e:	46bd      	mov	sp, r7
   142a0:	bc80      	pop	{r7}
   142a2:	4770      	bx	lr

000142a4 <nrf_uarte_int_enable_check>:

NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask)
{
   142a4:	b480      	push	{r7}
   142a6:	b083      	sub	sp, #12
   142a8:	af00      	add	r7, sp, #0
   142aa:	6078      	str	r0, [r7, #4]
   142ac:	6039      	str	r1, [r7, #0]
    return p_reg->INTENSET & mask;
   142ae:	687b      	ldr	r3, [r7, #4]
   142b0:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
   142b4:	683b      	ldr	r3, [r7, #0]
   142b6:	4013      	ands	r3, r2
}
   142b8:	4618      	mov	r0, r3
   142ba:	370c      	adds	r7, #12
   142bc:	46bd      	mov	sp, r7
   142be:	bc80      	pop	{r7}
   142c0:	4770      	bx	lr

000142c2 <nrf_uarte_int_disable>:

NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
{
   142c2:	b480      	push	{r7}
   142c4:	b083      	sub	sp, #12
   142c6:	af00      	add	r7, sp, #0
   142c8:	6078      	str	r0, [r7, #4]
   142ca:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   142cc:	687b      	ldr	r3, [r7, #4]
   142ce:	683a      	ldr	r2, [r7, #0]
   142d0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   142d4:	bf00      	nop
   142d6:	370c      	adds	r7, #12
   142d8:	46bd      	mov	sp, r7
   142da:	bc80      	pop	{r7}
   142dc:	4770      	bx	lr

000142de <nrf_uarte_publish_set>:
}

NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
                                             nrf_uarte_event_t event,
                                             uint8_t           channel)
{
   142de:	b480      	push	{r7}
   142e0:	b083      	sub	sp, #12
   142e2:	af00      	add	r7, sp, #0
   142e4:	6078      	str	r0, [r7, #4]
   142e6:	460b      	mov	r3, r1
   142e8:	807b      	strh	r3, [r7, #2]
   142ea:	4613      	mov	r3, r2
   142ec:	707b      	strb	r3, [r7, #1]
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
            ((uint32_t)channel | UARTE_PUBLISH_CTS_EN_Msk);
   142ee:	787a      	ldrb	r2, [r7, #1]
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
   142f0:	887b      	ldrh	r3, [r7, #2]
   142f2:	3380      	adds	r3, #128	; 0x80
   142f4:	6879      	ldr	r1, [r7, #4]
   142f6:	440b      	add	r3, r1
            ((uint32_t)channel | UARTE_PUBLISH_CTS_EN_Msk);
   142f8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
   142fc:	601a      	str	r2, [r3, #0]
}
   142fe:	bf00      	nop
   14300:	370c      	adds	r7, #12
   14302:	46bd      	mov	sp, r7
   14304:	bc80      	pop	{r7}
   14306:	4770      	bx	lr

00014308 <nrf_uarte_errorsrc_get_and_clear>:
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
}
#endif // defined(DPPI_PRESENT)

NRF_STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg)
{
   14308:	b480      	push	{r7}
   1430a:	b085      	sub	sp, #20
   1430c:	af00      	add	r7, sp, #0
   1430e:	6078      	str	r0, [r7, #4]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   14310:	687b      	ldr	r3, [r7, #4]
   14312:	f8d3 3480 	ldr.w	r3, [r3, #1152]	; 0x480
   14316:	60fb      	str	r3, [r7, #12]
    p_reg->ERRORSRC = errsrc_mask;
   14318:	687b      	ldr	r3, [r7, #4]
   1431a:	68fa      	ldr	r2, [r7, #12]
   1431c:	f8c3 2480 	str.w	r2, [r3, #1152]	; 0x480
    return errsrc_mask;
   14320:	68fb      	ldr	r3, [r7, #12]
}
   14322:	4618      	mov	r0, r3
   14324:	3714      	adds	r7, #20
   14326:	46bd      	mov	sp, r7
   14328:	bc80      	pop	{r7}
   1432a:	4770      	bx	lr

0001432c <nrf_uarte_enable>:

NRF_STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type * p_reg)
{
   1432c:	b480      	push	{r7}
   1432e:	b083      	sub	sp, #12
   14330:	af00      	add	r7, sp, #0
   14332:	6078      	str	r0, [r7, #4]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   14334:	687b      	ldr	r3, [r7, #4]
   14336:	2208      	movs	r2, #8
   14338:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   1433c:	bf00      	nop
   1433e:	370c      	adds	r7, #12
   14340:	46bd      	mov	sp, r7
   14342:	bc80      	pop	{r7}
   14344:	4770      	bx	lr

00014346 <nrf_uarte_disable>:

NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg)
{
   14346:	b480      	push	{r7}
   14348:	b083      	sub	sp, #12
   1434a:	af00      	add	r7, sp, #0
   1434c:	6078      	str	r0, [r7, #4]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   1434e:	687b      	ldr	r3, [r7, #4]
   14350:	2200      	movs	r2, #0
   14352:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   14356:	bf00      	nop
   14358:	370c      	adds	r7, #12
   1435a:	46bd      	mov	sp, r7
   1435c:	bc80      	pop	{r7}
   1435e:	4770      	bx	lr

00014360 <nrf_uarte_txrx_pins_set>:

NRF_STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg,
                                               uint32_t         pseltxd,
                                               uint32_t         pselrxd)
{
   14360:	b480      	push	{r7}
   14362:	b085      	sub	sp, #20
   14364:	af00      	add	r7, sp, #0
   14366:	60f8      	str	r0, [r7, #12]
   14368:	60b9      	str	r1, [r7, #8]
   1436a:	607a      	str	r2, [r7, #4]
    p_reg->PSEL.TXD = pseltxd;
   1436c:	68fb      	ldr	r3, [r7, #12]
   1436e:	68ba      	ldr	r2, [r7, #8]
   14370:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   14374:	68fb      	ldr	r3, [r7, #12]
   14376:	687a      	ldr	r2, [r7, #4]
   14378:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
}
   1437c:	bf00      	nop
   1437e:	3714      	adds	r7, #20
   14380:	46bd      	mov	sp, r7
   14382:	bc80      	pop	{r7}
   14384:	4770      	bx	lr

00014386 <nrf_uarte_rx_pin_get>:
{
    return p_reg->PSEL.TXD;
}

NRF_STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type const * p_reg)
{
   14386:	b480      	push	{r7}
   14388:	b083      	sub	sp, #12
   1438a:	af00      	add	r7, sp, #0
   1438c:	6078      	str	r0, [r7, #4]
    return p_reg->PSEL.RXD;
   1438e:	687b      	ldr	r3, [r7, #4]
   14390:	f8d3 3514 	ldr.w	r3, [r3, #1300]	; 0x514
}
   14394:	4618      	mov	r0, r3
   14396:	370c      	adds	r7, #12
   14398:	46bd      	mov	sp, r7
   1439a:	bc80      	pop	{r7}
   1439c:	4770      	bx	lr

0001439e <nrf_uarte_hwfc_pins_set>:
}

NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg,
                                               uint32_t         pselrts,
                                               uint32_t         pselcts)
{
   1439e:	b480      	push	{r7}
   143a0:	b085      	sub	sp, #20
   143a2:	af00      	add	r7, sp, #0
   143a4:	60f8      	str	r0, [r7, #12]
   143a6:	60b9      	str	r1, [r7, #8]
   143a8:	607a      	str	r2, [r7, #4]
    p_reg->PSEL.RTS = pselrts;
   143aa:	68fb      	ldr	r3, [r7, #12]
   143ac:	68ba      	ldr	r2, [r7, #8]
   143ae:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
   143b2:	68fb      	ldr	r3, [r7, #12]
   143b4:	687a      	ldr	r2, [r7, #4]
   143b6:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   143ba:	bf00      	nop
   143bc:	3714      	adds	r7, #20
   143be:	46bd      	mov	sp, r7
   143c0:	bc80      	pop	{r7}
   143c2:	4770      	bx	lr

000143c4 <nrf_uarte_task_trigger>:
{
    nrf_uarte_hwfc_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
}

NRF_STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task)
{
   143c4:	b480      	push	{r7}
   143c6:	b083      	sub	sp, #12
   143c8:	af00      	add	r7, sp, #0
   143ca:	6078      	str	r0, [r7, #4]
   143cc:	460b      	mov	r3, r1
   143ce:	70fb      	strb	r3, [r7, #3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   143d0:	78fb      	ldrb	r3, [r7, #3]
   143d2:	687a      	ldr	r2, [r7, #4]
   143d4:	4413      	add	r3, r2
   143d6:	2201      	movs	r2, #1
   143d8:	601a      	str	r2, [r3, #0]
}
   143da:	bf00      	nop
   143dc:	370c      	adds	r7, #12
   143de:	46bd      	mov	sp, r7
   143e0:	bc80      	pop	{r7}
   143e2:	4770      	bx	lr

000143e4 <nrf_uarte_task_address_get>:

NRF_STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type const * p_reg,
                                                      nrf_uarte_task_t       task)
{
   143e4:	b480      	push	{r7}
   143e6:	b083      	sub	sp, #12
   143e8:	af00      	add	r7, sp, #0
   143ea:	6078      	str	r0, [r7, #4]
   143ec:	460b      	mov	r3, r1
   143ee:	70fb      	strb	r3, [r7, #3]
    return (uint32_t)p_reg + (uint32_t)task;
   143f0:	78fa      	ldrb	r2, [r7, #3]
   143f2:	687b      	ldr	r3, [r7, #4]
   143f4:	4413      	add	r3, r2
}
   143f6:	4618      	mov	r0, r3
   143f8:	370c      	adds	r7, #12
   143fa:	46bd      	mov	sp, r7
   143fc:	bc80      	pop	{r7}
   143fe:	4770      	bx	lr

00014400 <nrf_uarte_configure>:

NRF_STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type           * p_reg,
                                           nrf_uarte_config_t const * p_cfg)
{
   14400:	b480      	push	{r7}
   14402:	b083      	sub	sp, #12
   14404:	af00      	add	r7, sp, #0
   14406:	6078      	str	r0, [r7, #4]
   14408:	6039      	str	r1, [r7, #0]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1440a:	683b      	ldr	r3, [r7, #0]
   1440c:	785a      	ldrb	r2, [r3, #1]
#if defined(UARTE_CONFIG_STOP_Msk)
                    | (uint32_t)p_cfg->stop
   1440e:	683b      	ldr	r3, [r7, #0]
   14410:	789b      	ldrb	r3, [r3, #2]
#endif
#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
                    | (uint32_t)p_cfg->paritytype
#endif
                    | (uint32_t)p_cfg->hwfc;
   14412:	4313      	orrs	r3, r2
   14414:	b2da      	uxtb	r2, r3
   14416:	683b      	ldr	r3, [r7, #0]
   14418:	781b      	ldrb	r3, [r3, #0]
   1441a:	4313      	orrs	r3, r2
   1441c:	b2db      	uxtb	r3, r3
   1441e:	461a      	mov	r2, r3
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   14420:	687b      	ldr	r3, [r7, #4]
   14422:	f8c3 256c 	str.w	r2, [r3, #1388]	; 0x56c
}
   14426:	bf00      	nop
   14428:	370c      	adds	r7, #12
   1442a:	46bd      	mov	sp, r7
   1442c:	bc80      	pop	{r7}
   1442e:	4770      	bx	lr

00014430 <nrf_uarte_baudrate_set>:

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
   14430:	b480      	push	{r7}
   14432:	b083      	sub	sp, #12
   14434:	af00      	add	r7, sp, #0
   14436:	6078      	str	r0, [r7, #4]
   14438:	6039      	str	r1, [r7, #0]
    p_reg->BAUDRATE = baudrate;
   1443a:	687b      	ldr	r3, [r7, #4]
   1443c:	683a      	ldr	r2, [r7, #0]
   1443e:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
}
   14442:	bf00      	nop
   14444:	370c      	adds	r7, #12
   14446:	46bd      	mov	sp, r7
   14448:	bc80      	pop	{r7}
   1444a:	4770      	bx	lr

0001444c <nrf_uarte_tx_buffer_set>:

NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
   1444c:	b480      	push	{r7}
   1444e:	b085      	sub	sp, #20
   14450:	af00      	add	r7, sp, #0
   14452:	60f8      	str	r0, [r7, #12]
   14454:	60b9      	str	r1, [r7, #8]
   14456:	607a      	str	r2, [r7, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   14458:	68ba      	ldr	r2, [r7, #8]
   1445a:	68fb      	ldr	r3, [r7, #12]
   1445c:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   14460:	68fb      	ldr	r3, [r7, #12]
   14462:	687a      	ldr	r2, [r7, #4]
   14464:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
}
   14468:	bf00      	nop
   1446a:	3714      	adds	r7, #20
   1446c:	46bd      	mov	sp, r7
   1446e:	bc80      	pop	{r7}
   14470:	4770      	bx	lr

00014472 <nrf_uarte_tx_amount_get>:

NRF_STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type const * p_reg)
{
   14472:	b480      	push	{r7}
   14474:	b083      	sub	sp, #12
   14476:	af00      	add	r7, sp, #0
   14478:	6078      	str	r0, [r7, #4]
    return p_reg->TXD.AMOUNT;
   1447a:	687b      	ldr	r3, [r7, #4]
   1447c:	f8d3 354c 	ldr.w	r3, [r3, #1356]	; 0x54c
}
   14480:	4618      	mov	r0, r3
   14482:	370c      	adds	r7, #12
   14484:	46bd      	mov	sp, r7
   14486:	bc80      	pop	{r7}
   14488:	4770      	bx	lr

0001448a <nrf_uarte_rx_buffer_set>:

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
   1448a:	b480      	push	{r7}
   1448c:	b085      	sub	sp, #20
   1448e:	af00      	add	r7, sp, #0
   14490:	60f8      	str	r0, [r7, #12]
   14492:	60b9      	str	r1, [r7, #8]
   14494:	607a      	str	r2, [r7, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   14496:	68ba      	ldr	r2, [r7, #8]
   14498:	68fb      	ldr	r3, [r7, #12]
   1449a:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   1449e:	68fb      	ldr	r3, [r7, #12]
   144a0:	687a      	ldr	r2, [r7, #4]
   144a2:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
}
   144a6:	bf00      	nop
   144a8:	3714      	adds	r7, #20
   144aa:	46bd      	mov	sp, r7
   144ac:	bc80      	pop	{r7}
   144ae:	4770      	bx	lr

000144b0 <nrf_uarte_rx_amount_get>:

NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg)
{
   144b0:	b480      	push	{r7}
   144b2:	b083      	sub	sp, #12
   144b4:	af00      	add	r7, sp, #0
   144b6:	6078      	str	r0, [r7, #4]
    return p_reg->RXD.AMOUNT;
   144b8:	687b      	ldr	r3, [r7, #4]
   144ba:	f8d3 353c 	ldr.w	r3, [r3, #1340]	; 0x53c
}
   144be:	4618      	mov	r0, r3
   144c0:	370c      	adds	r7, #12
   144c2:	46bd      	mov	sp, r7
   144c4:	bc80      	pop	{r7}
   144c6:	4770      	bx	lr

000144c8 <nrf_timer_subscribe_set>:

#if defined(DPPI_PRESENT)
NRF_STATIC_INLINE void nrf_timer_subscribe_set(NRF_TIMER_Type * p_reg,
                                               nrf_timer_task_t task,
                                               uint8_t          channel)
{
   144c8:	b480      	push	{r7}
   144ca:	b083      	sub	sp, #12
   144cc:	af00      	add	r7, sp, #0
   144ce:	6078      	str	r0, [r7, #4]
   144d0:	460b      	mov	r3, r1
   144d2:	70fb      	strb	r3, [r7, #3]
   144d4:	4613      	mov	r3, r2
   144d6:	70bb      	strb	r3, [r7, #2]
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
            ((uint32_t)channel | TIMER_SUBSCRIBE_START_EN_Msk);
   144d8:	78ba      	ldrb	r2, [r7, #2]
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
   144da:	78fb      	ldrb	r3, [r7, #3]
   144dc:	3380      	adds	r3, #128	; 0x80
   144de:	6879      	ldr	r1, [r7, #4]
   144e0:	440b      	add	r3, r1
            ((uint32_t)channel | TIMER_SUBSCRIBE_START_EN_Msk);
   144e2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
   144e6:	601a      	str	r2, [r3, #0]
}
   144e8:	bf00      	nop
   144ea:	370c      	adds	r7, #12
   144ec:	46bd      	mov	sp, r7
   144ee:	bc80      	pop	{r7}
   144f0:	4770      	bx	lr

000144f2 <nrf_dppi_channels_enable>:
{
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
   144f2:	b480      	push	{r7}
   144f4:	b083      	sub	sp, #12
   144f6:	af00      	add	r7, sp, #0
   144f8:	6078      	str	r0, [r7, #4]
   144fa:	6039      	str	r1, [r7, #0]
    p_reg->CHENSET = mask;
   144fc:	687b      	ldr	r3, [r7, #4]
   144fe:	683a      	ldr	r2, [r7, #0]
   14500:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   14504:	bf00      	nop
   14506:	370c      	adds	r7, #12
   14508:	46bd      	mov	sp, r7
   1450a:	bc80      	pop	{r7}
   1450c:	4770      	bx	lr

0001450e <nrfx_gppi_channel_endpoints_setup>:

__STATIC_INLINE void nrfx_gppi_channel_endpoints_setup(uint8_t  channel,
                                                       uint32_t eep,
                                                       uint32_t tep)
{
   1450e:	b580      	push	{r7, lr}
   14510:	b084      	sub	sp, #16
   14512:	af00      	add	r7, sp, #0
   14514:	4603      	mov	r3, r0
   14516:	60b9      	str	r1, [r7, #8]
   14518:	607a      	str	r2, [r7, #4]
   1451a:	73fb      	strb	r3, [r7, #15]
    nrfx_gppi_event_endpoint_setup(channel, eep);
   1451c:	7bfb      	ldrb	r3, [r7, #15]
   1451e:	68b9      	ldr	r1, [r7, #8]
   14520:	4618      	mov	r0, r3
   14522:	f7f2 ffb1 	bl	7488 <nrfx_gppi_event_endpoint_setup>
    nrfx_gppi_task_endpoint_setup(channel, tep);
   14526:	7bfb      	ldrb	r3, [r7, #15]
   14528:	6879      	ldr	r1, [r7, #4]
   1452a:	4618      	mov	r0, r3
   1452c:	f7f2 ffd2 	bl	74d4 <nrfx_gppi_task_endpoint_setup>
}
   14530:	bf00      	nop
   14532:	3710      	adds	r7, #16
   14534:	46bd      	mov	sp, r7
   14536:	bd80      	pop	{r7, pc}

00014538 <get_dev_data>:
{
   14538:	b480      	push	{r7}
   1453a:	b083      	sub	sp, #12
   1453c:	af00      	add	r7, sp, #0
   1453e:	6078      	str	r0, [r7, #4]
	return dev->data;
   14540:	687b      	ldr	r3, [r7, #4]
   14542:	68db      	ldr	r3, [r3, #12]
}
   14544:	4618      	mov	r0, r3
   14546:	370c      	adds	r7, #12
   14548:	46bd      	mov	sp, r7
   1454a:	bc80      	pop	{r7}
   1454c:	4770      	bx	lr

0001454e <get_dev_config>:
{
   1454e:	b480      	push	{r7}
   14550:	b083      	sub	sp, #12
   14552:	af00      	add	r7, sp, #0
   14554:	6078      	str	r0, [r7, #4]
	return dev->config;
   14556:	687b      	ldr	r3, [r7, #4]
   14558:	685b      	ldr	r3, [r3, #4]
}
   1455a:	4618      	mov	r0, r3
   1455c:	370c      	adds	r7, #12
   1455e:	46bd      	mov	sp, r7
   14560:	bc80      	pop	{r7}
   14562:	4770      	bx	lr

00014564 <get_uarte_instance>:
{
   14564:	b580      	push	{r7, lr}
   14566:	b084      	sub	sp, #16
   14568:	af00      	add	r7, sp, #0
   1456a:	6078      	str	r0, [r7, #4]
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   1456c:	6878      	ldr	r0, [r7, #4]
   1456e:	f7ff ffee 	bl	1454e <get_dev_config>
   14572:	60f8      	str	r0, [r7, #12]
	return config->uarte_regs;
   14574:	68fb      	ldr	r3, [r7, #12]
   14576:	681b      	ldr	r3, [r3, #0]
}
   14578:	4618      	mov	r0, r3
   1457a:	3710      	adds	r7, #16
   1457c:	46bd      	mov	sp, r7
   1457e:	bd80      	pop	{r7, pc}

00014580 <endtx_isr>:
{
   14580:	b580      	push	{r7, lr}
   14582:	b088      	sub	sp, #32
   14584:	af00      	add	r7, sp, #0
   14586:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   14588:	6878      	ldr	r0, [r7, #4]
   1458a:	f7ff ffeb 	bl	14564 <get_uarte_instance>
   1458e:	61f8      	str	r0, [r7, #28]
	__asm__ volatile(
   14590:	f04f 0320 	mov.w	r3, #32
   14594:	f3ef 8211 	mrs	r2, BASEPRI
   14598:	f383 8811 	msr	BASEPRI, r3
   1459c:	f3bf 8f6f 	isb	sy
   145a0:	617a      	str	r2, [r7, #20]
   145a2:	613b      	str	r3, [r7, #16]
	return key;
   145a4:	697b      	ldr	r3, [r7, #20]
	int key = irq_lock();
   145a6:	61bb      	str	r3, [r7, #24]
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   145a8:	f44f 7190 	mov.w	r1, #288	; 0x120
   145ac:	69f8      	ldr	r0, [r7, #28]
   145ae:	f7ff fe24 	bl	141fa <nrf_uarte_event_check>
   145b2:	4603      	mov	r3, r0
   145b4:	2b00      	cmp	r3, #0
   145b6:	d008      	beq.n	145ca <endtx_isr+0x4a>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDTX);
   145b8:	f44f 7190 	mov.w	r1, #288	; 0x120
   145bc:	69f8      	ldr	r0, [r7, #28]
   145be:	f7ff fe07 	bl	141d0 <nrf_uarte_event_clear>
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
   145c2:	210c      	movs	r1, #12
   145c4:	69f8      	ldr	r0, [r7, #28]
   145c6:	f7ff fefd 	bl	143c4 <nrf_uarte_task_trigger>
	irq_unlock(key);
   145ca:	69bb      	ldr	r3, [r7, #24]
   145cc:	60fb      	str	r3, [r7, #12]
	__asm__ volatile(
   145ce:	68fb      	ldr	r3, [r7, #12]
   145d0:	f383 8811 	msr	BASEPRI, r3
   145d4:	f3bf 8f6f 	isb	sy
}
   145d8:	bf00      	nop
}
   145da:	bf00      	nop
   145dc:	3720      	adds	r7, #32
   145de:	46bd      	mov	sp, r7
   145e0:	bd80      	pop	{r7, pc}

000145e2 <uarte_nrfx_isr_int>:
{
   145e2:	b580      	push	{r7, lr}
   145e4:	b086      	sub	sp, #24
   145e6:	af00      	add	r7, sp, #0
   145e8:	6078      	str	r0, [r7, #4]
	const struct device *dev = arg;
   145ea:	687b      	ldr	r3, [r7, #4]
   145ec:	617b      	str	r3, [r7, #20]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   145ee:	6978      	ldr	r0, [r7, #20]
   145f0:	f7ff ffb8 	bl	14564 <get_uarte_instance>
   145f4:	6138      	str	r0, [r7, #16]
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   145f6:	f44f 7180 	mov.w	r1, #256	; 0x100
   145fa:	6938      	ldr	r0, [r7, #16]
   145fc:	f7ff fe52 	bl	142a4 <nrf_uarte_int_enable_check>
   14600:	4603      	mov	r3, r0
   14602:	2b00      	cmp	r3, #0
   14604:	d00a      	beq.n	1461c <uarte_nrfx_isr_int+0x3a>
		nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   14606:	f44f 7190 	mov.w	r1, #288	; 0x120
   1460a:	6938      	ldr	r0, [r7, #16]
   1460c:	f7ff fdf5 	bl	141fa <nrf_uarte_event_check>
   14610:	4603      	mov	r3, r0
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   14612:	2b00      	cmp	r3, #0
   14614:	d002      	beq.n	1461c <uarte_nrfx_isr_int+0x3a>
		endtx_isr(dev);
   14616:	6978      	ldr	r0, [r7, #20]
   14618:	f7ff ffb2 	bl	14580 <endtx_isr>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1461c:	6978      	ldr	r0, [r7, #20]
   1461e:	f7ff ff8b 	bl	14538 <get_dev_data>
   14622:	60f8      	str	r0, [r7, #12]
	if (!data->int_driven) {
   14624:	68fb      	ldr	r3, [r7, #12]
   14626:	68db      	ldr	r3, [r3, #12]
   14628:	2b00      	cmp	r3, #0
   1462a:	d037      	beq.n	1469c <uarte_nrfx_isr_int+0xba>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   1462c:	f44f 71ac 	mov.w	r1, #344	; 0x158
   14630:	6938      	ldr	r0, [r7, #16]
   14632:	f7ff fde2 	bl	141fa <nrf_uarte_event_check>
   14636:	4603      	mov	r3, r0
   14638:	2b00      	cmp	r3, #0
   1463a:	d013      	beq.n	14664 <uarte_nrfx_isr_int+0x82>
		data->int_driven->fifo_fill_lock = 0;
   1463c:	68fb      	ldr	r3, [r7, #12]
   1463e:	68db      	ldr	r3, [r3, #12]
   14640:	2200      	movs	r2, #0
   14642:	611a      	str	r2, [r3, #16]
		if (data->int_driven->disable_tx_irq) {
   14644:	68fb      	ldr	r3, [r7, #12]
   14646:	68db      	ldr	r3, [r3, #12]
   14648:	7b9b      	ldrb	r3, [r3, #14]
   1464a:	b2db      	uxtb	r3, r3
   1464c:	2b00      	cmp	r3, #0
   1464e:	d009      	beq.n	14664 <uarte_nrfx_isr_int+0x82>
			nrf_uarte_int_disable(uarte,
   14650:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   14654:	6938      	ldr	r0, [r7, #16]
   14656:	f7ff fe34 	bl	142c2 <nrf_uarte_int_disable>
			data->int_driven->disable_tx_irq = false;
   1465a:	68fb      	ldr	r3, [r7, #12]
   1465c:	68db      	ldr	r3, [r3, #12]
   1465e:	2200      	movs	r2, #0
   14660:	739a      	strb	r2, [r3, #14]
			return;
   14662:	e01c      	b.n	1469e <uarte_nrfx_isr_int+0xbc>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   14664:	f44f 7192 	mov.w	r1, #292	; 0x124
   14668:	6938      	ldr	r0, [r7, #16]
   1466a:	f7ff fdc6 	bl	141fa <nrf_uarte_event_check>
   1466e:	4603      	mov	r3, r0
   14670:	2b00      	cmp	r3, #0
   14672:	d004      	beq.n	1467e <uarte_nrfx_isr_int+0x9c>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ERROR);
   14674:	f44f 7192 	mov.w	r1, #292	; 0x124
   14678:	6938      	ldr	r0, [r7, #16]
   1467a:	f7ff fda9 	bl	141d0 <nrf_uarte_event_clear>
	if (data->int_driven->cb) {
   1467e:	68fb      	ldr	r3, [r7, #12]
   14680:	68db      	ldr	r3, [r3, #12]
   14682:	681b      	ldr	r3, [r3, #0]
   14684:	2b00      	cmp	r3, #0
   14686:	d00a      	beq.n	1469e <uarte_nrfx_isr_int+0xbc>
		data->int_driven->cb(dev, data->int_driven->cb_data);
   14688:	68fb      	ldr	r3, [r7, #12]
   1468a:	68db      	ldr	r3, [r3, #12]
   1468c:	681b      	ldr	r3, [r3, #0]
   1468e:	68fa      	ldr	r2, [r7, #12]
   14690:	68d2      	ldr	r2, [r2, #12]
   14692:	6852      	ldr	r2, [r2, #4]
   14694:	4611      	mov	r1, r2
   14696:	6978      	ldr	r0, [r7, #20]
   14698:	4798      	blx	r3
   1469a:	e000      	b.n	1469e <uarte_nrfx_isr_int+0xbc>
		return;
   1469c:	bf00      	nop
}
   1469e:	3718      	adds	r7, #24
   146a0:	46bd      	mov	sp, r7
   146a2:	bd80      	pop	{r7, pc}

000146a4 <uarte_nrfx_configure>:
{
   146a4:	b580      	push	{r7, lr}
   146a6:	b084      	sub	sp, #16
   146a8:	af00      	add	r7, sp, #0
   146aa:	6078      	str	r0, [r7, #4]
   146ac:	6039      	str	r1, [r7, #0]
	switch (cfg->stop_bits) {
   146ae:	683b      	ldr	r3, [r7, #0]
   146b0:	795b      	ldrb	r3, [r3, #5]
   146b2:	2b01      	cmp	r3, #1
   146b4:	d002      	beq.n	146bc <uarte_nrfx_configure+0x18>
   146b6:	2b03      	cmp	r3, #3
   146b8:	d003      	beq.n	146c2 <uarte_nrfx_configure+0x1e>
   146ba:	e005      	b.n	146c8 <uarte_nrfx_configure+0x24>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   146bc:	2300      	movs	r3, #0
   146be:	73bb      	strb	r3, [r7, #14]
		break;
   146c0:	e005      	b.n	146ce <uarte_nrfx_configure+0x2a>
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   146c2:	2310      	movs	r3, #16
   146c4:	73bb      	strb	r3, [r7, #14]
		break;
   146c6:	e002      	b.n	146ce <uarte_nrfx_configure+0x2a>
		return -ENOTSUP;
   146c8:	f06f 0322 	mvn.w	r3, #34	; 0x22
   146cc:	e051      	b.n	14772 <uarte_nrfx_configure+0xce>
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   146ce:	683b      	ldr	r3, [r7, #0]
   146d0:	799b      	ldrb	r3, [r3, #6]
   146d2:	2b03      	cmp	r3, #3
   146d4:	d002      	beq.n	146dc <uarte_nrfx_configure+0x38>
		return -ENOTSUP;
   146d6:	f06f 0322 	mvn.w	r3, #34	; 0x22
   146da:	e04a      	b.n	14772 <uarte_nrfx_configure+0xce>
	switch (cfg->flow_ctrl) {
   146dc:	683b      	ldr	r3, [r7, #0]
   146de:	79db      	ldrb	r3, [r3, #7]
   146e0:	2b00      	cmp	r3, #0
   146e2:	d002      	beq.n	146ea <uarte_nrfx_configure+0x46>
   146e4:	2b01      	cmp	r3, #1
   146e6:	d003      	beq.n	146f0 <uarte_nrfx_configure+0x4c>
   146e8:	e00f      	b.n	1470a <uarte_nrfx_configure+0x66>
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
   146ea:	2300      	movs	r3, #0
   146ec:	733b      	strb	r3, [r7, #12]
		break;
   146ee:	e00f      	b.n	14710 <uarte_nrfx_configure+0x6c>
		if (get_dev_config(dev)->rts_cts_pins_set) {
   146f0:	6878      	ldr	r0, [r7, #4]
   146f2:	f7ff ff2c 	bl	1454e <get_dev_config>
   146f6:	4603      	mov	r3, r0
   146f8:	791b      	ldrb	r3, [r3, #4]
   146fa:	2b00      	cmp	r3, #0
   146fc:	d002      	beq.n	14704 <uarte_nrfx_configure+0x60>
			uarte_cfg.hwfc = NRF_UARTE_HWFC_ENABLED;
   146fe:	2301      	movs	r3, #1
   14700:	733b      	strb	r3, [r7, #12]
		break;
   14702:	e005      	b.n	14710 <uarte_nrfx_configure+0x6c>
			return -ENOTSUP;
   14704:	f06f 0322 	mvn.w	r3, #34	; 0x22
   14708:	e033      	b.n	14772 <uarte_nrfx_configure+0xce>
		return -ENOTSUP;
   1470a:	f06f 0322 	mvn.w	r3, #34	; 0x22
   1470e:	e030      	b.n	14772 <uarte_nrfx_configure+0xce>
	switch (cfg->parity) {
   14710:	683b      	ldr	r3, [r7, #0]
   14712:	791b      	ldrb	r3, [r3, #4]
   14714:	2b00      	cmp	r3, #0
   14716:	d002      	beq.n	1471e <uarte_nrfx_configure+0x7a>
   14718:	2b02      	cmp	r3, #2
   1471a:	d003      	beq.n	14724 <uarte_nrfx_configure+0x80>
   1471c:	e005      	b.n	1472a <uarte_nrfx_configure+0x86>
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
   1471e:	2300      	movs	r3, #0
   14720:	737b      	strb	r3, [r7, #13]
		break;
   14722:	e005      	b.n	14730 <uarte_nrfx_configure+0x8c>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   14724:	230e      	movs	r3, #14
   14726:	737b      	strb	r3, [r7, #13]
		break;
   14728:	e002      	b.n	14730 <uarte_nrfx_configure+0x8c>
		return -ENOTSUP;
   1472a:	f06f 0322 	mvn.w	r3, #34	; 0x22
   1472e:	e020      	b.n	14772 <uarte_nrfx_configure+0xce>
	if (baudrate_set(dev, cfg->baudrate) != 0) {
   14730:	683b      	ldr	r3, [r7, #0]
   14732:	681b      	ldr	r3, [r3, #0]
   14734:	4619      	mov	r1, r3
   14736:	6878      	ldr	r0, [r7, #4]
   14738:	f7f2 fef2 	bl	7520 <baudrate_set>
   1473c:	4603      	mov	r3, r0
   1473e:	2b00      	cmp	r3, #0
   14740:	d002      	beq.n	14748 <uarte_nrfx_configure+0xa4>
		return -ENOTSUP;
   14742:	f06f 0322 	mvn.w	r3, #34	; 0x22
   14746:	e014      	b.n	14772 <uarte_nrfx_configure+0xce>
	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);
   14748:	6878      	ldr	r0, [r7, #4]
   1474a:	f7ff ff0b 	bl	14564 <get_uarte_instance>
   1474e:	4602      	mov	r2, r0
   14750:	f107 030c 	add.w	r3, r7, #12
   14754:	4619      	mov	r1, r3
   14756:	4610      	mov	r0, r2
   14758:	f7ff fe52 	bl	14400 <nrf_uarte_configure>
	get_dev_data(dev)->uart_config = *cfg;
   1475c:	6878      	ldr	r0, [r7, #4]
   1475e:	f7ff feeb 	bl	14538 <get_dev_data>
   14762:	4603      	mov	r3, r0
   14764:	683a      	ldr	r2, [r7, #0]
   14766:	3304      	adds	r3, #4
   14768:	e892 0003 	ldmia.w	r2, {r0, r1}
   1476c:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
   14770:	2300      	movs	r3, #0
}
   14772:	4618      	mov	r0, r3
   14774:	3710      	adds	r7, #16
   14776:	46bd      	mov	sp, r7
   14778:	bd80      	pop	{r7, pc}

0001477a <uarte_nrfx_config_get>:
{
   1477a:	b580      	push	{r7, lr}
   1477c:	b082      	sub	sp, #8
   1477e:	af00      	add	r7, sp, #0
   14780:	6078      	str	r0, [r7, #4]
   14782:	6039      	str	r1, [r7, #0]
	*cfg = get_dev_data(dev)->uart_config;
   14784:	6878      	ldr	r0, [r7, #4]
   14786:	f7ff fed7 	bl	14538 <get_dev_data>
   1478a:	4603      	mov	r3, r0
   1478c:	683a      	ldr	r2, [r7, #0]
   1478e:	3304      	adds	r3, #4
   14790:	e893 0003 	ldmia.w	r3, {r0, r1}
   14794:	e882 0003 	stmia.w	r2, {r0, r1}
	return 0;
   14798:	2300      	movs	r3, #0
}
   1479a:	4618      	mov	r0, r3
   1479c:	3708      	adds	r7, #8
   1479e:	46bd      	mov	sp, r7
   147a0:	bd80      	pop	{r7, pc}

000147a2 <uarte_nrfx_err_check>:
{
   147a2:	b580      	push	{r7, lr}
   147a4:	b084      	sub	sp, #16
   147a6:	af00      	add	r7, sp, #0
   147a8:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   147aa:	6878      	ldr	r0, [r7, #4]
   147ac:	f7ff feda 	bl	14564 <get_uarte_instance>
   147b0:	60f8      	str	r0, [r7, #12]
	return nrf_uarte_errorsrc_get_and_clear(uarte);
   147b2:	68f8      	ldr	r0, [r7, #12]
   147b4:	f7ff fda8 	bl	14308 <nrf_uarte_errorsrc_get_and_clear>
   147b8:	4603      	mov	r3, r0
}
   147ba:	4618      	mov	r0, r3
   147bc:	3710      	adds	r7, #16
   147be:	46bd      	mov	sp, r7
   147c0:	bd80      	pop	{r7, pc}

000147c2 <is_tx_ready>:
{
   147c2:	b580      	push	{r7, lr}
   147c4:	b084      	sub	sp, #16
   147c6:	af00      	add	r7, sp, #0
   147c8:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   147ca:	6878      	ldr	r0, [r7, #4]
   147cc:	f7ff feca 	bl	14564 <get_uarte_instance>
   147d0:	60f8      	str	r0, [r7, #12]
	bool ppi_endtx = get_dev_config(dev)->ppi_endtx;
   147d2:	6878      	ldr	r0, [r7, #4]
   147d4:	f7ff febb 	bl	1454e <get_dev_config>
   147d8:	4603      	mov	r3, r0
   147da:	799b      	ldrb	r3, [r3, #6]
   147dc:	72fb      	strb	r3, [r7, #11]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   147de:	f44f 71ac 	mov.w	r1, #344	; 0x158
   147e2:	68f8      	ldr	r0, [r7, #12]
   147e4:	f7ff fd09 	bl	141fa <nrf_uarte_event_check>
   147e8:	4603      	mov	r3, r0
   147ea:	2b00      	cmp	r3, #0
   147ec:	d10d      	bne.n	1480a <is_tx_ready+0x48>
		(!ppi_endtx ?
   147ee:	7afb      	ldrb	r3, [r7, #11]
   147f0:	f083 0301 	eor.w	r3, r3, #1
   147f4:	b2db      	uxtb	r3, r3
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   147f6:	2b00      	cmp	r3, #0
   147f8:	d009      	beq.n	1480e <is_tx_ready+0x4c>
		       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) : 0);
   147fa:	f44f 7190 	mov.w	r1, #288	; 0x120
   147fe:	68f8      	ldr	r0, [r7, #12]
   14800:	f7ff fcfb 	bl	141fa <nrf_uarte_event_check>
   14804:	4603      	mov	r3, r0
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   14806:	2b00      	cmp	r3, #0
   14808:	d001      	beq.n	1480e <is_tx_ready+0x4c>
   1480a:	2301      	movs	r3, #1
   1480c:	e000      	b.n	14810 <is_tx_ready+0x4e>
   1480e:	2300      	movs	r3, #0
   14810:	f003 0301 	and.w	r3, r3, #1
   14814:	b2db      	uxtb	r3, r3
}
   14816:	4618      	mov	r0, r3
   14818:	3710      	adds	r7, #16
   1481a:	46bd      	mov	sp, r7
   1481c:	bd80      	pop	{r7, pc}

0001481e <tx_start>:
{
   1481e:	b580      	push	{r7, lr}
   14820:	b084      	sub	sp, #16
   14822:	af00      	add	r7, sp, #0
   14824:	60f8      	str	r0, [r7, #12]
   14826:	60b9      	str	r1, [r7, #8]
   14828:	607a      	str	r2, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, buf, len);
   1482a:	687a      	ldr	r2, [r7, #4]
   1482c:	68b9      	ldr	r1, [r7, #8]
   1482e:	68f8      	ldr	r0, [r7, #12]
   14830:	f7ff fe0c 	bl	1444c <nrf_uarte_tx_buffer_set>
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDTX);
   14834:	f44f 7190 	mov.w	r1, #288	; 0x120
   14838:	68f8      	ldr	r0, [r7, #12]
   1483a:	f7ff fcc9 	bl	141d0 <nrf_uarte_event_clear>
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_TXSTOPPED);
   1483e:	f44f 71ac 	mov.w	r1, #344	; 0x158
   14842:	68f8      	ldr	r0, [r7, #12]
   14844:	f7ff fcc4 	bl	141d0 <nrf_uarte_event_clear>
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTTX);
   14848:	2108      	movs	r1, #8
   1484a:	68f8      	ldr	r0, [r7, #12]
   1484c:	f7ff fdba 	bl	143c4 <nrf_uarte_task_trigger>
}
   14850:	bf00      	nop
   14852:	3710      	adds	r7, #16
   14854:	46bd      	mov	sp, r7
   14856:	bd80      	pop	{r7, pc}

00014858 <hw_rx_counting_enabled>:
{
   14858:	b480      	push	{r7}
   1485a:	b083      	sub	sp, #12
   1485c:	af00      	add	r7, sp, #0
   1485e:	6078      	str	r0, [r7, #4]
		return data->async->hw_rx_counting;
   14860:	687b      	ldr	r3, [r7, #4]
   14862:	691b      	ldr	r3, [r3, #16]
   14864:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
}
   14868:	4618      	mov	r0, r3
   1486a:	370c      	adds	r7, #12
   1486c:	46bd      	mov	sp, r7
   1486e:	bc80      	pop	{r7}
   14870:	4770      	bx	lr

00014872 <timer_handler>:
static void timer_handler(nrf_timer_event_t event_type, void *p_context) { }
   14872:	b480      	push	{r7}
   14874:	b083      	sub	sp, #12
   14876:	af00      	add	r7, sp, #0
   14878:	4603      	mov	r3, r0
   1487a:	6039      	str	r1, [r7, #0]
   1487c:	80fb      	strh	r3, [r7, #6]
   1487e:	bf00      	nop
   14880:	370c      	adds	r7, #12
   14882:	46bd      	mov	sp, r7
   14884:	bc80      	pop	{r7}
   14886:	4770      	bx	lr

00014888 <uarte_nrfx_tx>:
{
   14888:	b590      	push	{r4, r7, lr}
   1488a:	b08f      	sub	sp, #60	; 0x3c
   1488c:	af02      	add	r7, sp, #8
   1488e:	60f8      	str	r0, [r7, #12]
   14890:	60b9      	str	r1, [r7, #8]
   14892:	607a      	str	r2, [r7, #4]
   14894:	603b      	str	r3, [r7, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14896:	68f8      	ldr	r0, [r7, #12]
   14898:	f7ff fe4e 	bl	14538 <get_dev_data>
   1489c:	62f8      	str	r0, [r7, #44]	; 0x2c
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   1489e:	68f8      	ldr	r0, [r7, #12]
   148a0:	f7ff fe60 	bl	14564 <get_uarte_instance>
   148a4:	62b8      	str	r0, [r7, #40]	; 0x28
	if (!nrfx_is_in_ram(buf)) {
   148a6:	68b8      	ldr	r0, [r7, #8]
   148a8:	f7ff f9fc 	bl	13ca4 <nrfx_is_in_ram>
   148ac:	4603      	mov	r3, r0
   148ae:	f083 0301 	eor.w	r3, r3, #1
   148b2:	b2db      	uxtb	r3, r3
   148b4:	2b00      	cmp	r3, #0
   148b6:	d002      	beq.n	148be <uarte_nrfx_tx+0x36>
		return -ENOTSUP;
   148b8:	f06f 0322 	mvn.w	r3, #34	; 0x22
   148bc:	e06f      	b.n	1499e <uarte_nrfx_tx+0x116>
	__asm__ volatile(
   148be:	f04f 0320 	mov.w	r3, #32
   148c2:	f3ef 8211 	mrs	r2, BASEPRI
   148c6:	f383 8811 	msr	BASEPRI, r3
   148ca:	f3bf 8f6f 	isb	sy
   148ce:	623a      	str	r2, [r7, #32]
   148d0:	61fb      	str	r3, [r7, #28]
	return key;
   148d2:	6a3b      	ldr	r3, [r7, #32]
	int key = irq_lock();
   148d4:	627b      	str	r3, [r7, #36]	; 0x24
	if (data->async->tx_size) {
   148d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   148d8:	691b      	ldr	r3, [r3, #16]
   148da:	68db      	ldr	r3, [r3, #12]
   148dc:	2b00      	cmp	r3, #0
   148de:	d00a      	beq.n	148f6 <uarte_nrfx_tx+0x6e>
		irq_unlock(key);
   148e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   148e2:	61bb      	str	r3, [r7, #24]
	__asm__ volatile(
   148e4:	69bb      	ldr	r3, [r7, #24]
   148e6:	f383 8811 	msr	BASEPRI, r3
   148ea:	f3bf 8f6f 	isb	sy
}
   148ee:	bf00      	nop
		return -EBUSY;
   148f0:	f06f 030f 	mvn.w	r3, #15
   148f4:	e053      	b.n	1499e <uarte_nrfx_tx+0x116>
		data->async->tx_size = len;
   148f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   148f8:	691b      	ldr	r3, [r3, #16]
   148fa:	687a      	ldr	r2, [r7, #4]
   148fc:	60da      	str	r2, [r3, #12]
	nrf_uarte_int_enable(uarte, NRF_UARTE_INT_TXSTOPPED_MASK);
   148fe:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   14902:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   14904:	f7ff fcc0 	bl	14288 <nrf_uarte_int_enable>
	if (!is_tx_ready(dev)) {
   14908:	68f8      	ldr	r0, [r7, #12]
   1490a:	f7ff ff5a 	bl	147c2 <is_tx_ready>
   1490e:	4603      	mov	r3, r0
   14910:	f083 0301 	eor.w	r3, r3, #1
   14914:	b2db      	uxtb	r3, r3
   14916:	2b00      	cmp	r3, #0
   14918:	d004      	beq.n	14924 <uarte_nrfx_tx+0x9c>
		data->async->pend_tx_buf = (uint8_t *)buf;
   1491a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1491c:	691b      	ldr	r3, [r3, #16]
   1491e:	68ba      	ldr	r2, [r7, #8]
   14920:	611a      	str	r2, [r3, #16]
   14922:	e00e      	b.n	14942 <uarte_nrfx_tx+0xba>
		data->async->tx_buf = buf;
   14924:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   14926:	691b      	ldr	r3, [r3, #16]
   14928:	68ba      	ldr	r2, [r7, #8]
   1492a:	609a      	str	r2, [r3, #8]
		data->async->tx_amount = -1;
   1492c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1492e:	691b      	ldr	r3, [r3, #16]
   14930:	f04f 32ff 	mov.w	r2, #4294967295
   14934:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
		tx_start(uarte, buf, len);
   14938:	687a      	ldr	r2, [r7, #4]
   1493a:	68b9      	ldr	r1, [r7, #8]
   1493c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1493e:	f7ff ff6e 	bl	1481e <tx_start>
	irq_unlock(key);
   14942:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   14944:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
   14946:	697b      	ldr	r3, [r7, #20]
   14948:	f383 8811 	msr	BASEPRI, r3
   1494c:	f3bf 8f6f 	isb	sy
}
   14950:	bf00      	nop
	if (data->uart_config.flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS
   14952:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   14954:	7adb      	ldrb	r3, [r3, #11]
   14956:	2b01      	cmp	r3, #1
   14958:	d120      	bne.n	1499c <uarte_nrfx_tx+0x114>
	    && timeout != SYS_FOREVER_MS) {
   1495a:	683b      	ldr	r3, [r7, #0]
   1495c:	f1b3 3fff 	cmp.w	r3, #4294967295
   14960:	d01c      	beq.n	1499c <uarte_nrfx_tx+0x114>
		k_timer_start(&data->async->tx_timeout_timer, K_MSEC(timeout),
   14962:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   14964:	691b      	ldr	r3, [r3, #16]
   14966:	f103 0418 	add.w	r4, r3, #24
   1496a:	683b      	ldr	r3, [r7, #0]
   1496c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   14970:	461a      	mov	r2, r3
   14972:	ea4f 73e2 	mov.w	r3, r2, asr #31
   14976:	4610      	mov	r0, r2
   14978:	4619      	mov	r1, r3
   1497a:	f7ff f9b0 	bl	13cde <k_ms_to_ticks_ceil64>
   1497e:	4602      	mov	r2, r0
   14980:	460b      	mov	r3, r1
   14982:	4610      	mov	r0, r2
   14984:	4619      	mov	r1, r3
			      K_NO_WAIT);
   14986:	f04f 0200 	mov.w	r2, #0
   1498a:	f04f 0300 	mov.w	r3, #0
		k_timer_start(&data->async->tx_timeout_timer, K_MSEC(timeout),
   1498e:	e9cd 2300 	strd	r2, r3, [sp]
   14992:	4602      	mov	r2, r0
   14994:	460b      	mov	r3, r1
   14996:	4620      	mov	r0, r4
   14998:	f7ff fb06 	bl	13fa8 <k_timer_start>
	return 0;
   1499c:	2300      	movs	r3, #0
}
   1499e:	4618      	mov	r0, r3
   149a0:	3734      	adds	r7, #52	; 0x34
   149a2:	46bd      	mov	sp, r7
   149a4:	bd90      	pop	{r4, r7, pc}

000149a6 <uarte_nrfx_tx_abort>:
{
   149a6:	b580      	push	{r7, lr}
   149a8:	b084      	sub	sp, #16
   149aa:	af00      	add	r7, sp, #0
   149ac:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   149ae:	6878      	ldr	r0, [r7, #4]
   149b0:	f7ff fdc2 	bl	14538 <get_dev_data>
   149b4:	60f8      	str	r0, [r7, #12]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   149b6:	6878      	ldr	r0, [r7, #4]
   149b8:	f7ff fdd4 	bl	14564 <get_uarte_instance>
   149bc:	60b8      	str	r0, [r7, #8]
	if (data->async->tx_buf == NULL) {
   149be:	68fb      	ldr	r3, [r7, #12]
   149c0:	691b      	ldr	r3, [r3, #16]
   149c2:	689b      	ldr	r3, [r3, #8]
   149c4:	2b00      	cmp	r3, #0
   149c6:	d102      	bne.n	149ce <uarte_nrfx_tx_abort+0x28>
		return -EFAULT;
   149c8:	f06f 030d 	mvn.w	r3, #13
   149cc:	e00a      	b.n	149e4 <uarte_nrfx_tx_abort+0x3e>
	k_timer_stop(&data->async->tx_timeout_timer);
   149ce:	68fb      	ldr	r3, [r7, #12]
   149d0:	691b      	ldr	r3, [r3, #16]
   149d2:	3318      	adds	r3, #24
   149d4:	4618      	mov	r0, r3
   149d6:	f7ff fafa 	bl	13fce <k_timer_stop>
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
   149da:	210c      	movs	r1, #12
   149dc:	68b8      	ldr	r0, [r7, #8]
   149de:	f7ff fcf1 	bl	143c4 <nrf_uarte_task_trigger>
	return 0;
   149e2:	2300      	movs	r3, #0
}
   149e4:	4618      	mov	r0, r3
   149e6:	3710      	adds	r7, #16
   149e8:	46bd      	mov	sp, r7
   149ea:	bd80      	pop	{r7, pc}

000149ec <uarte_nrfx_rx_buf_rsp>:
{
   149ec:	b580      	push	{r7, lr}
   149ee:	b08c      	sub	sp, #48	; 0x30
   149f0:	af00      	add	r7, sp, #0
   149f2:	60f8      	str	r0, [r7, #12]
   149f4:	60b9      	str	r1, [r7, #8]
   149f6:	607a      	str	r2, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   149f8:	68f8      	ldr	r0, [r7, #12]
   149fa:	f7ff fd9d 	bl	14538 <get_dev_data>
   149fe:	62b8      	str	r0, [r7, #40]	; 0x28
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   14a00:	68f8      	ldr	r0, [r7, #12]
   14a02:	f7ff fdaf 	bl	14564 <get_uarte_instance>
   14a06:	6278      	str	r0, [r7, #36]	; 0x24
	__asm__ volatile(
   14a08:	f04f 0320 	mov.w	r3, #32
   14a0c:	f3ef 8211 	mrs	r2, BASEPRI
   14a10:	f383 8811 	msr	BASEPRI, r3
   14a14:	f3bf 8f6f 	isb	sy
   14a18:	61fa      	str	r2, [r7, #28]
   14a1a:	61bb      	str	r3, [r7, #24]
	return key;
   14a1c:	69fb      	ldr	r3, [r7, #28]
	int key = irq_lock();
   14a1e:	623b      	str	r3, [r7, #32]
	if ((data->async->rx_buf == NULL)) {
   14a20:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14a22:	691b      	ldr	r3, [r3, #16]
   14a24:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   14a26:	2b00      	cmp	r3, #0
   14a28:	d103      	bne.n	14a32 <uarte_nrfx_rx_buf_rsp+0x46>
		err = -EACCES;
   14a2a:	f06f 030c 	mvn.w	r3, #12
   14a2e:	62fb      	str	r3, [r7, #44]	; 0x2c
   14a30:	e01b      	b.n	14a6a <uarte_nrfx_rx_buf_rsp+0x7e>
	} else if (data->async->rx_next_buf == NULL) {
   14a32:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14a34:	691b      	ldr	r3, [r3, #16]
   14a36:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
   14a38:	2b00      	cmp	r3, #0
   14a3a:	d113      	bne.n	14a64 <uarte_nrfx_rx_buf_rsp+0x78>
		data->async->rx_next_buf = buf;
   14a3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14a3e:	691b      	ldr	r3, [r3, #16]
   14a40:	68ba      	ldr	r2, [r7, #8]
   14a42:	65da      	str	r2, [r3, #92]	; 0x5c
		data->async->rx_next_buf_len = len;
   14a44:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14a46:	691b      	ldr	r3, [r3, #16]
   14a48:	687a      	ldr	r2, [r7, #4]
   14a4a:	661a      	str	r2, [r3, #96]	; 0x60
		nrf_uarte_rx_buffer_set(uarte, buf, len);
   14a4c:	687a      	ldr	r2, [r7, #4]
   14a4e:	68b9      	ldr	r1, [r7, #8]
   14a50:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14a52:	f7ff fd1a 	bl	1448a <nrf_uarte_rx_buffer_set>
		nrf_uarte_shorts_enable(uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
   14a56:	2120      	movs	r1, #32
   14a58:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14a5a:	f7ff fbf0 	bl	1423e <nrf_uarte_shorts_enable>
		err = 0;
   14a5e:	2300      	movs	r3, #0
   14a60:	62fb      	str	r3, [r7, #44]	; 0x2c
   14a62:	e002      	b.n	14a6a <uarte_nrfx_rx_buf_rsp+0x7e>
		err = -EBUSY;
   14a64:	f06f 030f 	mvn.w	r3, #15
   14a68:	62fb      	str	r3, [r7, #44]	; 0x2c
	irq_unlock(key);
   14a6a:	6a3b      	ldr	r3, [r7, #32]
   14a6c:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
   14a6e:	697b      	ldr	r3, [r7, #20]
   14a70:	f383 8811 	msr	BASEPRI, r3
   14a74:	f3bf 8f6f 	isb	sy
}
   14a78:	bf00      	nop
	return err;
   14a7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
   14a7c:	4618      	mov	r0, r3
   14a7e:	3730      	adds	r7, #48	; 0x30
   14a80:	46bd      	mov	sp, r7
   14a82:	bd80      	pop	{r7, pc}

00014a84 <uarte_nrfx_callback_set>:
{
   14a84:	b580      	push	{r7, lr}
   14a86:	b086      	sub	sp, #24
   14a88:	af00      	add	r7, sp, #0
   14a8a:	60f8      	str	r0, [r7, #12]
   14a8c:	60b9      	str	r1, [r7, #8]
   14a8e:	607a      	str	r2, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14a90:	68f8      	ldr	r0, [r7, #12]
   14a92:	f7ff fd51 	bl	14538 <get_dev_data>
   14a96:	6178      	str	r0, [r7, #20]
	data->async->user_callback = callback;
   14a98:	697b      	ldr	r3, [r7, #20]
   14a9a:	691b      	ldr	r3, [r3, #16]
   14a9c:	68ba      	ldr	r2, [r7, #8]
   14a9e:	601a      	str	r2, [r3, #0]
	data->async->user_data = user_data;
   14aa0:	697b      	ldr	r3, [r7, #20]
   14aa2:	691b      	ldr	r3, [r3, #16]
   14aa4:	687a      	ldr	r2, [r7, #4]
   14aa6:	605a      	str	r2, [r3, #4]
	return 0;
   14aa8:	2300      	movs	r3, #0
}
   14aaa:	4618      	mov	r0, r3
   14aac:	3718      	adds	r7, #24
   14aae:	46bd      	mov	sp, r7
   14ab0:	bd80      	pop	{r7, pc}

00014ab2 <uarte_nrfx_rx_disable>:
{
   14ab2:	b580      	push	{r7, lr}
   14ab4:	b084      	sub	sp, #16
   14ab6:	af00      	add	r7, sp, #0
   14ab8:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14aba:	6878      	ldr	r0, [r7, #4]
   14abc:	f7ff fd3c 	bl	14538 <get_dev_data>
   14ac0:	60f8      	str	r0, [r7, #12]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   14ac2:	6878      	ldr	r0, [r7, #4]
   14ac4:	f7ff fd4e 	bl	14564 <get_uarte_instance>
   14ac8:	60b8      	str	r0, [r7, #8]
	if (data->async->rx_buf == NULL) {
   14aca:	68fb      	ldr	r3, [r7, #12]
   14acc:	691b      	ldr	r3, [r3, #16]
   14ace:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   14ad0:	2b00      	cmp	r3, #0
   14ad2:	d102      	bne.n	14ada <uarte_nrfx_rx_disable+0x28>
		return -EFAULT;
   14ad4:	f06f 030d 	mvn.w	r3, #13
   14ad8:	e01d      	b.n	14b16 <uarte_nrfx_rx_disable+0x64>
	if (data->async->rx_next_buf != NULL) {
   14ada:	68fb      	ldr	r3, [r7, #12]
   14adc:	691b      	ldr	r3, [r3, #16]
   14ade:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
   14ae0:	2b00      	cmp	r3, #0
   14ae2:	d008      	beq.n	14af6 <uarte_nrfx_rx_disable+0x44>
		nrf_uarte_shorts_disable(uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
   14ae4:	2120      	movs	r1, #32
   14ae6:	68b8      	ldr	r0, [r7, #8]
   14ae8:	f7ff fbbb 	bl	14262 <nrf_uarte_shorts_disable>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);
   14aec:	f44f 71a6 	mov.w	r1, #332	; 0x14c
   14af0:	68b8      	ldr	r0, [r7, #8]
   14af2:	f7ff fb6d 	bl	141d0 <nrf_uarte_event_clear>
	k_timer_stop(&data->async->rx_timeout_timer);
   14af6:	68fb      	ldr	r3, [r7, #12]
   14af8:	691b      	ldr	r3, [r3, #16]
   14afa:	3378      	adds	r3, #120	; 0x78
   14afc:	4618      	mov	r0, r3
   14afe:	f7ff fa66 	bl	13fce <k_timer_stop>
	data->async->rx_enabled = false;
   14b02:	68fb      	ldr	r3, [r7, #12]
   14b04:	691b      	ldr	r3, [r3, #16]
   14b06:	2200      	movs	r2, #0
   14b08:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);
   14b0c:	2104      	movs	r1, #4
   14b0e:	68b8      	ldr	r0, [r7, #8]
   14b10:	f7ff fc58 	bl	143c4 <nrf_uarte_task_trigger>
	return 0;
   14b14:	2300      	movs	r3, #0
}
   14b16:	4618      	mov	r0, r3
   14b18:	3710      	adds	r7, #16
   14b1a:	46bd      	mov	sp, r7
   14b1c:	bd80      	pop	{r7, pc}

00014b1e <tx_timeout>:
{
   14b1e:	b580      	push	{r7, lr}
   14b20:	b084      	sub	sp, #16
   14b22:	af00      	add	r7, sp, #0
   14b24:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = k_timer_user_data_get(timer);
   14b26:	6878      	ldr	r0, [r7, #4]
   14b28:	f7ff fa69 	bl	13ffe <k_timer_user_data_get>
   14b2c:	60f8      	str	r0, [r7, #12]
	(void) uarte_nrfx_tx_abort(data->dev);
   14b2e:	68fb      	ldr	r3, [r7, #12]
   14b30:	681b      	ldr	r3, [r3, #0]
   14b32:	4618      	mov	r0, r3
   14b34:	f7ff ff37 	bl	149a6 <uarte_nrfx_tx_abort>
}
   14b38:	bf00      	nop
   14b3a:	3710      	adds	r7, #16
   14b3c:	46bd      	mov	sp, r7
   14b3e:	bd80      	pop	{r7, pc}

00014b40 <user_callback>:
{
   14b40:	b580      	push	{r7, lr}
   14b42:	b084      	sub	sp, #16
   14b44:	af00      	add	r7, sp, #0
   14b46:	6078      	str	r0, [r7, #4]
   14b48:	6039      	str	r1, [r7, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14b4a:	6878      	ldr	r0, [r7, #4]
   14b4c:	f7ff fcf4 	bl	14538 <get_dev_data>
   14b50:	60f8      	str	r0, [r7, #12]
	if (data->async->user_callback) {
   14b52:	68fb      	ldr	r3, [r7, #12]
   14b54:	691b      	ldr	r3, [r3, #16]
   14b56:	681b      	ldr	r3, [r3, #0]
   14b58:	2b00      	cmp	r3, #0
   14b5a:	d008      	beq.n	14b6e <user_callback+0x2e>
		data->async->user_callback(dev, evt, data->async->user_data);
   14b5c:	68fb      	ldr	r3, [r7, #12]
   14b5e:	691b      	ldr	r3, [r3, #16]
   14b60:	681b      	ldr	r3, [r3, #0]
   14b62:	68fa      	ldr	r2, [r7, #12]
   14b64:	6912      	ldr	r2, [r2, #16]
   14b66:	6852      	ldr	r2, [r2, #4]
   14b68:	6839      	ldr	r1, [r7, #0]
   14b6a:	6878      	ldr	r0, [r7, #4]
   14b6c:	4798      	blx	r3
}
   14b6e:	bf00      	nop
   14b70:	3710      	adds	r7, #16
   14b72:	46bd      	mov	sp, r7
   14b74:	bd80      	pop	{r7, pc}

00014b76 <rx_timeout>:
{
   14b76:	b580      	push	{r7, lr}
   14b78:	b08e      	sub	sp, #56	; 0x38
   14b7a:	af00      	add	r7, sp, #0
   14b7c:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = k_timer_user_data_get(timer);
   14b7e:	6878      	ldr	r0, [r7, #4]
   14b80:	f7ff fa3d 	bl	13ffe <k_timer_user_data_get>
   14b84:	62b8      	str	r0, [r7, #40]	; 0x28
	const struct device *dev = data->dev;
   14b86:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14b88:	681b      	ldr	r3, [r3, #0]
   14b8a:	627b      	str	r3, [r7, #36]	; 0x24
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   14b8c:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14b8e:	f7ff fcde 	bl	1454e <get_dev_config>
   14b92:	6238      	str	r0, [r7, #32]
	if (data->async->is_in_irq) {
   14b94:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14b96:	691b      	ldr	r3, [r3, #16]
   14b98:	f893 30ba 	ldrb.w	r3, [r3, #186]	; 0xba
   14b9c:	b2db      	uxtb	r3, r3
   14b9e:	2b00      	cmp	r3, #0
   14ba0:	f040 80a2 	bne.w	14ce8 <rx_timeout+0x172>
	nrf_uarte_int_disable(get_uarte_instance(dev),
   14ba4:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14ba6:	f7ff fcdd 	bl	14564 <get_uarte_instance>
   14baa:	4603      	mov	r3, r0
   14bac:	2110      	movs	r1, #16
   14bae:	4618      	mov	r0, r3
   14bb0:	f7ff fb87 	bl	142c2 <nrf_uarte_int_disable>
	if (hw_rx_counting_enabled(data)) {
   14bb4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   14bb6:	f7ff fe4f 	bl	14858 <hw_rx_counting_enabled>
   14bba:	4603      	mov	r3, r0
   14bbc:	2b00      	cmp	r3, #0
   14bbe:	d007      	beq.n	14bd0 <rx_timeout+0x5a>
		read = nrfx_timer_capture(&cfg->timer, 0);
   14bc0:	6a3b      	ldr	r3, [r7, #32]
   14bc2:	3308      	adds	r3, #8
   14bc4:	2100      	movs	r1, #0
   14bc6:	4618      	mov	r0, r3
   14bc8:	f7f5 fef2 	bl	a9b0 <nrfx_timer_capture>
   14bcc:	6378      	str	r0, [r7, #52]	; 0x34
   14bce:	e004      	b.n	14bda <rx_timeout+0x64>
		read = data->async->rx_cnt.cnt;
   14bd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14bd2:	691b      	ldr	r3, [r3, #16]
   14bd4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
   14bd8:	637b      	str	r3, [r7, #52]	; 0x34
	if (read != data->async->rx_total_byte_cnt) {
   14bda:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14bdc:	691b      	ldr	r3, [r3, #16]
   14bde:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   14be0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14be2:	429a      	cmp	r2, r3
   14be4:	d009      	beq.n	14bfa <rx_timeout+0x84>
		data->async->rx_total_byte_cnt = read;
   14be6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14be8:	691b      	ldr	r3, [r3, #16]
   14bea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14bec:	665a      	str	r2, [r3, #100]	; 0x64
		data->async->rx_timeout_left = data->async->rx_timeout;
   14bee:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14bf0:	691a      	ldr	r2, [r3, #16]
   14bf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14bf4:	691b      	ldr	r3, [r3, #16]
   14bf6:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
   14bf8:	675a      	str	r2, [r3, #116]	; 0x74
	int32_t len = data->async->rx_total_byte_cnt
   14bfa:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14bfc:	691b      	ldr	r3, [r3, #16]
   14bfe:	6e5a      	ldr	r2, [r3, #100]	; 0x64
		    - data->async->rx_total_user_byte_cnt;
   14c00:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c02:	691b      	ldr	r3, [r3, #16]
   14c04:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   14c06:	1ad3      	subs	r3, r2, r3
	int32_t len = data->async->rx_total_byte_cnt
   14c08:	633b      	str	r3, [r7, #48]	; 0x30
	bool clipped = false;
   14c0a:	2300      	movs	r3, #0
   14c0c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (len + data->async->rx_offset > data->async->rx_buf_len) {
   14c10:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c12:	691b      	ldr	r3, [r3, #16]
   14c14:	6d9a      	ldr	r2, [r3, #88]	; 0x58
   14c16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14c18:	441a      	add	r2, r3
   14c1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c1c:	691b      	ldr	r3, [r3, #16]
   14c1e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   14c20:	429a      	cmp	r2, r3
   14c22:	d90a      	bls.n	14c3a <rx_timeout+0xc4>
		len = data->async->rx_buf_len - data->async->rx_offset;
   14c24:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c26:	691b      	ldr	r3, [r3, #16]
   14c28:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   14c2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c2c:	691b      	ldr	r3, [r3, #16]
   14c2e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   14c30:	1ad3      	subs	r3, r2, r3
   14c32:	633b      	str	r3, [r7, #48]	; 0x30
		clipped = true;
   14c34:	2301      	movs	r3, #1
   14c36:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (len > 0) {
   14c3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14c3c:	2b00      	cmp	r3, #0
   14c3e:	dd4a      	ble.n	14cd6 <rx_timeout+0x160>
		if (clipped ||
   14c40:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   14c44:	2b00      	cmp	r3, #0
   14c46:	d107      	bne.n	14c58 <rx_timeout+0xe2>
			(data->async->rx_timeout_left
   14c48:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c4a:	691b      	ldr	r3, [r3, #16]
   14c4c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
				< data->async->rx_timeout_slab)) {
   14c4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c50:	691b      	ldr	r3, [r3, #16]
   14c52:	6f1b      	ldr	r3, [r3, #112]	; 0x70
		if (clipped ||
   14c54:	429a      	cmp	r2, r3
   14c56:	da2a      	bge.n	14cae <rx_timeout+0x138>
			struct uart_event evt = {
   14c58:	f107 030c 	add.w	r3, r7, #12
   14c5c:	2200      	movs	r2, #0
   14c5e:	601a      	str	r2, [r3, #0]
   14c60:	605a      	str	r2, [r3, #4]
   14c62:	609a      	str	r2, [r3, #8]
   14c64:	60da      	str	r2, [r3, #12]
   14c66:	611a      	str	r2, [r3, #16]
   14c68:	2302      	movs	r3, #2
   14c6a:	733b      	strb	r3, [r7, #12]
				.data.rx.buf = data->async->rx_buf,
   14c6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c6e:	691b      	ldr	r3, [r3, #16]
   14c70:	6d1b      	ldr	r3, [r3, #80]	; 0x50
			struct uart_event evt = {
   14c72:	613b      	str	r3, [r7, #16]
				.data.rx.offset = data->async->rx_offset
   14c74:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c76:	691b      	ldr	r3, [r3, #16]
   14c78:	6d9b      	ldr	r3, [r3, #88]	; 0x58
			struct uart_event evt = {
   14c7a:	617b      	str	r3, [r7, #20]
   14c7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14c7e:	61bb      	str	r3, [r7, #24]
			data->async->rx_offset += len;
   14c80:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c82:	691b      	ldr	r3, [r3, #16]
   14c84:	6d99      	ldr	r1, [r3, #88]	; 0x58
   14c86:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   14c88:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c8a:	691b      	ldr	r3, [r3, #16]
   14c8c:	440a      	add	r2, r1
   14c8e:	659a      	str	r2, [r3, #88]	; 0x58
			data->async->rx_total_user_byte_cnt += len;
   14c90:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c92:	691b      	ldr	r3, [r3, #16]
   14c94:	6e99      	ldr	r1, [r3, #104]	; 0x68
   14c96:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   14c98:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14c9a:	691b      	ldr	r3, [r3, #16]
   14c9c:	440a      	add	r2, r1
   14c9e:	669a      	str	r2, [r3, #104]	; 0x68
			user_callback(dev, &evt);
   14ca0:	f107 030c 	add.w	r3, r7, #12
   14ca4:	4619      	mov	r1, r3
   14ca6:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14ca8:	f7ff ff4a 	bl	14b40 <user_callback>
				< data->async->rx_timeout_slab)) {
   14cac:	e009      	b.n	14cc2 <rx_timeout+0x14c>
			data->async->rx_timeout_left -=
   14cae:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14cb0:	691b      	ldr	r3, [r3, #16]
   14cb2:	6f59      	ldr	r1, [r3, #116]	; 0x74
				data->async->rx_timeout_slab;
   14cb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14cb6:	691b      	ldr	r3, [r3, #16]
   14cb8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
			data->async->rx_timeout_left -=
   14cba:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14cbc:	691b      	ldr	r3, [r3, #16]
   14cbe:	1a8a      	subs	r2, r1, r2
   14cc0:	675a      	str	r2, [r3, #116]	; 0x74
		if (clipped) {
   14cc2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   14cc6:	2b00      	cmp	r3, #0
   14cc8:	d005      	beq.n	14cd6 <rx_timeout+0x160>
			k_timer_stop(&data->async->rx_timeout_timer);
   14cca:	6abb      	ldr	r3, [r7, #40]	; 0x28
   14ccc:	691b      	ldr	r3, [r3, #16]
   14cce:	3378      	adds	r3, #120	; 0x78
   14cd0:	4618      	mov	r0, r3
   14cd2:	f7ff f97c 	bl	13fce <k_timer_stop>
	nrf_uarte_int_enable(get_uarte_instance(dev),
   14cd6:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14cd8:	f7ff fc44 	bl	14564 <get_uarte_instance>
   14cdc:	4603      	mov	r3, r0
   14cde:	2110      	movs	r1, #16
   14ce0:	4618      	mov	r0, r3
   14ce2:	f7ff fad1 	bl	14288 <nrf_uarte_int_enable>
   14ce6:	e000      	b.n	14cea <rx_timeout+0x174>
		return;
   14ce8:	bf00      	nop
}
   14cea:	3738      	adds	r7, #56	; 0x38
   14cec:	46bd      	mov	sp, r7
   14cee:	bd80      	pop	{r7, pc}

00014cf0 <error_isr>:
{
   14cf0:	b580      	push	{r7, lr}
   14cf2:	b08a      	sub	sp, #40	; 0x28
   14cf4:	af00      	add	r7, sp, #0
   14cf6:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   14cf8:	6878      	ldr	r0, [r7, #4]
   14cfa:	f7ff fc33 	bl	14564 <get_uarte_instance>
   14cfe:	6278      	str	r0, [r7, #36]	; 0x24
	uint32_t err = nrf_uarte_errorsrc_get_and_clear(uarte);
   14d00:	6a78      	ldr	r0, [r7, #36]	; 0x24
   14d02:	f7ff fb01 	bl	14308 <nrf_uarte_errorsrc_get_and_clear>
   14d06:	6238      	str	r0, [r7, #32]
	struct uart_event evt = {
   14d08:	f107 030c 	add.w	r3, r7, #12
   14d0c:	2200      	movs	r2, #0
   14d0e:	601a      	str	r2, [r3, #0]
   14d10:	605a      	str	r2, [r3, #4]
   14d12:	609a      	str	r2, [r3, #8]
   14d14:	60da      	str	r2, [r3, #12]
   14d16:	611a      	str	r2, [r3, #16]
   14d18:	2306      	movs	r3, #6
   14d1a:	733b      	strb	r3, [r7, #12]
		.data.rx_stop.reason = UARTE_ERROR_FROM_MASK(err),
   14d1c:	6a3b      	ldr	r3, [r7, #32]
   14d1e:	f003 0301 	and.w	r3, r3, #1
   14d22:	2b00      	cmp	r3, #0
   14d24:	d113      	bne.n	14d4e <error_isr+0x5e>
   14d26:	6a3b      	ldr	r3, [r7, #32]
   14d28:	f003 0302 	and.w	r3, r3, #2
   14d2c:	2b00      	cmp	r3, #0
   14d2e:	d10c      	bne.n	14d4a <error_isr+0x5a>
   14d30:	6a3b      	ldr	r3, [r7, #32]
   14d32:	f003 0304 	and.w	r3, r3, #4
   14d36:	2b00      	cmp	r3, #0
   14d38:	d105      	bne.n	14d46 <error_isr+0x56>
   14d3a:	6a3b      	ldr	r3, [r7, #32]
   14d3c:	b2db      	uxtb	r3, r3
   14d3e:	f003 0308 	and.w	r3, r3, #8
   14d42:	b2db      	uxtb	r3, r3
   14d44:	e004      	b.n	14d50 <error_isr+0x60>
   14d46:	2304      	movs	r3, #4
   14d48:	e002      	b.n	14d50 <error_isr+0x60>
   14d4a:	2302      	movs	r3, #2
   14d4c:	e000      	b.n	14d50 <error_isr+0x60>
   14d4e:	2301      	movs	r3, #1
	struct uart_event evt = {
   14d50:	743b      	strb	r3, [r7, #16]
	user_callback(dev, &evt);
   14d52:	f107 030c 	add.w	r3, r7, #12
   14d56:	4619      	mov	r1, r3
   14d58:	6878      	ldr	r0, [r7, #4]
   14d5a:	f7ff fef1 	bl	14b40 <user_callback>
	(void) uarte_nrfx_rx_disable(dev);
   14d5e:	6878      	ldr	r0, [r7, #4]
   14d60:	f7ff fea7 	bl	14ab2 <uarte_nrfx_rx_disable>
}
   14d64:	bf00      	nop
   14d66:	3728      	adds	r7, #40	; 0x28
   14d68:	46bd      	mov	sp, r7
   14d6a:	bd80      	pop	{r7, pc}

00014d6c <rxstarted_isr>:
{
   14d6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   14d6e:	b08b      	sub	sp, #44	; 0x2c
   14d70:	af02      	add	r7, sp, #8
   14d72:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14d74:	6878      	ldr	r0, [r7, #4]
   14d76:	f7ff fbdf 	bl	14538 <get_dev_data>
   14d7a:	61f8      	str	r0, [r7, #28]
	struct uart_event evt = {
   14d7c:	f107 0308 	add.w	r3, r7, #8
   14d80:	2200      	movs	r2, #0
   14d82:	601a      	str	r2, [r3, #0]
   14d84:	605a      	str	r2, [r3, #4]
   14d86:	609a      	str	r2, [r3, #8]
   14d88:	60da      	str	r2, [r3, #12]
   14d8a:	611a      	str	r2, [r3, #16]
   14d8c:	2303      	movs	r3, #3
   14d8e:	723b      	strb	r3, [r7, #8]
	user_callback(dev, &evt);
   14d90:	f107 0308 	add.w	r3, r7, #8
   14d94:	4619      	mov	r1, r3
   14d96:	6878      	ldr	r0, [r7, #4]
   14d98:	f7ff fed2 	bl	14b40 <user_callback>
	if (data->async->rx_timeout != SYS_FOREVER_MS) {
   14d9c:	69fb      	ldr	r3, [r7, #28]
   14d9e:	691b      	ldr	r3, [r3, #16]
   14da0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   14da2:	f1b3 3fff 	cmp.w	r3, #4294967295
   14da6:	d02e      	beq.n	14e06 <rxstarted_isr+0x9a>
		data->async->rx_timeout_left = data->async->rx_timeout;
   14da8:	69fb      	ldr	r3, [r7, #28]
   14daa:	691a      	ldr	r2, [r3, #16]
   14dac:	69fb      	ldr	r3, [r7, #28]
   14dae:	691b      	ldr	r3, [r3, #16]
   14db0:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
   14db2:	675a      	str	r2, [r3, #116]	; 0x74
		k_timer_start(&data->async->rx_timeout_timer,
   14db4:	69fb      	ldr	r3, [r7, #28]
   14db6:	691b      	ldr	r3, [r3, #16]
   14db8:	f103 0678 	add.w	r6, r3, #120	; 0x78
			      K_MSEC(data->async->rx_timeout_slab),
   14dbc:	69fb      	ldr	r3, [r7, #28]
   14dbe:	691b      	ldr	r3, [r3, #16]
   14dc0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   14dc2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   14dc6:	461a      	mov	r2, r3
   14dc8:	ea4f 73e2 	mov.w	r3, r2, asr #31
   14dcc:	4610      	mov	r0, r2
   14dce:	4619      	mov	r1, r3
   14dd0:	f7fe ff85 	bl	13cde <k_ms_to_ticks_ceil64>
   14dd4:	4602      	mov	r2, r0
   14dd6:	460b      	mov	r3, r1
   14dd8:	4614      	mov	r4, r2
   14dda:	461d      	mov	r5, r3
			      K_MSEC(data->async->rx_timeout_slab));
   14ddc:	69fb      	ldr	r3, [r7, #28]
   14dde:	691b      	ldr	r3, [r3, #16]
   14de0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   14de2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   14de6:	461a      	mov	r2, r3
   14de8:	ea4f 73e2 	mov.w	r3, r2, asr #31
   14dec:	4610      	mov	r0, r2
   14dee:	4619      	mov	r1, r3
   14df0:	f7fe ff75 	bl	13cde <k_ms_to_ticks_ceil64>
   14df4:	4602      	mov	r2, r0
   14df6:	460b      	mov	r3, r1
		k_timer_start(&data->async->rx_timeout_timer,
   14df8:	e9cd 2300 	strd	r2, r3, [sp]
   14dfc:	4622      	mov	r2, r4
   14dfe:	462b      	mov	r3, r5
   14e00:	4630      	mov	r0, r6
   14e02:	f7ff f8d1 	bl	13fa8 <k_timer_start>
}
   14e06:	bf00      	nop
   14e08:	3724      	adds	r7, #36	; 0x24
   14e0a:	46bd      	mov	sp, r7
   14e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}

00014e0e <endrx_isr>:
{
   14e0e:	b580      	push	{r7, lr}
   14e10:	b09a      	sub	sp, #104	; 0x68
   14e12:	af00      	add	r7, sp, #0
   14e14:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   14e16:	6878      	ldr	r0, [r7, #4]
   14e18:	f7ff fb8e 	bl	14538 <get_dev_data>
   14e1c:	6638      	str	r0, [r7, #96]	; 0x60
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   14e1e:	6878      	ldr	r0, [r7, #4]
   14e20:	f7ff fba0 	bl	14564 <get_uarte_instance>
   14e24:	65f8      	str	r0, [r7, #92]	; 0x5c
	if (!data->async->rx_enabled) {
   14e26:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e28:	691b      	ldr	r3, [r3, #16]
   14e2a:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
   14e2e:	f083 0301 	eor.w	r3, r3, #1
   14e32:	b2db      	uxtb	r3, r3
   14e34:	2b00      	cmp	r3, #0
   14e36:	d016      	beq.n	14e66 <endrx_isr+0x58>
		if (data->async->rx_buf == NULL) {
   14e38:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e3a:	691b      	ldr	r3, [r3, #16]
   14e3c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   14e3e:	2b00      	cmp	r3, #0
   14e40:	d111      	bne.n	14e66 <endrx_isr+0x58>
			struct uart_event evt = {
   14e42:	f107 0320 	add.w	r3, r7, #32
   14e46:	2200      	movs	r2, #0
   14e48:	601a      	str	r2, [r3, #0]
   14e4a:	605a      	str	r2, [r3, #4]
   14e4c:	609a      	str	r2, [r3, #8]
   14e4e:	60da      	str	r2, [r3, #12]
   14e50:	611a      	str	r2, [r3, #16]
   14e52:	2305      	movs	r3, #5
   14e54:	f887 3020 	strb.w	r3, [r7, #32]
			user_callback(dev, &evt);
   14e58:	f107 0320 	add.w	r3, r7, #32
   14e5c:	4619      	mov	r1, r3
   14e5e:	6878      	ldr	r0, [r7, #4]
   14e60:	f7ff fe6e 	bl	14b40 <user_callback>
   14e64:	e0cf      	b.n	15006 <endrx_isr+0x1f8>
	data->async->is_in_irq = true;
   14e66:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e68:	691b      	ldr	r3, [r3, #16]
   14e6a:	2201      	movs	r2, #1
   14e6c:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba
	k_timer_stop(&data->async->rx_timeout_timer);
   14e70:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e72:	691b      	ldr	r3, [r3, #16]
   14e74:	3378      	adds	r3, #120	; 0x78
   14e76:	4618      	mov	r0, r3
   14e78:	f7ff f8a9 	bl	13fce <k_timer_stop>
	const int rx_amount = nrf_uarte_rx_amount_get(uarte);
   14e7c:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   14e7e:	f7ff fb17 	bl	144b0 <nrf_uarte_rx_amount_get>
   14e82:	4603      	mov	r3, r0
   14e84:	65bb      	str	r3, [r7, #88]	; 0x58
	int rx_len = rx_amount - data->async->rx_offset;
   14e86:	6dba      	ldr	r2, [r7, #88]	; 0x58
   14e88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e8a:	691b      	ldr	r3, [r3, #16]
   14e8c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   14e8e:	1ad3      	subs	r3, r2, r3
   14e90:	667b      	str	r3, [r7, #100]	; 0x64
	if (rx_len < 0) {
   14e92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   14e94:	2b00      	cmp	r3, #0
   14e96:	da01      	bge.n	14e9c <endrx_isr+0x8e>
		rx_len = 0;
   14e98:	2300      	movs	r3, #0
   14e9a:	667b      	str	r3, [r7, #100]	; 0x64
	data->async->rx_total_user_byte_cnt += rx_len;
   14e9c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14e9e:	691b      	ldr	r3, [r3, #16]
   14ea0:	6e99      	ldr	r1, [r3, #104]	; 0x68
   14ea2:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   14ea4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ea6:	691b      	ldr	r3, [r3, #16]
   14ea8:	440a      	add	r2, r1
   14eaa:	669a      	str	r2, [r3, #104]	; 0x68
	if (!hw_rx_counting_enabled(data)) {
   14eac:	6e38      	ldr	r0, [r7, #96]	; 0x60
   14eae:	f7ff fcd3 	bl	14858 <hw_rx_counting_enabled>
   14eb2:	4603      	mov	r3, r0
   14eb4:	f083 0301 	eor.w	r3, r3, #1
   14eb8:	b2db      	uxtb	r3, r3
   14eba:	2b00      	cmp	r3, #0
   14ebc:	d006      	beq.n	14ecc <endrx_isr+0xbe>
		data->async->rx_cnt.cnt = data->async->rx_total_user_byte_cnt;
   14ebe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ec0:	691a      	ldr	r2, [r3, #16]
   14ec2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ec4:	691b      	ldr	r3, [r3, #16]
   14ec6:	6e92      	ldr	r2, [r2, #104]	; 0x68
   14ec8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
	if (rx_len > 0) {
   14ecc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   14ece:	2b00      	cmp	r3, #0
   14ed0:	dd19      	ble.n	14f06 <endrx_isr+0xf8>
		struct uart_event evt = {
   14ed2:	f107 030c 	add.w	r3, r7, #12
   14ed6:	2200      	movs	r2, #0
   14ed8:	601a      	str	r2, [r3, #0]
   14eda:	605a      	str	r2, [r3, #4]
   14edc:	609a      	str	r2, [r3, #8]
   14ede:	60da      	str	r2, [r3, #12]
   14ee0:	611a      	str	r2, [r3, #16]
   14ee2:	2302      	movs	r3, #2
   14ee4:	733b      	strb	r3, [r7, #12]
			.data.rx.buf = data->async->rx_buf,
   14ee6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ee8:	691b      	ldr	r3, [r3, #16]
   14eea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
		struct uart_event evt = {
   14eec:	613b      	str	r3, [r7, #16]
			.data.rx.offset = data->async->rx_offset,
   14eee:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ef0:	691b      	ldr	r3, [r3, #16]
   14ef2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
		struct uart_event evt = {
   14ef4:	617b      	str	r3, [r7, #20]
   14ef6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   14ef8:	61bb      	str	r3, [r7, #24]
		user_callback(dev, &evt);
   14efa:	f107 030c 	add.w	r3, r7, #12
   14efe:	4619      	mov	r1, r3
   14f00:	6878      	ldr	r0, [r7, #4]
   14f02:	f7ff fe1d 	bl	14b40 <user_callback>
	if (!data->async->rx_enabled) {
   14f06:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f08:	691b      	ldr	r3, [r3, #16]
   14f0a:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
   14f0e:	f083 0301 	eor.w	r3, r3, #1
   14f12:	b2db      	uxtb	r3, r3
   14f14:	2b00      	cmp	r3, #0
   14f16:	d005      	beq.n	14f24 <endrx_isr+0x116>
		data->async->is_in_irq = false;
   14f18:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f1a:	691b      	ldr	r3, [r3, #16]
   14f1c:	2200      	movs	r2, #0
   14f1e:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba
		return;
   14f22:	e070      	b.n	15006 <endrx_isr+0x1f8>
	struct uart_event evt = {
   14f24:	f107 0334 	add.w	r3, r7, #52	; 0x34
   14f28:	2200      	movs	r2, #0
   14f2a:	601a      	str	r2, [r3, #0]
   14f2c:	605a      	str	r2, [r3, #4]
   14f2e:	609a      	str	r2, [r3, #8]
   14f30:	60da      	str	r2, [r3, #12]
   14f32:	611a      	str	r2, [r3, #16]
   14f34:	2304      	movs	r3, #4
   14f36:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
		.data.rx_buf.buf = data->async->rx_buf,
   14f3a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f3c:	691b      	ldr	r3, [r3, #16]
   14f3e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
	struct uart_event evt = {
   14f40:	63bb      	str	r3, [r7, #56]	; 0x38
	user_callback(dev, &evt);
   14f42:	f107 0334 	add.w	r3, r7, #52	; 0x34
   14f46:	4619      	mov	r1, r3
   14f48:	6878      	ldr	r0, [r7, #4]
   14f4a:	f7ff fdf9 	bl	14b40 <user_callback>
	__asm__ volatile(
   14f4e:	f04f 0320 	mov.w	r3, #32
   14f52:	f3ef 8211 	mrs	r2, BASEPRI
   14f56:	f383 8811 	msr	BASEPRI, r3
   14f5a:	f3bf 8f6f 	isb	sy
   14f5e:	653a      	str	r2, [r7, #80]	; 0x50
   14f60:	64fb      	str	r3, [r7, #76]	; 0x4c
	return key;
   14f62:	6d3b      	ldr	r3, [r7, #80]	; 0x50
	int key = irq_lock();
   14f64:	657b      	str	r3, [r7, #84]	; 0x54
	if (data->async->rx_next_buf) {
   14f66:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f68:	691b      	ldr	r3, [r3, #16]
   14f6a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
   14f6c:	2b00      	cmp	r3, #0
   14f6e:	d02b      	beq.n	14fc8 <endrx_isr+0x1ba>
		data->async->rx_buf = data->async->rx_next_buf;
   14f70:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f72:	691a      	ldr	r2, [r3, #16]
   14f74:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f76:	691b      	ldr	r3, [r3, #16]
   14f78:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
   14f7a:	651a      	str	r2, [r3, #80]	; 0x50
		data->async->rx_buf_len = data->async->rx_next_buf_len;
   14f7c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f7e:	691a      	ldr	r2, [r3, #16]
   14f80:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f82:	691b      	ldr	r3, [r3, #16]
   14f84:	6e12      	ldr	r2, [r2, #96]	; 0x60
   14f86:	655a      	str	r2, [r3, #84]	; 0x54
		data->async->rx_next_buf = NULL;
   14f88:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f8a:	691b      	ldr	r3, [r3, #16]
   14f8c:	2200      	movs	r2, #0
   14f8e:	65da      	str	r2, [r3, #92]	; 0x5c
		data->async->rx_next_buf_len = 0;
   14f90:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f92:	691b      	ldr	r3, [r3, #16]
   14f94:	2200      	movs	r2, #0
   14f96:	661a      	str	r2, [r3, #96]	; 0x60
		data->async->rx_offset = 0;
   14f98:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14f9a:	691b      	ldr	r3, [r3, #16]
   14f9c:	2200      	movs	r2, #0
   14f9e:	659a      	str	r2, [r3, #88]	; 0x58
		if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {
   14fa0:	f44f 71a6 	mov.w	r1, #332	; 0x14c
   14fa4:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   14fa6:	f7ff f928 	bl	141fa <nrf_uarte_event_check>
   14faa:	4603      	mov	r3, r0
   14fac:	f083 0301 	eor.w	r3, r3, #1
   14fb0:	b2db      	uxtb	r3, r3
   14fb2:	2b00      	cmp	r3, #0
   14fb4:	d003      	beq.n	14fbe <endrx_isr+0x1b0>
			nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
   14fb6:	2100      	movs	r1, #0
   14fb8:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   14fba:	f7ff fa03 	bl	143c4 <nrf_uarte_task_trigger>
		nrf_uarte_shorts_disable(uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
   14fbe:	2120      	movs	r1, #32
   14fc0:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   14fc2:	f7ff f94e 	bl	14262 <nrf_uarte_shorts_disable>
   14fc6:	e003      	b.n	14fd0 <endrx_isr+0x1c2>
		data->async->rx_buf = NULL;
   14fc8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14fca:	691b      	ldr	r3, [r3, #16]
   14fcc:	2200      	movs	r2, #0
   14fce:	651a      	str	r2, [r3, #80]	; 0x50
	irq_unlock(key);
   14fd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   14fd2:	64bb      	str	r3, [r7, #72]	; 0x48
	__asm__ volatile(
   14fd4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   14fd6:	f383 8811 	msr	BASEPRI, r3
   14fda:	f3bf 8f6f 	isb	sy
}
   14fde:	bf00      	nop
	if (data->async->rx_buf == NULL) {
   14fe0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14fe2:	691b      	ldr	r3, [r3, #16]
   14fe4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   14fe6:	2b00      	cmp	r3, #0
   14fe8:	d108      	bne.n	14ffc <endrx_isr+0x1ee>
		evt.type = UART_RX_DISABLED;
   14fea:	2305      	movs	r3, #5
   14fec:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
		user_callback(dev, &evt);
   14ff0:	f107 0334 	add.w	r3, r7, #52	; 0x34
   14ff4:	4619      	mov	r1, r3
   14ff6:	6878      	ldr	r0, [r7, #4]
   14ff8:	f7ff fda2 	bl	14b40 <user_callback>
	data->async->is_in_irq = false;
   14ffc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   14ffe:	691b      	ldr	r3, [r3, #16]
   15000:	2200      	movs	r2, #0
   15002:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba
}
   15006:	3768      	adds	r7, #104	; 0x68
   15008:	46bd      	mov	sp, r7
   1500a:	bd80      	pop	{r7, pc}

0001500c <txstopped_isr>:
{
   1500c:	b580      	push	{r7, lr}
   1500e:	b092      	sub	sp, #72	; 0x48
   15010:	af00      	add	r7, sp, #0
   15012:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   15014:	6878      	ldr	r0, [r7, #4]
   15016:	f7ff fa8f 	bl	14538 <get_dev_data>
   1501a:	6478      	str	r0, [r7, #68]	; 0x44
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   1501c:	6878      	ldr	r0, [r7, #4]
   1501e:	f7ff faa1 	bl	14564 <get_uarte_instance>
   15022:	6438      	str	r0, [r7, #64]	; 0x40
	if (!data->async->tx_buf) {
   15024:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15026:	691b      	ldr	r3, [r3, #16]
   15028:	689b      	ldr	r3, [r3, #8]
   1502a:	2b00      	cmp	r3, #0
   1502c:	d13b      	bne.n	150a6 <txstopped_isr+0x9a>
		if (data->async->pend_tx_buf) {
   1502e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15030:	691b      	ldr	r3, [r3, #16]
   15032:	691b      	ldr	r3, [r3, #16]
   15034:	2b00      	cmp	r3, #0
   15036:	f000 808d 	beq.w	15154 <txstopped_isr+0x148>
	__asm__ volatile(
   1503a:	f04f 0320 	mov.w	r3, #32
   1503e:	f3ef 8211 	mrs	r2, BASEPRI
   15042:	f383 8811 	msr	BASEPRI, r3
   15046:	f3bf 8f6f 	isb	sy
   1504a:	637a      	str	r2, [r7, #52]	; 0x34
   1504c:	633b      	str	r3, [r7, #48]	; 0x30
	return key;
   1504e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
			key = irq_lock();
   15050:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (nrf_uarte_event_check(uarte,
   15052:	f44f 71ac 	mov.w	r1, #344	; 0x158
   15056:	6c38      	ldr	r0, [r7, #64]	; 0x40
   15058:	f7ff f8cf 	bl	141fa <nrf_uarte_event_check>
   1505c:	4603      	mov	r3, r0
   1505e:	2b00      	cmp	r3, #0
   15060:	d019      	beq.n	15096 <txstopped_isr+0x8a>
				data->async->tx_buf = data->async->pend_tx_buf;
   15062:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15064:	691a      	ldr	r2, [r3, #16]
   15066:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15068:	691b      	ldr	r3, [r3, #16]
   1506a:	6912      	ldr	r2, [r2, #16]
   1506c:	609a      	str	r2, [r3, #8]
				data->async->pend_tx_buf = NULL;
   1506e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15070:	691b      	ldr	r3, [r3, #16]
   15072:	2200      	movs	r2, #0
   15074:	611a      	str	r2, [r3, #16]
				data->async->tx_amount = -1;
   15076:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15078:	691b      	ldr	r3, [r3, #16]
   1507a:	f04f 32ff 	mov.w	r2, #4294967295
   1507e:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
				tx_start(uarte, data->async->tx_buf,
   15082:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15084:	691b      	ldr	r3, [r3, #16]
   15086:	6899      	ldr	r1, [r3, #8]
					 data->async->tx_size);
   15088:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1508a:	691b      	ldr	r3, [r3, #16]
				tx_start(uarte, data->async->tx_buf,
   1508c:	68db      	ldr	r3, [r3, #12]
   1508e:	461a      	mov	r2, r3
   15090:	6c38      	ldr	r0, [r7, #64]	; 0x40
   15092:	f7ff fbc4 	bl	1481e <tx_start>
			irq_unlock(key);
   15096:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   15098:	62fb      	str	r3, [r7, #44]	; 0x2c
	__asm__ volatile(
   1509a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1509c:	f383 8811 	msr	BASEPRI, r3
   150a0:	f3bf 8f6f 	isb	sy
}
   150a4:	e057      	b.n	15156 <txstopped_isr+0x14a>
	k_timer_stop(&data->async->tx_timeout_timer);
   150a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   150a8:	691b      	ldr	r3, [r3, #16]
   150aa:	3318      	adds	r3, #24
   150ac:	4618      	mov	r0, r3
   150ae:	f7fe ff8e 	bl	13fce <k_timer_stop>
	__asm__ volatile(
   150b2:	f04f 0320 	mov.w	r3, #32
   150b6:	f3ef 8211 	mrs	r2, BASEPRI
   150ba:	f383 8811 	msr	BASEPRI, r3
   150be:	f3bf 8f6f 	isb	sy
   150c2:	62ba      	str	r2, [r7, #40]	; 0x28
   150c4:	627b      	str	r3, [r7, #36]	; 0x24
	return key;
   150c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
	key = irq_lock();
   150c8:	63fb      	str	r3, [r7, #60]	; 0x3c
	size_t amount = (data->async->tx_amount >= 0) ?
   150ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   150cc:	691b      	ldr	r3, [r3, #16]
   150ce:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
			data->async->tx_amount : nrf_uarte_tx_amount_get(uarte);
   150d2:	2b00      	cmp	r3, #0
   150d4:	db04      	blt.n	150e0 <txstopped_isr+0xd4>
   150d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   150d8:	691b      	ldr	r3, [r3, #16]
   150da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
   150de:	e003      	b.n	150e8 <txstopped_isr+0xdc>
   150e0:	6c38      	ldr	r0, [r7, #64]	; 0x40
   150e2:	f7ff f9c6 	bl	14472 <nrf_uarte_tx_amount_get>
   150e6:	4603      	mov	r3, r0
	size_t amount = (data->async->tx_amount >= 0) ?
   150e8:	63bb      	str	r3, [r7, #56]	; 0x38
	irq_unlock(key);
   150ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   150ec:	623b      	str	r3, [r7, #32]
	__asm__ volatile(
   150ee:	6a3b      	ldr	r3, [r7, #32]
   150f0:	f383 8811 	msr	BASEPRI, r3
   150f4:	f3bf 8f6f 	isb	sy
}
   150f8:	bf00      	nop
	struct uart_event evt = {
   150fa:	f107 030c 	add.w	r3, r7, #12
   150fe:	2200      	movs	r2, #0
   15100:	601a      	str	r2, [r3, #0]
   15102:	605a      	str	r2, [r3, #4]
   15104:	609a      	str	r2, [r3, #8]
   15106:	60da      	str	r2, [r3, #12]
   15108:	611a      	str	r2, [r3, #16]
		.data.tx.buf = data->async->tx_buf,
   1510a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1510c:	691b      	ldr	r3, [r3, #16]
   1510e:	689b      	ldr	r3, [r3, #8]
	struct uart_event evt = {
   15110:	613b      	str	r3, [r7, #16]
   15112:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   15114:	617b      	str	r3, [r7, #20]
	if (amount == data->async->tx_size) {
   15116:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15118:	691b      	ldr	r3, [r3, #16]
   1511a:	68db      	ldr	r3, [r3, #12]
   1511c:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1511e:	429a      	cmp	r2, r3
   15120:	d102      	bne.n	15128 <txstopped_isr+0x11c>
		evt.type = UART_TX_DONE;
   15122:	2300      	movs	r3, #0
   15124:	733b      	strb	r3, [r7, #12]
   15126:	e001      	b.n	1512c <txstopped_isr+0x120>
		evt.type = UART_TX_ABORTED;
   15128:	2301      	movs	r3, #1
   1512a:	733b      	strb	r3, [r7, #12]
	nrf_uarte_int_disable(uarte, NRF_UARTE_INT_TXSTOPPED_MASK);
   1512c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   15130:	6c38      	ldr	r0, [r7, #64]	; 0x40
   15132:	f7ff f8c6 	bl	142c2 <nrf_uarte_int_disable>
	data->async->tx_buf = NULL;
   15136:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15138:	691b      	ldr	r3, [r3, #16]
   1513a:	2200      	movs	r2, #0
   1513c:	609a      	str	r2, [r3, #8]
	data->async->tx_size = 0;
   1513e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   15140:	691b      	ldr	r3, [r3, #16]
   15142:	2200      	movs	r2, #0
   15144:	60da      	str	r2, [r3, #12]
	user_callback(dev, &evt);
   15146:	f107 030c 	add.w	r3, r7, #12
   1514a:	4619      	mov	r1, r3
   1514c:	6878      	ldr	r0, [r7, #4]
   1514e:	f7ff fcf7 	bl	14b40 <user_callback>
   15152:	e000      	b.n	15156 <txstopped_isr+0x14a>
		return;
   15154:	bf00      	nop
}
   15156:	3748      	adds	r7, #72	; 0x48
   15158:	46bd      	mov	sp, r7
   1515a:	bd80      	pop	{r7, pc}

0001515c <uarte_nrfx_isr_async>:
{
   1515c:	b580      	push	{r7, lr}
   1515e:	b084      	sub	sp, #16
   15160:	af00      	add	r7, sp, #0
   15162:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15164:	6878      	ldr	r0, [r7, #4]
   15166:	f7ff f9fd 	bl	14564 <get_uarte_instance>
   1516a:	60f8      	str	r0, [r7, #12]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1516c:	6878      	ldr	r0, [r7, #4]
   1516e:	f7ff f9e3 	bl	14538 <get_dev_data>
   15172:	60b8      	str	r0, [r7, #8]
	if (!hw_rx_counting_enabled(data)
   15174:	68b8      	ldr	r0, [r7, #8]
   15176:	f7ff fb6f 	bl	14858 <hw_rx_counting_enabled>
   1517a:	4603      	mov	r3, r0
   1517c:	f083 0301 	eor.w	r3, r3, #1
   15180:	b2db      	uxtb	r3, r3
   15182:	2b00      	cmp	r3, #0
   15184:	d014      	beq.n	151b0 <uarte_nrfx_isr_async+0x54>
	    && nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXDRDY)) {
   15186:	f44f 7184 	mov.w	r1, #264	; 0x108
   1518a:	68f8      	ldr	r0, [r7, #12]
   1518c:	f7ff f835 	bl	141fa <nrf_uarte_event_check>
   15190:	4603      	mov	r3, r0
   15192:	2b00      	cmp	r3, #0
   15194:	d00c      	beq.n	151b0 <uarte_nrfx_isr_async+0x54>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXDRDY);
   15196:	f44f 7184 	mov.w	r1, #264	; 0x108
   1519a:	68f8      	ldr	r0, [r7, #12]
   1519c:	f7ff f818 	bl	141d0 <nrf_uarte_event_clear>
		data->async->rx_cnt.cnt++;
   151a0:	68bb      	ldr	r3, [r7, #8]
   151a2:	691b      	ldr	r3, [r3, #16]
   151a4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
   151a8:	3201      	adds	r2, #1
   151aa:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
		return;
   151ae:	e065      	b.n	1527c <uarte_nrfx_isr_async+0x120>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   151b0:	f44f 7192 	mov.w	r1, #292	; 0x124
   151b4:	68f8      	ldr	r0, [r7, #12]
   151b6:	f7ff f820 	bl	141fa <nrf_uarte_event_check>
   151ba:	4603      	mov	r3, r0
   151bc:	2b00      	cmp	r3, #0
   151be:	d007      	beq.n	151d0 <uarte_nrfx_isr_async+0x74>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ERROR);
   151c0:	f44f 7192 	mov.w	r1, #292	; 0x124
   151c4:	68f8      	ldr	r0, [r7, #12]
   151c6:	f7ff f803 	bl	141d0 <nrf_uarte_event_clear>
		error_isr(dev);
   151ca:	6878      	ldr	r0, [r7, #4]
   151cc:	f7ff fd90 	bl	14cf0 <error_isr>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   151d0:	f44f 7188 	mov.w	r1, #272	; 0x110
   151d4:	68f8      	ldr	r0, [r7, #12]
   151d6:	f7ff f810 	bl	141fa <nrf_uarte_event_check>
   151da:	4603      	mov	r3, r0
   151dc:	2b00      	cmp	r3, #0
   151de:	d007      	beq.n	151f0 <uarte_nrfx_isr_async+0x94>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   151e0:	f44f 7188 	mov.w	r1, #272	; 0x110
   151e4:	68f8      	ldr	r0, [r7, #12]
   151e6:	f7fe fff3 	bl	141d0 <nrf_uarte_event_clear>
		endrx_isr(dev);
   151ea:	6878      	ldr	r0, [r7, #4]
   151ec:	f7ff fe0f 	bl	14e0e <endrx_isr>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {
   151f0:	f44f 71a6 	mov.w	r1, #332	; 0x14c
   151f4:	68f8      	ldr	r0, [r7, #12]
   151f6:	f7ff f800 	bl	141fa <nrf_uarte_event_check>
   151fa:	4603      	mov	r3, r0
   151fc:	2b00      	cmp	r3, #0
   151fe:	d007      	beq.n	15210 <uarte_nrfx_isr_async+0xb4>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);
   15200:	f44f 71a6 	mov.w	r1, #332	; 0x14c
   15204:	68f8      	ldr	r0, [r7, #12]
   15206:	f7fe ffe3 	bl	141d0 <nrf_uarte_event_clear>
		rxstarted_isr(dev);
   1520a:	6878      	ldr	r0, [r7, #4]
   1520c:	f7ff fdae 	bl	14d6c <rxstarted_isr>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXTO)) {
   15210:	f44f 71a2 	mov.w	r1, #324	; 0x144
   15214:	68f8      	ldr	r0, [r7, #12]
   15216:	f7fe fff0 	bl	141fa <nrf_uarte_event_check>
   1521a:	4603      	mov	r3, r0
   1521c:	2b00      	cmp	r3, #0
   1521e:	d007      	beq.n	15230 <uarte_nrfx_isr_async+0xd4>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXTO);
   15220:	f44f 71a2 	mov.w	r1, #324	; 0x144
   15224:	68f8      	ldr	r0, [r7, #12]
   15226:	f7fe ffd3 	bl	141d0 <nrf_uarte_event_clear>
		rxto_isr(dev);
   1522a:	6878      	ldr	r0, [r7, #4]
   1522c:	f7f2 fc74 	bl	7b18 <rxto_isr>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)
   15230:	f44f 7190 	mov.w	r1, #288	; 0x120
   15234:	68f8      	ldr	r0, [r7, #12]
   15236:	f7fe ffe0 	bl	141fa <nrf_uarte_event_check>
   1523a:	4603      	mov	r3, r0
   1523c:	2b00      	cmp	r3, #0
   1523e:	d00a      	beq.n	15256 <uarte_nrfx_isr_async+0xfa>
	    && nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK)) {
   15240:	f44f 7180 	mov.w	r1, #256	; 0x100
   15244:	68f8      	ldr	r0, [r7, #12]
   15246:	f7ff f82d 	bl	142a4 <nrf_uarte_int_enable_check>
   1524a:	4603      	mov	r3, r0
   1524c:	2b00      	cmp	r3, #0
   1524e:	d002      	beq.n	15256 <uarte_nrfx_isr_async+0xfa>
		endtx_isr(dev);
   15250:	6878      	ldr	r0, [r7, #4]
   15252:	f7ff f995 	bl	14580 <endtx_isr>
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)
   15256:	f44f 71ac 	mov.w	r1, #344	; 0x158
   1525a:	68f8      	ldr	r0, [r7, #12]
   1525c:	f7fe ffcd 	bl	141fa <nrf_uarte_event_check>
   15260:	4603      	mov	r3, r0
   15262:	2b00      	cmp	r3, #0
   15264:	d00a      	beq.n	1527c <uarte_nrfx_isr_async+0x120>
	    && nrf_uarte_int_enable_check(uarte,
   15266:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   1526a:	68f8      	ldr	r0, [r7, #12]
   1526c:	f7ff f81a 	bl	142a4 <nrf_uarte_int_enable_check>
   15270:	4603      	mov	r3, r0
   15272:	2b00      	cmp	r3, #0
   15274:	d002      	beq.n	1527c <uarte_nrfx_isr_async+0x120>
		txstopped_isr(dev);
   15276:	6878      	ldr	r0, [r7, #4]
   15278:	f7ff fec8 	bl	1500c <txstopped_isr>
}
   1527c:	3710      	adds	r7, #16
   1527e:	46bd      	mov	sp, r7
   15280:	bd80      	pop	{r7, pc}

00015282 <uarte_nrfx_poll_in>:
{
   15282:	b580      	push	{r7, lr}
   15284:	b084      	sub	sp, #16
   15286:	af00      	add	r7, sp, #0
   15288:	6078      	str	r0, [r7, #4]
   1528a:	6039      	str	r1, [r7, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   1528c:	6878      	ldr	r0, [r7, #4]
   1528e:	f7ff f953 	bl	14538 <get_dev_data>
   15292:	60f8      	str	r0, [r7, #12]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15294:	6878      	ldr	r0, [r7, #4]
   15296:	f7ff f965 	bl	14564 <get_uarte_instance>
   1529a:	60b8      	str	r0, [r7, #8]
	if (data->async) {
   1529c:	68fb      	ldr	r3, [r7, #12]
   1529e:	691b      	ldr	r3, [r3, #16]
   152a0:	2b00      	cmp	r3, #0
   152a2:	d002      	beq.n	152aa <uarte_nrfx_poll_in+0x28>
		return -ENOTSUP;
   152a4:	f06f 0322 	mvn.w	r3, #34	; 0x22
   152a8:	e01b      	b.n	152e2 <uarte_nrfx_poll_in+0x60>
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   152aa:	f44f 7188 	mov.w	r1, #272	; 0x110
   152ae:	68b8      	ldr	r0, [r7, #8]
   152b0:	f7fe ffa3 	bl	141fa <nrf_uarte_event_check>
   152b4:	4603      	mov	r3, r0
   152b6:	f083 0301 	eor.w	r3, r3, #1
   152ba:	b2db      	uxtb	r3, r3
   152bc:	2b00      	cmp	r3, #0
   152be:	d002      	beq.n	152c6 <uarte_nrfx_poll_in+0x44>
		return -1;
   152c0:	f04f 33ff 	mov.w	r3, #4294967295
   152c4:	e00d      	b.n	152e2 <uarte_nrfx_poll_in+0x60>
	*c = data->rx_data;
   152c6:	68fb      	ldr	r3, [r7, #12]
   152c8:	7d5a      	ldrb	r2, [r3, #21]
   152ca:	683b      	ldr	r3, [r7, #0]
   152cc:	701a      	strb	r2, [r3, #0]
	nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   152ce:	f44f 7188 	mov.w	r1, #272	; 0x110
   152d2:	68b8      	ldr	r0, [r7, #8]
   152d4:	f7fe ff7c 	bl	141d0 <nrf_uarte_event_clear>
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
   152d8:	2100      	movs	r1, #0
   152da:	68b8      	ldr	r0, [r7, #8]
   152dc:	f7ff f872 	bl	143c4 <nrf_uarte_task_trigger>
	return 0;
   152e0:	2300      	movs	r3, #0
}
   152e2:	4618      	mov	r0, r3
   152e4:	3710      	adds	r7, #16
   152e6:	46bd      	mov	sp, r7
   152e8:	bd80      	pop	{r7, pc}

000152ea <uarte_nrfx_poll_out>:
{
   152ea:	b580      	push	{r7, lr}
   152ec:	b090      	sub	sp, #64	; 0x40
   152ee:	af00      	add	r7, sp, #0
   152f0:	6078      	str	r0, [r7, #4]
   152f2:	460b      	mov	r3, r1
   152f4:	70fb      	strb	r3, [r7, #3]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   152f6:	6878      	ldr	r0, [r7, #4]
   152f8:	f7ff f91e 	bl	14538 <get_dev_data>
   152fc:	6338      	str	r0, [r7, #48]	; 0x30
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   152fe:	f002 fe71 	bl	17fe4 <k_is_in_isr>
   15302:	4603      	mov	r3, r0
   15304:	2b00      	cmp	r3, #0
   15306:	d104      	bne.n	15312 <uarte_nrfx_poll_out+0x28>
   15308:	f7f2 f84e 	bl	73a8 <k_is_pre_kernel>
   1530c:	4603      	mov	r3, r0
   1530e:	2b00      	cmp	r3, #0
   15310:	d001      	beq.n	15316 <uarte_nrfx_poll_out+0x2c>
   15312:	2301      	movs	r3, #1
   15314:	e000      	b.n	15318 <uarte_nrfx_poll_out+0x2e>
   15316:	2300      	movs	r3, #0
   15318:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   1531c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   15320:	f003 0301 	and.w	r3, r3, #1
   15324:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15328:	6878      	ldr	r0, [r7, #4]
   1532a:	f7ff f91b 	bl	14564 <get_uarte_instance>
   1532e:	62b8      	str	r0, [r7, #40]	; 0x28
	if (isr_mode) {
   15330:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   15334:	2b00      	cmp	r3, #0
   15336:	d02e      	beq.n	15396 <uarte_nrfx_poll_out+0xac>
	__asm__ volatile(
   15338:	f04f 0320 	mov.w	r3, #32
   1533c:	f3ef 8211 	mrs	r2, BASEPRI
   15340:	f383 8811 	msr	BASEPRI, r3
   15344:	f3bf 8f6f 	isb	sy
   15348:	627a      	str	r2, [r7, #36]	; 0x24
   1534a:	623b      	str	r3, [r7, #32]
	return key;
   1534c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
			key = irq_lock();
   1534e:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (is_tx_ready(dev)) {
   15350:	6878      	ldr	r0, [r7, #4]
   15352:	f7ff fa36 	bl	147c2 <is_tx_ready>
   15356:	4603      	mov	r3, r0
   15358:	2b00      	cmp	r3, #0
   1535a:	d013      	beq.n	15384 <uarte_nrfx_poll_out+0x9a>
				if (data->async->tx_size &&
   1535c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1535e:	691b      	ldr	r3, [r3, #16]
   15360:	68db      	ldr	r3, [r3, #12]
   15362:	2b00      	cmp	r3, #0
   15364:	d051      	beq.n	1540a <uarte_nrfx_poll_out+0x120>
					data->async->tx_amount < 0) {
   15366:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   15368:	691b      	ldr	r3, [r3, #16]
   1536a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
				if (data->async->tx_size &&
   1536e:	2b00      	cmp	r3, #0
   15370:	da4b      	bge.n	1540a <uarte_nrfx_poll_out+0x120>
						nrf_uarte_tx_amount_get(uarte);
   15372:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15374:	f7ff f87d 	bl	14472 <nrf_uarte_tx_amount_get>
   15378:	4602      	mov	r2, r0
					data->async->tx_amount =
   1537a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1537c:	691b      	ldr	r3, [r3, #16]
   1537e:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
				break;
   15382:	e042      	b.n	1540a <uarte_nrfx_poll_out+0x120>
			irq_unlock(key);
   15384:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   15386:	61fb      	str	r3, [r7, #28]
	__asm__ volatile(
   15388:	69fb      	ldr	r3, [r7, #28]
   1538a:	f383 8811 	msr	BASEPRI, r3
   1538e:	f3bf 8f6f 	isb	sy
}
   15392:	bf00      	nop
			key = irq_lock();
   15394:	e7d0      	b.n	15338 <uarte_nrfx_poll_out+0x4e>
			NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   15396:	2300      	movs	r3, #0
   15398:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
   1539c:	2364      	movs	r3, #100	; 0x64
   1539e:	637b      	str	r3, [r7, #52]	; 0x34
   153a0:	6878      	ldr	r0, [r7, #4]
   153a2:	f7ff fa0e 	bl	147c2 <is_tx_ready>
   153a6:	4603      	mov	r3, r0
   153a8:	2b00      	cmp	r3, #0
   153aa:	d003      	beq.n	153b4 <uarte_nrfx_poll_out+0xca>
   153ac:	2301      	movs	r3, #1
   153ae:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
   153b2:	e008      	b.n	153c6 <uarte_nrfx_poll_out+0xdc>
   153b4:	2001      	movs	r0, #1
   153b6:	f001 faac 	bl	16912 <nrfx_busy_wait>
   153ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   153bc:	3b01      	subs	r3, #1
   153be:	637b      	str	r3, [r7, #52]	; 0x34
   153c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   153c2:	2b00      	cmp	r3, #0
   153c4:	d1ec      	bne.n	153a0 <uarte_nrfx_poll_out+0xb6>
			if (res) {
   153c6:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
   153ca:	2b00      	cmp	r3, #0
   153cc:	d019      	beq.n	15402 <uarte_nrfx_poll_out+0x118>
	__asm__ volatile(
   153ce:	f04f 0320 	mov.w	r3, #32
   153d2:	f3ef 8211 	mrs	r2, BASEPRI
   153d6:	f383 8811 	msr	BASEPRI, r3
   153da:	f3bf 8f6f 	isb	sy
   153de:	61ba      	str	r2, [r7, #24]
   153e0:	617b      	str	r3, [r7, #20]
	return key;
   153e2:	69bb      	ldr	r3, [r7, #24]
				key = irq_lock();
   153e4:	63fb      	str	r3, [r7, #60]	; 0x3c
				if (is_tx_ready(dev)) {
   153e6:	6878      	ldr	r0, [r7, #4]
   153e8:	f7ff f9eb 	bl	147c2 <is_tx_ready>
   153ec:	4603      	mov	r3, r0
   153ee:	2b00      	cmp	r3, #0
   153f0:	d10d      	bne.n	1540e <uarte_nrfx_poll_out+0x124>
				irq_unlock(key);
   153f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   153f4:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
   153f6:	693b      	ldr	r3, [r7, #16]
   153f8:	f383 8811 	msr	BASEPRI, r3
   153fc:	f3bf 8f6f 	isb	sy
}
   15400:	bf00      	nop
			k_msleep(1);
   15402:	2001      	movs	r0, #1
   15404:	f7fe fd90 	bl	13f28 <k_msleep>
		do {
   15408:	e7c5      	b.n	15396 <uarte_nrfx_poll_out+0xac>
				break;
   1540a:	bf00      	nop
   1540c:	e000      	b.n	15410 <uarte_nrfx_poll_out+0x126>
					break;
   1540e:	bf00      	nop
	data->char_out = c;
   15410:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   15412:	78fa      	ldrb	r2, [r7, #3]
   15414:	751a      	strb	r2, [r3, #20]
	tx_start(uarte, &data->char_out, 1);
   15416:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   15418:	3314      	adds	r3, #20
   1541a:	2201      	movs	r2, #1
   1541c:	4619      	mov	r1, r3
   1541e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15420:	f7ff f9fd 	bl	1481e <tx_start>
	irq_unlock(key);
   15424:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   15426:	60fb      	str	r3, [r7, #12]
	__asm__ volatile(
   15428:	68fb      	ldr	r3, [r7, #12]
   1542a:	f383 8811 	msr	BASEPRI, r3
   1542e:	f3bf 8f6f 	isb	sy
}
   15432:	bf00      	nop
}
   15434:	bf00      	nop
   15436:	3740      	adds	r7, #64	; 0x40
   15438:	46bd      	mov	sp, r7
   1543a:	bd80      	pop	{r7, pc}

0001543c <uarte_nrfx_fifo_fill>:
{
   1543c:	b580      	push	{r7, lr}
   1543e:	b08c      	sub	sp, #48	; 0x30
   15440:	af00      	add	r7, sp, #0
   15442:	60f8      	str	r0, [r7, #12]
   15444:	60b9      	str	r1, [r7, #8]
   15446:	607a      	str	r2, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15448:	68f8      	ldr	r0, [r7, #12]
   1544a:	f7ff f88b 	bl	14564 <get_uarte_instance>
   1544e:	62b8      	str	r0, [r7, #40]	; 0x28
	struct uarte_nrfx_data *data = get_dev_data(dev);
   15450:	68f8      	ldr	r0, [r7, #12]
   15452:	f7ff f871 	bl	14538 <get_dev_data>
   15456:	6278      	str	r0, [r7, #36]	; 0x24
	len = MIN(len, data->int_driven->tx_buff_size);
   15458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1545a:	68db      	ldr	r3, [r3, #12]
   1545c:	899b      	ldrh	r3, [r3, #12]
   1545e:	461a      	mov	r2, r3
   15460:	687b      	ldr	r3, [r7, #4]
   15462:	4293      	cmp	r3, r2
   15464:	bfa8      	it	ge
   15466:	4613      	movge	r3, r2
   15468:	607b      	str	r3, [r7, #4]
	if (!atomic_cas(&data->int_driven->fifo_fill_lock, 0, 1)) {
   1546a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1546c:	68db      	ldr	r3, [r3, #12]
   1546e:	3310      	adds	r3, #16
   15470:	2201      	movs	r2, #1
   15472:	2100      	movs	r1, #0
   15474:	4618      	mov	r0, r3
   15476:	f7fe fbf3 	bl	13c60 <atomic_cas>
   1547a:	4603      	mov	r3, r0
   1547c:	f083 0301 	eor.w	r3, r3, #1
   15480:	b2db      	uxtb	r3, r3
   15482:	2b00      	cmp	r3, #0
   15484:	d001      	beq.n	1548a <uarte_nrfx_fifo_fill+0x4e>
		return 0;
   15486:	2300      	movs	r3, #0
   15488:	e040      	b.n	1550c <uarte_nrfx_fifo_fill+0xd0>
	for (int i = 0; i < len; i++) {
   1548a:	2300      	movs	r3, #0
   1548c:	62fb      	str	r3, [r7, #44]	; 0x2c
   1548e:	e00c      	b.n	154aa <uarte_nrfx_fifo_fill+0x6e>
		data->int_driven->tx_buffer[i] = tx_data[i];
   15490:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   15492:	68ba      	ldr	r2, [r7, #8]
   15494:	441a      	add	r2, r3
   15496:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15498:	68db      	ldr	r3, [r3, #12]
   1549a:	6899      	ldr	r1, [r3, #8]
   1549c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1549e:	440b      	add	r3, r1
   154a0:	7812      	ldrb	r2, [r2, #0]
   154a2:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < len; i++) {
   154a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   154a6:	3301      	adds	r3, #1
   154a8:	62fb      	str	r3, [r7, #44]	; 0x2c
   154aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   154ac:	687b      	ldr	r3, [r7, #4]
   154ae:	429a      	cmp	r2, r3
   154b0:	dbee      	blt.n	15490 <uarte_nrfx_fifo_fill+0x54>
	__asm__ volatile(
   154b2:	f04f 0320 	mov.w	r3, #32
   154b6:	f3ef 8211 	mrs	r2, BASEPRI
   154ba:	f383 8811 	msr	BASEPRI, r3
   154be:	f3bf 8f6f 	isb	sy
   154c2:	61fa      	str	r2, [r7, #28]
   154c4:	61bb      	str	r3, [r7, #24]
	return key;
   154c6:	69fb      	ldr	r3, [r7, #28]
	int key = irq_lock();
   154c8:	623b      	str	r3, [r7, #32]
	if (!is_tx_ready(dev)) {
   154ca:	68f8      	ldr	r0, [r7, #12]
   154cc:	f7ff f979 	bl	147c2 <is_tx_ready>
   154d0:	4603      	mov	r3, r0
   154d2:	f083 0301 	eor.w	r3, r3, #1
   154d6:	b2db      	uxtb	r3, r3
   154d8:	2b00      	cmp	r3, #0
   154da:	d006      	beq.n	154ea <uarte_nrfx_fifo_fill+0xae>
		data->int_driven->fifo_fill_lock = 0;
   154dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   154de:	68db      	ldr	r3, [r3, #12]
   154e0:	2200      	movs	r2, #0
   154e2:	611a      	str	r2, [r3, #16]
		len = 0;
   154e4:	2300      	movs	r3, #0
   154e6:	607b      	str	r3, [r7, #4]
   154e8:	e007      	b.n	154fa <uarte_nrfx_fifo_fill+0xbe>
		tx_start(uarte, data->int_driven->tx_buffer, len);
   154ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   154ec:	68db      	ldr	r3, [r3, #12]
   154ee:	689b      	ldr	r3, [r3, #8]
   154f0:	687a      	ldr	r2, [r7, #4]
   154f2:	4619      	mov	r1, r3
   154f4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   154f6:	f7ff f992 	bl	1481e <tx_start>
	irq_unlock(key);
   154fa:	6a3b      	ldr	r3, [r7, #32]
   154fc:	617b      	str	r3, [r7, #20]
	__asm__ volatile(
   154fe:	697b      	ldr	r3, [r7, #20]
   15500:	f383 8811 	msr	BASEPRI, r3
   15504:	f3bf 8f6f 	isb	sy
}
   15508:	bf00      	nop
	return len;
   1550a:	687b      	ldr	r3, [r7, #4]
}
   1550c:	4618      	mov	r0, r3
   1550e:	3730      	adds	r7, #48	; 0x30
   15510:	46bd      	mov	sp, r7
   15512:	bd80      	pop	{r7, pc}

00015514 <uarte_nrfx_fifo_read>:
{
   15514:	b580      	push	{r7, lr}
   15516:	b088      	sub	sp, #32
   15518:	af00      	add	r7, sp, #0
   1551a:	60f8      	str	r0, [r7, #12]
   1551c:	60b9      	str	r1, [r7, #8]
   1551e:	607a      	str	r2, [r7, #4]
	int num_rx = 0;
   15520:	2300      	movs	r3, #0
   15522:	61fb      	str	r3, [r7, #28]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15524:	68f8      	ldr	r0, [r7, #12]
   15526:	f7ff f81d 	bl	14564 <get_uarte_instance>
   1552a:	61b8      	str	r0, [r7, #24]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   1552c:	68f8      	ldr	r0, [r7, #12]
   1552e:	f7ff f803 	bl	14538 <get_dev_data>
   15532:	6178      	str	r0, [r7, #20]
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   15534:	f44f 7188 	mov.w	r1, #272	; 0x110
   15538:	69b8      	ldr	r0, [r7, #24]
   1553a:	f7fe fe5e 	bl	141fa <nrf_uarte_event_check>
   1553e:	4603      	mov	r3, r0
   15540:	2b00      	cmp	r3, #0
   15542:	d011      	beq.n	15568 <uarte_nrfx_fifo_read+0x54>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   15544:	f44f 7188 	mov.w	r1, #272	; 0x110
   15548:	69b8      	ldr	r0, [r7, #24]
   1554a:	f7fe fe41 	bl	141d0 <nrf_uarte_event_clear>
		rx_data[num_rx++] = (uint8_t)data->rx_data;
   1554e:	69fb      	ldr	r3, [r7, #28]
   15550:	1c5a      	adds	r2, r3, #1
   15552:	61fa      	str	r2, [r7, #28]
   15554:	461a      	mov	r2, r3
   15556:	68bb      	ldr	r3, [r7, #8]
   15558:	4413      	add	r3, r2
   1555a:	697a      	ldr	r2, [r7, #20]
   1555c:	7d52      	ldrb	r2, [r2, #21]
   1555e:	701a      	strb	r2, [r3, #0]
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
   15560:	2100      	movs	r1, #0
   15562:	69b8      	ldr	r0, [r7, #24]
   15564:	f7fe ff2e 	bl	143c4 <nrf_uarte_task_trigger>
	return num_rx;
   15568:	69fb      	ldr	r3, [r7, #28]
}
   1556a:	4618      	mov	r0, r3
   1556c:	3720      	adds	r7, #32
   1556e:	46bd      	mov	sp, r7
   15570:	bd80      	pop	{r7, pc}

00015572 <uarte_nrfx_irq_tx_enable>:
{
   15572:	b580      	push	{r7, lr}
   15574:	b088      	sub	sp, #32
   15576:	af00      	add	r7, sp, #0
   15578:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   1557a:	6878      	ldr	r0, [r7, #4]
   1557c:	f7fe fff2 	bl	14564 <get_uarte_instance>
   15580:	61f8      	str	r0, [r7, #28]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   15582:	6878      	ldr	r0, [r7, #4]
   15584:	f7fe ffd8 	bl	14538 <get_dev_data>
   15588:	61b8      	str	r0, [r7, #24]
	__asm__ volatile(
   1558a:	f04f 0320 	mov.w	r3, #32
   1558e:	f3ef 8211 	mrs	r2, BASEPRI
   15592:	f383 8811 	msr	BASEPRI, r3
   15596:	f3bf 8f6f 	isb	sy
   1559a:	60fa      	str	r2, [r7, #12]
   1559c:	60bb      	str	r3, [r7, #8]
	return key;
   1559e:	68fb      	ldr	r3, [r7, #12]
	int key = irq_lock();
   155a0:	617b      	str	r3, [r7, #20]
	data->int_driven->disable_tx_irq = false;
   155a2:	69bb      	ldr	r3, [r7, #24]
   155a4:	68db      	ldr	r3, [r3, #12]
   155a6:	2200      	movs	r2, #0
   155a8:	739a      	strb	r2, [r3, #14]
	nrf_uarte_int_enable(uarte, NRF_UARTE_INT_TXSTOPPED_MASK);
   155aa:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   155ae:	69f8      	ldr	r0, [r7, #28]
   155b0:	f7fe fe6a 	bl	14288 <nrf_uarte_int_enable>
	irq_unlock(key);
   155b4:	697b      	ldr	r3, [r7, #20]
   155b6:	613b      	str	r3, [r7, #16]
	__asm__ volatile(
   155b8:	693b      	ldr	r3, [r7, #16]
   155ba:	f383 8811 	msr	BASEPRI, r3
   155be:	f3bf 8f6f 	isb	sy
}
   155c2:	bf00      	nop
}
   155c4:	bf00      	nop
   155c6:	3720      	adds	r7, #32
   155c8:	46bd      	mov	sp, r7
   155ca:	bd80      	pop	{r7, pc}

000155cc <uarte_nrfx_irq_tx_disable>:
{
   155cc:	b580      	push	{r7, lr}
   155ce:	b084      	sub	sp, #16
   155d0:	af00      	add	r7, sp, #0
   155d2:	6078      	str	r0, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   155d4:	6878      	ldr	r0, [r7, #4]
   155d6:	f7fe ffaf 	bl	14538 <get_dev_data>
   155da:	60f8      	str	r0, [r7, #12]
	data->int_driven->disable_tx_irq = true;
   155dc:	68fb      	ldr	r3, [r7, #12]
   155de:	68db      	ldr	r3, [r3, #12]
   155e0:	2201      	movs	r2, #1
   155e2:	739a      	strb	r2, [r3, #14]
}
   155e4:	bf00      	nop
   155e6:	3710      	adds	r7, #16
   155e8:	46bd      	mov	sp, r7
   155ea:	bd80      	pop	{r7, pc}

000155ec <uarte_nrfx_irq_tx_ready_complete>:
{
   155ec:	b580      	push	{r7, lr}
   155ee:	b084      	sub	sp, #16
   155f0:	af00      	add	r7, sp, #0
   155f2:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   155f4:	6878      	ldr	r0, [r7, #4]
   155f6:	f7fe ffb5 	bl	14564 <get_uarte_instance>
   155fa:	60f8      	str	r0, [r7, #12]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   155fc:	6878      	ldr	r0, [r7, #4]
   155fe:	f7fe ff9b 	bl	14538 <get_dev_data>
   15602:	60b8      	str	r0, [r7, #8]
	return !data->int_driven->disable_tx_irq &&
   15604:	68bb      	ldr	r3, [r7, #8]
   15606:	68db      	ldr	r3, [r3, #12]
   15608:	7b9b      	ldrb	r3, [r3, #14]
   1560a:	b2db      	uxtb	r3, r3
   1560c:	f083 0301 	eor.w	r3, r3, #1
   15610:	b2db      	uxtb	r3, r3
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&
   15612:	2b00      	cmp	r3, #0
   15614:	d011      	beq.n	1563a <uarte_nrfx_irq_tx_ready_complete+0x4e>
   15616:	f44f 71ac 	mov.w	r1, #344	; 0x158
   1561a:	68f8      	ldr	r0, [r7, #12]
   1561c:	f7fe fded 	bl	141fa <nrf_uarte_event_check>
   15620:	4603      	mov	r3, r0
	return !data->int_driven->disable_tx_irq &&
   15622:	2b00      	cmp	r3, #0
   15624:	d009      	beq.n	1563a <uarte_nrfx_irq_tx_ready_complete+0x4e>
	       nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_TXSTOPPED_MASK);
   15626:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   1562a:	68f8      	ldr	r0, [r7, #12]
   1562c:	f7fe fe3a 	bl	142a4 <nrf_uarte_int_enable_check>
   15630:	4603      	mov	r3, r0
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&
   15632:	2b00      	cmp	r3, #0
   15634:	d001      	beq.n	1563a <uarte_nrfx_irq_tx_ready_complete+0x4e>
   15636:	2301      	movs	r3, #1
   15638:	e000      	b.n	1563c <uarte_nrfx_irq_tx_ready_complete+0x50>
   1563a:	2300      	movs	r3, #0
}
   1563c:	4618      	mov	r0, r3
   1563e:	3710      	adds	r7, #16
   15640:	46bd      	mov	sp, r7
   15642:	bd80      	pop	{r7, pc}

00015644 <uarte_nrfx_irq_rx_ready>:
{
   15644:	b580      	push	{r7, lr}
   15646:	b084      	sub	sp, #16
   15648:	af00      	add	r7, sp, #0
   1564a:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   1564c:	6878      	ldr	r0, [r7, #4]
   1564e:	f7fe ff89 	bl	14564 <get_uarte_instance>
   15652:	60f8      	str	r0, [r7, #12]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX);
   15654:	f44f 7188 	mov.w	r1, #272	; 0x110
   15658:	68f8      	ldr	r0, [r7, #12]
   1565a:	f7fe fdce 	bl	141fa <nrf_uarte_event_check>
   1565e:	4603      	mov	r3, r0
}
   15660:	4618      	mov	r0, r3
   15662:	3710      	adds	r7, #16
   15664:	46bd      	mov	sp, r7
   15666:	bd80      	pop	{r7, pc}

00015668 <uarte_nrfx_irq_rx_enable>:
{
   15668:	b580      	push	{r7, lr}
   1566a:	b084      	sub	sp, #16
   1566c:	af00      	add	r7, sp, #0
   1566e:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15670:	6878      	ldr	r0, [r7, #4]
   15672:	f7fe ff77 	bl	14564 <get_uarte_instance>
   15676:	60f8      	str	r0, [r7, #12]
	nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ENDRX_MASK);
   15678:	2110      	movs	r1, #16
   1567a:	68f8      	ldr	r0, [r7, #12]
   1567c:	f7fe fe04 	bl	14288 <nrf_uarte_int_enable>
}
   15680:	bf00      	nop
   15682:	3710      	adds	r7, #16
   15684:	46bd      	mov	sp, r7
   15686:	bd80      	pop	{r7, pc}

00015688 <uarte_nrfx_irq_rx_disable>:
{
   15688:	b580      	push	{r7, lr}
   1568a:	b084      	sub	sp, #16
   1568c:	af00      	add	r7, sp, #0
   1568e:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   15690:	6878      	ldr	r0, [r7, #4]
   15692:	f7fe ff67 	bl	14564 <get_uarte_instance>
   15696:	60f8      	str	r0, [r7, #12]
	nrf_uarte_int_disable(uarte, NRF_UARTE_INT_ENDRX_MASK);
   15698:	2110      	movs	r1, #16
   1569a:	68f8      	ldr	r0, [r7, #12]
   1569c:	f7fe fe11 	bl	142c2 <nrf_uarte_int_disable>
}
   156a0:	bf00      	nop
   156a2:	3710      	adds	r7, #16
   156a4:	46bd      	mov	sp, r7
   156a6:	bd80      	pop	{r7, pc}

000156a8 <uarte_nrfx_irq_err_enable>:
{
   156a8:	b580      	push	{r7, lr}
   156aa:	b084      	sub	sp, #16
   156ac:	af00      	add	r7, sp, #0
   156ae:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   156b0:	6878      	ldr	r0, [r7, #4]
   156b2:	f7fe ff57 	bl	14564 <get_uarte_instance>
   156b6:	60f8      	str	r0, [r7, #12]
	nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ERROR_MASK);
   156b8:	f44f 7100 	mov.w	r1, #512	; 0x200
   156bc:	68f8      	ldr	r0, [r7, #12]
   156be:	f7fe fde3 	bl	14288 <nrf_uarte_int_enable>
}
   156c2:	bf00      	nop
   156c4:	3710      	adds	r7, #16
   156c6:	46bd      	mov	sp, r7
   156c8:	bd80      	pop	{r7, pc}

000156ca <uarte_nrfx_irq_err_disable>:
{
   156ca:	b580      	push	{r7, lr}
   156cc:	b084      	sub	sp, #16
   156ce:	af00      	add	r7, sp, #0
   156d0:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   156d2:	6878      	ldr	r0, [r7, #4]
   156d4:	f7fe ff46 	bl	14564 <get_uarte_instance>
   156d8:	60f8      	str	r0, [r7, #12]
	nrf_uarte_int_disable(uarte, NRF_UARTE_INT_ERROR_MASK);
   156da:	f44f 7100 	mov.w	r1, #512	; 0x200
   156de:	68f8      	ldr	r0, [r7, #12]
   156e0:	f7fe fdef 	bl	142c2 <nrf_uarte_int_disable>
}
   156e4:	bf00      	nop
   156e6:	3710      	adds	r7, #16
   156e8:	46bd      	mov	sp, r7
   156ea:	bd80      	pop	{r7, pc}

000156ec <uarte_nrfx_irq_is_pending>:
{
   156ec:	b580      	push	{r7, lr}
   156ee:	b084      	sub	sp, #16
   156f0:	af00      	add	r7, sp, #0
   156f2:	6078      	str	r0, [r7, #4]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   156f4:	6878      	ldr	r0, [r7, #4]
   156f6:	f7fe ff35 	bl	14564 <get_uarte_instance>
   156fa:	60f8      	str	r0, [r7, #12]
	return ((nrf_uarte_int_enable_check(uarte,
   156fc:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   15700:	68f8      	ldr	r0, [r7, #12]
   15702:	f7fe fdcf 	bl	142a4 <nrf_uarte_int_enable_check>
   15706:	4603      	mov	r3, r0
		||
   15708:	2b00      	cmp	r3, #0
   1570a:	d005      	beq.n	15718 <uarte_nrfx_irq_is_pending+0x2c>
		 uarte_nrfx_irq_tx_ready_complete(dev))
   1570c:	6878      	ldr	r0, [r7, #4]
   1570e:	f7ff ff6d 	bl	155ec <uarte_nrfx_irq_tx_ready_complete>
   15712:	4603      	mov	r3, r0
					    NRF_UARTE_INT_TXSTOPPED_MASK) &&
   15714:	2b00      	cmp	r3, #0
   15716:	d10c      	bne.n	15732 <uarte_nrfx_irq_is_pending+0x46>
		(nrf_uarte_int_enable_check(uarte,
   15718:	2110      	movs	r1, #16
   1571a:	68f8      	ldr	r0, [r7, #12]
   1571c:	f7fe fdc2 	bl	142a4 <nrf_uarte_int_enable_check>
   15720:	4603      	mov	r3, r0
		||
   15722:	2b00      	cmp	r3, #0
   15724:	d007      	beq.n	15736 <uarte_nrfx_irq_is_pending+0x4a>
		 uarte_nrfx_irq_rx_ready(dev)));
   15726:	6878      	ldr	r0, [r7, #4]
   15728:	f7ff ff8c 	bl	15644 <uarte_nrfx_irq_rx_ready>
   1572c:	4603      	mov	r3, r0
					    NRF_UARTE_INT_ENDRX_MASK) &&
   1572e:	2b00      	cmp	r3, #0
   15730:	d001      	beq.n	15736 <uarte_nrfx_irq_is_pending+0x4a>
		||
   15732:	2301      	movs	r3, #1
   15734:	e000      	b.n	15738 <uarte_nrfx_irq_is_pending+0x4c>
   15736:	2300      	movs	r3, #0
}
   15738:	4618      	mov	r0, r3
   1573a:	3710      	adds	r7, #16
   1573c:	46bd      	mov	sp, r7
   1573e:	bd80      	pop	{r7, pc}

00015740 <uarte_nrfx_irq_update>:
{
   15740:	b480      	push	{r7}
   15742:	b083      	sub	sp, #12
   15744:	af00      	add	r7, sp, #0
   15746:	6078      	str	r0, [r7, #4]
	return 1;
   15748:	2301      	movs	r3, #1
}
   1574a:	4618      	mov	r0, r3
   1574c:	370c      	adds	r7, #12
   1574e:	46bd      	mov	sp, r7
   15750:	bc80      	pop	{r7}
   15752:	4770      	bx	lr

00015754 <uarte_nrfx_irq_callback_set>:
{
   15754:	b580      	push	{r7, lr}
   15756:	b086      	sub	sp, #24
   15758:	af00      	add	r7, sp, #0
   1575a:	60f8      	str	r0, [r7, #12]
   1575c:	60b9      	str	r1, [r7, #8]
   1575e:	607a      	str	r2, [r7, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   15760:	68f8      	ldr	r0, [r7, #12]
   15762:	f7fe fee9 	bl	14538 <get_dev_data>
   15766:	6178      	str	r0, [r7, #20]
	data->int_driven->cb = cb;
   15768:	697b      	ldr	r3, [r7, #20]
   1576a:	68db      	ldr	r3, [r3, #12]
   1576c:	68ba      	ldr	r2, [r7, #8]
   1576e:	601a      	str	r2, [r3, #0]
	data->int_driven->cb_data = cb_data;
   15770:	697b      	ldr	r3, [r7, #20]
   15772:	68db      	ldr	r3, [r3, #12]
   15774:	687a      	ldr	r2, [r7, #4]
   15776:	605a      	str	r2, [r3, #4]
}
   15778:	bf00      	nop
   1577a:	3718      	adds	r7, #24
   1577c:	46bd      	mov	sp, r7
   1577e:	bd80      	pop	{r7, pc}

00015780 <uarte_instance_init>:
{
   15780:	b580      	push	{r7, lr}
   15782:	b088      	sub	sp, #32
   15784:	af00      	add	r7, sp, #0
   15786:	60f8      	str	r0, [r7, #12]
   15788:	60b9      	str	r1, [r7, #8]
   1578a:	4613      	mov	r3, r2
   1578c:	71fb      	strb	r3, [r7, #7]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
   1578e:	68f8      	ldr	r0, [r7, #12]
   15790:	f7fe fee8 	bl	14564 <get_uarte_instance>
   15794:	61f8      	str	r0, [r7, #28]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   15796:	68f8      	ldr	r0, [r7, #12]
   15798:	f7fe fece 	bl	14538 <get_dev_data>
   1579c:	61b8      	str	r0, [r7, #24]
	nrf_uarte_disable(uarte);
   1579e:	69f8      	ldr	r0, [r7, #28]
   157a0:	f7fe fdd1 	bl	14346 <nrf_uarte_disable>
	data->dev = dev;
   157a4:	69bb      	ldr	r3, [r7, #24]
   157a6:	68fa      	ldr	r2, [r7, #12]
   157a8:	601a      	str	r2, [r3, #0]
	nrf_gpio_pin_write(config->pseltxd, 1);
   157aa:	68bb      	ldr	r3, [r7, #8]
   157ac:	681b      	ldr	r3, [r3, #0]
   157ae:	2101      	movs	r1, #1
   157b0:	4618      	mov	r0, r3
   157b2:	f7fe fca9 	bl	14108 <nrf_gpio_pin_write>
	nrf_gpio_cfg_output(config->pseltxd);
   157b6:	68bb      	ldr	r3, [r7, #8]
   157b8:	681b      	ldr	r3, [r3, #0]
   157ba:	4618      	mov	r0, r3
   157bc:	f7fe fc54 	bl	14068 <nrf_gpio_cfg_output>
	if (config->pselrxd !=  NRF_UARTE_PSEL_DISCONNECTED) {
   157c0:	68bb      	ldr	r3, [r7, #8]
   157c2:	685b      	ldr	r3, [r3, #4]
   157c4:	f1b3 3fff 	cmp.w	r3, #4294967295
   157c8:	d005      	beq.n	157d6 <uarte_instance_init+0x56>
		nrf_gpio_cfg_input(config->pselrxd, NRF_GPIO_PIN_NOPULL);
   157ca:	68bb      	ldr	r3, [r7, #8]
   157cc:	685b      	ldr	r3, [r3, #4]
   157ce:	2100      	movs	r1, #0
   157d0:	4618      	mov	r0, r3
   157d2:	f7fe fc5b 	bl	1408c <nrf_gpio_cfg_input>
	nrf_uarte_txrx_pins_set(uarte, config->pseltxd, config->pselrxd);
   157d6:	68bb      	ldr	r3, [r7, #8]
   157d8:	6819      	ldr	r1, [r3, #0]
   157da:	68bb      	ldr	r3, [r7, #8]
   157dc:	685b      	ldr	r3, [r3, #4]
   157de:	461a      	mov	r2, r3
   157e0:	69f8      	ldr	r0, [r7, #28]
   157e2:	f7fe fdbd 	bl	14360 <nrf_uarte_txrx_pins_set>
	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED) {
   157e6:	68bb      	ldr	r3, [r7, #8]
   157e8:	689b      	ldr	r3, [r3, #8]
   157ea:	f1b3 3fff 	cmp.w	r3, #4294967295
   157ee:	d005      	beq.n	157fc <uarte_instance_init+0x7c>
		nrf_gpio_cfg_input(config->pselcts, NRF_GPIO_PIN_NOPULL);
   157f0:	68bb      	ldr	r3, [r7, #8]
   157f2:	689b      	ldr	r3, [r3, #8]
   157f4:	2100      	movs	r1, #0
   157f6:	4618      	mov	r0, r3
   157f8:	f7fe fc48 	bl	1408c <nrf_gpio_cfg_input>
	if (config->pselrts != NRF_UARTE_PSEL_DISCONNECTED) {
   157fc:	68bb      	ldr	r3, [r7, #8]
   157fe:	68db      	ldr	r3, [r3, #12]
   15800:	f1b3 3fff 	cmp.w	r3, #4294967295
   15804:	d00a      	beq.n	1581c <uarte_instance_init+0x9c>
		nrf_gpio_pin_write(config->pselrts, 1);
   15806:	68bb      	ldr	r3, [r7, #8]
   15808:	68db      	ldr	r3, [r3, #12]
   1580a:	2101      	movs	r1, #1
   1580c:	4618      	mov	r0, r3
   1580e:	f7fe fc7b 	bl	14108 <nrf_gpio_pin_write>
		nrf_gpio_cfg_output(config->pselrts);
   15812:	68bb      	ldr	r3, [r7, #8]
   15814:	68db      	ldr	r3, [r3, #12]
   15816:	4618      	mov	r0, r3
   15818:	f7fe fc26 	bl	14068 <nrf_gpio_cfg_output>
	nrf_uarte_hwfc_pins_set(uarte, config->pselrts, config->pselcts);
   1581c:	68bb      	ldr	r3, [r7, #8]
   1581e:	68d9      	ldr	r1, [r3, #12]
   15820:	68bb      	ldr	r3, [r7, #8]
   15822:	689b      	ldr	r3, [r3, #8]
   15824:	461a      	mov	r2, r3
   15826:	69f8      	ldr	r0, [r7, #28]
   15828:	f7fe fdb9 	bl	1439e <nrf_uarte_hwfc_pins_set>
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1582c:	68f8      	ldr	r0, [r7, #12]
   1582e:	f7fe fe83 	bl	14538 <get_dev_data>
   15832:	4603      	mov	r3, r0
   15834:	3304      	adds	r3, #4
   15836:	4619      	mov	r1, r3
   15838:	68f8      	ldr	r0, [r7, #12]
   1583a:	f7fe ff33 	bl	146a4 <uarte_nrfx_configure>
   1583e:	6178      	str	r0, [r7, #20]
	if (err) {
   15840:	697b      	ldr	r3, [r7, #20]
   15842:	2b00      	cmp	r3, #0
   15844:	d001      	beq.n	1584a <uarte_instance_init+0xca>
		return err;
   15846:	697b      	ldr	r3, [r7, #20]
   15848:	e054      	b.n	158f4 <uarte_instance_init+0x174>
	if (get_dev_config(dev)->ppi_endtx) {
   1584a:	68f8      	ldr	r0, [r7, #12]
   1584c:	f7fe fe7f 	bl	1454e <get_dev_config>
   15850:	4603      	mov	r3, r0
   15852:	799b      	ldrb	r3, [r3, #6]
   15854:	2b00      	cmp	r3, #0
   15856:	d009      	beq.n	1586c <uarte_instance_init+0xec>
		err = endtx_stoptx_ppi_init(uarte, data);
   15858:	69b9      	ldr	r1, [r7, #24]
   1585a:	69f8      	ldr	r0, [r7, #28]
   1585c:	f7f2 f9a8 	bl	7bb0 <endtx_stoptx_ppi_init>
   15860:	6178      	str	r0, [r7, #20]
		if (err < 0) {
   15862:	697b      	ldr	r3, [r7, #20]
   15864:	2b00      	cmp	r3, #0
   15866:	da01      	bge.n	1586c <uarte_instance_init+0xec>
			return err;
   15868:	697b      	ldr	r3, [r7, #20]
   1586a:	e043      	b.n	158f4 <uarte_instance_init+0x174>
	if (data->async) {
   1586c:	69bb      	ldr	r3, [r7, #24]
   1586e:	691b      	ldr	r3, [r3, #16]
   15870:	2b00      	cmp	r3, #0
   15872:	d008      	beq.n	15886 <uarte_instance_init+0x106>
		err = uarte_nrfx_init(dev);
   15874:	68f8      	ldr	r0, [r7, #12]
   15876:	f7f2 f86d 	bl	7954 <uarte_nrfx_init>
   1587a:	6178      	str	r0, [r7, #20]
		if (err < 0) {
   1587c:	697b      	ldr	r3, [r7, #20]
   1587e:	2b00      	cmp	r3, #0
   15880:	da19      	bge.n	158b6 <uarte_instance_init+0x136>
			return err;
   15882:	697b      	ldr	r3, [r7, #20]
   15884:	e036      	b.n	158f4 <uarte_instance_init+0x174>
		nrf_uarte_enable(uarte);
   15886:	69f8      	ldr	r0, [r7, #28]
   15888:	f7fe fd50 	bl	1432c <nrf_uarte_enable>
		if (config->pselrxd != NRF_UARTE_PSEL_DISCONNECTED) {
   1588c:	68bb      	ldr	r3, [r7, #8]
   1588e:	685b      	ldr	r3, [r3, #4]
   15890:	f1b3 3fff 	cmp.w	r3, #4294967295
   15894:	d00f      	beq.n	158b6 <uarte_instance_init+0x136>
			nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);
   15896:	f44f 7188 	mov.w	r1, #272	; 0x110
   1589a:	69f8      	ldr	r0, [r7, #28]
   1589c:	f7fe fc98 	bl	141d0 <nrf_uarte_event_clear>
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   158a0:	69bb      	ldr	r3, [r7, #24]
   158a2:	3315      	adds	r3, #21
   158a4:	2201      	movs	r2, #1
   158a6:	4619      	mov	r1, r3
   158a8:	69f8      	ldr	r0, [r7, #28]
   158aa:	f7fe fdee 	bl	1448a <nrf_uarte_rx_buffer_set>
			nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
   158ae:	2100      	movs	r1, #0
   158b0:	69f8      	ldr	r0, [r7, #28]
   158b2:	f7fe fd87 	bl	143c4 <nrf_uarte_task_trigger>
	if (!get_dev_config(dev)->ppi_endtx) {
   158b6:	68f8      	ldr	r0, [r7, #12]
   158b8:	f7fe fe49 	bl	1454e <get_dev_config>
   158bc:	4603      	mov	r3, r0
   158be:	799b      	ldrb	r3, [r3, #6]
   158c0:	f083 0301 	eor.w	r3, r3, #1
   158c4:	b2db      	uxtb	r3, r3
   158c6:	2b00      	cmp	r3, #0
   158c8:	d004      	beq.n	158d4 <uarte_instance_init+0x154>
		nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ENDTX_MASK);
   158ca:	f44f 7180 	mov.w	r1, #256	; 0x100
   158ce:	69f8      	ldr	r0, [r7, #28]
   158d0:	f7fe fcda 	bl	14288 <nrf_uarte_int_enable>
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   158d4:	69bb      	ldr	r3, [r7, #24]
   158d6:	3314      	adds	r3, #20
   158d8:	2200      	movs	r2, #0
   158da:	4619      	mov	r1, r3
   158dc:	69f8      	ldr	r0, [r7, #28]
   158de:	f7fe fdb5 	bl	1444c <nrf_uarte_tx_buffer_set>
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTTX);
   158e2:	2108      	movs	r1, #8
   158e4:	69f8      	ldr	r0, [r7, #28]
   158e6:	f7fe fd6d 	bl	143c4 <nrf_uarte_task_trigger>
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
   158ea:	210c      	movs	r1, #12
   158ec:	69f8      	ldr	r0, [r7, #28]
   158ee:	f7fe fd69 	bl	143c4 <nrf_uarte_task_trigger>
	return 0;
   158f2:	2300      	movs	r3, #0
}
   158f4:	4618      	mov	r0, r3
   158f6:	3720      	adds	r7, #32
   158f8:	46bd      	mov	sp, r7
   158fa:	bd80      	pop	{r7, pc}

000158fc <_is_user_context>:
{
   158fc:	b480      	push	{r7}
   158fe:	af00      	add	r7, sp, #0
	return false;
   15900:	2300      	movs	r3, #0
}
   15902:	4618      	mov	r0, r3
   15904:	46bd      	mov	sp, r7
   15906:	bc80      	pop	{r7}
   15908:	4770      	bx	lr

0001590a <atomic_cas>:
{
   1590a:	b490      	push	{r4, r7}
   1590c:	b084      	sub	sp, #16
   1590e:	af00      	add	r7, sp, #0
   15910:	60f8      	str	r0, [r7, #12]
   15912:	60b9      	str	r1, [r7, #8]
   15914:	607a      	str	r2, [r7, #4]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   15916:	687c      	ldr	r4, [r7, #4]
   15918:	68fa      	ldr	r2, [r7, #12]
   1591a:	f107 0308 	add.w	r3, r7, #8
   1591e:	6818      	ldr	r0, [r3, #0]
   15920:	e8d2 1fef 	ldaex	r1, [r2]
   15924:	4281      	cmp	r1, r0
   15926:	d106      	bne.n	15936 <atomic_cas+0x2c>
   15928:	e8c2 4fec 	stlex	ip, r4, [r2]
   1592c:	f1bc 0f00 	cmp.w	ip, #0
   15930:	f1bc 0f00 	cmp.w	ip, #0
   15934:	d1f4      	bne.n	15920 <atomic_cas+0x16>
   15936:	bf0c      	ite	eq
   15938:	2201      	moveq	r2, #1
   1593a:	2200      	movne	r2, #0
   1593c:	2a00      	cmp	r2, #0
   1593e:	d100      	bne.n	15942 <atomic_cas+0x38>
   15940:	6019      	str	r1, [r3, #0]
   15942:	4613      	mov	r3, r2
}
   15944:	4618      	mov	r0, r3
   15946:	3710      	adds	r7, #16
   15948:	46bd      	mov	sp, r7
   1594a:	bc90      	pop	{r4, r7}
   1594c:	4770      	bx	lr

0001594e <atomic_ptr_cas>:
{
   1594e:	b490      	push	{r4, r7}
   15950:	b084      	sub	sp, #16
   15952:	af00      	add	r7, sp, #0
   15954:	60f8      	str	r0, [r7, #12]
   15956:	60b9      	str	r1, [r7, #8]
   15958:	607a      	str	r2, [r7, #4]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1595a:	687c      	ldr	r4, [r7, #4]
   1595c:	68fa      	ldr	r2, [r7, #12]
   1595e:	f107 0308 	add.w	r3, r7, #8
   15962:	6818      	ldr	r0, [r3, #0]
   15964:	e8d2 1fef 	ldaex	r1, [r2]
   15968:	4281      	cmp	r1, r0
   1596a:	d106      	bne.n	1597a <atomic_ptr_cas+0x2c>
   1596c:	e8c2 4fec 	stlex	ip, r4, [r2]
   15970:	f1bc 0f00 	cmp.w	ip, #0
   15974:	f1bc 0f00 	cmp.w	ip, #0
   15978:	d1f4      	bne.n	15964 <atomic_ptr_cas+0x16>
   1597a:	bf0c      	ite	eq
   1597c:	2201      	moveq	r2, #1
   1597e:	2200      	movne	r2, #0
   15980:	2a00      	cmp	r2, #0
   15982:	d100      	bne.n	15986 <atomic_ptr_cas+0x38>
   15984:	6019      	str	r1, [r3, #0]
   15986:	4613      	mov	r3, r2
}
   15988:	4618      	mov	r0, r3
   1598a:	3710      	adds	r7, #16
   1598c:	46bd      	mov	sp, r7
   1598e:	bc90      	pop	{r4, r7}
   15990:	4770      	bx	lr

00015992 <nrf_event_readback>:
{
   15992:	b480      	push	{r7}
   15994:	b083      	sub	sp, #12
   15996:	af00      	add	r7, sp, #0
   15998:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   1599a:	687b      	ldr	r3, [r7, #4]
   1599c:	681b      	ldr	r3, [r3, #0]
}
   1599e:	bf00      	nop
   159a0:	370c      	adds	r7, #12
   159a2:	46bd      	mov	sp, r7
   159a4:	bc80      	pop	{r7}
   159a6:	4770      	bx	lr

000159a8 <k_ms_to_ticks_ceil64>:
{
   159a8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   159ac:	b08c      	sub	sp, #48	; 0x30
   159ae:	af00      	add	r7, sp, #0
   159b0:	e9c7 0100 	strd	r0, r1, [r7]
   159b4:	e9d7 2300 	ldrd	r2, r3, [r7]
   159b8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   159bc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   159c0:	627b      	str	r3, [r7, #36]	; 0x24
   159c2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   159c6:	623b      	str	r3, [r7, #32]
   159c8:	2301      	movs	r3, #1
   159ca:	77fb      	strb	r3, [r7, #31]
   159cc:	2300      	movs	r3, #0
   159ce:	77bb      	strb	r3, [r7, #30]
   159d0:	2301      	movs	r3, #1
   159d2:	777b      	strb	r3, [r7, #29]
   159d4:	2300      	movs	r3, #0
   159d6:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   159d8:	7ffb      	ldrb	r3, [r7, #31]
   159da:	2b00      	cmp	r3, #0
   159dc:	d00f      	beq.n	159fe <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   159de:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   159e0:	6a3b      	ldr	r3, [r7, #32]
   159e2:	429a      	cmp	r2, r3
   159e4:	d20b      	bcs.n	159fe <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   159e6:	6a3b      	ldr	r3, [r7, #32]
   159e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   159ea:	fbb3 f2f2 	udiv	r2, r3, r2
   159ee:	6a79      	ldr	r1, [r7, #36]	; 0x24
   159f0:	fb01 f202 	mul.w	r2, r1, r2
   159f4:	1a9b      	subs	r3, r3, r2
   159f6:	2b00      	cmp	r3, #0
   159f8:	d101      	bne.n	159fe <k_ms_to_ticks_ceil64+0x56>
   159fa:	2301      	movs	r3, #1
   159fc:	e000      	b.n	15a00 <k_ms_to_ticks_ceil64+0x58>
   159fe:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   15a00:	76fb      	strb	r3, [r7, #27]
   15a02:	7efb      	ldrb	r3, [r7, #27]
   15a04:	f003 0301 	and.w	r3, r3, #1
   15a08:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   15a0a:	7ffb      	ldrb	r3, [r7, #31]
   15a0c:	2b00      	cmp	r3, #0
   15a0e:	d00f      	beq.n	15a30 <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   15a10:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15a12:	6a3b      	ldr	r3, [r7, #32]
   15a14:	429a      	cmp	r2, r3
   15a16:	d90b      	bls.n	15a30 <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   15a18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15a1a:	6a3a      	ldr	r2, [r7, #32]
   15a1c:	fbb3 f2f2 	udiv	r2, r3, r2
   15a20:	6a39      	ldr	r1, [r7, #32]
   15a22:	fb01 f202 	mul.w	r2, r1, r2
   15a26:	1a9b      	subs	r3, r3, r2
   15a28:	2b00      	cmp	r3, #0
   15a2a:	d101      	bne.n	15a30 <k_ms_to_ticks_ceil64+0x88>
   15a2c:	2301      	movs	r3, #1
   15a2e:	e000      	b.n	15a32 <k_ms_to_ticks_ceil64+0x8a>
   15a30:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   15a32:	76bb      	strb	r3, [r7, #26]
   15a34:	7ebb      	ldrb	r3, [r7, #26]
   15a36:	f003 0301 	and.w	r3, r3, #1
   15a3a:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   15a3c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15a3e:	6a3b      	ldr	r3, [r7, #32]
   15a40:	429a      	cmp	r2, r3
   15a42:	d10a      	bne.n	15a5a <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   15a44:	7fbb      	ldrb	r3, [r7, #30]
   15a46:	2b00      	cmp	r3, #0
   15a48:	d004      	beq.n	15a54 <k_ms_to_ticks_ceil64+0xac>
   15a4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   15a4c:	461a      	mov	r2, r3
   15a4e:	f04f 0300 	mov.w	r3, #0
   15a52:	e0c8      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
   15a54:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   15a58:	e0c5      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   15a5a:	f04f 0200 	mov.w	r2, #0
   15a5e:	f04f 0300 	mov.w	r3, #0
   15a62:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   15a66:	7efb      	ldrb	r3, [r7, #27]
   15a68:	f083 0301 	eor.w	r3, r3, #1
   15a6c:	b2db      	uxtb	r3, r3
   15a6e:	2b00      	cmp	r3, #0
   15a70:	d01e      	beq.n	15ab0 <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   15a72:	7ebb      	ldrb	r3, [r7, #26]
   15a74:	2b00      	cmp	r3, #0
   15a76:	d004      	beq.n	15a82 <k_ms_to_ticks_ceil64+0xda>
   15a78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15a7a:	6a3b      	ldr	r3, [r7, #32]
   15a7c:	fbb2 f3f3 	udiv	r3, r2, r3
   15a80:	e000      	b.n	15a84 <k_ms_to_ticks_ceil64+0xdc>
   15a82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15a84:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   15a86:	7f7b      	ldrb	r3, [r7, #29]
   15a88:	2b00      	cmp	r3, #0
   15a8a:	d007      	beq.n	15a9c <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   15a8c:	68fb      	ldr	r3, [r7, #12]
   15a8e:	3b01      	subs	r3, #1
   15a90:	461a      	mov	r2, r3
   15a92:	f04f 0300 	mov.w	r3, #0
   15a96:	e9c7 2304 	strd	r2, r3, [r7, #16]
   15a9a:	e009      	b.n	15ab0 <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   15a9c:	7f3b      	ldrb	r3, [r7, #28]
   15a9e:	2b00      	cmp	r3, #0
   15aa0:	d006      	beq.n	15ab0 <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   15aa2:	68fb      	ldr	r3, [r7, #12]
   15aa4:	085b      	lsrs	r3, r3, #1
   15aa6:	461a      	mov	r2, r3
   15aa8:	f04f 0300 	mov.w	r3, #0
   15aac:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   15ab0:	7ebb      	ldrb	r3, [r7, #26]
   15ab2:	2b00      	cmp	r3, #0
   15ab4:	d02a      	beq.n	15b0c <k_ms_to_ticks_ceil64+0x164>
		t += off;
   15ab6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   15aba:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   15abe:	1884      	adds	r4, r0, r2
   15ac0:	eb41 0503 	adc.w	r5, r1, r3
   15ac4:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   15ac8:	7fbb      	ldrb	r3, [r7, #30]
   15aca:	2b00      	cmp	r3, #0
   15acc:	d010      	beq.n	15af0 <k_ms_to_ticks_ceil64+0x148>
   15ace:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   15ad2:	2b01      	cmp	r3, #1
   15ad4:	bf08      	it	eq
   15ad6:	2a00      	cmpeq	r2, #0
   15ad8:	d20a      	bcs.n	15af0 <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   15ada:	6aba      	ldr	r2, [r7, #40]	; 0x28
   15adc:	6a79      	ldr	r1, [r7, #36]	; 0x24
   15ade:	6a3b      	ldr	r3, [r7, #32]
   15ae0:	fbb1 f3f3 	udiv	r3, r1, r3
   15ae4:	fbb2 f3f3 	udiv	r3, r2, r3
   15ae8:	461a      	mov	r2, r3
   15aea:	f04f 0300 	mov.w	r3, #0
   15aee:	e07a      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   15af0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15af2:	6a3b      	ldr	r3, [r7, #32]
   15af4:	fbb2 f3f3 	udiv	r3, r2, r3
   15af8:	461a      	mov	r2, r3
   15afa:	f04f 0300 	mov.w	r3, #0
   15afe:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   15b02:	f7ea fb1f 	bl	144 <__aeabi_uldivmod>
   15b06:	4602      	mov	r2, r0
   15b08:	460b      	mov	r3, r1
   15b0a:	e06c      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   15b0c:	7efb      	ldrb	r3, [r7, #27]
   15b0e:	2b00      	cmp	r3, #0
   15b10:	d021      	beq.n	15b56 <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   15b12:	7fbb      	ldrb	r3, [r7, #30]
   15b14:	2b00      	cmp	r3, #0
   15b16:	d00a      	beq.n	15b2e <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   15b18:	6abb      	ldr	r3, [r7, #40]	; 0x28
   15b1a:	6a39      	ldr	r1, [r7, #32]
   15b1c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   15b1e:	fbb1 f2f2 	udiv	r2, r1, r2
   15b22:	fb02 f303 	mul.w	r3, r2, r3
   15b26:	461a      	mov	r2, r3
   15b28:	f04f 0300 	mov.w	r3, #0
   15b2c:	e05b      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   15b2e:	6a3a      	ldr	r2, [r7, #32]
   15b30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15b32:	fbb2 f3f3 	udiv	r3, r2, r3
   15b36:	461a      	mov	r2, r3
   15b38:	f04f 0300 	mov.w	r3, #0
   15b3c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   15b3e:	fb03 f001 	mul.w	r0, r3, r1
   15b42:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   15b44:	fb02 f101 	mul.w	r1, r2, r1
   15b48:	4401      	add	r1, r0
   15b4a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15b4c:	fba0 2302 	umull	r2, r3, r0, r2
   15b50:	4419      	add	r1, r3
   15b52:	460b      	mov	r3, r1
   15b54:	e047      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   15b56:	7fbb      	ldrb	r3, [r7, #30]
   15b58:	2b00      	cmp	r3, #0
   15b5a:	d024      	beq.n	15ba6 <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   15b5c:	6a3b      	ldr	r3, [r7, #32]
   15b5e:	461a      	mov	r2, r3
   15b60:	f04f 0300 	mov.w	r3, #0
   15b64:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   15b66:	fb03 f001 	mul.w	r0, r3, r1
   15b6a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   15b6c:	fb02 f101 	mul.w	r1, r2, r1
   15b70:	4401      	add	r1, r0
   15b72:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15b74:	fba0 2302 	umull	r2, r3, r0, r2
   15b78:	4419      	add	r1, r3
   15b7a:	460b      	mov	r3, r1
   15b7c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   15b80:	eb12 0a00 	adds.w	sl, r2, r0
   15b84:	eb43 0b01 	adc.w	fp, r3, r1
   15b88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15b8a:	461a      	mov	r2, r3
   15b8c:	f04f 0300 	mov.w	r3, #0
   15b90:	4650      	mov	r0, sl
   15b92:	4659      	mov	r1, fp
   15b94:	f7ea fad6 	bl	144 <__aeabi_uldivmod>
   15b98:	4602      	mov	r2, r0
   15b9a:	460b      	mov	r3, r1
   15b9c:	4613      	mov	r3, r2
   15b9e:	461a      	mov	r2, r3
   15ba0:	f04f 0300 	mov.w	r3, #0
   15ba4:	e01f      	b.n	15be6 <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   15ba6:	6a3b      	ldr	r3, [r7, #32]
   15ba8:	461a      	mov	r2, r3
   15baa:	f04f 0300 	mov.w	r3, #0
   15bae:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   15bb0:	fb03 f001 	mul.w	r0, r3, r1
   15bb4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   15bb6:	fb02 f101 	mul.w	r1, r2, r1
   15bba:	4401      	add	r1, r0
   15bbc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15bbe:	fba0 2302 	umull	r2, r3, r0, r2
   15bc2:	4419      	add	r1, r3
   15bc4:	460b      	mov	r3, r1
   15bc6:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   15bca:	eb12 0800 	adds.w	r8, r2, r0
   15bce:	eb43 0901 	adc.w	r9, r3, r1
   15bd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15bd4:	461a      	mov	r2, r3
   15bd6:	f04f 0300 	mov.w	r3, #0
   15bda:	4640      	mov	r0, r8
   15bdc:	4649      	mov	r1, r9
   15bde:	f7ea fab1 	bl	144 <__aeabi_uldivmod>
   15be2:	4602      	mov	r2, r0
   15be4:	460b      	mov	r3, r1
}
   15be6:	4610      	mov	r0, r2
   15be8:	4619      	mov	r1, r3
   15bea:	3730      	adds	r7, #48	; 0x30
   15bec:	46bd      	mov	sp, r7
   15bee:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

00015bf2 <k_msleep>:
{
   15bf2:	b580      	push	{r7, lr}
   15bf4:	b082      	sub	sp, #8
   15bf6:	af00      	add	r7, sp, #0
   15bf8:	6078      	str	r0, [r7, #4]
	return k_sleep(Z_TIMEOUT_MS(ms));
   15bfa:	687b      	ldr	r3, [r7, #4]
   15bfc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   15c00:	461a      	mov	r2, r3
   15c02:	ea4f 73e2 	mov.w	r3, r2, asr #31
   15c06:	4610      	mov	r0, r2
   15c08:	4619      	mov	r1, r3
   15c0a:	f7ff fecd 	bl	159a8 <k_ms_to_ticks_ceil64>
   15c0e:	4602      	mov	r2, r0
   15c10:	460b      	mov	r3, r1
   15c12:	4610      	mov	r0, r2
   15c14:	4619      	mov	r1, r3
   15c16:	f000 f81e 	bl	15c56 <k_sleep>
   15c1a:	4601      	mov	r1, r0
   15c1c:	460b      	mov	r3, r1
}
   15c1e:	4618      	mov	r0, r3
   15c20:	3708      	adds	r7, #8
   15c22:	46bd      	mov	sp, r7
   15c24:	bd80      	pop	{r7, pc}

00015c26 <z_impl_k_timer_user_data_set>:
{
   15c26:	b480      	push	{r7}
   15c28:	b083      	sub	sp, #12
   15c2a:	af00      	add	r7, sp, #0
   15c2c:	6078      	str	r0, [r7, #4]
   15c2e:	6039      	str	r1, [r7, #0]
	timer->user_data = user_data;
   15c30:	687b      	ldr	r3, [r7, #4]
   15c32:	683a      	ldr	r2, [r7, #0]
   15c34:	635a      	str	r2, [r3, #52]	; 0x34
}
   15c36:	bf00      	nop
   15c38:	370c      	adds	r7, #12
   15c3a:	46bd      	mov	sp, r7
   15c3c:	bc80      	pop	{r7}
   15c3e:	4770      	bx	lr

00015c40 <z_impl_k_timer_user_data_get>:
{
   15c40:	b480      	push	{r7}
   15c42:	b083      	sub	sp, #12
   15c44:	af00      	add	r7, sp, #0
   15c46:	6078      	str	r0, [r7, #4]
	return timer->user_data;
   15c48:	687b      	ldr	r3, [r7, #4]
   15c4a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
   15c4c:	4618      	mov	r0, r3
   15c4e:	370c      	adds	r7, #12
   15c50:	46bd      	mov	sp, r7
   15c52:	bc80      	pop	{r7}
   15c54:	4770      	bx	lr

00015c56 <k_sleep>:
{
   15c56:	b580      	push	{r7, lr}
   15c58:	b082      	sub	sp, #8
   15c5a:	af00      	add	r7, sp, #0
   15c5c:	e9c7 0100 	strd	r0, r1, [r7]
	return z_impl_k_sleep(timeout);
   15c60:	e9d7 0100 	ldrd	r0, r1, [r7]
   15c64:	f7f8 fb16 	bl	e294 <z_impl_k_sleep>
   15c68:	4603      	mov	r3, r0
}
   15c6a:	4618      	mov	r0, r3
   15c6c:	3708      	adds	r7, #8
   15c6e:	46bd      	mov	sp, r7
   15c70:	bd80      	pop	{r7, pc}

00015c72 <k_timer_start>:
{
   15c72:	b580      	push	{r7, lr}
   15c74:	b086      	sub	sp, #24
   15c76:	af02      	add	r7, sp, #8
   15c78:	60f8      	str	r0, [r7, #12]
   15c7a:	e9c7 2300 	strd	r2, r3, [r7]
	z_impl_k_timer_start(timer, duration, period);
   15c7e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
   15c82:	e9cd 2300 	strd	r2, r3, [sp]
   15c86:	e9d7 2300 	ldrd	r2, r3, [r7]
   15c8a:	68f8      	ldr	r0, [r7, #12]
   15c8c:	f7f9 fd1a 	bl	f6c4 <z_impl_k_timer_start>
}
   15c90:	bf00      	nop
   15c92:	3710      	adds	r7, #16
   15c94:	46bd      	mov	sp, r7
   15c96:	bd80      	pop	{r7, pc}

00015c98 <k_timer_stop>:
{
   15c98:	b580      	push	{r7, lr}
   15c9a:	b082      	sub	sp, #8
   15c9c:	af00      	add	r7, sp, #0
   15c9e:	6078      	str	r0, [r7, #4]
	z_impl_k_timer_stop(timer);
   15ca0:	6878      	ldr	r0, [r7, #4]
   15ca2:	f002 fbd2 	bl	1844a <z_impl_k_timer_stop>
}
   15ca6:	bf00      	nop
   15ca8:	3708      	adds	r7, #8
   15caa:	46bd      	mov	sp, r7
   15cac:	bd80      	pop	{r7, pc}

00015cae <k_timer_user_data_set>:
{
   15cae:	b580      	push	{r7, lr}
   15cb0:	b082      	sub	sp, #8
   15cb2:	af00      	add	r7, sp, #0
   15cb4:	6078      	str	r0, [r7, #4]
   15cb6:	6039      	str	r1, [r7, #0]
	z_impl_k_timer_user_data_set(timer, user_data);
   15cb8:	6839      	ldr	r1, [r7, #0]
   15cba:	6878      	ldr	r0, [r7, #4]
   15cbc:	f7ff ffb3 	bl	15c26 <z_impl_k_timer_user_data_set>
}
   15cc0:	bf00      	nop
   15cc2:	3708      	adds	r7, #8
   15cc4:	46bd      	mov	sp, r7
   15cc6:	bd80      	pop	{r7, pc}

00015cc8 <k_timer_user_data_get>:
{
   15cc8:	b580      	push	{r7, lr}
   15cca:	b082      	sub	sp, #8
   15ccc:	af00      	add	r7, sp, #0
   15cce:	6078      	str	r0, [r7, #4]
	return z_impl_k_timer_user_data_get(timer);
   15cd0:	6878      	ldr	r0, [r7, #4]
   15cd2:	f7ff ffb5 	bl	15c40 <z_impl_k_timer_user_data_get>
   15cd6:	4603      	mov	r3, r0
}
   15cd8:	4618      	mov	r0, r3
   15cda:	3708      	adds	r7, #8
   15cdc:	46bd      	mov	sp, r7
   15cde:	bd80      	pop	{r7, pc}

00015ce0 <device_get_binding>:
{
   15ce0:	b580      	push	{r7, lr}
   15ce2:	b082      	sub	sp, #8
   15ce4:	af00      	add	r7, sp, #0
   15ce6:	6078      	str	r0, [r7, #4]
	return z_impl_device_get_binding(name);
   15ce8:	6878      	ldr	r0, [r7, #4]
   15cea:	f7f4 ff01 	bl	aaf0 <z_impl_device_get_binding>
   15cee:	4603      	mov	r3, r0
}
   15cf0:	4618      	mov	r0, r3
   15cf2:	3708      	adds	r7, #8
   15cf4:	46bd      	mov	sp, r7
   15cf6:	bd80      	pop	{r7, pc}

00015cf8 <uart_callback_set>:
{
   15cf8:	b580      	push	{r7, lr}
   15cfa:	b086      	sub	sp, #24
   15cfc:	af00      	add	r7, sp, #0
   15cfe:	60f8      	str	r0, [r7, #12]
   15d00:	60b9      	str	r1, [r7, #8]
   15d02:	607a      	str	r2, [r7, #4]
	const struct uart_driver_api *api =
   15d04:	68fb      	ldr	r3, [r7, #12]
   15d06:	689b      	ldr	r3, [r3, #8]
   15d08:	617b      	str	r3, [r7, #20]
	return api->callback_set(dev, callback, user_data);
   15d0a:	697b      	ldr	r3, [r7, #20]
   15d0c:	681b      	ldr	r3, [r3, #0]
   15d0e:	687a      	ldr	r2, [r7, #4]
   15d10:	68b9      	ldr	r1, [r7, #8]
   15d12:	68f8      	ldr	r0, [r7, #12]
   15d14:	4798      	blx	r3
   15d16:	4603      	mov	r3, r0
}
   15d18:	4618      	mov	r0, r3
   15d1a:	3718      	adds	r7, #24
   15d1c:	46bd      	mov	sp, r7
   15d1e:	bd80      	pop	{r7, pc}

00015d20 <z_impl_uart_tx>:
{
   15d20:	b590      	push	{r4, r7, lr}
   15d22:	b087      	sub	sp, #28
   15d24:	af00      	add	r7, sp, #0
   15d26:	60f8      	str	r0, [r7, #12]
   15d28:	60b9      	str	r1, [r7, #8]
   15d2a:	607a      	str	r2, [r7, #4]
   15d2c:	603b      	str	r3, [r7, #0]
	const struct uart_driver_api *api =
   15d2e:	68fb      	ldr	r3, [r7, #12]
   15d30:	689b      	ldr	r3, [r3, #8]
   15d32:	617b      	str	r3, [r7, #20]
	return api->tx(dev, buf, len, timeout);
   15d34:	697b      	ldr	r3, [r7, #20]
   15d36:	685c      	ldr	r4, [r3, #4]
   15d38:	683b      	ldr	r3, [r7, #0]
   15d3a:	687a      	ldr	r2, [r7, #4]
   15d3c:	68b9      	ldr	r1, [r7, #8]
   15d3e:	68f8      	ldr	r0, [r7, #12]
   15d40:	47a0      	blx	r4
   15d42:	4603      	mov	r3, r0
}
   15d44:	4618      	mov	r0, r3
   15d46:	371c      	adds	r7, #28
   15d48:	46bd      	mov	sp, r7
   15d4a:	bd90      	pop	{r4, r7, pc}

00015d4c <z_impl_uart_tx_abort>:
{
   15d4c:	b580      	push	{r7, lr}
   15d4e:	b084      	sub	sp, #16
   15d50:	af00      	add	r7, sp, #0
   15d52:	6078      	str	r0, [r7, #4]
	const struct uart_driver_api *api =
   15d54:	687b      	ldr	r3, [r7, #4]
   15d56:	689b      	ldr	r3, [r3, #8]
   15d58:	60fb      	str	r3, [r7, #12]
	return api->tx_abort(dev);
   15d5a:	68fb      	ldr	r3, [r7, #12]
   15d5c:	689b      	ldr	r3, [r3, #8]
   15d5e:	6878      	ldr	r0, [r7, #4]
   15d60:	4798      	blx	r3
   15d62:	4603      	mov	r3, r0
}
   15d64:	4618      	mov	r0, r3
   15d66:	3710      	adds	r7, #16
   15d68:	46bd      	mov	sp, r7
   15d6a:	bd80      	pop	{r7, pc}

00015d6c <z_impl_uart_rx_enable>:
{
   15d6c:	b590      	push	{r4, r7, lr}
   15d6e:	b087      	sub	sp, #28
   15d70:	af00      	add	r7, sp, #0
   15d72:	60f8      	str	r0, [r7, #12]
   15d74:	60b9      	str	r1, [r7, #8]
   15d76:	607a      	str	r2, [r7, #4]
   15d78:	603b      	str	r3, [r7, #0]
	const struct uart_driver_api *api =
   15d7a:	68fb      	ldr	r3, [r7, #12]
   15d7c:	689b      	ldr	r3, [r3, #8]
   15d7e:	617b      	str	r3, [r7, #20]
	return api->rx_enable(dev, buf, len, timeout);
   15d80:	697b      	ldr	r3, [r7, #20]
   15d82:	68dc      	ldr	r4, [r3, #12]
   15d84:	683b      	ldr	r3, [r7, #0]
   15d86:	687a      	ldr	r2, [r7, #4]
   15d88:	68b9      	ldr	r1, [r7, #8]
   15d8a:	68f8      	ldr	r0, [r7, #12]
   15d8c:	47a0      	blx	r4
   15d8e:	4603      	mov	r3, r0
}
   15d90:	4618      	mov	r0, r3
   15d92:	371c      	adds	r7, #28
   15d94:	46bd      	mov	sp, r7
   15d96:	bd90      	pop	{r4, r7, pc}

00015d98 <uart_rx_buf_rsp>:
{
   15d98:	b580      	push	{r7, lr}
   15d9a:	b086      	sub	sp, #24
   15d9c:	af00      	add	r7, sp, #0
   15d9e:	60f8      	str	r0, [r7, #12]
   15da0:	60b9      	str	r1, [r7, #8]
   15da2:	607a      	str	r2, [r7, #4]
	const struct uart_driver_api *api =
   15da4:	68fb      	ldr	r3, [r7, #12]
   15da6:	689b      	ldr	r3, [r3, #8]
   15da8:	617b      	str	r3, [r7, #20]
	return api->rx_buf_rsp(dev, buf, len);
   15daa:	697b      	ldr	r3, [r7, #20]
   15dac:	691b      	ldr	r3, [r3, #16]
   15dae:	687a      	ldr	r2, [r7, #4]
   15db0:	68b9      	ldr	r1, [r7, #8]
   15db2:	68f8      	ldr	r0, [r7, #12]
   15db4:	4798      	blx	r3
   15db6:	4603      	mov	r3, r0
}
   15db8:	4618      	mov	r0, r3
   15dba:	3718      	adds	r7, #24
   15dbc:	46bd      	mov	sp, r7
   15dbe:	bd80      	pop	{r7, pc}

00015dc0 <z_impl_uart_rx_disable>:
{
   15dc0:	b580      	push	{r7, lr}
   15dc2:	b084      	sub	sp, #16
   15dc4:	af00      	add	r7, sp, #0
   15dc6:	6078      	str	r0, [r7, #4]
	const struct uart_driver_api *api =
   15dc8:	687b      	ldr	r3, [r7, #4]
   15dca:	689b      	ldr	r3, [r3, #8]
   15dcc:	60fb      	str	r3, [r7, #12]
	return api->rx_disable(dev);
   15dce:	68fb      	ldr	r3, [r7, #12]
   15dd0:	695b      	ldr	r3, [r3, #20]
   15dd2:	6878      	ldr	r0, [r7, #4]
   15dd4:	4798      	blx	r3
   15dd6:	4603      	mov	r3, r0
}
   15dd8:	4618      	mov	r0, r3
   15dda:	3710      	adds	r7, #16
   15ddc:	46bd      	mov	sp, r7
   15dde:	bd80      	pop	{r7, pc}

00015de0 <z_impl_uart_configure>:
{
   15de0:	b580      	push	{r7, lr}
   15de2:	b084      	sub	sp, #16
   15de4:	af00      	add	r7, sp, #0
   15de6:	6078      	str	r0, [r7, #4]
   15de8:	6039      	str	r1, [r7, #0]
	const struct uart_driver_api *api =
   15dea:	687b      	ldr	r3, [r7, #4]
   15dec:	689b      	ldr	r3, [r3, #8]
   15dee:	60fb      	str	r3, [r7, #12]
	if (api->configure != NULL) {
   15df0:	68fb      	ldr	r3, [r7, #12]
   15df2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15df4:	2b00      	cmp	r3, #0
   15df6:	d006      	beq.n	15e06 <z_impl_uart_configure+0x26>
		return api->configure(dev, cfg);
   15df8:	68fb      	ldr	r3, [r7, #12]
   15dfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   15dfc:	6839      	ldr	r1, [r7, #0]
   15dfe:	6878      	ldr	r0, [r7, #4]
   15e00:	4798      	blx	r3
   15e02:	4603      	mov	r3, r0
   15e04:	e001      	b.n	15e0a <z_impl_uart_configure+0x2a>
	return -ENOTSUP;
   15e06:	f06f 0322 	mvn.w	r3, #34	; 0x22
}
   15e0a:	4618      	mov	r0, r3
   15e0c:	3710      	adds	r7, #16
   15e0e:	46bd      	mov	sp, r7
   15e10:	bd80      	pop	{r7, pc}

00015e12 <z_impl_uart_config_get>:
{
   15e12:	b580      	push	{r7, lr}
   15e14:	b084      	sub	sp, #16
   15e16:	af00      	add	r7, sp, #0
   15e18:	6078      	str	r0, [r7, #4]
   15e1a:	6039      	str	r1, [r7, #0]
	const struct uart_driver_api *api =
   15e1c:	687b      	ldr	r3, [r7, #4]
   15e1e:	689b      	ldr	r3, [r3, #8]
   15e20:	60fb      	str	r3, [r7, #12]
	if (api->config_get != NULL) {
   15e22:	68fb      	ldr	r3, [r7, #12]
   15e24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15e26:	2b00      	cmp	r3, #0
   15e28:	d006      	beq.n	15e38 <z_impl_uart_config_get+0x26>
		return api->config_get(dev, cfg);
   15e2a:	68fb      	ldr	r3, [r7, #12]
   15e2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15e2e:	6839      	ldr	r1, [r7, #0]
   15e30:	6878      	ldr	r0, [r7, #4]
   15e32:	4798      	blx	r3
   15e34:	4603      	mov	r3, r0
   15e36:	e001      	b.n	15e3c <z_impl_uart_config_get+0x2a>
	return -ENOTSUP;
   15e38:	f06f 0322 	mvn.w	r3, #34	; 0x22
}
   15e3c:	4618      	mov	r0, r3
   15e3e:	3710      	adds	r7, #16
   15e40:	46bd      	mov	sp, r7
   15e42:	bd80      	pop	{r7, pc}

00015e44 <uart_tx>:
{
   15e44:	b580      	push	{r7, lr}
   15e46:	b084      	sub	sp, #16
   15e48:	af00      	add	r7, sp, #0
   15e4a:	60f8      	str	r0, [r7, #12]
   15e4c:	60b9      	str	r1, [r7, #8]
   15e4e:	607a      	str	r2, [r7, #4]
   15e50:	603b      	str	r3, [r7, #0]
	return z_impl_uart_tx(dev, buf, len, timeout);
   15e52:	683b      	ldr	r3, [r7, #0]
   15e54:	687a      	ldr	r2, [r7, #4]
   15e56:	68b9      	ldr	r1, [r7, #8]
   15e58:	68f8      	ldr	r0, [r7, #12]
   15e5a:	f7ff ff61 	bl	15d20 <z_impl_uart_tx>
   15e5e:	4603      	mov	r3, r0
}
   15e60:	4618      	mov	r0, r3
   15e62:	3710      	adds	r7, #16
   15e64:	46bd      	mov	sp, r7
   15e66:	bd80      	pop	{r7, pc}

00015e68 <uart_tx_abort>:
{
   15e68:	b580      	push	{r7, lr}
   15e6a:	b082      	sub	sp, #8
   15e6c:	af00      	add	r7, sp, #0
   15e6e:	6078      	str	r0, [r7, #4]
	return z_impl_uart_tx_abort(dev);
   15e70:	6878      	ldr	r0, [r7, #4]
   15e72:	f7ff ff6b 	bl	15d4c <z_impl_uart_tx_abort>
   15e76:	4603      	mov	r3, r0
}
   15e78:	4618      	mov	r0, r3
   15e7a:	3708      	adds	r7, #8
   15e7c:	46bd      	mov	sp, r7
   15e7e:	bd80      	pop	{r7, pc}

00015e80 <uart_rx_enable>:
{
   15e80:	b580      	push	{r7, lr}
   15e82:	b084      	sub	sp, #16
   15e84:	af00      	add	r7, sp, #0
   15e86:	60f8      	str	r0, [r7, #12]
   15e88:	60b9      	str	r1, [r7, #8]
   15e8a:	607a      	str	r2, [r7, #4]
   15e8c:	603b      	str	r3, [r7, #0]
	return z_impl_uart_rx_enable(dev, buf, len, timeout);
   15e8e:	683b      	ldr	r3, [r7, #0]
   15e90:	687a      	ldr	r2, [r7, #4]
   15e92:	68b9      	ldr	r1, [r7, #8]
   15e94:	68f8      	ldr	r0, [r7, #12]
   15e96:	f7ff ff69 	bl	15d6c <z_impl_uart_rx_enable>
   15e9a:	4603      	mov	r3, r0
}
   15e9c:	4618      	mov	r0, r3
   15e9e:	3710      	adds	r7, #16
   15ea0:	46bd      	mov	sp, r7
   15ea2:	bd80      	pop	{r7, pc}

00015ea4 <uart_rx_disable>:
{
   15ea4:	b580      	push	{r7, lr}
   15ea6:	b082      	sub	sp, #8
   15ea8:	af00      	add	r7, sp, #0
   15eaa:	6078      	str	r0, [r7, #4]
	return z_impl_uart_rx_disable(dev);
   15eac:	6878      	ldr	r0, [r7, #4]
   15eae:	f7ff ff87 	bl	15dc0 <z_impl_uart_rx_disable>
   15eb2:	4603      	mov	r3, r0
}
   15eb4:	4618      	mov	r0, r3
   15eb6:	3708      	adds	r7, #8
   15eb8:	46bd      	mov	sp, r7
   15eba:	bd80      	pop	{r7, pc}

00015ebc <uart_configure>:
{
   15ebc:	b580      	push	{r7, lr}
   15ebe:	b082      	sub	sp, #8
   15ec0:	af00      	add	r7, sp, #0
   15ec2:	6078      	str	r0, [r7, #4]
   15ec4:	6039      	str	r1, [r7, #0]
	return z_impl_uart_configure(dev, cfg);
   15ec6:	6839      	ldr	r1, [r7, #0]
   15ec8:	6878      	ldr	r0, [r7, #4]
   15eca:	f7ff ff89 	bl	15de0 <z_impl_uart_configure>
   15ece:	4603      	mov	r3, r0
}
   15ed0:	4618      	mov	r0, r3
   15ed2:	3708      	adds	r7, #8
   15ed4:	46bd      	mov	sp, r7
   15ed6:	bd80      	pop	{r7, pc}

00015ed8 <uart_config_get>:
{
   15ed8:	b580      	push	{r7, lr}
   15eda:	b082      	sub	sp, #8
   15edc:	af00      	add	r7, sp, #0
   15ede:	6078      	str	r0, [r7, #4]
   15ee0:	6039      	str	r1, [r7, #0]
	return z_impl_uart_config_get(dev, cfg);
   15ee2:	6839      	ldr	r1, [r7, #0]
   15ee4:	6878      	ldr	r0, [r7, #4]
   15ee6:	f7ff ff94 	bl	15e12 <z_impl_uart_config_get>
   15eea:	4603      	mov	r3, r0
}
   15eec:	4618      	mov	r0, r3
   15eee:	3708      	adds	r7, #8
   15ef0:	46bd      	mov	sp, r7
   15ef2:	bd80      	pop	{r7, pc}

00015ef4 <z_impl_gpio_config>:
{
   15ef4:	b580      	push	{r7, lr}
   15ef6:	b086      	sub	sp, #24
   15ef8:	af00      	add	r7, sp, #0
   15efa:	60f8      	str	r0, [r7, #12]
   15efc:	460b      	mov	r3, r1
   15efe:	607a      	str	r2, [r7, #4]
   15f00:	72fb      	strb	r3, [r7, #11]
	const struct gpio_driver_api *api =
   15f02:	68fb      	ldr	r3, [r7, #12]
   15f04:	689b      	ldr	r3, [r3, #8]
   15f06:	617b      	str	r3, [r7, #20]
	return api->pin_configure(port, pin, flags);
   15f08:	697b      	ldr	r3, [r7, #20]
   15f0a:	681b      	ldr	r3, [r3, #0]
   15f0c:	7af9      	ldrb	r1, [r7, #11]
   15f0e:	687a      	ldr	r2, [r7, #4]
   15f10:	68f8      	ldr	r0, [r7, #12]
   15f12:	4798      	blx	r3
   15f14:	4603      	mov	r3, r0
}
   15f16:	4618      	mov	r0, r3
   15f18:	3718      	adds	r7, #24
   15f1a:	46bd      	mov	sp, r7
   15f1c:	bd80      	pop	{r7, pc}

00015f1e <gpio_add_callback>:
 *
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(const struct device *port,
				    struct gpio_callback *callback)
{
   15f1e:	b580      	push	{r7, lr}
   15f20:	b084      	sub	sp, #16
   15f22:	af00      	add	r7, sp, #0
   15f24:	6078      	str	r0, [r7, #4]
   15f26:	6039      	str	r1, [r7, #0]
	const struct gpio_driver_api *api =
   15f28:	687b      	ldr	r3, [r7, #4]
   15f2a:	689b      	ldr	r3, [r3, #8]
   15f2c:	60fb      	str	r3, [r7, #12]
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
   15f2e:	68fb      	ldr	r3, [r7, #12]
   15f30:	69db      	ldr	r3, [r3, #28]
   15f32:	2b00      	cmp	r3, #0
   15f34:	d102      	bne.n	15f3c <gpio_add_callback+0x1e>
		return -ENOTSUP;
   15f36:	f06f 0322 	mvn.w	r3, #34	; 0x22
   15f3a:	e006      	b.n	15f4a <gpio_add_callback+0x2c>
	}

	return api->manage_callback(port, callback, true);
   15f3c:	68fb      	ldr	r3, [r7, #12]
   15f3e:	69db      	ldr	r3, [r3, #28]
   15f40:	2201      	movs	r2, #1
   15f42:	6839      	ldr	r1, [r7, #0]
   15f44:	6878      	ldr	r0, [r7, #4]
   15f46:	4798      	blx	r3
   15f48:	4603      	mov	r3, r0
}
   15f4a:	4618      	mov	r0, r3
   15f4c:	3710      	adds	r7, #16
   15f4e:	46bd      	mov	sp, r7
   15f50:	bd80      	pop	{r7, pc}

00015f52 <gpio_config>:
extern "C" {
#endif

extern int z_impl_gpio_config(const struct device * port, gpio_pin_t pin, gpio_flags_t flags);
static inline int gpio_config(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
{
   15f52:	b580      	push	{r7, lr}
   15f54:	b084      	sub	sp, #16
   15f56:	af00      	add	r7, sp, #0
   15f58:	60f8      	str	r0, [r7, #12]
   15f5a:	460b      	mov	r3, r1
   15f5c:	607a      	str	r2, [r7, #4]
   15f5e:	72fb      	strb	r3, [r7, #11]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&port, *(uintptr_t *)&pin, *(uintptr_t *)&flags, K_SYSCALL_GPIO_CONFIG);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_config(port, pin, flags);
   15f60:	7afb      	ldrb	r3, [r7, #11]
   15f62:	687a      	ldr	r2, [r7, #4]
   15f64:	4619      	mov	r1, r3
   15f66:	68f8      	ldr	r0, [r7, #12]
   15f68:	f7ff ffc4 	bl	15ef4 <z_impl_gpio_config>
   15f6c:	4603      	mov	r3, r0
}
   15f6e:	4618      	mov	r0, r3
   15f70:	3710      	adds	r7, #16
   15f72:	46bd      	mov	sp, r7
   15f74:	bd80      	pop	{r7, pc}

00015f76 <gpio_pin_interrupt_configure>:


extern int z_impl_gpio_pin_interrupt_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags);
static inline int gpio_pin_interrupt_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
{
   15f76:	b580      	push	{r7, lr}
   15f78:	b084      	sub	sp, #16
   15f7a:	af00      	add	r7, sp, #0
   15f7c:	60f8      	str	r0, [r7, #12]
   15f7e:	460b      	mov	r3, r1
   15f80:	607a      	str	r2, [r7, #4]
   15f82:	72fb      	strb	r3, [r7, #11]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&port, *(uintptr_t *)&pin, *(uintptr_t *)&flags, K_SYSCALL_GPIO_PIN_INTERRUPT_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
   15f84:	7afb      	ldrb	r3, [r7, #11]
   15f86:	687a      	ldr	r2, [r7, #4]
   15f88:	4619      	mov	r1, r3
   15f8a:	68f8      	ldr	r0, [r7, #12]
   15f8c:	f7f1 fecc 	bl	7d28 <z_impl_gpio_pin_interrupt_configure>
   15f90:	4603      	mov	r3, r0
}
   15f92:	4618      	mov	r0, r3
   15f94:	3710      	adds	r7, #16
   15f96:	46bd      	mov	sp, r7
   15f98:	bd80      	pop	{r7, pc}

00015f9a <nrf_gpio_cfg>:
{
   15f9a:	b580      	push	{r7, lr}
   15f9c:	b084      	sub	sp, #16
   15f9e:	af00      	add	r7, sp, #0
   15fa0:	6078      	str	r0, [r7, #4]
   15fa2:	4608      	mov	r0, r1
   15fa4:	4611      	mov	r1, r2
   15fa6:	461a      	mov	r2, r3
   15fa8:	4603      	mov	r3, r0
   15faa:	70fb      	strb	r3, [r7, #3]
   15fac:	460b      	mov	r3, r1
   15fae:	70bb      	strb	r3, [r7, #2]
   15fb0:	4613      	mov	r3, r2
   15fb2:	707b      	strb	r3, [r7, #1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   15fb4:	1d3b      	adds	r3, r7, #4
   15fb6:	4618      	mov	r0, r3
   15fb8:	f7f2 f8d4 	bl	8164 <nrf_gpio_pin_port_decode>
   15fbc:	60f8      	str	r0, [r7, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   15fbe:	78fa      	ldrb	r2, [r7, #3]
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   15fc0:	78bb      	ldrb	r3, [r7, #2]
   15fc2:	005b      	lsls	r3, r3, #1
   15fc4:	431a      	orrs	r2, r3
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   15fc6:	787b      	ldrb	r3, [r7, #1]
   15fc8:	009b      	lsls	r3, r3, #2
   15fca:	431a      	orrs	r2, r3
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   15fcc:	7e3b      	ldrb	r3, [r7, #24]
   15fce:	021b      	lsls	r3, r3, #8
   15fd0:	ea42 0103 	orr.w	r1, r2, r3
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   15fd4:	7f3b      	ldrb	r3, [r7, #28]
   15fd6:	041b      	lsls	r3, r3, #16
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   15fd8:	687a      	ldr	r2, [r7, #4]
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   15fda:	4319      	orrs	r1, r3
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   15fdc:	68fb      	ldr	r3, [r7, #12]
   15fde:	3280      	adds	r2, #128	; 0x80
   15fe0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   15fe4:	bf00      	nop
   15fe6:	3710      	adds	r7, #16
   15fe8:	46bd      	mov	sp, r7
   15fea:	bd80      	pop	{r7, pc}

00015fec <nrf_gpio_cfg_output>:
{
   15fec:	b580      	push	{r7, lr}
   15fee:	b084      	sub	sp, #16
   15ff0:	af02      	add	r7, sp, #8
   15ff2:	6078      	str	r0, [r7, #4]
    nrf_gpio_cfg(
   15ff4:	2300      	movs	r3, #0
   15ff6:	9301      	str	r3, [sp, #4]
   15ff8:	2300      	movs	r3, #0
   15ffa:	9300      	str	r3, [sp, #0]
   15ffc:	2300      	movs	r3, #0
   15ffe:	2201      	movs	r2, #1
   16000:	2101      	movs	r1, #1
   16002:	6878      	ldr	r0, [r7, #4]
   16004:	f7ff ffc9 	bl	15f9a <nrf_gpio_cfg>
}
   16008:	bf00      	nop
   1600a:	3708      	adds	r7, #8
   1600c:	46bd      	mov	sp, r7
   1600e:	bd80      	pop	{r7, pc}

00016010 <nrf_gpio_cfg_input>:
{
   16010:	b580      	push	{r7, lr}
   16012:	b084      	sub	sp, #16
   16014:	af02      	add	r7, sp, #8
   16016:	6078      	str	r0, [r7, #4]
   16018:	460b      	mov	r3, r1
   1601a:	70fb      	strb	r3, [r7, #3]
    nrf_gpio_cfg(
   1601c:	78fb      	ldrb	r3, [r7, #3]
   1601e:	2200      	movs	r2, #0
   16020:	9201      	str	r2, [sp, #4]
   16022:	2200      	movs	r2, #0
   16024:	9200      	str	r2, [sp, #0]
   16026:	2200      	movs	r2, #0
   16028:	2100      	movs	r1, #0
   1602a:	6878      	ldr	r0, [r7, #4]
   1602c:	f7ff ffb5 	bl	15f9a <nrf_gpio_cfg>
}
   16030:	bf00      	nop
   16032:	3708      	adds	r7, #8
   16034:	46bd      	mov	sp, r7
   16036:	bd80      	pop	{r7, pc}

00016038 <nrf_gpio_pin_set>:
{
   16038:	b580      	push	{r7, lr}
   1603a:	b084      	sub	sp, #16
   1603c:	af00      	add	r7, sp, #0
   1603e:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   16040:	1d3b      	adds	r3, r7, #4
   16042:	4618      	mov	r0, r3
   16044:	f7f2 f88e 	bl	8164 <nrf_gpio_pin_port_decode>
   16048:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1604a:	687b      	ldr	r3, [r7, #4]
   1604c:	2201      	movs	r2, #1
   1604e:	fa02 f303 	lsl.w	r3, r2, r3
   16052:	4619      	mov	r1, r3
   16054:	68f8      	ldr	r0, [r7, #12]
   16056:	f000 f83a 	bl	160ce <nrf_gpio_port_out_set>
}
   1605a:	bf00      	nop
   1605c:	3710      	adds	r7, #16
   1605e:	46bd      	mov	sp, r7
   16060:	bd80      	pop	{r7, pc}

00016062 <nrf_gpio_pin_clear>:
{
   16062:	b580      	push	{r7, lr}
   16064:	b084      	sub	sp, #16
   16066:	af00      	add	r7, sp, #0
   16068:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1606a:	1d3b      	adds	r3, r7, #4
   1606c:	4618      	mov	r0, r3
   1606e:	f7f2 f879 	bl	8164 <nrf_gpio_pin_port_decode>
   16072:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   16074:	687b      	ldr	r3, [r7, #4]
   16076:	2201      	movs	r2, #1
   16078:	fa02 f303 	lsl.w	r3, r2, r3
   1607c:	4619      	mov	r1, r3
   1607e:	68f8      	ldr	r0, [r7, #12]
   16080:	f000 f832 	bl	160e8 <nrf_gpio_port_out_clear>
}
   16084:	bf00      	nop
   16086:	3710      	adds	r7, #16
   16088:	46bd      	mov	sp, r7
   1608a:	bd80      	pop	{r7, pc}

0001608c <nrf_gpio_pin_read>:
{
   1608c:	b580      	push	{r7, lr}
   1608e:	b084      	sub	sp, #16
   16090:	af00      	add	r7, sp, #0
   16092:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   16094:	1d3b      	adds	r3, r7, #4
   16096:	4618      	mov	r0, r3
   16098:	f7f2 f864 	bl	8164 <nrf_gpio_pin_port_decode>
   1609c:	60f8      	str	r0, [r7, #12]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   1609e:	68f8      	ldr	r0, [r7, #12]
   160a0:	f000 f80a 	bl	160b8 <nrf_gpio_port_in_read>
   160a4:	4602      	mov	r2, r0
   160a6:	687b      	ldr	r3, [r7, #4]
   160a8:	fa22 f303 	lsr.w	r3, r2, r3
   160ac:	f003 0301 	and.w	r3, r3, #1
}
   160b0:	4618      	mov	r0, r3
   160b2:	3710      	adds	r7, #16
   160b4:	46bd      	mov	sp, r7
   160b6:	bd80      	pop	{r7, pc}

000160b8 <nrf_gpio_port_in_read>:
{
   160b8:	b480      	push	{r7}
   160ba:	b083      	sub	sp, #12
   160bc:	af00      	add	r7, sp, #0
   160be:	6078      	str	r0, [r7, #4]
    return p_reg->IN;
   160c0:	687b      	ldr	r3, [r7, #4]
   160c2:	691b      	ldr	r3, [r3, #16]
}
   160c4:	4618      	mov	r0, r3
   160c6:	370c      	adds	r7, #12
   160c8:	46bd      	mov	sp, r7
   160ca:	bc80      	pop	{r7}
   160cc:	4770      	bx	lr

000160ce <nrf_gpio_port_out_set>:
{
   160ce:	b480      	push	{r7}
   160d0:	b083      	sub	sp, #12
   160d2:	af00      	add	r7, sp, #0
   160d4:	6078      	str	r0, [r7, #4]
   160d6:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   160d8:	687b      	ldr	r3, [r7, #4]
   160da:	683a      	ldr	r2, [r7, #0]
   160dc:	609a      	str	r2, [r3, #8]
}
   160de:	bf00      	nop
   160e0:	370c      	adds	r7, #12
   160e2:	46bd      	mov	sp, r7
   160e4:	bc80      	pop	{r7}
   160e6:	4770      	bx	lr

000160e8 <nrf_gpio_port_out_clear>:
{
   160e8:	b480      	push	{r7}
   160ea:	b083      	sub	sp, #12
   160ec:	af00      	add	r7, sp, #0
   160ee:	6078      	str	r0, [r7, #4]
   160f0:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   160f2:	687b      	ldr	r3, [r7, #4]
   160f4:	683a      	ldr	r2, [r7, #0]
   160f6:	60da      	str	r2, [r3, #12]
}
   160f8:	bf00      	nop
   160fa:	370c      	adds	r7, #12
   160fc:	46bd      	mov	sp, r7
   160fe:	bc80      	pop	{r7}
   16100:	4770      	bx	lr

00016102 <nrf_gpio_pin_present_check>:
{
   16102:	b480      	push	{r7}
   16104:	b085      	sub	sp, #20
   16106:	af00      	add	r7, sp, #0
   16108:	6078      	str	r0, [r7, #4]
    uint32_t port = pin_number >> 5;
   1610a:	687b      	ldr	r3, [r7, #4]
   1610c:	095b      	lsrs	r3, r3, #5
   1610e:	60bb      	str	r3, [r7, #8]
    uint32_t mask = 0;
   16110:	2300      	movs	r3, #0
   16112:	60fb      	str	r3, [r7, #12]
    switch (port)
   16114:	68bb      	ldr	r3, [r7, #8]
   16116:	2b00      	cmp	r3, #0
   16118:	d103      	bne.n	16122 <nrf_gpio_pin_present_check+0x20>
            mask = P0_FEATURE_PINS_PRESENT;
   1611a:	f04f 33ff 	mov.w	r3, #4294967295
   1611e:	60fb      	str	r3, [r7, #12]
            break;
   16120:	bf00      	nop
    pin_number &= 0x1F;
   16122:	687b      	ldr	r3, [r7, #4]
   16124:	f003 031f 	and.w	r3, r3, #31
   16128:	607b      	str	r3, [r7, #4]
    return (mask & (1UL << pin_number)) ? true : false;
   1612a:	68fa      	ldr	r2, [r7, #12]
   1612c:	687b      	ldr	r3, [r7, #4]
   1612e:	fa22 f303 	lsr.w	r3, r2, r3
   16132:	f003 0301 	and.w	r3, r3, #1
   16136:	2b00      	cmp	r3, #0
   16138:	bf14      	ite	ne
   1613a:	2301      	movne	r3, #1
   1613c:	2300      	moveq	r3, #0
   1613e:	b2db      	uxtb	r3, r3
}
   16140:	4618      	mov	r0, r3
   16142:	3714      	adds	r7, #20
   16144:	46bd      	mov	sp, r7
   16146:	bc80      	pop	{r7}
   16148:	4770      	bx	lr

0001614a <nrf_gpio_pin_port_number_extract>:
{
   1614a:	b480      	push	{r7}
   1614c:	b085      	sub	sp, #20
   1614e:	af00      	add	r7, sp, #0
   16150:	6078      	str	r0, [r7, #4]
    uint32_t pin_number = *p_pin;
   16152:	687b      	ldr	r3, [r7, #4]
   16154:	681b      	ldr	r3, [r3, #0]
   16156:	60fb      	str	r3, [r7, #12]
    *p_pin = pin_number & 0x1F;
   16158:	68fb      	ldr	r3, [r7, #12]
   1615a:	f003 021f 	and.w	r2, r3, #31
   1615e:	687b      	ldr	r3, [r7, #4]
   16160:	601a      	str	r2, [r3, #0]
    return pin_number >> 5;
   16162:	68fb      	ldr	r3, [r7, #12]
   16164:	095b      	lsrs	r3, r3, #5
}
   16166:	4618      	mov	r0, r3
   16168:	3714      	adds	r7, #20
   1616a:	46bd      	mov	sp, r7
   1616c:	bc80      	pop	{r7}
   1616e:	4770      	bx	lr

00016170 <nrf_gpiote_event_clear>:
{
   16170:	b580      	push	{r7, lr}
   16172:	b082      	sub	sp, #8
   16174:	af00      	add	r7, sp, #0
   16176:	6078      	str	r0, [r7, #4]
   16178:	460b      	mov	r3, r1
   1617a:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1617c:	887b      	ldrh	r3, [r7, #2]
   1617e:	4619      	mov	r1, r3
   16180:	6878      	ldr	r0, [r7, #4]
   16182:	f000 f811 	bl	161a8 <nrf_gpiote_event_address_get>
   16186:	4603      	mov	r3, r0
   16188:	461a      	mov	r2, r3
   1618a:	2300      	movs	r3, #0
   1618c:	6013      	str	r3, [r2, #0]
    nrf_event_readback((void *)nrf_gpiote_event_address_get(p_reg, event));
   1618e:	887b      	ldrh	r3, [r7, #2]
   16190:	4619      	mov	r1, r3
   16192:	6878      	ldr	r0, [r7, #4]
   16194:	f000 f808 	bl	161a8 <nrf_gpiote_event_address_get>
   16198:	4603      	mov	r3, r0
   1619a:	4618      	mov	r0, r3
   1619c:	f7ff fbf9 	bl	15992 <nrf_event_readback>
}
   161a0:	bf00      	nop
   161a2:	3708      	adds	r7, #8
   161a4:	46bd      	mov	sp, r7
   161a6:	bd80      	pop	{r7, pc}

000161a8 <nrf_gpiote_event_address_get>:
{
   161a8:	b480      	push	{r7}
   161aa:	b083      	sub	sp, #12
   161ac:	af00      	add	r7, sp, #0
   161ae:	6078      	str	r0, [r7, #4]
   161b0:	460b      	mov	r3, r1
   161b2:	807b      	strh	r3, [r7, #2]
    return ((uint32_t)p_reg + event);
   161b4:	887a      	ldrh	r2, [r7, #2]
   161b6:	687b      	ldr	r3, [r7, #4]
   161b8:	4413      	add	r3, r2
}
   161ba:	4618      	mov	r0, r3
   161bc:	370c      	adds	r7, #12
   161be:	46bd      	mov	sp, r7
   161c0:	bc80      	pop	{r7}
   161c2:	4770      	bx	lr

000161c4 <nrf_gpiote_event_enable>:
{
   161c4:	b480      	push	{r7}
   161c6:	b083      	sub	sp, #12
   161c8:	af00      	add	r7, sp, #0
   161ca:	6078      	str	r0, [r7, #4]
   161cc:	6039      	str	r1, [r7, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   161ce:	687b      	ldr	r3, [r7, #4]
   161d0:	683a      	ldr	r2, [r7, #0]
   161d2:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   161d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   161da:	f043 0101 	orr.w	r1, r3, #1
   161de:	687b      	ldr	r3, [r7, #4]
   161e0:	683a      	ldr	r2, [r7, #0]
   161e2:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   161e6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   161ea:	bf00      	nop
   161ec:	370c      	adds	r7, #12
   161ee:	46bd      	mov	sp, r7
   161f0:	bc80      	pop	{r7}
   161f2:	4770      	bx	lr

000161f4 <nrf_gpiote_event_configure>:
{
   161f4:	b480      	push	{r7}
   161f6:	b085      	sub	sp, #20
   161f8:	af00      	add	r7, sp, #0
   161fa:	60f8      	str	r0, [r7, #12]
   161fc:	60b9      	str	r1, [r7, #8]
   161fe:	607a      	str	r2, [r7, #4]
   16200:	70fb      	strb	r3, [r7, #3]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   16202:	68fb      	ldr	r3, [r7, #12]
   16204:	68ba      	ldr	r2, [r7, #8]
   16206:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1620a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1620e:	f423 3347 	bic.w	r3, r3, #203776	; 0x31c00
   16212:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   16216:	68fa      	ldr	r2, [r7, #12]
   16218:	68b9      	ldr	r1, [r7, #8]
   1621a:	f501 71a2 	add.w	r1, r1, #324	; 0x144
   1621e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   16222:	68fb      	ldr	r3, [r7, #12]
   16224:	68ba      	ldr	r2, [r7, #8]
   16226:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1622a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   1622e:	687b      	ldr	r3, [r7, #4]
   16230:	021b      	lsls	r3, r3, #8
   16232:	f403 51f8 	and.w	r1, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
   16236:	78fb      	ldrb	r3, [r7, #3]
   16238:	041b      	lsls	r3, r3, #16
   1623a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1623e:	430b      	orrs	r3, r1
   16240:	ea42 0103 	orr.w	r1, r2, r3
   16244:	68fb      	ldr	r3, [r7, #12]
   16246:	68ba      	ldr	r2, [r7, #8]
   16248:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1624c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   16250:	bf00      	nop
   16252:	3714      	adds	r7, #20
   16254:	46bd      	mov	sp, r7
   16256:	bc80      	pop	{r7}
   16258:	4770      	bx	lr

0001625a <nrf_gpiote_event_pin_get>:
{
   1625a:	b480      	push	{r7}
   1625c:	b083      	sub	sp, #12
   1625e:	af00      	add	r7, sp, #0
   16260:	6078      	str	r0, [r7, #4]
   16262:	6039      	str	r1, [r7, #0]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   16264:	687b      	ldr	r3, [r7, #4]
   16266:	683a      	ldr	r2, [r7, #0]
   16268:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   1626c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16270:	0a1b      	lsrs	r3, r3, #8
   16272:	f003 031f 	and.w	r3, r3, #31
}
   16276:	4618      	mov	r0, r3
   16278:	370c      	adds	r7, #12
   1627a:	46bd      	mov	sp, r7
   1627c:	bc80      	pop	{r7}
   1627e:	4770      	bx	lr

00016280 <nrf_gpiote_event_polarity_get>:
{
   16280:	b480      	push	{r7}
   16282:	b083      	sub	sp, #12
   16284:	af00      	add	r7, sp, #0
   16286:	6078      	str	r0, [r7, #4]
   16288:	6039      	str	r1, [r7, #0]
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   1628a:	687b      	ldr	r3, [r7, #4]
   1628c:	683a      	ldr	r2, [r7, #0]
   1628e:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   16292:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16296:	0c1b      	lsrs	r3, r3, #16
   16298:	f003 0303 	and.w	r3, r3, #3
   1629c:	b2db      	uxtb	r3, r3
}
   1629e:	4618      	mov	r0, r3
   162a0:	370c      	adds	r7, #12
   162a2:	46bd      	mov	sp, r7
   162a4:	bc80      	pop	{r7}
   162a6:	4770      	bx	lr

000162a8 <nrf_gpiote_te_default>:
{
   162a8:	b480      	push	{r7}
   162aa:	b083      	sub	sp, #12
   162ac:	af00      	add	r7, sp, #0
   162ae:	6078      	str	r0, [r7, #4]
   162b0:	6039      	str	r1, [r7, #0]
    p_reg->CONFIG[idx] = 0;
   162b2:	687b      	ldr	r3, [r7, #4]
   162b4:	683a      	ldr	r2, [r7, #0]
   162b6:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   162ba:	2100      	movs	r1, #0
   162bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   162c0:	bf00      	nop
   162c2:	370c      	adds	r7, #12
   162c4:	46bd      	mov	sp, r7
   162c6:	bc80      	pop	{r7}
   162c8:	4770      	bx	lr

000162ca <get_dev_data>:
{
   162ca:	b480      	push	{r7}
   162cc:	b083      	sub	sp, #12
   162ce:	af00      	add	r7, sp, #0
   162d0:	6078      	str	r0, [r7, #4]
	return dev->data;
   162d2:	687b      	ldr	r3, [r7, #4]
   162d4:	68db      	ldr	r3, [r3, #12]
}
   162d6:	4618      	mov	r0, r3
   162d8:	370c      	adds	r7, #12
   162da:	46bd      	mov	sp, r7
   162dc:	bc80      	pop	{r7}
   162de:	4770      	bx	lr

000162e0 <get_dev_config>:
{
   162e0:	b480      	push	{r7}
   162e2:	b083      	sub	sp, #12
   162e4:	af00      	add	r7, sp, #0
   162e6:	6078      	str	r0, [r7, #4]
	return dev->config;
   162e8:	687b      	ldr	r3, [r7, #4]
   162ea:	685b      	ldr	r3, [r3, #4]
}
   162ec:	4618      	mov	r0, r3
   162ee:	370c      	adds	r7, #12
   162f0:	46bd      	mov	sp, r7
   162f2:	bc80      	pop	{r7}
   162f4:	4770      	bx	lr

000162f6 <tx_complete>:
{
   162f6:	b580      	push	{r7, lr}
   162f8:	b082      	sub	sp, #8
   162fa:	af00      	add	r7, sp, #0
   162fc:	6078      	str	r0, [r7, #4]
	ctrl_pin_idle(&data->req_pin);
   162fe:	687b      	ldr	r3, [r7, #4]
   16300:	3304      	adds	r3, #4
   16302:	4618      	mov	r0, r3
   16304:	f7f2 f808 	bl	8318 <ctrl_pin_idle>
	data->tx_buf = NULL;
   16308:	687b      	ldr	r3, [r7, #4]
   1630a:	2200      	movs	r2, #0
   1630c:	66da      	str	r2, [r3, #108]	; 0x6c
	data->tx_active = false;
   1630e:	687b      	ldr	r3, [r7, #4]
   16310:	2200      	movs	r2, #0
   16312:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
}
   16316:	bf00      	nop
   16318:	3708      	adds	r7, #8
   1631a:	46bd      	mov	sp, r7
   1631c:	bd80      	pop	{r7, pc}

0001631e <gpio_handler>:
{
   1631e:	b580      	push	{r7, lr}
   16320:	b086      	sub	sp, #24
   16322:	af00      	add	r7, sp, #0
   16324:	60f8      	str	r0, [r7, #12]
   16326:	60b9      	str	r1, [r7, #8]
   16328:	607a      	str	r2, [r7, #4]
	const struct lpuart_bidir_gpio *io =
   1632a:	68bb      	ldr	r3, [r7, #8]
   1632c:	617b      	str	r3, [r7, #20]
	if (io->req) {
   1632e:	697b      	ldr	r3, [r7, #20]
   16330:	7cdb      	ldrb	r3, [r3, #19]
   16332:	2b00      	cmp	r3, #0
   16334:	d006      	beq.n	16344 <gpio_handler+0x26>
		data = CONTAINER_OF(io, struct lpuart_data, req_pin);
   16336:	697b      	ldr	r3, [r7, #20]
   16338:	3b04      	subs	r3, #4
   1633a:	613b      	str	r3, [r7, #16]
		on_req_pin_change(data);
   1633c:	6938      	ldr	r0, [r7, #16]
   1633e:	f7f2 f965 	bl	860c <on_req_pin_change>
		return;
   16342:	e005      	b.n	16350 <gpio_handler+0x32>
	data = CONTAINER_OF(io, struct lpuart_data, rdy_pin);
   16344:	697b      	ldr	r3, [r7, #20]
   16346:	3b18      	subs	r3, #24
   16348:	613b      	str	r3, [r7, #16]
	on_rdy_pin_change(data);
   1634a:	6938      	ldr	r0, [r7, #16]
   1634c:	f7f2 fa44 	bl	87d8 <on_rdy_pin_change>
}
   16350:	3718      	adds	r7, #24
   16352:	46bd      	mov	sp, r7
   16354:	bd80      	pop	{r7, pc}

00016356 <api_callback_set>:
{
   16356:	b580      	push	{r7, lr}
   16358:	b086      	sub	sp, #24
   1635a:	af00      	add	r7, sp, #0
   1635c:	60f8      	str	r0, [r7, #12]
   1635e:	60b9      	str	r1, [r7, #8]
   16360:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   16362:	68f8      	ldr	r0, [r7, #12]
   16364:	f7ff ffb1 	bl	162ca <get_dev_data>
   16368:	6178      	str	r0, [r7, #20]
	data->user_callback = callback;
   1636a:	697b      	ldr	r3, [r7, #20]
   1636c:	68ba      	ldr	r2, [r7, #8]
   1636e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	data->user_data = user_data;
   16372:	697b      	ldr	r3, [r7, #20]
   16374:	687a      	ldr	r2, [r7, #4]
   16376:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	return 0;
   1637a:	2300      	movs	r3, #0
}
   1637c:	4618      	mov	r0, r3
   1637e:	3718      	adds	r7, #24
   16380:	46bd      	mov	sp, r7
   16382:	bd80      	pop	{r7, pc}

00016384 <user_callback>:
{
   16384:	b580      	push	{r7, lr}
   16386:	b084      	sub	sp, #16
   16388:	af00      	add	r7, sp, #0
   1638a:	6078      	str	r0, [r7, #4]
   1638c:	6039      	str	r1, [r7, #0]
	const struct lpuart_data *data = get_dev_data(dev);
   1638e:	6878      	ldr	r0, [r7, #4]
   16390:	f7ff ff9b 	bl	162ca <get_dev_data>
   16394:	60f8      	str	r0, [r7, #12]
	if (data->user_callback) {
   16396:	68fb      	ldr	r3, [r7, #12]
   16398:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   1639c:	2b00      	cmp	r3, #0
   1639e:	d008      	beq.n	163b2 <user_callback+0x2e>
		data->user_callback(dev, evt, data->user_data);
   163a0:	68fb      	ldr	r3, [r7, #12]
   163a2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   163a6:	68fa      	ldr	r2, [r7, #12]
   163a8:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
   163ac:	6839      	ldr	r1, [r7, #0]
   163ae:	6878      	ldr	r0, [r7, #4]
   163b0:	4798      	blx	r3
}
   163b2:	bf00      	nop
   163b4:	3710      	adds	r7, #16
   163b6:	46bd      	mov	sp, r7
   163b8:	bd80      	pop	{r7, pc}

000163ba <api_tx_abort>:
{
   163ba:	b580      	push	{r7, lr}
   163bc:	b08e      	sub	sp, #56	; 0x38
   163be:	af00      	add	r7, sp, #0
   163c0:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   163c2:	6878      	ldr	r0, [r7, #4]
   163c4:	f7ff ff81 	bl	162ca <get_dev_data>
   163c8:	6378      	str	r0, [r7, #52]	; 0x34
	const uint8_t *buf = data->tx_buf;
   163ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   163cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   163ce:	633b      	str	r3, [r7, #48]	; 0x30
	if (data->tx_buf == NULL) {
   163d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   163d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   163d4:	2b00      	cmp	r3, #0
   163d6:	d102      	bne.n	163de <api_tx_abort+0x24>
		return -EFAULT;
   163d8:	f06f 030d 	mvn.w	r3, #13
   163dc:	e03a      	b.n	16454 <api_tx_abort+0x9a>
	k_timer_stop(&data->tx_timer);
   163de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   163e0:	3330      	adds	r3, #48	; 0x30
   163e2:	4618      	mov	r0, r3
   163e4:	f7ff fc58 	bl	15c98 <k_timer_stop>
	__asm__ volatile(
   163e8:	f04f 0320 	mov.w	r3, #32
   163ec:	f3ef 8211 	mrs	r2, BASEPRI
   163f0:	f383 8811 	msr	BASEPRI, r3
   163f4:	f3bf 8f6f 	isb	sy
   163f8:	623a      	str	r2, [r7, #32]
   163fa:	61fb      	str	r3, [r7, #28]
	return key;
   163fc:	6a3b      	ldr	r3, [r7, #32]
	key = irq_lock();
   163fe:	62fb      	str	r3, [r7, #44]	; 0x2c
	tx_complete(data);
   16400:	6b78      	ldr	r0, [r7, #52]	; 0x34
   16402:	f7ff ff78 	bl	162f6 <tx_complete>
	irq_unlock(key);
   16406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   16408:	627b      	str	r3, [r7, #36]	; 0x24
	__asm__ volatile(
   1640a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1640c:	f383 8811 	msr	BASEPRI, r3
   16410:	f3bf 8f6f 	isb	sy
}
   16414:	bf00      	nop
	err = uart_tx_abort(data->uart);
   16416:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   16418:	681b      	ldr	r3, [r3, #0]
   1641a:	4618      	mov	r0, r3
   1641c:	f7ff fd24 	bl	15e68 <uart_tx_abort>
   16420:	62b8      	str	r0, [r7, #40]	; 0x28
	if (err != -EFAULT) {
   16422:	6abb      	ldr	r3, [r7, #40]	; 0x28
   16424:	f113 0f0e 	cmn.w	r3, #14
   16428:	d001      	beq.n	1642e <api_tx_abort+0x74>
		return err;
   1642a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1642c:	e012      	b.n	16454 <api_tx_abort+0x9a>
	struct uart_event event = {
   1642e:	f107 0308 	add.w	r3, r7, #8
   16432:	2200      	movs	r2, #0
   16434:	601a      	str	r2, [r3, #0]
   16436:	605a      	str	r2, [r3, #4]
   16438:	609a      	str	r2, [r3, #8]
   1643a:	60da      	str	r2, [r3, #12]
   1643c:	611a      	str	r2, [r3, #16]
   1643e:	2301      	movs	r3, #1
   16440:	723b      	strb	r3, [r7, #8]
   16442:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   16444:	60fb      	str	r3, [r7, #12]
	user_callback(dev, &event);
   16446:	f107 0308 	add.w	r3, r7, #8
   1644a:	4619      	mov	r1, r3
   1644c:	6878      	ldr	r0, [r7, #4]
   1644e:	f7ff ff99 	bl	16384 <user_callback>
	return err;
   16452:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
   16454:	4618      	mov	r0, r3
   16456:	3738      	adds	r7, #56	; 0x38
   16458:	46bd      	mov	sp, r7
   1645a:	bd80      	pop	{r7, pc}

0001645c <api_rx_disable>:
{
   1645c:	b580      	push	{r7, lr}
   1645e:	b084      	sub	sp, #16
   16460:	af00      	add	r7, sp, #0
   16462:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   16464:	6878      	ldr	r0, [r7, #4]
   16466:	f7ff ff30 	bl	162ca <get_dev_data>
   1646a:	60f8      	str	r0, [r7, #12]
	data->rx_state = RX_TO_OFF;
   1646c:	68fb      	ldr	r3, [r7, #12]
   1646e:	2204      	movs	r2, #4
   16470:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	return uart_rx_disable(data->uart);
   16474:	68fb      	ldr	r3, [r7, #12]
   16476:	681b      	ldr	r3, [r3, #0]
   16478:	4618      	mov	r0, r3
   1647a:	f7ff fd13 	bl	15ea4 <uart_rx_disable>
   1647e:	4603      	mov	r3, r0
}
   16480:	4618      	mov	r0, r3
   16482:	3710      	adds	r7, #16
   16484:	46bd      	mov	sp, r7
   16486:	bd80      	pop	{r7, pc}

00016488 <int_driven_rd_available>:
{
   16488:	b480      	push	{r7}
   1648a:	b083      	sub	sp, #12
   1648c:	af00      	add	r7, sp, #0
   1648e:	6078      	str	r0, [r7, #4]
	return data->int_driven.rxlen - data->int_driven.rxrd;
   16490:	687b      	ldr	r3, [r7, #4]
   16492:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
   16496:	687b      	ldr	r3, [r7, #4]
   16498:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
   1649c:	1ad3      	subs	r3, r2, r3
}
   1649e:	4618      	mov	r0, r3
   164a0:	370c      	adds	r7, #12
   164a2:	46bd      	mov	sp, r7
   164a4:	bc80      	pop	{r7}
   164a6:	4770      	bx	lr

000164a8 <api_fifo_read>:
{
   164a8:	b580      	push	{r7, lr}
   164aa:	b088      	sub	sp, #32
   164ac:	af00      	add	r7, sp, #0
   164ae:	60f8      	str	r0, [r7, #12]
   164b0:	60b9      	str	r1, [r7, #8]
   164b2:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   164b4:	68f8      	ldr	r0, [r7, #12]
   164b6:	f7ff ff08 	bl	162ca <get_dev_data>
   164ba:	61b8      	str	r0, [r7, #24]
	uint32_t available = int_driven_rd_available(data);
   164bc:	69b8      	ldr	r0, [r7, #24]
   164be:	f7ff ffe3 	bl	16488 <int_driven_rd_available>
   164c2:	6178      	str	r0, [r7, #20]
	uint32_t cpylen = 0;
   164c4:	2300      	movs	r3, #0
   164c6:	61fb      	str	r3, [r7, #28]
	if (available) {
   164c8:	697b      	ldr	r3, [r7, #20]
   164ca:	2b00      	cmp	r3, #0
   164cc:	d029      	beq.n	16522 <api_fifo_read+0x7a>
		cpylen = MIN(available, size);
   164ce:	687b      	ldr	r3, [r7, #4]
   164d0:	697a      	ldr	r2, [r7, #20]
   164d2:	4293      	cmp	r3, r2
   164d4:	bf28      	it	cs
   164d6:	4613      	movcs	r3, r2
   164d8:	61fb      	str	r3, [r7, #28]
		       &data->int_driven.rxbuf[data->int_driven.rxrd],
   164da:	69bb      	ldr	r3, [r7, #24]
   164dc:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
   164e0:	f503 738c 	add.w	r3, r3, #280	; 0x118
   164e4:	69ba      	ldr	r2, [r7, #24]
   164e6:	4413      	add	r3, r2
   164e8:	3304      	adds	r3, #4
		memcpy(rx_data,
   164ea:	69fa      	ldr	r2, [r7, #28]
   164ec:	4619      	mov	r1, r3
   164ee:	68b8      	ldr	r0, [r7, #8]
   164f0:	f7fc fe1e 	bl	13130 <memcpy>
		data->int_driven.rxrd += cpylen;
   164f4:	69bb      	ldr	r3, [r7, #24]
   164f6:	f8d3 21a0 	ldr.w	r2, [r3, #416]	; 0x1a0
   164fa:	69fb      	ldr	r3, [r7, #28]
   164fc:	441a      	add	r2, r3
   164fe:	69bb      	ldr	r3, [r7, #24]
   16500:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
		if ((data->rx_state == RX_IDLE)
   16504:	69bb      	ldr	r3, [r7, #24]
   16506:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
   1650a:	2b01      	cmp	r3, #1
   1650c:	d109      	bne.n	16522 <api_fifo_read+0x7a>
		    && !int_driven_rd_available(data)) {
   1650e:	69b8      	ldr	r0, [r7, #24]
   16510:	f7ff ffba 	bl	16488 <int_driven_rd_available>
   16514:	4603      	mov	r3, r0
   16516:	2b00      	cmp	r3, #0
   16518:	d103      	bne.n	16522 <api_fifo_read+0x7a>
			int_driven_rx_feed(dev, data);
   1651a:	69b9      	ldr	r1, [r7, #24]
   1651c:	68f8      	ldr	r0, [r7, #12]
   1651e:	f7f2 fee3 	bl	92e8 <int_driven_rx_feed>
	return cpylen;
   16522:	69fb      	ldr	r3, [r7, #28]
}
   16524:	4618      	mov	r0, r3
   16526:	3720      	adds	r7, #32
   16528:	46bd      	mov	sp, r7
   1652a:	bd80      	pop	{r7, pc}

0001652c <api_fifo_fill>:
{
   1652c:	b580      	push	{r7, lr}
   1652e:	b086      	sub	sp, #24
   16530:	af00      	add	r7, sp, #0
   16532:	60f8      	str	r0, [r7, #12]
   16534:	60b9      	str	r1, [r7, #8]
   16536:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   16538:	68f8      	ldr	r0, [r7, #12]
   1653a:	f7ff fec6 	bl	162ca <get_dev_data>
   1653e:	6178      	str	r0, [r7, #20]
	size = MIN(size, sizeof(data->int_driven.txbuf));
   16540:	687b      	ldr	r3, [r7, #4]
   16542:	2b80      	cmp	r3, #128	; 0x80
   16544:	bf28      	it	cs
   16546:	2380      	movcs	r3, #128	; 0x80
   16548:	607b      	str	r3, [r7, #4]
	if (!atomic_cas((atomic_t *)&data->int_driven.txlen, 0, size)) {
   1654a:	697b      	ldr	r3, [r7, #20]
   1654c:	f503 738c 	add.w	r3, r3, #280	; 0x118
   16550:	687a      	ldr	r2, [r7, #4]
   16552:	2100      	movs	r1, #0
   16554:	4618      	mov	r0, r3
   16556:	f7ff f9d8 	bl	1590a <atomic_cas>
   1655a:	4603      	mov	r3, r0
   1655c:	f083 0301 	eor.w	r3, r3, #1
   16560:	b2db      	uxtb	r3, r3
   16562:	2b00      	cmp	r3, #0
   16564:	d001      	beq.n	1656a <api_fifo_fill+0x3e>
		return 0;
   16566:	2300      	movs	r3, #0
   16568:	e01c      	b.n	165a4 <api_fifo_fill+0x78>
	memcpy(data->int_driven.txbuf, tx_data, size);
   1656a:	697b      	ldr	r3, [r7, #20]
   1656c:	3398      	adds	r3, #152	; 0x98
   1656e:	687a      	ldr	r2, [r7, #4]
   16570:	68b9      	ldr	r1, [r7, #8]
   16572:	4618      	mov	r0, r3
   16574:	f7fc fddc 	bl	13130 <memcpy>
	err = api_tx(dev, data->int_driven.txbuf,
   16578:	697b      	ldr	r3, [r7, #20]
   1657a:	f103 0198 	add.w	r1, r3, #152	; 0x98
   1657e:	697b      	ldr	r3, [r7, #20]
   16580:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   16584:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   16588:	68f8      	ldr	r0, [r7, #12]
   1658a:	f7f2 fcbf 	bl	8f0c <api_tx>
   1658e:	6138      	str	r0, [r7, #16]
	if (err < 0) {
   16590:	693b      	ldr	r3, [r7, #16]
   16592:	2b00      	cmp	r3, #0
   16594:	da05      	bge.n	165a2 <api_fifo_fill+0x76>
		data->int_driven.txlen = 0;
   16596:	697b      	ldr	r3, [r7, #20]
   16598:	2200      	movs	r2, #0
   1659a:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
		return 0;
   1659e:	2300      	movs	r3, #0
   165a0:	e000      	b.n	165a4 <api_fifo_fill+0x78>
	return size;
   165a2:	687b      	ldr	r3, [r7, #4]
}
   165a4:	4618      	mov	r0, r3
   165a6:	3718      	adds	r7, #24
   165a8:	46bd      	mov	sp, r7
   165aa:	bd80      	pop	{r7, pc}

000165ac <api_irq_tx_enable>:
{
   165ac:	b580      	push	{r7, lr}
   165ae:	b084      	sub	sp, #16
   165b0:	af00      	add	r7, sp, #0
   165b2:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   165b4:	6878      	ldr	r0, [r7, #4]
   165b6:	f7ff fe88 	bl	162ca <get_dev_data>
   165ba:	60f8      	str	r0, [r7, #12]
	data->int_driven.tx_enabled = true;
   165bc:	68fb      	ldr	r3, [r7, #12]
   165be:	2201      	movs	r2, #1
   165c0:	f883 21a4 	strb.w	r2, [r3, #420]	; 0x1a4
	if (data->tx_buf == NULL) {
   165c4:	68fb      	ldr	r3, [r7, #12]
   165c6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   165c8:	2b00      	cmp	r3, #0
   165ca:	d108      	bne.n	165de <api_irq_tx_enable+0x32>
		data->int_driven.callback(dev, data->int_driven.user_data);
   165cc:	68fb      	ldr	r3, [r7, #12]
   165ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   165d2:	68fa      	ldr	r2, [r7, #12]
   165d4:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
   165d8:	4611      	mov	r1, r2
   165da:	6878      	ldr	r0, [r7, #4]
   165dc:	4798      	blx	r3
}
   165de:	bf00      	nop
   165e0:	3710      	adds	r7, #16
   165e2:	46bd      	mov	sp, r7
   165e4:	bd80      	pop	{r7, pc}

000165e6 <api_irq_tx_disable>:
{
   165e6:	b580      	push	{r7, lr}
   165e8:	b084      	sub	sp, #16
   165ea:	af00      	add	r7, sp, #0
   165ec:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   165ee:	6878      	ldr	r0, [r7, #4]
   165f0:	f7ff fe6b 	bl	162ca <get_dev_data>
   165f4:	60f8      	str	r0, [r7, #12]
	data->int_driven.tx_enabled = false;
   165f6:	68fb      	ldr	r3, [r7, #12]
   165f8:	2200      	movs	r2, #0
   165fa:	f883 21a4 	strb.w	r2, [r3, #420]	; 0x1a4
}
   165fe:	bf00      	nop
   16600:	3710      	adds	r7, #16
   16602:	46bd      	mov	sp, r7
   16604:	bd80      	pop	{r7, pc}

00016606 <api_irq_tx_ready>:
{
   16606:	b580      	push	{r7, lr}
   16608:	b084      	sub	sp, #16
   1660a:	af00      	add	r7, sp, #0
   1660c:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   1660e:	6878      	ldr	r0, [r7, #4]
   16610:	f7ff fe5b 	bl	162ca <get_dev_data>
   16614:	60f8      	str	r0, [r7, #12]
	return data->int_driven.tx_enabled && (data->tx_buf == NULL);
   16616:	68fb      	ldr	r3, [r7, #12]
   16618:	f893 31a4 	ldrb.w	r3, [r3, #420]	; 0x1a4
   1661c:	2b00      	cmp	r3, #0
   1661e:	d005      	beq.n	1662c <api_irq_tx_ready+0x26>
   16620:	68fb      	ldr	r3, [r7, #12]
   16622:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   16624:	2b00      	cmp	r3, #0
   16626:	d101      	bne.n	1662c <api_irq_tx_ready+0x26>
   16628:	2301      	movs	r3, #1
   1662a:	e000      	b.n	1662e <api_irq_tx_ready+0x28>
   1662c:	2300      	movs	r3, #0
}
   1662e:	4618      	mov	r0, r3
   16630:	3710      	adds	r7, #16
   16632:	46bd      	mov	sp, r7
   16634:	bd80      	pop	{r7, pc}

00016636 <api_irq_callback_set>:
{
   16636:	b580      	push	{r7, lr}
   16638:	b086      	sub	sp, #24
   1663a:	af00      	add	r7, sp, #0
   1663c:	60f8      	str	r0, [r7, #12]
   1663e:	60b9      	str	r1, [r7, #8]
   16640:	607a      	str	r2, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   16642:	68f8      	ldr	r0, [r7, #12]
   16644:	f7ff fe41 	bl	162ca <get_dev_data>
   16648:	6178      	str	r0, [r7, #20]
	data->int_driven.callback = cb;
   1664a:	697b      	ldr	r3, [r7, #20]
   1664c:	68ba      	ldr	r2, [r7, #8]
   1664e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	data->int_driven.user_data = user_data;
   16652:	697b      	ldr	r3, [r7, #20]
   16654:	687a      	ldr	r2, [r7, #4]
   16656:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   1665a:	bf00      	nop
   1665c:	3718      	adds	r7, #24
   1665e:	46bd      	mov	sp, r7
   16660:	bd80      	pop	{r7, pc}

00016662 <api_irq_rx_enable>:
{
   16662:	b580      	push	{r7, lr}
   16664:	b084      	sub	sp, #16
   16666:	af00      	add	r7, sp, #0
   16668:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   1666a:	6878      	ldr	r0, [r7, #4]
   1666c:	f7ff fe2d 	bl	162ca <get_dev_data>
   16670:	60f8      	str	r0, [r7, #12]
	data->int_driven.rx_enabled = true;
   16672:	68fb      	ldr	r3, [r7, #12]
   16674:	2201      	movs	r2, #1
   16676:	f883 21a5 	strb.w	r2, [r3, #421]	; 0x1a5
	if (int_driven_rd_available(data)) {
   1667a:	68f8      	ldr	r0, [r7, #12]
   1667c:	f7ff ff04 	bl	16488 <int_driven_rd_available>
   16680:	4603      	mov	r3, r0
   16682:	2b00      	cmp	r3, #0
   16684:	d008      	beq.n	16698 <api_irq_rx_enable+0x36>
		data->int_driven.callback(dev, data->int_driven.user_data);
   16686:	68fb      	ldr	r3, [r7, #12]
   16688:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1668c:	68fa      	ldr	r2, [r7, #12]
   1668e:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
   16692:	4611      	mov	r1, r2
   16694:	6878      	ldr	r0, [r7, #4]
   16696:	4798      	blx	r3
}
   16698:	bf00      	nop
   1669a:	3710      	adds	r7, #16
   1669c:	46bd      	mov	sp, r7
   1669e:	bd80      	pop	{r7, pc}

000166a0 <api_irq_rx_disable>:
{
   166a0:	b580      	push	{r7, lr}
   166a2:	b084      	sub	sp, #16
   166a4:	af00      	add	r7, sp, #0
   166a6:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   166a8:	6878      	ldr	r0, [r7, #4]
   166aa:	f7ff fe0e 	bl	162ca <get_dev_data>
   166ae:	60f8      	str	r0, [r7, #12]
	data->int_driven.rx_enabled = false;
   166b0:	68fb      	ldr	r3, [r7, #12]
   166b2:	2200      	movs	r2, #0
   166b4:	f883 21a5 	strb.w	r2, [r3, #421]	; 0x1a5
}
   166b8:	bf00      	nop
   166ba:	3710      	adds	r7, #16
   166bc:	46bd      	mov	sp, r7
   166be:	bd80      	pop	{r7, pc}

000166c0 <api_irq_rx_ready>:
{
   166c0:	b580      	push	{r7, lr}
   166c2:	b084      	sub	sp, #16
   166c4:	af00      	add	r7, sp, #0
   166c6:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   166c8:	6878      	ldr	r0, [r7, #4]
   166ca:	f7ff fdfe 	bl	162ca <get_dev_data>
   166ce:	60f8      	str	r0, [r7, #12]
	return data->int_driven.rx_enabled &&
   166d0:	68fb      	ldr	r3, [r7, #12]
   166d2:	f893 31a5 	ldrb.w	r3, [r3, #421]	; 0x1a5
   166d6:	2b00      	cmp	r3, #0
   166d8:	d00b      	beq.n	166f2 <api_irq_rx_ready+0x32>
		int_driven_rd_available(get_dev_data(dev));
   166da:	6878      	ldr	r0, [r7, #4]
   166dc:	f7ff fdf5 	bl	162ca <get_dev_data>
   166e0:	4603      	mov	r3, r0
   166e2:	4618      	mov	r0, r3
   166e4:	f7ff fed0 	bl	16488 <int_driven_rd_available>
   166e8:	4603      	mov	r3, r0
	return data->int_driven.rx_enabled &&
   166ea:	2b00      	cmp	r3, #0
   166ec:	d001      	beq.n	166f2 <api_irq_rx_ready+0x32>
   166ee:	2301      	movs	r3, #1
   166f0:	e000      	b.n	166f4 <api_irq_rx_ready+0x34>
   166f2:	2300      	movs	r3, #0
}
   166f4:	4618      	mov	r0, r3
   166f6:	3710      	adds	r7, #16
   166f8:	46bd      	mov	sp, r7
   166fa:	bd80      	pop	{r7, pc}

000166fc <api_irq_tx_complete>:
{
   166fc:	b580      	push	{r7, lr}
   166fe:	b082      	sub	sp, #8
   16700:	af00      	add	r7, sp, #0
   16702:	6078      	str	r0, [r7, #4]
	return api_irq_tx_ready(dev);
   16704:	6878      	ldr	r0, [r7, #4]
   16706:	f7ff ff7e 	bl	16606 <api_irq_tx_ready>
   1670a:	4603      	mov	r3, r0
}
   1670c:	4618      	mov	r0, r3
   1670e:	3708      	adds	r7, #8
   16710:	46bd      	mov	sp, r7
   16712:	bd80      	pop	{r7, pc}

00016714 <api_irq_err_enable>:
{
   16714:	b580      	push	{r7, lr}
   16716:	b084      	sub	sp, #16
   16718:	af00      	add	r7, sp, #0
   1671a:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   1671c:	6878      	ldr	r0, [r7, #4]
   1671e:	f7ff fdd4 	bl	162ca <get_dev_data>
   16722:	60f8      	str	r0, [r7, #12]
	data->int_driven.err_enabled = true;
   16724:	68fb      	ldr	r3, [r7, #12]
   16726:	2201      	movs	r2, #1
   16728:	f883 21a6 	strb.w	r2, [r3, #422]	; 0x1a6
}
   1672c:	bf00      	nop
   1672e:	3710      	adds	r7, #16
   16730:	46bd      	mov	sp, r7
   16732:	bd80      	pop	{r7, pc}

00016734 <api_irq_err_disable>:
{
   16734:	b580      	push	{r7, lr}
   16736:	b084      	sub	sp, #16
   16738:	af00      	add	r7, sp, #0
   1673a:	6078      	str	r0, [r7, #4]
	struct lpuart_data *data = get_dev_data(dev);
   1673c:	6878      	ldr	r0, [r7, #4]
   1673e:	f7ff fdc4 	bl	162ca <get_dev_data>
   16742:	60f8      	str	r0, [r7, #12]
	data->int_driven.err_enabled = false;
   16744:	68fb      	ldr	r3, [r7, #12]
   16746:	2200      	movs	r2, #0
   16748:	f883 21a6 	strb.w	r2, [r3, #422]	; 0x1a6
}
   1674c:	bf00      	nop
   1674e:	3710      	adds	r7, #16
   16750:	46bd      	mov	sp, r7
   16752:	bd80      	pop	{r7, pc}

00016754 <api_irq_is_pending>:
{
   16754:	b580      	push	{r7, lr}
   16756:	b082      	sub	sp, #8
   16758:	af00      	add	r7, sp, #0
   1675a:	6078      	str	r0, [r7, #4]
	return api_irq_rx_ready(dev) || api_irq_tx_ready(dev);
   1675c:	6878      	ldr	r0, [r7, #4]
   1675e:	f7ff ffaf 	bl	166c0 <api_irq_rx_ready>
   16762:	4603      	mov	r3, r0
   16764:	2b00      	cmp	r3, #0
   16766:	d105      	bne.n	16774 <api_irq_is_pending+0x20>
   16768:	6878      	ldr	r0, [r7, #4]
   1676a:	f7ff ff4c 	bl	16606 <api_irq_tx_ready>
   1676e:	4603      	mov	r3, r0
   16770:	2b00      	cmp	r3, #0
   16772:	d001      	beq.n	16778 <api_irq_is_pending+0x24>
   16774:	2301      	movs	r3, #1
   16776:	e000      	b.n	1677a <api_irq_is_pending+0x26>
   16778:	2300      	movs	r3, #0
}
   1677a:	4618      	mov	r0, r3
   1677c:	3708      	adds	r7, #8
   1677e:	46bd      	mov	sp, r7
   16780:	bd80      	pop	{r7, pc}

00016782 <api_irq_update>:
{
   16782:	b480      	push	{r7}
   16784:	b083      	sub	sp, #12
   16786:	af00      	add	r7, sp, #0
   16788:	6078      	str	r0, [r7, #4]
	return 1;
   1678a:	2301      	movs	r3, #1
}
   1678c:	4618      	mov	r0, r3
   1678e:	370c      	adds	r7, #12
   16790:	46bd      	mov	sp, r7
   16792:	bc80      	pop	{r7}
   16794:	4770      	bx	lr

00016796 <api_poll_in>:

static int api_poll_in(const struct device *dev, unsigned char *p_char)
{
   16796:	b580      	push	{r7, lr}
   16798:	b082      	sub	sp, #8
   1679a:	af00      	add	r7, sp, #0
   1679c:	6078      	str	r0, [r7, #4]
   1679e:	6039      	str	r1, [r7, #0]
#if CONFIG_NRF_SW_LPUART_INT_DRIVEN
	return api_fifo_read(dev, p_char, 1) ? 0 : -1;
   167a0:	2201      	movs	r2, #1
   167a2:	6839      	ldr	r1, [r7, #0]
   167a4:	6878      	ldr	r0, [r7, #4]
   167a6:	f7ff fe7f 	bl	164a8 <api_fifo_read>
   167aa:	4603      	mov	r3, r0
   167ac:	2b00      	cmp	r3, #0
   167ae:	d001      	beq.n	167b4 <api_poll_in+0x1e>
   167b0:	2300      	movs	r3, #0
   167b2:	e001      	b.n	167b8 <api_poll_in+0x22>
   167b4:	f04f 33ff 	mov.w	r3, #4294967295
#else
	return -ENOTSUP;
#endif
}
   167b8:	4618      	mov	r0, r3
   167ba:	3708      	adds	r7, #8
   167bc:	46bd      	mov	sp, r7
   167be:	bd80      	pop	{r7, pc}

000167c0 <api_poll_out>:

static void api_poll_out(const struct device *dev, unsigned char out_char)
{
   167c0:	b580      	push	{r7, lr}
   167c2:	b086      	sub	sp, #24
   167c4:	af00      	add	r7, sp, #0
   167c6:	6078      	str	r0, [r7, #4]
   167c8:	460b      	mov	r3, r1
   167ca:	70fb      	strb	r3, [r7, #3]
	struct lpuart_data *data = get_dev_data(dev);
   167cc:	6878      	ldr	r0, [r7, #4]
   167ce:	f7ff fd7c 	bl	162ca <get_dev_data>
   167d2:	6178      	str	r0, [r7, #20]
	bool thread_ctx = !k_is_in_isr() && !k_is_pre_kernel();
   167d4:	f001 fc06 	bl	17fe4 <k_is_in_isr>
   167d8:	4603      	mov	r3, r0
   167da:	f083 0301 	eor.w	r3, r3, #1
   167de:	b2db      	uxtb	r3, r3
   167e0:	2b00      	cmp	r3, #0
   167e2:	d009      	beq.n	167f8 <api_poll_out+0x38>
   167e4:	f7f1 fa8a 	bl	7cfc <k_is_pre_kernel>
   167e8:	4603      	mov	r3, r0
   167ea:	f083 0301 	eor.w	r3, r3, #1
   167ee:	b2db      	uxtb	r3, r3
   167f0:	2b00      	cmp	r3, #0
   167f2:	d001      	beq.n	167f8 <api_poll_out+0x38>
   167f4:	2301      	movs	r3, #1
   167f6:	e000      	b.n	167fa <api_poll_out+0x3a>
   167f8:	2300      	movs	r3, #0
   167fa:	74fb      	strb	r3, [r7, #19]
   167fc:	7cfb      	ldrb	r3, [r7, #19]
   167fe:	f003 0301 	and.w	r3, r3, #1
   16802:	74fb      	strb	r3, [r7, #19]
	int err;

	if (thread_ctx) {
   16804:	7cfb      	ldrb	r3, [r7, #19]
   16806:	2b00      	cmp	r3, #0
   16808:	d008      	beq.n	1681c <api_poll_out+0x5c>
		/* in thread context pend until tx is in idle */
		while (data->tx_buf) {
   1680a:	e002      	b.n	16812 <api_poll_out+0x52>
			k_msleep(1);
   1680c:	2001      	movs	r0, #1
   1680e:	f7ff f9f0 	bl	15bf2 <k_msleep>
		while (data->tx_buf) {
   16812:	697b      	ldr	r3, [r7, #20]
   16814:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   16816:	2b00      	cmp	r3, #0
   16818:	d1f8      	bne.n	1680c <api_poll_out+0x4c>
   1681a:	e003      	b.n	16824 <api_poll_out+0x64>
		}
	} else if (data->tx_buf) {
   1681c:	697b      	ldr	r3, [r7, #20]
   1681e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   16820:	2b00      	cmp	r3, #0
   16822:	d11f      	bne.n	16864 <api_poll_out+0xa4>
		return;
	}

	if (!atomic_cas(&data->txbyte, -1, out_char)) {
   16824:	697b      	ldr	r3, [r7, #20]
   16826:	3368      	adds	r3, #104	; 0x68
   16828:	78fa      	ldrb	r2, [r7, #3]
   1682a:	f04f 31ff 	mov.w	r1, #4294967295
   1682e:	4618      	mov	r0, r3
   16830:	f7ff f86b 	bl	1590a <atomic_cas>
   16834:	4603      	mov	r3, r0
   16836:	f083 0301 	eor.w	r3, r3, #1
   1683a:	b2db      	uxtb	r3, r3
   1683c:	2b00      	cmp	r3, #0
   1683e:	d113      	bne.n	16868 <api_poll_out+0xa8>
		return;
	}

	err = api_tx(dev, (uint8_t *)&data->txbyte, 1,
   16840:	697b      	ldr	r3, [r7, #20]
   16842:	f103 0168 	add.w	r1, r3, #104	; 0x68
   16846:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1684a:	2201      	movs	r2, #1
   1684c:	6878      	ldr	r0, [r7, #4]
   1684e:	f7f2 fb5d 	bl	8f0c <api_tx>
   16852:	60f8      	str	r0, [r7, #12]
		     CONFIG_NRF_SW_LPUART_DEFAULT_TX_TIMEOUT);
	if (err < 0) {
   16854:	68fb      	ldr	r3, [r7, #12]
   16856:	2b00      	cmp	r3, #0
   16858:	da07      	bge.n	1686a <api_poll_out+0xaa>
		data->txbyte = -1;
   1685a:	697b      	ldr	r3, [r7, #20]
   1685c:	f04f 32ff 	mov.w	r2, #4294967295
   16860:	669a      	str	r2, [r3, #104]	; 0x68
   16862:	e002      	b.n	1686a <api_poll_out+0xaa>
		return;
   16864:	bf00      	nop
   16866:	e000      	b.n	1686a <api_poll_out+0xaa>
		return;
   16868:	bf00      	nop
	}
}
   1686a:	3718      	adds	r7, #24
   1686c:	46bd      	mov	sp, r7
   1686e:	bd80      	pop	{r7, pc}

00016870 <api_configure>:

static int api_configure(const struct device *dev, const struct uart_config *cfg)
{
   16870:	b580      	push	{r7, lr}
   16872:	b084      	sub	sp, #16
   16874:	af00      	add	r7, sp, #0
   16876:	6078      	str	r0, [r7, #4]
   16878:	6039      	str	r1, [r7, #0]
	const struct lpuart_data *data = get_dev_data(dev);
   1687a:	6878      	ldr	r0, [r7, #4]
   1687c:	f7ff fd25 	bl	162ca <get_dev_data>
   16880:	60f8      	str	r0, [r7, #12]

	if (cfg->flow_ctrl != UART_CFG_FLOW_CTRL_NONE) {
   16882:	683b      	ldr	r3, [r7, #0]
   16884:	79db      	ldrb	r3, [r3, #7]
   16886:	2b00      	cmp	r3, #0
   16888:	d002      	beq.n	16890 <api_configure+0x20>
		return -ENOTSUP;
   1688a:	f06f 0322 	mvn.w	r3, #34	; 0x22
   1688e:	e006      	b.n	1689e <api_configure+0x2e>
	}

	return uart_configure(data->uart, cfg);
   16890:	68fb      	ldr	r3, [r7, #12]
   16892:	681b      	ldr	r3, [r3, #0]
   16894:	6839      	ldr	r1, [r7, #0]
   16896:	4618      	mov	r0, r3
   16898:	f7ff fb10 	bl	15ebc <uart_configure>
   1689c:	4603      	mov	r3, r0
}
   1689e:	4618      	mov	r0, r3
   168a0:	3710      	adds	r7, #16
   168a2:	46bd      	mov	sp, r7
   168a4:	bd80      	pop	{r7, pc}

000168a6 <api_config_get>:

static int api_config_get(const struct device *dev, struct uart_config *cfg)
{
   168a6:	b580      	push	{r7, lr}
   168a8:	b084      	sub	sp, #16
   168aa:	af00      	add	r7, sp, #0
   168ac:	6078      	str	r0, [r7, #4]
   168ae:	6039      	str	r1, [r7, #0]
	const struct lpuart_data *data = get_dev_data(dev);
   168b0:	6878      	ldr	r0, [r7, #4]
   168b2:	f7ff fd0a 	bl	162ca <get_dev_data>
   168b6:	60f8      	str	r0, [r7, #12]

	return uart_config_get(data->uart, cfg);
   168b8:	68fb      	ldr	r3, [r7, #12]
   168ba:	681b      	ldr	r3, [r3, #0]
   168bc:	6839      	ldr	r1, [r7, #0]
   168be:	4618      	mov	r0, r3
   168c0:	f7ff fb0a 	bl	15ed8 <uart_config_get>
   168c4:	4603      	mov	r3, r0
}
   168c6:	4618      	mov	r0, r3
   168c8:	3710      	adds	r7, #16
   168ca:	46bd      	mov	sp, r7
   168cc:	bd80      	pop	{r7, pc}

000168ce <_is_user_context>:
{
   168ce:	b480      	push	{r7}
   168d0:	af00      	add	r7, sp, #0
	return false;
   168d2:	2300      	movs	r3, #0
}
   168d4:	4618      	mov	r0, r3
   168d6:	46bd      	mov	sp, r7
   168d8:	bc80      	pop	{r7}
   168da:	4770      	bx	lr

000168dc <log_panic>:
{
   168dc:	b580      	push	{r7, lr}
   168de:	af00      	add	r7, sp, #0
	z_impl_log_panic();
   168e0:	f7eb fe52 	bl	2588 <z_impl_log_panic>
}
   168e4:	bf00      	nop
   168e6:	bd80      	pop	{r7, pc}

000168e8 <k_busy_wait>:
{
   168e8:	b580      	push	{r7, lr}
   168ea:	b082      	sub	sp, #8
   168ec:	af00      	add	r7, sp, #0
   168ee:	6078      	str	r0, [r7, #4]
	z_impl_k_busy_wait(usec_to_wait);
   168f0:	6878      	ldr	r0, [r7, #4]
   168f2:	f001 fb88 	bl	18006 <z_impl_k_busy_wait>
}
   168f6:	bf00      	nop
   168f8:	3708      	adds	r7, #8
   168fa:	46bd      	mov	sp, r7
   168fc:	bd80      	pop	{r7, pc}

000168fe <nrfx_isr>:
{
   168fe:	b580      	push	{r7, lr}
   16900:	b082      	sub	sp, #8
   16902:	af00      	add	r7, sp, #0
   16904:	6078      	str	r0, [r7, #4]
	((nrfx_irq_handler_t)irq_handler)();
   16906:	687b      	ldr	r3, [r7, #4]
   16908:	4798      	blx	r3
}
   1690a:	bf00      	nop
   1690c:	3708      	adds	r7, #8
   1690e:	46bd      	mov	sp, r7
   16910:	bd80      	pop	{r7, pc}

00016912 <nrfx_busy_wait>:
{
   16912:	b580      	push	{r7, lr}
   16914:	b082      	sub	sp, #8
   16916:	af00      	add	r7, sp, #0
   16918:	6078      	str	r0, [r7, #4]
	k_busy_wait(usec_to_wait);
   1691a:	6878      	ldr	r0, [r7, #4]
   1691c:	f7ff ffe4 	bl	168e8 <k_busy_wait>
}
   16920:	bf00      	nop
   16922:	3708      	adds	r7, #8
   16924:	46bd      	mov	sp, r7
   16926:	bd80      	pop	{r7, pc}

00016928 <nrfx_get_irq_number>:
{
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
   16928:	b480      	push	{r7}
   1692a:	b083      	sub	sp, #12
   1692c:	af00      	add	r7, sp, #0
   1692e:	6078      	str	r0, [r7, #4]
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   16930:	687b      	ldr	r3, [r7, #4]
   16932:	0b1b      	lsrs	r3, r3, #12
   16934:	b25b      	sxtb	r3, r3
}
   16936:	4618      	mov	r0, r3
   16938:	370c      	adds	r7, #12
   1693a:	46bd      	mov	sp, r7
   1693c:	bc80      	pop	{r7}
   1693e:	4770      	bx	lr

00016940 <nrf_event_readback>:
{
   16940:	b480      	push	{r7}
   16942:	b083      	sub	sp, #12
   16944:	af00      	add	r7, sp, #0
   16946:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   16948:	687b      	ldr	r3, [r7, #4]
   1694a:	681b      	ldr	r3, [r3, #0]
}
   1694c:	bf00      	nop
   1694e:	370c      	adds	r7, #12
   16950:	46bd      	mov	sp, r7
   16952:	bc80      	pop	{r7}
   16954:	4770      	bx	lr

00016956 <nrf_clock_int_enable>:
{
   16956:	b480      	push	{r7}
   16958:	b083      	sub	sp, #12
   1695a:	af00      	add	r7, sp, #0
   1695c:	6078      	str	r0, [r7, #4]
   1695e:	6039      	str	r1, [r7, #0]
    p_reg->INTENSET = mask;
   16960:	687b      	ldr	r3, [r7, #4]
   16962:	683a      	ldr	r2, [r7, #0]
   16964:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   16968:	bf00      	nop
   1696a:	370c      	adds	r7, #12
   1696c:	46bd      	mov	sp, r7
   1696e:	bc80      	pop	{r7}
   16970:	4770      	bx	lr

00016972 <nrf_clock_int_disable>:
{
   16972:	b480      	push	{r7}
   16974:	b083      	sub	sp, #12
   16976:	af00      	add	r7, sp, #0
   16978:	6078      	str	r0, [r7, #4]
   1697a:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   1697c:	687b      	ldr	r3, [r7, #4]
   1697e:	683a      	ldr	r2, [r7, #0]
   16980:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   16984:	bf00      	nop
   16986:	370c      	adds	r7, #12
   16988:	46bd      	mov	sp, r7
   1698a:	bc80      	pop	{r7}
   1698c:	4770      	bx	lr

0001698e <nrf_clock_task_trigger>:
{
   1698e:	b480      	push	{r7}
   16990:	b083      	sub	sp, #12
   16992:	af00      	add	r7, sp, #0
   16994:	6078      	str	r0, [r7, #4]
   16996:	460b      	mov	r3, r1
   16998:	70fb      	strb	r3, [r7, #3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1699a:	78fb      	ldrb	r3, [r7, #3]
   1699c:	687a      	ldr	r2, [r7, #4]
   1699e:	4413      	add	r3, r2
   169a0:	2201      	movs	r2, #1
   169a2:	601a      	str	r2, [r3, #0]
}
   169a4:	bf00      	nop
   169a6:	370c      	adds	r7, #12
   169a8:	46bd      	mov	sp, r7
   169aa:	bc80      	pop	{r7}
   169ac:	4770      	bx	lr

000169ae <nrf_clock_event_clear>:
{
   169ae:	b580      	push	{r7, lr}
   169b0:	b082      	sub	sp, #8
   169b2:	af00      	add	r7, sp, #0
   169b4:	6078      	str	r0, [r7, #4]
   169b6:	460b      	mov	r3, r1
   169b8:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   169ba:	887b      	ldrh	r3, [r7, #2]
   169bc:	687a      	ldr	r2, [r7, #4]
   169be:	4413      	add	r3, r2
   169c0:	2200      	movs	r2, #0
   169c2:	601a      	str	r2, [r3, #0]
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
   169c4:	887b      	ldrh	r3, [r7, #2]
   169c6:	687a      	ldr	r2, [r7, #4]
   169c8:	4413      	add	r3, r2
   169ca:	4618      	mov	r0, r3
   169cc:	f7ff ffb8 	bl	16940 <nrf_event_readback>
}
   169d0:	bf00      	nop
   169d2:	3708      	adds	r7, #8
   169d4:	46bd      	mov	sp, r7
   169d6:	bd80      	pop	{r7, pc}

000169d8 <nrf_clock_event_check>:
{
   169d8:	b480      	push	{r7}
   169da:	b083      	sub	sp, #12
   169dc:	af00      	add	r7, sp, #0
   169de:	6078      	str	r0, [r7, #4]
   169e0:	460b      	mov	r3, r1
   169e2:	807b      	strh	r3, [r7, #2]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   169e4:	887b      	ldrh	r3, [r7, #2]
   169e6:	687a      	ldr	r2, [r7, #4]
   169e8:	4413      	add	r3, r2
   169ea:	681b      	ldr	r3, [r3, #0]
   169ec:	2b00      	cmp	r3, #0
   169ee:	bf14      	ite	ne
   169f0:	2301      	movne	r3, #1
   169f2:	2300      	moveq	r3, #0
   169f4:	b2db      	uxtb	r3, r3
}
   169f6:	4618      	mov	r0, r3
   169f8:	370c      	adds	r7, #12
   169fa:	46bd      	mov	sp, r7
   169fc:	bc80      	pop	{r7}
   169fe:	4770      	bx	lr

00016a00 <nrf_clock_lf_src_set>:
{
   16a00:	b480      	push	{r7}
   16a02:	b083      	sub	sp, #12
   16a04:	af00      	add	r7, sp, #0
   16a06:	6078      	str	r0, [r7, #4]
   16a08:	460b      	mov	r3, r1
   16a0a:	70fb      	strb	r3, [r7, #3]
    p_reg->LFCLKSRC = (uint32_t)(source);
   16a0c:	78fa      	ldrb	r2, [r7, #3]
   16a0e:	687b      	ldr	r3, [r7, #4]
   16a10:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   16a14:	bf00      	nop
   16a16:	370c      	adds	r7, #12
   16a18:	46bd      	mov	sp, r7
   16a1a:	bc80      	pop	{r7}
   16a1c:	4770      	bx	lr

00016a1e <nrfx_power_clock_irq_init>:
extern "C" {
#endif


__STATIC_INLINE void nrfx_power_clock_irq_init(void)
{
   16a1e:	b580      	push	{r7, lr}
   16a20:	b082      	sub	sp, #8
   16a22:	af00      	add	r7, sp, #0
    #endif
    priority = NRFX_POWER_DEFAULT_CONFIG_IRQ_PRIORITY;
#elif NRFX_CHECK(NRFX_POWER_ENABLED)
    priority = NRFX_POWER_DEFAULT_CONFIG_IRQ_PRIORITY;
#elif NRFX_CHECK(NRFX_CLOCK_ENABLED)
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
   16a24:	2307      	movs	r3, #7
   16a26:	71fb      	strb	r3, [r7, #7]
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   16a28:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
   16a2c:	f7ff ff7c 	bl	16928 <nrfx_get_irq_number>
   16a30:	4603      	mov	r3, r0
   16a32:	4618      	mov	r0, r3
   16a34:	f7ee f84e 	bl	4ad4 <arch_irq_is_enabled>
   16a38:	4603      	mov	r3, r0
   16a3a:	2b00      	cmp	r3, #0
   16a3c:	d107      	bne.n	16a4e <nrfx_power_clock_irq_init+0x30>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   16a3e:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
   16a42:	f7ff ff71 	bl	16928 <nrfx_get_irq_number>
   16a46:	4603      	mov	r3, r0
   16a48:	4618      	mov	r0, r3
   16a4a:	f7fc f998 	bl	12d7e <arch_irq_enable>
    }
}
   16a4e:	bf00      	nop
   16a50:	3708      	adds	r7, #8
   16a52:	46bd      	mov	sp, r7
   16a54:	bd80      	pop	{r7, pc}

00016a56 <nrfx_clock_is_running>:
{
   16a56:	b580      	push	{r7, lr}
   16a58:	b082      	sub	sp, #8
   16a5a:	af00      	add	r7, sp, #0
   16a5c:	4603      	mov	r3, r0
   16a5e:	6039      	str	r1, [r7, #0]
   16a60:	71fb      	strb	r3, [r7, #7]
    return nrf_clock_is_running(NRF_CLOCK, domain, p_clk_src);
   16a62:	79fb      	ldrb	r3, [r7, #7]
   16a64:	683a      	ldr	r2, [r7, #0]
   16a66:	4619      	mov	r1, r3
   16a68:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
   16a6c:	f7f3 f854 	bl	9b18 <nrf_clock_is_running>
   16a70:	4603      	mov	r3, r0
}
   16a72:	4618      	mov	r0, r3
   16a74:	3708      	adds	r7, #8
   16a76:	46bd      	mov	sp, r7
   16a78:	bd80      	pop	{r7, pc}

00016a7a <_is_user_context>:
{
   16a7a:	b480      	push	{r7}
   16a7c:	af00      	add	r7, sp, #0
	return false;
   16a7e:	2300      	movs	r3, #0
}
   16a80:	4618      	mov	r0, r3
   16a82:	46bd      	mov	sp, r7
   16a84:	bc80      	pop	{r7}
   16a86:	4770      	bx	lr

00016a88 <nrf_dppi_channels_enable>:
{
   16a88:	b480      	push	{r7}
   16a8a:	b083      	sub	sp, #12
   16a8c:	af00      	add	r7, sp, #0
   16a8e:	6078      	str	r0, [r7, #4]
   16a90:	6039      	str	r1, [r7, #0]
    p_reg->CHENSET = mask;
   16a92:	687b      	ldr	r3, [r7, #4]
   16a94:	683a      	ldr	r2, [r7, #0]
   16a96:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   16a9a:	bf00      	nop
   16a9c:	370c      	adds	r7, #12
   16a9e:	46bd      	mov	sp, r7
   16aa0:	bc80      	pop	{r7}
   16aa2:	4770      	bx	lr

00016aa4 <_is_user_context>:
{
   16aa4:	b480      	push	{r7}
   16aa6:	af00      	add	r7, sp, #0
	return false;
   16aa8:	2300      	movs	r3, #0
}
   16aaa:	4618      	mov	r0, r3
   16aac:	46bd      	mov	sp, r7
   16aae:	bc80      	pop	{r7}
   16ab0:	4770      	bx	lr

00016ab2 <nrfx_get_irq_number>:
{
   16ab2:	b480      	push	{r7}
   16ab4:	b083      	sub	sp, #12
   16ab6:	af00      	add	r7, sp, #0
   16ab8:	6078      	str	r0, [r7, #4]
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   16aba:	687b      	ldr	r3, [r7, #4]
   16abc:	0b1b      	lsrs	r3, r3, #12
   16abe:	b25b      	sxtb	r3, r3
}
   16ac0:	4618      	mov	r0, r3
   16ac2:	370c      	adds	r7, #12
   16ac4:	46bd      	mov	sp, r7
   16ac6:	bc80      	pop	{r7}
   16ac8:	4770      	bx	lr

00016aca <nrf_event_readback>:
{
   16aca:	b480      	push	{r7}
   16acc:	b083      	sub	sp, #12
   16ace:	af00      	add	r7, sp, #0
   16ad0:	6078      	str	r0, [r7, #4]
    (void)*((volatile uint32_t *)(p_event_reg));
   16ad2:	687b      	ldr	r3, [r7, #4]
   16ad4:	681b      	ldr	r3, [r3, #0]
}
   16ad6:	bf00      	nop
   16ad8:	370c      	adds	r7, #12
   16ada:	46bd      	mov	sp, r7
   16adc:	bc80      	pop	{r7}
   16ade:	4770      	bx	lr

00016ae0 <nrf_timer_task_trigger>:
{
   16ae0:	b480      	push	{r7}
   16ae2:	b083      	sub	sp, #12
   16ae4:	af00      	add	r7, sp, #0
   16ae6:	6078      	str	r0, [r7, #4]
   16ae8:	460b      	mov	r3, r1
   16aea:	70fb      	strb	r3, [r7, #3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   16aec:	78fb      	ldrb	r3, [r7, #3]
   16aee:	687a      	ldr	r2, [r7, #4]
   16af0:	4413      	add	r3, r2
   16af2:	2201      	movs	r2, #1
   16af4:	601a      	str	r2, [r3, #0]
}
   16af6:	bf00      	nop
   16af8:	370c      	adds	r7, #12
   16afa:	46bd      	mov	sp, r7
   16afc:	bc80      	pop	{r7}
   16afe:	4770      	bx	lr

00016b00 <nrf_timer_event_clear>:
{
   16b00:	b580      	push	{r7, lr}
   16b02:	b082      	sub	sp, #8
   16b04:	af00      	add	r7, sp, #0
   16b06:	6078      	str	r0, [r7, #4]
   16b08:	460b      	mov	r3, r1
   16b0a:	807b      	strh	r3, [r7, #2]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   16b0c:	887b      	ldrh	r3, [r7, #2]
   16b0e:	687a      	ldr	r2, [r7, #4]
   16b10:	4413      	add	r3, r2
   16b12:	2200      	movs	r2, #0
   16b14:	601a      	str	r2, [r3, #0]
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
   16b16:	887b      	ldrh	r3, [r7, #2]
   16b18:	687a      	ldr	r2, [r7, #4]
   16b1a:	4413      	add	r3, r2
   16b1c:	4618      	mov	r0, r3
   16b1e:	f7ff ffd4 	bl	16aca <nrf_event_readback>
}
   16b22:	bf00      	nop
   16b24:	3708      	adds	r7, #8
   16b26:	46bd      	mov	sp, r7
   16b28:	bd80      	pop	{r7, pc}

00016b2a <nrf_timer_shorts_disable>:
{
   16b2a:	b480      	push	{r7}
   16b2c:	b083      	sub	sp, #12
   16b2e:	af00      	add	r7, sp, #0
   16b30:	6078      	str	r0, [r7, #4]
   16b32:	6039      	str	r1, [r7, #0]
    p_reg->SHORTS &= ~(mask);
   16b34:	687b      	ldr	r3, [r7, #4]
   16b36:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   16b3a:	683b      	ldr	r3, [r7, #0]
   16b3c:	43db      	mvns	r3, r3
   16b3e:	401a      	ands	r2, r3
   16b40:	687b      	ldr	r3, [r7, #4]
   16b42:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   16b46:	bf00      	nop
   16b48:	370c      	adds	r7, #12
   16b4a:	46bd      	mov	sp, r7
   16b4c:	bc80      	pop	{r7}
   16b4e:	4770      	bx	lr

00016b50 <nrf_timer_int_disable>:
{
   16b50:	b480      	push	{r7}
   16b52:	b083      	sub	sp, #12
   16b54:	af00      	add	r7, sp, #0
   16b56:	6078      	str	r0, [r7, #4]
   16b58:	6039      	str	r1, [r7, #0]
    p_reg->INTENCLR = mask;
   16b5a:	687b      	ldr	r3, [r7, #4]
   16b5c:	683a      	ldr	r2, [r7, #0]
   16b5e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   16b62:	bf00      	nop
   16b64:	370c      	adds	r7, #12
   16b66:	46bd      	mov	sp, r7
   16b68:	bc80      	pop	{r7}
   16b6a:	4770      	bx	lr

00016b6c <nrf_timer_mode_set>:
}
#endif // defined(DPPI_PRESENT)

NRF_STATIC_INLINE void nrf_timer_mode_set(NRF_TIMER_Type * p_reg,
                                          nrf_timer_mode_t mode)
{
   16b6c:	b480      	push	{r7}
   16b6e:	b083      	sub	sp, #12
   16b70:	af00      	add	r7, sp, #0
   16b72:	6078      	str	r0, [r7, #4]
   16b74:	460b      	mov	r3, r1
   16b76:	70fb      	strb	r3, [r7, #3]
    p_reg->MODE = (p_reg->MODE & ~TIMER_MODE_MODE_Msk) |
   16b78:	687b      	ldr	r3, [r7, #4]
   16b7a:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
   16b7e:	f023 0203 	bic.w	r2, r3, #3
                    ((mode << TIMER_MODE_MODE_Pos) & TIMER_MODE_MODE_Msk);
   16b82:	78fb      	ldrb	r3, [r7, #3]
   16b84:	f003 0303 	and.w	r3, r3, #3
    p_reg->MODE = (p_reg->MODE & ~TIMER_MODE_MODE_Msk) |
   16b88:	431a      	orrs	r2, r3
   16b8a:	687b      	ldr	r3, [r7, #4]
   16b8c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   16b90:	bf00      	nop
   16b92:	370c      	adds	r7, #12
   16b94:	46bd      	mov	sp, r7
   16b96:	bc80      	pop	{r7}
   16b98:	4770      	bx	lr

00016b9a <nrf_timer_bit_width_set>:
    return (nrf_timer_mode_t)(p_reg->MODE);
}

NRF_STATIC_INLINE void nrf_timer_bit_width_set(NRF_TIMER_Type *      p_reg,
                                               nrf_timer_bit_width_t bit_width)
{
   16b9a:	b480      	push	{r7}
   16b9c:	b083      	sub	sp, #12
   16b9e:	af00      	add	r7, sp, #0
   16ba0:	6078      	str	r0, [r7, #4]
   16ba2:	460b      	mov	r3, r1
   16ba4:	70fb      	strb	r3, [r7, #3]
    p_reg->BITMODE = (p_reg->BITMODE & ~TIMER_BITMODE_BITMODE_Msk) |
   16ba6:	687b      	ldr	r3, [r7, #4]
   16ba8:	f8d3 3508 	ldr.w	r3, [r3, #1288]	; 0x508
   16bac:	f023 0203 	bic.w	r2, r3, #3
                       ((bit_width << TIMER_BITMODE_BITMODE_Pos) &
   16bb0:	78fb      	ldrb	r3, [r7, #3]
   16bb2:	f003 0303 	and.w	r3, r3, #3
    p_reg->BITMODE = (p_reg->BITMODE & ~TIMER_BITMODE_BITMODE_Msk) |
   16bb6:	431a      	orrs	r2, r3
   16bb8:	687b      	ldr	r3, [r7, #4]
   16bba:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
                            TIMER_BITMODE_BITMODE_Msk);
}
   16bbe:	bf00      	nop
   16bc0:	370c      	adds	r7, #12
   16bc2:	46bd      	mov	sp, r7
   16bc4:	bc80      	pop	{r7}
   16bc6:	4770      	bx	lr

00016bc8 <nrf_timer_frequency_set>:
    return (nrf_timer_bit_width_t)(p_reg->BITMODE);
}

NRF_STATIC_INLINE void nrf_timer_frequency_set(NRF_TIMER_Type *      p_reg,
                                               nrf_timer_frequency_t frequency)
{
   16bc8:	b480      	push	{r7}
   16bca:	b083      	sub	sp, #12
   16bcc:	af00      	add	r7, sp, #0
   16bce:	6078      	str	r0, [r7, #4]
   16bd0:	460b      	mov	r3, r1
   16bd2:	70fb      	strb	r3, [r7, #3]
    p_reg->PRESCALER = (p_reg->PRESCALER & ~TIMER_PRESCALER_PRESCALER_Msk) |
   16bd4:	687b      	ldr	r3, [r7, #4]
   16bd6:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
   16bda:	f023 020f 	bic.w	r2, r3, #15
                         ((frequency << TIMER_PRESCALER_PRESCALER_Pos) &
   16bde:	78fb      	ldrb	r3, [r7, #3]
   16be0:	f003 030f 	and.w	r3, r3, #15
    p_reg->PRESCALER = (p_reg->PRESCALER & ~TIMER_PRESCALER_PRESCALER_Msk) |
   16be4:	431a      	orrs	r2, r3
   16be6:	687b      	ldr	r3, [r7, #4]
   16be8:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
                              TIMER_PRESCALER_PRESCALER_Msk);
}
   16bec:	bf00      	nop
   16bee:	370c      	adds	r7, #12
   16bf0:	46bd      	mov	sp, r7
   16bf2:	bc80      	pop	{r7}
   16bf4:	4770      	bx	lr

00016bf6 <nrf_timer_cc_get>:
    p_reg->CC[cc_channel] = cc_value;
}

NRF_STATIC_INLINE uint32_t nrf_timer_cc_get(NRF_TIMER_Type const * p_reg,
                                            nrf_timer_cc_channel_t cc_channel)
{
   16bf6:	b480      	push	{r7}
   16bf8:	b083      	sub	sp, #12
   16bfa:	af00      	add	r7, sp, #0
   16bfc:	6078      	str	r0, [r7, #4]
   16bfe:	460b      	mov	r3, r1
   16c00:	70fb      	strb	r3, [r7, #3]
    return (uint32_t)p_reg->CC[cc_channel];
   16c02:	78fa      	ldrb	r2, [r7, #3]
   16c04:	687b      	ldr	r3, [r7, #4]
   16c06:	f502 72a8 	add.w	r2, r2, #336	; 0x150
   16c0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
   16c0e:	4618      	mov	r0, r3
   16c10:	370c      	adds	r7, #12
   16c12:	46bd      	mov	sp, r7
   16c14:	bc80      	pop	{r7}
   16c16:	4770      	bx	lr

00016c18 <nrf_timer_capture_task_get>:

NRF_STATIC_INLINE nrf_timer_task_t nrf_timer_capture_task_get(uint32_t channel)
{
   16c18:	b480      	push	{r7}
   16c1a:	b083      	sub	sp, #12
   16c1c:	af00      	add	r7, sp, #0
   16c1e:	6078      	str	r0, [r7, #4]
    return (nrf_timer_task_t)NRFX_OFFSETOF(NRF_TIMER_Type, TASKS_CAPTURE[channel]);
   16c20:	687b      	ldr	r3, [r7, #4]
   16c22:	009b      	lsls	r3, r3, #2
   16c24:	3340      	adds	r3, #64	; 0x40
   16c26:	b2db      	uxtb	r3, r3
}
   16c28:	4618      	mov	r0, r3
   16c2a:	370c      	adds	r7, #12
   16c2c:	46bd      	mov	sp, r7
   16c2e:	bc80      	pop	{r7}
   16c30:	4770      	bx	lr

00016c32 <nrf_timer_compare_event_get>:

NRF_STATIC_INLINE nrf_timer_event_t nrf_timer_compare_event_get(uint32_t channel)
{
   16c32:	b480      	push	{r7}
   16c34:	b083      	sub	sp, #12
   16c36:	af00      	add	r7, sp, #0
   16c38:	6078      	str	r0, [r7, #4]
    return (nrf_timer_event_t)NRFX_OFFSETOF(NRF_TIMER_Type, EVENTS_COMPARE[channel]);
   16c3a:	687b      	ldr	r3, [r7, #4]
   16c3c:	009b      	lsls	r3, r3, #2
   16c3e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
   16c42:	b29b      	uxth	r3, r3
}
   16c44:	4618      	mov	r0, r3
   16c46:	370c      	adds	r7, #12
   16c48:	46bd      	mov	sp, r7
   16c4a:	bc80      	pop	{r7}
   16c4c:	4770      	bx	lr

00016c4e <_is_user_context>:
{
   16c4e:	b480      	push	{r7}
   16c50:	af00      	add	r7, sp, #0
	return false;
   16c52:	2300      	movs	r3, #0
}
   16c54:	4618      	mov	r0, r3
   16c56:	46bd      	mov	sp, r7
   16c58:	bc80      	pop	{r7}
   16c5a:	4770      	bx	lr

00016c5c <z_object_init>:

/**
 * @internal
 */
static inline void z_object_init(const void *obj)
{
   16c5c:	b480      	push	{r7}
   16c5e:	b083      	sub	sp, #12
   16c60:	af00      	add	r7, sp, #0
   16c62:	6078      	str	r0, [r7, #4]
	ARG_UNUSED(obj);
}
   16c64:	bf00      	nop
   16c66:	370c      	adds	r7, #12
   16c68:	46bd      	mov	sp, r7
   16c6a:	bc80      	pop	{r7}
   16c6c:	4770      	bx	lr

00016c6e <_is_user_context>:
{
   16c6e:	b480      	push	{r7}
   16c70:	af00      	add	r7, sp, #0
	return false;
   16c72:	2300      	movs	r3, #0
}
   16c74:	4618      	mov	r0, r3
   16c76:	46bd      	mov	sp, r7
   16c78:	bc80      	pop	{r7}
   16c7a:	4770      	bx	lr

00016c7c <k_current_get>:
{
   16c7c:	b580      	push	{r7, lr}
   16c7e:	af00      	add	r7, sp, #0
	return z_impl_k_current_get();
   16c80:	f7f7 fb5e 	bl	e340 <z_impl_k_current_get>
   16c84:	4603      	mov	r3, r0
}
   16c86:	4618      	mov	r0, r3
   16c88:	bd80      	pop	{r7, pc}

00016c8a <k_thread_abort>:
{
   16c8a:	b580      	push	{r7, lr}
   16c8c:	b082      	sub	sp, #8
   16c8e:	af00      	add	r7, sp, #0
   16c90:	6078      	str	r0, [r7, #4]
	z_impl_k_thread_abort(thread);
   16c92:	6878      	ldr	r0, [r7, #4]
   16c94:	f7ef fa3a 	bl	610c <z_impl_k_thread_abort>
}
   16c98:	bf00      	nop
   16c9a:	3708      	adds	r7, #8
   16c9c:	46bd      	mov	sp, r7
   16c9e:	bd80      	pop	{r7, pc}

00016ca0 <z_coredump>:

#else

void z_coredump(unsigned int reason, const z_arch_esf_t *esf,
		struct k_thread *thread)
{
   16ca0:	b480      	push	{r7}
   16ca2:	b085      	sub	sp, #20
   16ca4:	af00      	add	r7, sp, #0
   16ca6:	60f8      	str	r0, [r7, #12]
   16ca8:	60b9      	str	r1, [r7, #8]
   16caa:	607a      	str	r2, [r7, #4]
}
   16cac:	bf00      	nop
   16cae:	3714      	adds	r7, #20
   16cb0:	46bd      	mov	sp, r7
   16cb2:	bc80      	pop	{r7}
   16cb4:	4770      	bx	lr

00016cb6 <get_cpu>:
{
   16cb6:	b480      	push	{r7}
   16cb8:	af00      	add	r7, sp, #0
	return 0;
   16cba:	2300      	movs	r3, #0
}
   16cbc:	4618      	mov	r0, r3
   16cbe:	46bd      	mov	sp, r7
   16cc0:	bc80      	pop	{r7}
   16cc2:	4770      	bx	lr

00016cc4 <_is_user_context>:
{
   16cc4:	b480      	push	{r7}
   16cc6:	af00      	add	r7, sp, #0
	return false;
   16cc8:	2300      	movs	r3, #0
}
   16cca:	4618      	mov	r0, r3
   16ccc:	46bd      	mov	sp, r7
   16cce:	bc80      	pop	{r7}
   16cd0:	4770      	bx	lr

00016cd2 <k_cpu_idle>:
{
   16cd2:	b580      	push	{r7, lr}
   16cd4:	af00      	add	r7, sp, #0
	arch_cpu_idle();
   16cd6:	f7ed ffa1 	bl	4c1c <arch_cpu_idle>
}
   16cda:	bf00      	nop
   16cdc:	bd80      	pop	{r7, pc}

00016cde <z_reschedule_unlocked>:
{
   16cde:	b580      	push	{r7, lr}
   16ce0:	b082      	sub	sp, #8
   16ce2:	af00      	add	r7, sp, #0
	__asm__ volatile(
   16ce4:	f04f 0320 	mov.w	r3, #32
   16ce8:	f3ef 8211 	mrs	r2, BASEPRI
   16cec:	f383 8811 	msr	BASEPRI, r3
   16cf0:	f3bf 8f6f 	isb	sy
   16cf4:	607a      	str	r2, [r7, #4]
   16cf6:	603b      	str	r3, [r7, #0]
	return key;
   16cf8:	687b      	ldr	r3, [r7, #4]
	(void) z_reschedule_irqlock(arch_irq_lock());
   16cfa:	4618      	mov	r0, r3
   16cfc:	f000 ffa4 	bl	17c48 <z_reschedule_irqlock>
}
   16d00:	bf00      	nop
   16d02:	3708      	adds	r7, #8
   16d04:	46bd      	mov	sp, r7
   16d06:	bd80      	pop	{r7, pc}

00016d08 <sys_power_save_idle>:
{
   16d08:	b580      	push	{r7, lr}
   16d0a:	b082      	sub	sp, #8
   16d0c:	af00      	add	r7, sp, #0
	int32_t ticks = z_get_next_timeout_expiry();
   16d0e:	f7f8 f9cf 	bl	f0b0 <z_get_next_timeout_expiry>
   16d12:	6078      	str	r0, [r7, #4]
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   16d14:	687b      	ldr	r3, [r7, #4]
   16d16:	2b02      	cmp	r3, #2
   16d18:	dd01      	ble.n	16d1e <sys_power_save_idle+0x16>
   16d1a:	687b      	ldr	r3, [r7, #4]
   16d1c:	e000      	b.n	16d20 <sys_power_save_idle+0x18>
   16d1e:	2301      	movs	r3, #1
   16d20:	2101      	movs	r1, #1
   16d22:	4618      	mov	r0, r3
   16d24:	f7f8 fa36 	bl	f194 <z_set_timeout_expiry>
	set_kernel_idle_time_in_ticks(ticks);
   16d28:	6878      	ldr	r0, [r7, #4]
   16d2a:	f7f4 f8e3 	bl	aef4 <set_kernel_idle_time_in_ticks>
	k_cpu_idle();
   16d2e:	f7ff ffd0 	bl	16cd2 <k_cpu_idle>
}
   16d32:	bf00      	nop
   16d34:	3708      	adds	r7, #8
   16d36:	46bd      	mov	sp, r7
   16d38:	bd80      	pop	{r7, pc}

00016d3a <z_sys_power_save_idle_exit>:
{
   16d3a:	b580      	push	{r7, lr}
   16d3c:	b082      	sub	sp, #8
   16d3e:	af00      	add	r7, sp, #0
   16d40:	6078      	str	r0, [r7, #4]
	z_clock_idle_exit();
   16d42:	f7fb fe97 	bl	12a74 <z_clock_idle_exit>
}
   16d46:	bf00      	nop
   16d48:	3708      	adds	r7, #8
   16d4a:	46bd      	mov	sp, r7
   16d4c:	bd80      	pop	{r7, pc}

00016d4e <sys_dlist_init>:
 *
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
   16d4e:	b480      	push	{r7}
   16d50:	b083      	sub	sp, #12
   16d52:	af00      	add	r7, sp, #0
   16d54:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   16d56:	687b      	ldr	r3, [r7, #4]
   16d58:	687a      	ldr	r2, [r7, #4]
   16d5a:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   16d5c:	687b      	ldr	r3, [r7, #4]
   16d5e:	687a      	ldr	r2, [r7, #4]
   16d60:	605a      	str	r2, [r3, #4]
}
   16d62:	bf00      	nop
   16d64:	370c      	adds	r7, #12
   16d66:	46bd      	mov	sp, r7
   16d68:	bc80      	pop	{r7}
   16d6a:	4770      	bx	lr

00016d6c <Z_KERNEL_STACK_BUFFER>:
		sym[Z_KERNEL_STACK_SIZE_ADJUST(size)]

#define K_KERNEL_STACK_SIZEOF(sym) (sizeof(sym) - K_KERNEL_STACK_RESERVED)

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
   16d6c:	b480      	push	{r7}
   16d6e:	b083      	sub	sp, #12
   16d70:	af00      	add	r7, sp, #0
   16d72:	6078      	str	r0, [r7, #4]
	return (char *)sym + K_KERNEL_STACK_RESERVED;
   16d74:	687b      	ldr	r3, [r7, #4]
}
   16d76:	4618      	mov	r0, r3
   16d78:	370c      	adds	r7, #12
   16d7a:	46bd      	mov	sp, r7
   16d7c:	bc80      	pop	{r7}
   16d7e:	4770      	bx	lr

00016d80 <k_busy_wait>:
{
   16d80:	b580      	push	{r7, lr}
   16d82:	b082      	sub	sp, #8
   16d84:	af00      	add	r7, sp, #0
   16d86:	6078      	str	r0, [r7, #4]
	z_impl_k_busy_wait(usec_to_wait);
   16d88:	6878      	ldr	r0, [r7, #4]
   16d8a:	f001 f93c 	bl	18006 <z_impl_k_busy_wait>
}
   16d8e:	bf00      	nop
   16d90:	3708      	adds	r7, #8
   16d92:	46bd      	mov	sp, r7
   16d94:	bd80      	pop	{r7, pc}

00016d96 <z_mark_thread_as_started>:
{
   16d96:	b480      	push	{r7}
   16d98:	b083      	sub	sp, #12
   16d9a:	af00      	add	r7, sp, #0
   16d9c:	6078      	str	r0, [r7, #4]
	thread->base.thread_state &= ~_THREAD_PRESTART;
   16d9e:	687b      	ldr	r3, [r7, #4]
   16da0:	7b5b      	ldrb	r3, [r3, #13]
   16da2:	f023 0304 	bic.w	r3, r3, #4
   16da6:	b2da      	uxtb	r2, r3
   16da8:	687b      	ldr	r3, [r7, #4]
   16daa:	735a      	strb	r2, [r3, #13]
}
   16dac:	bf00      	nop
   16dae:	370c      	adds	r7, #12
   16db0:	46bd      	mov	sp, r7
   16db2:	bc80      	pop	{r7}
   16db4:	4770      	bx	lr

00016db6 <gcov_static_init>:
#ifdef CONFIG_COVERAGE_GCOV
void gcov_coverage_dump(void);
void gcov_static_init(void);
#else
static inline void gcov_coverage_dump(void) { }
static inline void gcov_static_init(void) { }
   16db6:	b480      	push	{r7}
   16db8:	af00      	add	r7, sp, #0
   16dba:	bf00      	nop
   16dbc:	46bd      	mov	sp, r7
   16dbe:	bc80      	pop	{r7}
   16dc0:	4770      	bx	lr

00016dc2 <sys_dlist_init>:
{
   16dc2:	b480      	push	{r7}
   16dc4:	b083      	sub	sp, #12
   16dc6:	af00      	add	r7, sp, #0
   16dc8:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   16dca:	687b      	ldr	r3, [r7, #4]
   16dcc:	687a      	ldr	r2, [r7, #4]
   16dce:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   16dd0:	687b      	ldr	r3, [r7, #4]
   16dd2:	687a      	ldr	r2, [r7, #4]
   16dd4:	605a      	str	r2, [r3, #4]
}
   16dd6:	bf00      	nop
   16dd8:	370c      	adds	r7, #12
   16dda:	46bd      	mov	sp, r7
   16ddc:	bc80      	pop	{r7}
   16dde:	4770      	bx	lr

00016de0 <z_object_init>:
{
   16de0:	b480      	push	{r7}
   16de2:	b083      	sub	sp, #12
   16de4:	af00      	add	r7, sp, #0
   16de6:	6078      	str	r0, [r7, #4]
}
   16de8:	bf00      	nop
   16dea:	370c      	adds	r7, #12
   16dec:	46bd      	mov	sp, r7
   16dee:	bc80      	pop	{r7}
   16df0:	4770      	bx	lr

00016df2 <z_waitq_init>:
#define _WAIT_Q_FOR_EACH(wq, thread_ptr) \
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
   16df2:	b580      	push	{r7, lr}
   16df4:	b082      	sub	sp, #8
   16df6:	af00      	add	r7, sp, #0
   16df8:	6078      	str	r0, [r7, #4]
	sys_dlist_init(&w->waitq);
   16dfa:	687b      	ldr	r3, [r7, #4]
   16dfc:	4618      	mov	r0, r3
   16dfe:	f7ff ffe0 	bl	16dc2 <sys_dlist_init>
}
   16e02:	bf00      	nop
   16e04:	3708      	adds	r7, #8
   16e06:	46bd      	mov	sp, r7
   16e08:	bd80      	pop	{r7, pc}

00016e0a <create_free_list>:
{
   16e0a:	b480      	push	{r7}
   16e0c:	b085      	sub	sp, #20
   16e0e:	af00      	add	r7, sp, #0
   16e10:	6078      	str	r0, [r7, #4]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   16e12:	687b      	ldr	r3, [r7, #4]
   16e14:	68db      	ldr	r3, [r3, #12]
   16e16:	687a      	ldr	r2, [r7, #4]
   16e18:	6912      	ldr	r2, [r2, #16]
   16e1a:	4313      	orrs	r3, r2
   16e1c:	f003 0303 	and.w	r3, r3, #3
   16e20:	2b00      	cmp	r3, #0
   16e22:	d002      	beq.n	16e2a <create_free_list+0x20>
		return -EINVAL;
   16e24:	f06f 0315 	mvn.w	r3, #21
   16e28:	e01d      	b.n	16e66 <create_free_list+0x5c>
	slab->free_list = NULL;
   16e2a:	687b      	ldr	r3, [r7, #4]
   16e2c:	2200      	movs	r2, #0
   16e2e:	615a      	str	r2, [r3, #20]
	p = slab->buffer;
   16e30:	687b      	ldr	r3, [r7, #4]
   16e32:	691b      	ldr	r3, [r3, #16]
   16e34:	60bb      	str	r3, [r7, #8]
	for (j = 0U; j < slab->num_blocks; j++) {
   16e36:	2300      	movs	r3, #0
   16e38:	60fb      	str	r3, [r7, #12]
   16e3a:	e00e      	b.n	16e5a <create_free_list+0x50>
		*(char **)p = slab->free_list;
   16e3c:	687b      	ldr	r3, [r7, #4]
   16e3e:	695a      	ldr	r2, [r3, #20]
   16e40:	68bb      	ldr	r3, [r7, #8]
   16e42:	601a      	str	r2, [r3, #0]
		slab->free_list = p;
   16e44:	687b      	ldr	r3, [r7, #4]
   16e46:	68ba      	ldr	r2, [r7, #8]
   16e48:	615a      	str	r2, [r3, #20]
		p += slab->block_size;
   16e4a:	687b      	ldr	r3, [r7, #4]
   16e4c:	68db      	ldr	r3, [r3, #12]
   16e4e:	68ba      	ldr	r2, [r7, #8]
   16e50:	4413      	add	r3, r2
   16e52:	60bb      	str	r3, [r7, #8]
	for (j = 0U; j < slab->num_blocks; j++) {
   16e54:	68fb      	ldr	r3, [r7, #12]
   16e56:	3301      	adds	r3, #1
   16e58:	60fb      	str	r3, [r7, #12]
   16e5a:	687b      	ldr	r3, [r7, #4]
   16e5c:	689b      	ldr	r3, [r3, #8]
   16e5e:	68fa      	ldr	r2, [r7, #12]
   16e60:	429a      	cmp	r2, r3
   16e62:	d3eb      	bcc.n	16e3c <create_free_list+0x32>
	return 0;
   16e64:	2300      	movs	r3, #0
}
   16e66:	4618      	mov	r0, r3
   16e68:	3714      	adds	r7, #20
   16e6a:	46bd      	mov	sp, r7
   16e6c:	bc80      	pop	{r7}
   16e6e:	4770      	bx	lr

00016e70 <k_mem_slab_init>:
{
   16e70:	b580      	push	{r7, lr}
   16e72:	b086      	sub	sp, #24
   16e74:	af00      	add	r7, sp, #0
   16e76:	60f8      	str	r0, [r7, #12]
   16e78:	60b9      	str	r1, [r7, #8]
   16e7a:	607a      	str	r2, [r7, #4]
   16e7c:	603b      	str	r3, [r7, #0]
	int rc = 0;
   16e7e:	2300      	movs	r3, #0
   16e80:	617b      	str	r3, [r7, #20]
	slab->num_blocks = num_blocks;
   16e82:	68fb      	ldr	r3, [r7, #12]
   16e84:	683a      	ldr	r2, [r7, #0]
   16e86:	609a      	str	r2, [r3, #8]
	slab->block_size = block_size;
   16e88:	68fb      	ldr	r3, [r7, #12]
   16e8a:	687a      	ldr	r2, [r7, #4]
   16e8c:	60da      	str	r2, [r3, #12]
	slab->buffer = buffer;
   16e8e:	68fb      	ldr	r3, [r7, #12]
   16e90:	68ba      	ldr	r2, [r7, #8]
   16e92:	611a      	str	r2, [r3, #16]
	slab->num_used = 0U;
   16e94:	68fb      	ldr	r3, [r7, #12]
   16e96:	2200      	movs	r2, #0
   16e98:	619a      	str	r2, [r3, #24]
	rc = create_free_list(slab);
   16e9a:	68f8      	ldr	r0, [r7, #12]
   16e9c:	f7ff ffb5 	bl	16e0a <create_free_list>
   16ea0:	6178      	str	r0, [r7, #20]
	if (rc < 0) {
   16ea2:	697b      	ldr	r3, [r7, #20]
   16ea4:	2b00      	cmp	r3, #0
   16ea6:	db07      	blt.n	16eb8 <k_mem_slab_init+0x48>
	z_waitq_init(&slab->wait_q);
   16ea8:	68fb      	ldr	r3, [r7, #12]
   16eaa:	4618      	mov	r0, r3
   16eac:	f7ff ffa1 	bl	16df2 <z_waitq_init>
	z_object_init(slab);
   16eb0:	68f8      	ldr	r0, [r7, #12]
   16eb2:	f7ff ff95 	bl	16de0 <z_object_init>
   16eb6:	e000      	b.n	16eba <k_mem_slab_init+0x4a>
		goto out;
   16eb8:	bf00      	nop
	return rc;
   16eba:	697b      	ldr	r3, [r7, #20]
}
   16ebc:	4618      	mov	r0, r3
   16ebe:	3718      	adds	r7, #24
   16ec0:	46bd      	mov	sp, r7
   16ec2:	bd80      	pop	{r7, pc}

00016ec4 <sys_dlist_init>:
{
   16ec4:	b480      	push	{r7}
   16ec6:	b083      	sub	sp, #12
   16ec8:	af00      	add	r7, sp, #0
   16eca:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   16ecc:	687b      	ldr	r3, [r7, #4]
   16ece:	687a      	ldr	r2, [r7, #4]
   16ed0:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   16ed2:	687b      	ldr	r3, [r7, #4]
   16ed4:	687a      	ldr	r2, [r7, #4]
   16ed6:	605a      	str	r2, [r3, #4]
}
   16ed8:	bf00      	nop
   16eda:	370c      	adds	r7, #12
   16edc:	46bd      	mov	sp, r7
   16ede:	bc80      	pop	{r7}
   16ee0:	4770      	bx	lr

00016ee2 <sys_dnode_is_linked>:
 *
 * @return true if node is linked into a list, false if it is not
 */

static inline bool sys_dnode_is_linked(const sys_dnode_t *node)
{
   16ee2:	b480      	push	{r7}
   16ee4:	b083      	sub	sp, #12
   16ee6:	af00      	add	r7, sp, #0
   16ee8:	6078      	str	r0, [r7, #4]
	return node->next != NULL;
   16eea:	687b      	ldr	r3, [r7, #4]
   16eec:	681b      	ldr	r3, [r3, #0]
   16eee:	2b00      	cmp	r3, #0
   16ef0:	bf14      	ite	ne
   16ef2:	2301      	movne	r3, #1
   16ef4:	2300      	moveq	r3, #0
   16ef6:	b2db      	uxtb	r3, r3
}
   16ef8:	4618      	mov	r0, r3
   16efa:	370c      	adds	r7, #12
   16efc:	46bd      	mov	sp, r7
   16efe:	bc80      	pop	{r7}
   16f00:	4770      	bx	lr

00016f02 <sys_dlist_is_empty>:
 *
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
   16f02:	b480      	push	{r7}
   16f04:	b083      	sub	sp, #12
   16f06:	af00      	add	r7, sp, #0
   16f08:	6078      	str	r0, [r7, #4]
	return list->head == list;
   16f0a:	687b      	ldr	r3, [r7, #4]
   16f0c:	681b      	ldr	r3, [r3, #0]
   16f0e:	687a      	ldr	r2, [r7, #4]
   16f10:	429a      	cmp	r2, r3
   16f12:	bf0c      	ite	eq
   16f14:	2301      	moveq	r3, #1
   16f16:	2300      	movne	r3, #0
   16f18:	b2db      	uxtb	r3, r3
}
   16f1a:	4618      	mov	r0, r3
   16f1c:	370c      	adds	r7, #12
   16f1e:	46bd      	mov	sp, r7
   16f20:	bc80      	pop	{r7}
   16f22:	4770      	bx	lr

00016f24 <sys_dlist_peek_head>:
 *
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
   16f24:	b580      	push	{r7, lr}
   16f26:	b082      	sub	sp, #8
   16f28:	af00      	add	r7, sp, #0
   16f2a:	6078      	str	r0, [r7, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   16f2c:	6878      	ldr	r0, [r7, #4]
   16f2e:	f7ff ffe8 	bl	16f02 <sys_dlist_is_empty>
   16f32:	4603      	mov	r3, r0
   16f34:	2b00      	cmp	r3, #0
   16f36:	d102      	bne.n	16f3e <sys_dlist_peek_head+0x1a>
   16f38:	687b      	ldr	r3, [r7, #4]
   16f3a:	681b      	ldr	r3, [r3, #0]
   16f3c:	e000      	b.n	16f40 <sys_dlist_peek_head+0x1c>
   16f3e:	2300      	movs	r3, #0
}
   16f40:	4618      	mov	r0, r3
   16f42:	3708      	adds	r7, #8
   16f44:	46bd      	mov	sp, r7
   16f46:	bd80      	pop	{r7, pc}

00016f48 <_is_user_context>:
{
   16f48:	b480      	push	{r7}
   16f4a:	af00      	add	r7, sp, #0
	return false;
   16f4c:	2300      	movs	r3, #0
}
   16f4e:	4618      	mov	r0, r3
   16f50:	46bd      	mov	sp, r7
   16f52:	bc80      	pop	{r7}
   16f54:	4770      	bx	lr

00016f56 <z_object_init>:
{
   16f56:	b480      	push	{r7}
   16f58:	b083      	sub	sp, #12
   16f5a:	af00      	add	r7, sp, #0
   16f5c:	6078      	str	r0, [r7, #4]
}
   16f5e:	bf00      	nop
   16f60:	370c      	adds	r7, #12
   16f62:	46bd      	mov	sp, r7
   16f64:	bc80      	pop	{r7}
   16f66:	4770      	bx	lr

00016f68 <z_is_inactive_timeout>:
{
   16f68:	b580      	push	{r7, lr}
   16f6a:	b082      	sub	sp, #8
   16f6c:	af00      	add	r7, sp, #0
   16f6e:	6078      	str	r0, [r7, #4]
	return !sys_dnode_is_linked(&t->node);
   16f70:	687b      	ldr	r3, [r7, #4]
   16f72:	4618      	mov	r0, r3
   16f74:	f7ff ffb5 	bl	16ee2 <sys_dnode_is_linked>
   16f78:	4603      	mov	r3, r0
   16f7a:	2b00      	cmp	r3, #0
   16f7c:	bf14      	ite	ne
   16f7e:	2301      	movne	r3, #1
   16f80:	2300      	moveq	r3, #0
   16f82:	b2db      	uxtb	r3, r3
   16f84:	f083 0301 	eor.w	r3, r3, #1
   16f88:	b2db      	uxtb	r3, r3
   16f8a:	f003 0301 	and.w	r3, r3, #1
   16f8e:	b2db      	uxtb	r3, r3
}
   16f90:	4618      	mov	r0, r3
   16f92:	3708      	adds	r7, #8
   16f94:	46bd      	mov	sp, r7
   16f96:	bd80      	pop	{r7, pc}

00016f98 <z_is_thread_prevented_from_running>:
{
   16f98:	b480      	push	{r7}
   16f9a:	b085      	sub	sp, #20
   16f9c:	af00      	add	r7, sp, #0
   16f9e:	6078      	str	r0, [r7, #4]
	uint8_t state = thread->base.thread_state;
   16fa0:	687b      	ldr	r3, [r7, #4]
   16fa2:	7b5b      	ldrb	r3, [r3, #13]
   16fa4:	73fb      	strb	r3, [r7, #15]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   16fa6:	7bfb      	ldrb	r3, [r7, #15]
   16fa8:	f003 031f 	and.w	r3, r3, #31
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
   16fac:	2b00      	cmp	r3, #0
   16fae:	bf14      	ite	ne
   16fb0:	2301      	movne	r3, #1
   16fb2:	2300      	moveq	r3, #0
   16fb4:	b2db      	uxtb	r3, r3
}
   16fb6:	4618      	mov	r0, r3
   16fb8:	3714      	adds	r7, #20
   16fba:	46bd      	mov	sp, r7
   16fbc:	bc80      	pop	{r7}
   16fbe:	4770      	bx	lr

00016fc0 <z_is_thread_timeout_active>:
{
   16fc0:	b580      	push	{r7, lr}
   16fc2:	b082      	sub	sp, #8
   16fc4:	af00      	add	r7, sp, #0
   16fc6:	6078      	str	r0, [r7, #4]
	return !z_is_inactive_timeout(&thread->base.timeout);
   16fc8:	687b      	ldr	r3, [r7, #4]
   16fca:	3318      	adds	r3, #24
   16fcc:	4618      	mov	r0, r3
   16fce:	f7ff ffcb 	bl	16f68 <z_is_inactive_timeout>
   16fd2:	4603      	mov	r3, r0
   16fd4:	2b00      	cmp	r3, #0
   16fd6:	bf14      	ite	ne
   16fd8:	2301      	movne	r3, #1
   16fda:	2300      	moveq	r3, #0
   16fdc:	b2db      	uxtb	r3, r3
   16fde:	f083 0301 	eor.w	r3, r3, #1
   16fe2:	b2db      	uxtb	r3, r3
   16fe4:	f003 0301 	and.w	r3, r3, #1
   16fe8:	b2db      	uxtb	r3, r3
}
   16fea:	4618      	mov	r0, r3
   16fec:	3708      	adds	r7, #8
   16fee:	46bd      	mov	sp, r7
   16ff0:	bd80      	pop	{r7, pc}

00016ff2 <z_is_thread_ready>:
{
   16ff2:	b580      	push	{r7, lr}
   16ff4:	b082      	sub	sp, #8
   16ff6:	af00      	add	r7, sp, #0
   16ff8:	6078      	str	r0, [r7, #4]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   16ffa:	6878      	ldr	r0, [r7, #4]
   16ffc:	f7ff ffcc 	bl	16f98 <z_is_thread_prevented_from_running>
   17000:	4603      	mov	r3, r0
   17002:	f083 0301 	eor.w	r3, r3, #1
   17006:	b2db      	uxtb	r3, r3
   17008:	2b00      	cmp	r3, #0
   1700a:	d00a      	beq.n	17022 <z_is_thread_ready+0x30>
		 z_is_thread_timeout_active(thread));
   1700c:	6878      	ldr	r0, [r7, #4]
   1700e:	f7ff ffd7 	bl	16fc0 <z_is_thread_timeout_active>
   17012:	4603      	mov	r3, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   17014:	f083 0301 	eor.w	r3, r3, #1
   17018:	b2db      	uxtb	r3, r3
   1701a:	2b00      	cmp	r3, #0
   1701c:	d001      	beq.n	17022 <z_is_thread_ready+0x30>
   1701e:	2301      	movs	r3, #1
   17020:	e000      	b.n	17024 <z_is_thread_ready+0x32>
   17022:	2300      	movs	r3, #0
   17024:	f003 0301 	and.w	r3, r3, #1
   17028:	b2db      	uxtb	r3, r3
}
   1702a:	4618      	mov	r0, r3
   1702c:	3708      	adds	r7, #8
   1702e:	46bd      	mov	sp, r7
   17030:	bd80      	pop	{r7, pc}

00017032 <z_is_under_prio_ceiling>:
{
   17032:	b480      	push	{r7}
   17034:	b083      	sub	sp, #12
   17036:	af00      	add	r7, sp, #0
   17038:	6078      	str	r0, [r7, #4]
	return prio >= CONFIG_PRIORITY_CEILING;
   1703a:	687b      	ldr	r3, [r7, #4]
   1703c:	43db      	mvns	r3, r3
   1703e:	0fdb      	lsrs	r3, r3, #31
   17040:	b2db      	uxtb	r3, r3
}
   17042:	4618      	mov	r0, r3
   17044:	370c      	adds	r7, #12
   17046:	46bd      	mov	sp, r7
   17048:	bc80      	pop	{r7}
   1704a:	4770      	bx	lr

0001704c <z_get_new_prio_with_ceiling>:
{
   1704c:	b580      	push	{r7, lr}
   1704e:	b082      	sub	sp, #8
   17050:	af00      	add	r7, sp, #0
   17052:	6078      	str	r0, [r7, #4]
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   17054:	6878      	ldr	r0, [r7, #4]
   17056:	f7ff ffec 	bl	17032 <z_is_under_prio_ceiling>
   1705a:	4603      	mov	r3, r0
   1705c:	2b00      	cmp	r3, #0
   1705e:	d001      	beq.n	17064 <z_get_new_prio_with_ceiling+0x18>
   17060:	687b      	ldr	r3, [r7, #4]
   17062:	e000      	b.n	17066 <z_get_new_prio_with_ceiling+0x1a>
   17064:	2300      	movs	r3, #0
}
   17066:	4618      	mov	r0, r3
   17068:	3708      	adds	r7, #8
   1706a:	46bd      	mov	sp, r7
   1706c:	bd80      	pop	{r7, pc}

0001706e <z_is_prio1_higher_than_prio2>:
{
   1706e:	b480      	push	{r7}
   17070:	b083      	sub	sp, #12
   17072:	af00      	add	r7, sp, #0
   17074:	6078      	str	r0, [r7, #4]
   17076:	6039      	str	r1, [r7, #0]
	return prio1 < prio2;
   17078:	687a      	ldr	r2, [r7, #4]
   1707a:	683b      	ldr	r3, [r7, #0]
   1707c:	429a      	cmp	r2, r3
   1707e:	bfb4      	ite	lt
   17080:	2301      	movlt	r3, #1
   17082:	2300      	movge	r3, #0
   17084:	b2db      	uxtb	r3, r3
}
   17086:	4618      	mov	r0, r3
   17088:	370c      	adds	r7, #12
   1708a:	46bd      	mov	sp, r7
   1708c:	bc80      	pop	{r7}
   1708e:	4770      	bx	lr

00017090 <z_is_prio_higher>:
{
   17090:	b580      	push	{r7, lr}
   17092:	b082      	sub	sp, #8
   17094:	af00      	add	r7, sp, #0
   17096:	6078      	str	r0, [r7, #4]
   17098:	6039      	str	r1, [r7, #0]
	return z_is_prio1_higher_than_prio2(prio, test_prio);
   1709a:	6839      	ldr	r1, [r7, #0]
   1709c:	6878      	ldr	r0, [r7, #4]
   1709e:	f7ff ffe6 	bl	1706e <z_is_prio1_higher_than_prio2>
   170a2:	4603      	mov	r3, r0
}
   170a4:	4618      	mov	r0, r3
   170a6:	3708      	adds	r7, #8
   170a8:	46bd      	mov	sp, r7
   170aa:	bd80      	pop	{r7, pc}

000170ac <z_waitq_init>:
{
   170ac:	b580      	push	{r7, lr}
   170ae:	b082      	sub	sp, #8
   170b0:	af00      	add	r7, sp, #0
   170b2:	6078      	str	r0, [r7, #4]
	sys_dlist_init(&w->waitq);
   170b4:	687b      	ldr	r3, [r7, #4]
   170b6:	4618      	mov	r0, r3
   170b8:	f7ff ff04 	bl	16ec4 <sys_dlist_init>
}
   170bc:	bf00      	nop
   170be:	3708      	adds	r7, #8
   170c0:	46bd      	mov	sp, r7
   170c2:	bd80      	pop	{r7, pc}

000170c4 <z_waitq_head>:

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
   170c4:	b580      	push	{r7, lr}
   170c6:	b082      	sub	sp, #8
   170c8:	af00      	add	r7, sp, #0
   170ca:	6078      	str	r0, [r7, #4]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   170cc:	687b      	ldr	r3, [r7, #4]
   170ce:	4618      	mov	r0, r3
   170d0:	f7ff ff28 	bl	16f24 <sys_dlist_peek_head>
   170d4:	4603      	mov	r3, r0
}
   170d6:	4618      	mov	r0, r3
   170d8:	3708      	adds	r7, #8
   170da:	46bd      	mov	sp, r7
   170dc:	bd80      	pop	{r7, pc}

000170de <z_impl_k_mutex_init>:
{
   170de:	b580      	push	{r7, lr}
   170e0:	b082      	sub	sp, #8
   170e2:	af00      	add	r7, sp, #0
   170e4:	6078      	str	r0, [r7, #4]
	mutex->owner = NULL;
   170e6:	687b      	ldr	r3, [r7, #4]
   170e8:	2200      	movs	r2, #0
   170ea:	609a      	str	r2, [r3, #8]
	mutex->lock_count = 0U;
   170ec:	687b      	ldr	r3, [r7, #4]
   170ee:	2200      	movs	r2, #0
   170f0:	60da      	str	r2, [r3, #12]
	z_waitq_init(&mutex->wait_q);
   170f2:	687b      	ldr	r3, [r7, #4]
   170f4:	4618      	mov	r0, r3
   170f6:	f7ff ffd9 	bl	170ac <z_waitq_init>
	z_object_init(mutex);
   170fa:	6878      	ldr	r0, [r7, #4]
   170fc:	f7ff ff2b 	bl	16f56 <z_object_init>
	return 0;
   17100:	2300      	movs	r3, #0
}
   17102:	4618      	mov	r0, r3
   17104:	3708      	adds	r7, #8
   17106:	46bd      	mov	sp, r7
   17108:	bd80      	pop	{r7, pc}

0001710a <new_prio_for_inheritance>:
{
   1710a:	b580      	push	{r7, lr}
   1710c:	b084      	sub	sp, #16
   1710e:	af00      	add	r7, sp, #0
   17110:	6078      	str	r0, [r7, #4]
   17112:	6039      	str	r1, [r7, #0]
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
   17114:	6839      	ldr	r1, [r7, #0]
   17116:	6878      	ldr	r0, [r7, #4]
   17118:	f7ff ffba 	bl	17090 <z_is_prio_higher>
   1711c:	4603      	mov	r3, r0
   1711e:	2b00      	cmp	r3, #0
   17120:	d001      	beq.n	17126 <new_prio_for_inheritance+0x1c>
   17122:	687b      	ldr	r3, [r7, #4]
   17124:	e000      	b.n	17128 <new_prio_for_inheritance+0x1e>
   17126:	683b      	ldr	r3, [r7, #0]
   17128:	60fb      	str	r3, [r7, #12]
	new_prio = z_get_new_prio_with_ceiling(new_prio);
   1712a:	68f8      	ldr	r0, [r7, #12]
   1712c:	f7ff ff8e 	bl	1704c <z_get_new_prio_with_ceiling>
   17130:	60f8      	str	r0, [r7, #12]
	return new_prio;
   17132:	68fb      	ldr	r3, [r7, #12]
}
   17134:	4618      	mov	r0, r3
   17136:	3710      	adds	r7, #16
   17138:	46bd      	mov	sp, r7
   1713a:	bd80      	pop	{r7, pc}

0001713c <atomic_set>:
{
   1713c:	b480      	push	{r7}
   1713e:	b083      	sub	sp, #12
   17140:	af00      	add	r7, sp, #0
   17142:	6078      	str	r0, [r7, #4]
   17144:	6039      	str	r1, [r7, #0]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   17146:	683a      	ldr	r2, [r7, #0]
   17148:	687b      	ldr	r3, [r7, #4]
   1714a:	e8d3 1fef 	ldaex	r1, [r3]
   1714e:	e8c3 2fe0 	stlex	r0, r2, [r3]
   17152:	2800      	cmp	r0, #0
   17154:	d1f9      	bne.n	1714a <atomic_set+0xe>
   17156:	460b      	mov	r3, r1
}
   17158:	4618      	mov	r0, r3
   1715a:	370c      	adds	r7, #12
   1715c:	46bd      	mov	sp, r7
   1715e:	bc80      	pop	{r7}
   17160:	4770      	bx	lr

00017162 <atomic_clear>:
{
   17162:	b580      	push	{r7, lr}
   17164:	b082      	sub	sp, #8
   17166:	af00      	add	r7, sp, #0
   17168:	6078      	str	r0, [r7, #4]
	return atomic_set(target, 0);
   1716a:	2100      	movs	r1, #0
   1716c:	6878      	ldr	r0, [r7, #4]
   1716e:	f7ff ffe5 	bl	1713c <atomic_set>
   17172:	4603      	mov	r3, r0
}
   17174:	4618      	mov	r0, r3
   17176:	3708      	adds	r7, #8
   17178:	46bd      	mov	sp, r7
   1717a:	bd80      	pop	{r7, pc}

0001717c <sys_dlist_init>:
{
   1717c:	b480      	push	{r7}
   1717e:	b083      	sub	sp, #12
   17180:	af00      	add	r7, sp, #0
   17182:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   17184:	687b      	ldr	r3, [r7, #4]
   17186:	687a      	ldr	r2, [r7, #4]
   17188:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   1718a:	687b      	ldr	r3, [r7, #4]
   1718c:	687a      	ldr	r2, [r7, #4]
   1718e:	605a      	str	r2, [r3, #4]
}
   17190:	bf00      	nop
   17192:	370c      	adds	r7, #12
   17194:	46bd      	mov	sp, r7
   17196:	bc80      	pop	{r7}
   17198:	4770      	bx	lr

0001719a <sys_dnode_init>:
{
   1719a:	b480      	push	{r7}
   1719c:	b083      	sub	sp, #12
   1719e:	af00      	add	r7, sp, #0
   171a0:	6078      	str	r0, [r7, #4]
	node->next = NULL;
   171a2:	687b      	ldr	r3, [r7, #4]
   171a4:	2200      	movs	r2, #0
   171a6:	601a      	str	r2, [r3, #0]
	node->prev = NULL;
   171a8:	687b      	ldr	r3, [r7, #4]
   171aa:	2200      	movs	r2, #0
   171ac:	605a      	str	r2, [r3, #4]
}
   171ae:	bf00      	nop
   171b0:	370c      	adds	r7, #12
   171b2:	46bd      	mov	sp, r7
   171b4:	bc80      	pop	{r7}
   171b6:	4770      	bx	lr

000171b8 <sys_dnode_is_linked>:
{
   171b8:	b480      	push	{r7}
   171ba:	b083      	sub	sp, #12
   171bc:	af00      	add	r7, sp, #0
   171be:	6078      	str	r0, [r7, #4]
	return node->next != NULL;
   171c0:	687b      	ldr	r3, [r7, #4]
   171c2:	681b      	ldr	r3, [r3, #0]
   171c4:	2b00      	cmp	r3, #0
   171c6:	bf14      	ite	ne
   171c8:	2301      	movne	r3, #1
   171ca:	2300      	moveq	r3, #0
   171cc:	b2db      	uxtb	r3, r3
}
   171ce:	4618      	mov	r0, r3
   171d0:	370c      	adds	r7, #12
   171d2:	46bd      	mov	sp, r7
   171d4:	bc80      	pop	{r7}
   171d6:	4770      	bx	lr

000171d8 <sys_dlist_is_empty>:
{
   171d8:	b480      	push	{r7}
   171da:	b083      	sub	sp, #12
   171dc:	af00      	add	r7, sp, #0
   171de:	6078      	str	r0, [r7, #4]
	return list->head == list;
   171e0:	687b      	ldr	r3, [r7, #4]
   171e2:	681b      	ldr	r3, [r3, #0]
   171e4:	687a      	ldr	r2, [r7, #4]
   171e6:	429a      	cmp	r2, r3
   171e8:	bf0c      	ite	eq
   171ea:	2301      	moveq	r3, #1
   171ec:	2300      	movne	r3, #0
   171ee:	b2db      	uxtb	r3, r3
}
   171f0:	4618      	mov	r0, r3
   171f2:	370c      	adds	r7, #12
   171f4:	46bd      	mov	sp, r7
   171f6:	bc80      	pop	{r7}
   171f8:	4770      	bx	lr

000171fa <sys_dlist_peek_head>:
{
   171fa:	b580      	push	{r7, lr}
   171fc:	b082      	sub	sp, #8
   171fe:	af00      	add	r7, sp, #0
   17200:	6078      	str	r0, [r7, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   17202:	6878      	ldr	r0, [r7, #4]
   17204:	f7ff ffe8 	bl	171d8 <sys_dlist_is_empty>
   17208:	4603      	mov	r3, r0
   1720a:	2b00      	cmp	r3, #0
   1720c:	d102      	bne.n	17214 <sys_dlist_peek_head+0x1a>
   1720e:	687b      	ldr	r3, [r7, #4]
   17210:	681b      	ldr	r3, [r3, #0]
   17212:	e000      	b.n	17216 <sys_dlist_peek_head+0x1c>
   17214:	2300      	movs	r3, #0
}
   17216:	4618      	mov	r0, r3
   17218:	3708      	adds	r7, #8
   1721a:	46bd      	mov	sp, r7
   1721c:	bd80      	pop	{r7, pc}

0001721e <sys_dlist_peek_next_no_check>:
 * @return a pointer to the next element from a node, NULL if node is the tail
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
   1721e:	b480      	push	{r7}
   17220:	b083      	sub	sp, #12
   17222:	af00      	add	r7, sp, #0
   17224:	6078      	str	r0, [r7, #4]
   17226:	6039      	str	r1, [r7, #0]
	return (node == list->tail) ? NULL : node->next;
   17228:	687b      	ldr	r3, [r7, #4]
   1722a:	685b      	ldr	r3, [r3, #4]
   1722c:	683a      	ldr	r2, [r7, #0]
   1722e:	429a      	cmp	r2, r3
   17230:	d002      	beq.n	17238 <sys_dlist_peek_next_no_check+0x1a>
   17232:	683b      	ldr	r3, [r7, #0]
   17234:	681b      	ldr	r3, [r3, #0]
   17236:	e000      	b.n	1723a <sys_dlist_peek_next_no_check+0x1c>
   17238:	2300      	movs	r3, #0
}
   1723a:	4618      	mov	r0, r3
   1723c:	370c      	adds	r7, #12
   1723e:	46bd      	mov	sp, r7
   17240:	bc80      	pop	{r7}
   17242:	4770      	bx	lr

00017244 <sys_dlist_peek_next>:
 * or NULL (when node comes from reading the head of an empty list).
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
   17244:	b580      	push	{r7, lr}
   17246:	b082      	sub	sp, #8
   17248:	af00      	add	r7, sp, #0
   1724a:	6078      	str	r0, [r7, #4]
   1724c:	6039      	str	r1, [r7, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1724e:	683b      	ldr	r3, [r7, #0]
   17250:	2b00      	cmp	r3, #0
   17252:	d005      	beq.n	17260 <sys_dlist_peek_next+0x1c>
   17254:	6839      	ldr	r1, [r7, #0]
   17256:	6878      	ldr	r0, [r7, #4]
   17258:	f7ff ffe1 	bl	1721e <sys_dlist_peek_next_no_check>
   1725c:	4603      	mov	r3, r0
   1725e:	e000      	b.n	17262 <sys_dlist_peek_next+0x1e>
   17260:	2300      	movs	r3, #0
}
   17262:	4618      	mov	r0, r3
   17264:	3708      	adds	r7, #8
   17266:	46bd      	mov	sp, r7
   17268:	bd80      	pop	{r7, pc}

0001726a <sys_dlist_append>:
 *
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
   1726a:	b480      	push	{r7}
   1726c:	b083      	sub	sp, #12
   1726e:	af00      	add	r7, sp, #0
   17270:	6078      	str	r0, [r7, #4]
   17272:	6039      	str	r1, [r7, #0]
	node->next = list;
   17274:	683b      	ldr	r3, [r7, #0]
   17276:	687a      	ldr	r2, [r7, #4]
   17278:	601a      	str	r2, [r3, #0]
	node->prev = list->tail;
   1727a:	687b      	ldr	r3, [r7, #4]
   1727c:	685a      	ldr	r2, [r3, #4]
   1727e:	683b      	ldr	r3, [r7, #0]
   17280:	605a      	str	r2, [r3, #4]

	list->tail->next = node;
   17282:	687b      	ldr	r3, [r7, #4]
   17284:	685b      	ldr	r3, [r3, #4]
   17286:	683a      	ldr	r2, [r7, #0]
   17288:	601a      	str	r2, [r3, #0]
	list->tail = node;
   1728a:	687b      	ldr	r3, [r7, #4]
   1728c:	683a      	ldr	r2, [r7, #0]
   1728e:	605a      	str	r2, [r3, #4]
}
   17290:	bf00      	nop
   17292:	370c      	adds	r7, #12
   17294:	46bd      	mov	sp, r7
   17296:	bc80      	pop	{r7}
   17298:	4770      	bx	lr

0001729a <sys_dlist_insert>:
 *
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
   1729a:	b480      	push	{r7}
   1729c:	b083      	sub	sp, #12
   1729e:	af00      	add	r7, sp, #0
   172a0:	6078      	str	r0, [r7, #4]
   172a2:	6039      	str	r1, [r7, #0]
	node->prev = successor->prev;
   172a4:	687b      	ldr	r3, [r7, #4]
   172a6:	685a      	ldr	r2, [r3, #4]
   172a8:	683b      	ldr	r3, [r7, #0]
   172aa:	605a      	str	r2, [r3, #4]
	node->next = successor;
   172ac:	683b      	ldr	r3, [r7, #0]
   172ae:	687a      	ldr	r2, [r7, #4]
   172b0:	601a      	str	r2, [r3, #0]
	successor->prev->next = node;
   172b2:	687b      	ldr	r3, [r7, #4]
   172b4:	685b      	ldr	r3, [r3, #4]
   172b6:	683a      	ldr	r2, [r7, #0]
   172b8:	601a      	str	r2, [r3, #0]
	successor->prev = node;
   172ba:	687b      	ldr	r3, [r7, #4]
   172bc:	683a      	ldr	r2, [r7, #0]
   172be:	605a      	str	r2, [r3, #4]
}
   172c0:	bf00      	nop
   172c2:	370c      	adds	r7, #12
   172c4:	46bd      	mov	sp, r7
   172c6:	bc80      	pop	{r7}
   172c8:	4770      	bx	lr

000172ca <sys_dlist_remove>:
 *
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
   172ca:	b580      	push	{r7, lr}
   172cc:	b082      	sub	sp, #8
   172ce:	af00      	add	r7, sp, #0
   172d0:	6078      	str	r0, [r7, #4]
	node->prev->next = node->next;
   172d2:	687b      	ldr	r3, [r7, #4]
   172d4:	685b      	ldr	r3, [r3, #4]
   172d6:	687a      	ldr	r2, [r7, #4]
   172d8:	6812      	ldr	r2, [r2, #0]
   172da:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   172dc:	687b      	ldr	r3, [r7, #4]
   172de:	681b      	ldr	r3, [r3, #0]
   172e0:	687a      	ldr	r2, [r7, #4]
   172e2:	6852      	ldr	r2, [r2, #4]
   172e4:	605a      	str	r2, [r3, #4]
	sys_dnode_init(node);
   172e6:	6878      	ldr	r0, [r7, #4]
   172e8:	f7ff ff57 	bl	1719a <sys_dnode_init>
}
   172ec:	bf00      	nop
   172ee:	3708      	adds	r7, #8
   172f0:	46bd      	mov	sp, r7
   172f2:	bd80      	pop	{r7, pc}

000172f4 <_is_user_context>:
{
   172f4:	b480      	push	{r7}
   172f6:	af00      	add	r7, sp, #0
	return false;
   172f8:	2300      	movs	r3, #0
}
   172fa:	4618      	mov	r0, r3
   172fc:	46bd      	mov	sp, r7
   172fe:	bc80      	pop	{r7}
   17300:	4770      	bx	lr

00017302 <k_ms_to_ticks_ceil32>:
{
   17302:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   17306:	b08c      	sub	sp, #48	; 0x30
   17308:	af00      	add	r7, sp, #0
   1730a:	6078      	str	r0, [r7, #4]
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
   1730c:	687b      	ldr	r3, [r7, #4]
   1730e:	461a      	mov	r2, r3
   17310:	f04f 0300 	mov.w	r3, #0
   17314:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   17318:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1731c:	627b      	str	r3, [r7, #36]	; 0x24
   1731e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   17322:	623b      	str	r3, [r7, #32]
   17324:	2301      	movs	r3, #1
   17326:	77fb      	strb	r3, [r7, #31]
   17328:	2301      	movs	r3, #1
   1732a:	77bb      	strb	r3, [r7, #30]
   1732c:	2301      	movs	r3, #1
   1732e:	777b      	strb	r3, [r7, #29]
   17330:	2300      	movs	r3, #0
   17332:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   17334:	7ffb      	ldrb	r3, [r7, #31]
   17336:	2b00      	cmp	r3, #0
   17338:	d00f      	beq.n	1735a <k_ms_to_ticks_ceil32+0x58>
	bool mul_ratio = const_hz &&
   1733a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1733c:	6a3b      	ldr	r3, [r7, #32]
   1733e:	429a      	cmp	r2, r3
   17340:	d20b      	bcs.n	1735a <k_ms_to_ticks_ceil32+0x58>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   17342:	6a3b      	ldr	r3, [r7, #32]
   17344:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17346:	fbb3 f2f2 	udiv	r2, r3, r2
   1734a:	6a79      	ldr	r1, [r7, #36]	; 0x24
   1734c:	fb01 f202 	mul.w	r2, r1, r2
   17350:	1a9b      	subs	r3, r3, r2
   17352:	2b00      	cmp	r3, #0
   17354:	d101      	bne.n	1735a <k_ms_to_ticks_ceil32+0x58>
   17356:	2301      	movs	r3, #1
   17358:	e000      	b.n	1735c <k_ms_to_ticks_ceil32+0x5a>
   1735a:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   1735c:	76fb      	strb	r3, [r7, #27]
   1735e:	7efb      	ldrb	r3, [r7, #27]
   17360:	f003 0301 	and.w	r3, r3, #1
   17364:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   17366:	7ffb      	ldrb	r3, [r7, #31]
   17368:	2b00      	cmp	r3, #0
   1736a:	d00f      	beq.n	1738c <k_ms_to_ticks_ceil32+0x8a>
	bool div_ratio = const_hz &&
   1736c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1736e:	6a3b      	ldr	r3, [r7, #32]
   17370:	429a      	cmp	r2, r3
   17372:	d90b      	bls.n	1738c <k_ms_to_ticks_ceil32+0x8a>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   17374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17376:	6a3a      	ldr	r2, [r7, #32]
   17378:	fbb3 f2f2 	udiv	r2, r3, r2
   1737c:	6a39      	ldr	r1, [r7, #32]
   1737e:	fb01 f202 	mul.w	r2, r1, r2
   17382:	1a9b      	subs	r3, r3, r2
   17384:	2b00      	cmp	r3, #0
   17386:	d101      	bne.n	1738c <k_ms_to_ticks_ceil32+0x8a>
   17388:	2301      	movs	r3, #1
   1738a:	e000      	b.n	1738e <k_ms_to_ticks_ceil32+0x8c>
   1738c:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   1738e:	76bb      	strb	r3, [r7, #26]
   17390:	7ebb      	ldrb	r3, [r7, #26]
   17392:	f003 0301 	and.w	r3, r3, #1
   17396:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   17398:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1739a:	6a3b      	ldr	r3, [r7, #32]
   1739c:	429a      	cmp	r2, r3
   1739e:	d10a      	bne.n	173b6 <k_ms_to_ticks_ceil32+0xb4>
		return result32 ? ((uint32_t)t) : t;
   173a0:	7fbb      	ldrb	r3, [r7, #30]
   173a2:	2b00      	cmp	r3, #0
   173a4:	d004      	beq.n	173b0 <k_ms_to_ticks_ceil32+0xae>
   173a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   173a8:	461a      	mov	r2, r3
   173aa:	f04f 0300 	mov.w	r3, #0
   173ae:	e0c8      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
   173b0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   173b4:	e0c5      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
	uint64_t off = 0;
   173b6:	f04f 0200 	mov.w	r2, #0
   173ba:	f04f 0300 	mov.w	r3, #0
   173be:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   173c2:	7efb      	ldrb	r3, [r7, #27]
   173c4:	f083 0301 	eor.w	r3, r3, #1
   173c8:	b2db      	uxtb	r3, r3
   173ca:	2b00      	cmp	r3, #0
   173cc:	d01e      	beq.n	1740c <k_ms_to_ticks_ceil32+0x10a>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   173ce:	7ebb      	ldrb	r3, [r7, #26]
   173d0:	2b00      	cmp	r3, #0
   173d2:	d004      	beq.n	173de <k_ms_to_ticks_ceil32+0xdc>
   173d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   173d6:	6a3b      	ldr	r3, [r7, #32]
   173d8:	fbb2 f3f3 	udiv	r3, r2, r3
   173dc:	e000      	b.n	173e0 <k_ms_to_ticks_ceil32+0xde>
   173de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   173e0:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   173e2:	7f7b      	ldrb	r3, [r7, #29]
   173e4:	2b00      	cmp	r3, #0
   173e6:	d007      	beq.n	173f8 <k_ms_to_ticks_ceil32+0xf6>
			off = rdivisor - 1U;
   173e8:	68fb      	ldr	r3, [r7, #12]
   173ea:	3b01      	subs	r3, #1
   173ec:	461a      	mov	r2, r3
   173ee:	f04f 0300 	mov.w	r3, #0
   173f2:	e9c7 2304 	strd	r2, r3, [r7, #16]
   173f6:	e009      	b.n	1740c <k_ms_to_ticks_ceil32+0x10a>
		} else if (round_off) {
   173f8:	7f3b      	ldrb	r3, [r7, #28]
   173fa:	2b00      	cmp	r3, #0
   173fc:	d006      	beq.n	1740c <k_ms_to_ticks_ceil32+0x10a>
			off = rdivisor / 2U;
   173fe:	68fb      	ldr	r3, [r7, #12]
   17400:	085b      	lsrs	r3, r3, #1
   17402:	461a      	mov	r2, r3
   17404:	f04f 0300 	mov.w	r3, #0
   17408:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   1740c:	7ebb      	ldrb	r3, [r7, #26]
   1740e:	2b00      	cmp	r3, #0
   17410:	d02a      	beq.n	17468 <k_ms_to_ticks_ceil32+0x166>
		t += off;
   17412:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   17416:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   1741a:	1884      	adds	r4, r0, r2
   1741c:	eb41 0503 	adc.w	r5, r1, r3
   17420:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   17424:	7fbb      	ldrb	r3, [r7, #30]
   17426:	2b00      	cmp	r3, #0
   17428:	d010      	beq.n	1744c <k_ms_to_ticks_ceil32+0x14a>
   1742a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   1742e:	2b01      	cmp	r3, #1
   17430:	bf08      	it	eq
   17432:	2a00      	cmpeq	r2, #0
   17434:	d20a      	bcs.n	1744c <k_ms_to_ticks_ceil32+0x14a>
			return ((uint32_t)t) / (from_hz / to_hz);
   17436:	6aba      	ldr	r2, [r7, #40]	; 0x28
   17438:	6a79      	ldr	r1, [r7, #36]	; 0x24
   1743a:	6a3b      	ldr	r3, [r7, #32]
   1743c:	fbb1 f3f3 	udiv	r3, r1, r3
   17440:	fbb2 f3f3 	udiv	r3, r2, r3
   17444:	461a      	mov	r2, r3
   17446:	f04f 0300 	mov.w	r3, #0
   1744a:	e07a      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
			return t / (from_hz / to_hz);
   1744c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1744e:	6a3b      	ldr	r3, [r7, #32]
   17450:	fbb2 f3f3 	udiv	r3, r2, r3
   17454:	461a      	mov	r2, r3
   17456:	f04f 0300 	mov.w	r3, #0
   1745a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   1745e:	f7e8 fe71 	bl	144 <__aeabi_uldivmod>
   17462:	4602      	mov	r2, r0
   17464:	460b      	mov	r3, r1
   17466:	e06c      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
	} else if (mul_ratio) {
   17468:	7efb      	ldrb	r3, [r7, #27]
   1746a:	2b00      	cmp	r3, #0
   1746c:	d021      	beq.n	174b2 <k_ms_to_ticks_ceil32+0x1b0>
		if (result32) {
   1746e:	7fbb      	ldrb	r3, [r7, #30]
   17470:	2b00      	cmp	r3, #0
   17472:	d00a      	beq.n	1748a <k_ms_to_ticks_ceil32+0x188>
			return ((uint32_t)t) * (to_hz / from_hz);
   17474:	6abb      	ldr	r3, [r7, #40]	; 0x28
   17476:	6a39      	ldr	r1, [r7, #32]
   17478:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1747a:	fbb1 f2f2 	udiv	r2, r1, r2
   1747e:	fb02 f303 	mul.w	r3, r2, r3
   17482:	461a      	mov	r2, r3
   17484:	f04f 0300 	mov.w	r3, #0
   17488:	e05b      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
			return t * (to_hz / from_hz);
   1748a:	6a3a      	ldr	r2, [r7, #32]
   1748c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1748e:	fbb2 f3f3 	udiv	r3, r2, r3
   17492:	461a      	mov	r2, r3
   17494:	f04f 0300 	mov.w	r3, #0
   17498:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1749a:	fb03 f001 	mul.w	r0, r3, r1
   1749e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   174a0:	fb02 f101 	mul.w	r1, r2, r1
   174a4:	4401      	add	r1, r0
   174a6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   174a8:	fba0 2302 	umull	r2, r3, r0, r2
   174ac:	4419      	add	r1, r3
   174ae:	460b      	mov	r3, r1
   174b0:	e047      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
		if (result32) {
   174b2:	7fbb      	ldrb	r3, [r7, #30]
   174b4:	2b00      	cmp	r3, #0
   174b6:	d024      	beq.n	17502 <k_ms_to_ticks_ceil32+0x200>
			return (uint32_t)((t * to_hz + off) / from_hz);
   174b8:	6a3b      	ldr	r3, [r7, #32]
   174ba:	461a      	mov	r2, r3
   174bc:	f04f 0300 	mov.w	r3, #0
   174c0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   174c2:	fb03 f001 	mul.w	r0, r3, r1
   174c6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   174c8:	fb02 f101 	mul.w	r1, r2, r1
   174cc:	4401      	add	r1, r0
   174ce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   174d0:	fba0 2302 	umull	r2, r3, r0, r2
   174d4:	4419      	add	r1, r3
   174d6:	460b      	mov	r3, r1
   174d8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   174dc:	eb12 0a00 	adds.w	sl, r2, r0
   174e0:	eb43 0b01 	adc.w	fp, r3, r1
   174e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   174e6:	461a      	mov	r2, r3
   174e8:	f04f 0300 	mov.w	r3, #0
   174ec:	4650      	mov	r0, sl
   174ee:	4659      	mov	r1, fp
   174f0:	f7e8 fe28 	bl	144 <__aeabi_uldivmod>
   174f4:	4602      	mov	r2, r0
   174f6:	460b      	mov	r3, r1
   174f8:	4613      	mov	r3, r2
   174fa:	461a      	mov	r2, r3
   174fc:	f04f 0300 	mov.w	r3, #0
   17500:	e01f      	b.n	17542 <k_ms_to_ticks_ceil32+0x240>
			return (t * to_hz + off) / from_hz;
   17502:	6a3b      	ldr	r3, [r7, #32]
   17504:	461a      	mov	r2, r3
   17506:	f04f 0300 	mov.w	r3, #0
   1750a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1750c:	fb03 f001 	mul.w	r0, r3, r1
   17510:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   17512:	fb02 f101 	mul.w	r1, r2, r1
   17516:	4401      	add	r1, r0
   17518:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1751a:	fba0 2302 	umull	r2, r3, r0, r2
   1751e:	4419      	add	r1, r3
   17520:	460b      	mov	r3, r1
   17522:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   17526:	eb12 0800 	adds.w	r8, r2, r0
   1752a:	eb43 0901 	adc.w	r9, r3, r1
   1752e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17530:	461a      	mov	r2, r3
   17532:	f04f 0300 	mov.w	r3, #0
   17536:	4640      	mov	r0, r8
   17538:	4649      	mov	r1, r9
   1753a:	f7e8 fe03 	bl	144 <__aeabi_uldivmod>
   1753e:	4602      	mov	r2, r0
   17540:	460b      	mov	r3, r1
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
   17542:	4613      	mov	r3, r2
}
   17544:	4618      	mov	r0, r3
   17546:	3730      	adds	r7, #48	; 0x30
   17548:	46bd      	mov	sp, r7
   1754a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0001754e <k_ticks_to_ms_floor64>:
{
   1754e:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   17552:	b08c      	sub	sp, #48	; 0x30
   17554:	af00      	add	r7, sp, #0
   17556:	e9c7 0100 	strd	r0, r1, [r7]
   1755a:	e9d7 2300 	ldrd	r2, r3, [r7]
   1755e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   17562:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   17566:	627b      	str	r3, [r7, #36]	; 0x24
   17568:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1756c:	623b      	str	r3, [r7, #32]
   1756e:	2301      	movs	r3, #1
   17570:	77fb      	strb	r3, [r7, #31]
   17572:	2300      	movs	r3, #0
   17574:	77bb      	strb	r3, [r7, #30]
   17576:	2300      	movs	r3, #0
   17578:	777b      	strb	r3, [r7, #29]
   1757a:	2300      	movs	r3, #0
   1757c:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1757e:	7ffb      	ldrb	r3, [r7, #31]
   17580:	2b00      	cmp	r3, #0
   17582:	d00f      	beq.n	175a4 <k_ticks_to_ms_floor64+0x56>
	bool mul_ratio = const_hz &&
   17584:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17586:	6a3b      	ldr	r3, [r7, #32]
   17588:	429a      	cmp	r2, r3
   1758a:	d20b      	bcs.n	175a4 <k_ticks_to_ms_floor64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   1758c:	6a3b      	ldr	r3, [r7, #32]
   1758e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17590:	fbb3 f2f2 	udiv	r2, r3, r2
   17594:	6a79      	ldr	r1, [r7, #36]	; 0x24
   17596:	fb01 f202 	mul.w	r2, r1, r2
   1759a:	1a9b      	subs	r3, r3, r2
   1759c:	2b00      	cmp	r3, #0
   1759e:	d101      	bne.n	175a4 <k_ticks_to_ms_floor64+0x56>
   175a0:	2301      	movs	r3, #1
   175a2:	e000      	b.n	175a6 <k_ticks_to_ms_floor64+0x58>
   175a4:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   175a6:	76fb      	strb	r3, [r7, #27]
   175a8:	7efb      	ldrb	r3, [r7, #27]
   175aa:	f003 0301 	and.w	r3, r3, #1
   175ae:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   175b0:	7ffb      	ldrb	r3, [r7, #31]
   175b2:	2b00      	cmp	r3, #0
   175b4:	d00f      	beq.n	175d6 <k_ticks_to_ms_floor64+0x88>
	bool div_ratio = const_hz &&
   175b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   175b8:	6a3b      	ldr	r3, [r7, #32]
   175ba:	429a      	cmp	r2, r3
   175bc:	d90b      	bls.n	175d6 <k_ticks_to_ms_floor64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   175be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   175c0:	6a3a      	ldr	r2, [r7, #32]
   175c2:	fbb3 f2f2 	udiv	r2, r3, r2
   175c6:	6a39      	ldr	r1, [r7, #32]
   175c8:	fb01 f202 	mul.w	r2, r1, r2
   175cc:	1a9b      	subs	r3, r3, r2
   175ce:	2b00      	cmp	r3, #0
   175d0:	d101      	bne.n	175d6 <k_ticks_to_ms_floor64+0x88>
   175d2:	2301      	movs	r3, #1
   175d4:	e000      	b.n	175d8 <k_ticks_to_ms_floor64+0x8a>
   175d6:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   175d8:	76bb      	strb	r3, [r7, #26]
   175da:	7ebb      	ldrb	r3, [r7, #26]
   175dc:	f003 0301 	and.w	r3, r3, #1
   175e0:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   175e2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   175e4:	6a3b      	ldr	r3, [r7, #32]
   175e6:	429a      	cmp	r2, r3
   175e8:	d10a      	bne.n	17600 <k_ticks_to_ms_floor64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   175ea:	7fbb      	ldrb	r3, [r7, #30]
   175ec:	2b00      	cmp	r3, #0
   175ee:	d004      	beq.n	175fa <k_ticks_to_ms_floor64+0xac>
   175f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   175f2:	461a      	mov	r2, r3
   175f4:	f04f 0300 	mov.w	r3, #0
   175f8:	e0c8      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
   175fa:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   175fe:	e0c5      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
	uint64_t off = 0;
   17600:	f04f 0200 	mov.w	r2, #0
   17604:	f04f 0300 	mov.w	r3, #0
   17608:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   1760c:	7efb      	ldrb	r3, [r7, #27]
   1760e:	f083 0301 	eor.w	r3, r3, #1
   17612:	b2db      	uxtb	r3, r3
   17614:	2b00      	cmp	r3, #0
   17616:	d01e      	beq.n	17656 <k_ticks_to_ms_floor64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   17618:	7ebb      	ldrb	r3, [r7, #26]
   1761a:	2b00      	cmp	r3, #0
   1761c:	d004      	beq.n	17628 <k_ticks_to_ms_floor64+0xda>
   1761e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17620:	6a3b      	ldr	r3, [r7, #32]
   17622:	fbb2 f3f3 	udiv	r3, r2, r3
   17626:	e000      	b.n	1762a <k_ticks_to_ms_floor64+0xdc>
   17628:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1762a:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   1762c:	7f7b      	ldrb	r3, [r7, #29]
   1762e:	2b00      	cmp	r3, #0
   17630:	d007      	beq.n	17642 <k_ticks_to_ms_floor64+0xf4>
			off = rdivisor - 1U;
   17632:	68fb      	ldr	r3, [r7, #12]
   17634:	3b01      	subs	r3, #1
   17636:	461a      	mov	r2, r3
   17638:	f04f 0300 	mov.w	r3, #0
   1763c:	e9c7 2304 	strd	r2, r3, [r7, #16]
   17640:	e009      	b.n	17656 <k_ticks_to_ms_floor64+0x108>
		} else if (round_off) {
   17642:	7f3b      	ldrb	r3, [r7, #28]
   17644:	2b00      	cmp	r3, #0
   17646:	d006      	beq.n	17656 <k_ticks_to_ms_floor64+0x108>
			off = rdivisor / 2U;
   17648:	68fb      	ldr	r3, [r7, #12]
   1764a:	085b      	lsrs	r3, r3, #1
   1764c:	461a      	mov	r2, r3
   1764e:	f04f 0300 	mov.w	r3, #0
   17652:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   17656:	7ebb      	ldrb	r3, [r7, #26]
   17658:	2b00      	cmp	r3, #0
   1765a:	d02a      	beq.n	176b2 <k_ticks_to_ms_floor64+0x164>
		t += off;
   1765c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   17660:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   17664:	1884      	adds	r4, r0, r2
   17666:	eb41 0503 	adc.w	r5, r1, r3
   1766a:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   1766e:	7fbb      	ldrb	r3, [r7, #30]
   17670:	2b00      	cmp	r3, #0
   17672:	d010      	beq.n	17696 <k_ticks_to_ms_floor64+0x148>
   17674:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   17678:	2b01      	cmp	r3, #1
   1767a:	bf08      	it	eq
   1767c:	2a00      	cmpeq	r2, #0
   1767e:	d20a      	bcs.n	17696 <k_ticks_to_ms_floor64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   17680:	6aba      	ldr	r2, [r7, #40]	; 0x28
   17682:	6a79      	ldr	r1, [r7, #36]	; 0x24
   17684:	6a3b      	ldr	r3, [r7, #32]
   17686:	fbb1 f3f3 	udiv	r3, r1, r3
   1768a:	fbb2 f3f3 	udiv	r3, r2, r3
   1768e:	461a      	mov	r2, r3
   17690:	f04f 0300 	mov.w	r3, #0
   17694:	e07a      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
			return t / (from_hz / to_hz);
   17696:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17698:	6a3b      	ldr	r3, [r7, #32]
   1769a:	fbb2 f3f3 	udiv	r3, r2, r3
   1769e:	461a      	mov	r2, r3
   176a0:	f04f 0300 	mov.w	r3, #0
   176a4:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   176a8:	f7e8 fd4c 	bl	144 <__aeabi_uldivmod>
   176ac:	4602      	mov	r2, r0
   176ae:	460b      	mov	r3, r1
   176b0:	e06c      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
	} else if (mul_ratio) {
   176b2:	7efb      	ldrb	r3, [r7, #27]
   176b4:	2b00      	cmp	r3, #0
   176b6:	d021      	beq.n	176fc <k_ticks_to_ms_floor64+0x1ae>
		if (result32) {
   176b8:	7fbb      	ldrb	r3, [r7, #30]
   176ba:	2b00      	cmp	r3, #0
   176bc:	d00a      	beq.n	176d4 <k_ticks_to_ms_floor64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   176be:	6abb      	ldr	r3, [r7, #40]	; 0x28
   176c0:	6a39      	ldr	r1, [r7, #32]
   176c2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   176c4:	fbb1 f2f2 	udiv	r2, r1, r2
   176c8:	fb02 f303 	mul.w	r3, r2, r3
   176cc:	461a      	mov	r2, r3
   176ce:	f04f 0300 	mov.w	r3, #0
   176d2:	e05b      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
			return t * (to_hz / from_hz);
   176d4:	6a3a      	ldr	r2, [r7, #32]
   176d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   176d8:	fbb2 f3f3 	udiv	r3, r2, r3
   176dc:	461a      	mov	r2, r3
   176de:	f04f 0300 	mov.w	r3, #0
   176e2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   176e4:	fb03 f001 	mul.w	r0, r3, r1
   176e8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   176ea:	fb02 f101 	mul.w	r1, r2, r1
   176ee:	4401      	add	r1, r0
   176f0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   176f2:	fba0 2302 	umull	r2, r3, r0, r2
   176f6:	4419      	add	r1, r3
   176f8:	460b      	mov	r3, r1
   176fa:	e047      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
		if (result32) {
   176fc:	7fbb      	ldrb	r3, [r7, #30]
   176fe:	2b00      	cmp	r3, #0
   17700:	d024      	beq.n	1774c <k_ticks_to_ms_floor64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   17702:	6a3b      	ldr	r3, [r7, #32]
   17704:	461a      	mov	r2, r3
   17706:	f04f 0300 	mov.w	r3, #0
   1770a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1770c:	fb03 f001 	mul.w	r0, r3, r1
   17710:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   17712:	fb02 f101 	mul.w	r1, r2, r1
   17716:	4401      	add	r1, r0
   17718:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1771a:	fba0 2302 	umull	r2, r3, r0, r2
   1771e:	4419      	add	r1, r3
   17720:	460b      	mov	r3, r1
   17722:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   17726:	eb12 0a00 	adds.w	sl, r2, r0
   1772a:	eb43 0b01 	adc.w	fp, r3, r1
   1772e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17730:	461a      	mov	r2, r3
   17732:	f04f 0300 	mov.w	r3, #0
   17736:	4650      	mov	r0, sl
   17738:	4659      	mov	r1, fp
   1773a:	f7e8 fd03 	bl	144 <__aeabi_uldivmod>
   1773e:	4602      	mov	r2, r0
   17740:	460b      	mov	r3, r1
   17742:	4613      	mov	r3, r2
   17744:	461a      	mov	r2, r3
   17746:	f04f 0300 	mov.w	r3, #0
   1774a:	e01f      	b.n	1778c <k_ticks_to_ms_floor64+0x23e>
			return (t * to_hz + off) / from_hz;
   1774c:	6a3b      	ldr	r3, [r7, #32]
   1774e:	461a      	mov	r2, r3
   17750:	f04f 0300 	mov.w	r3, #0
   17754:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   17756:	fb03 f001 	mul.w	r0, r3, r1
   1775a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   1775c:	fb02 f101 	mul.w	r1, r2, r1
   17760:	4401      	add	r1, r0
   17762:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   17764:	fba0 2302 	umull	r2, r3, r0, r2
   17768:	4419      	add	r1, r3
   1776a:	460b      	mov	r3, r1
   1776c:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   17770:	eb12 0800 	adds.w	r8, r2, r0
   17774:	eb43 0901 	adc.w	r9, r3, r1
   17778:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1777a:	461a      	mov	r2, r3
   1777c:	f04f 0300 	mov.w	r3, #0
   17780:	4640      	mov	r0, r8
   17782:	4649      	mov	r1, r9
   17784:	f7e8 fcde 	bl	144 <__aeabi_uldivmod>
   17788:	4602      	mov	r2, r0
   1778a:	460b      	mov	r3, r1
}
   1778c:	4610      	mov	r0, r2
   1778e:	4619      	mov	r1, r3
   17790:	3730      	adds	r7, #48	; 0x30
   17792:	46bd      	mov	sp, r7
   17794:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

00017798 <k_yield>:
{
   17798:	b580      	push	{r7, lr}
   1779a:	af00      	add	r7, sp, #0
	z_impl_k_yield();
   1779c:	f7f6 fb60 	bl	de60 <z_impl_k_yield>
}
   177a0:	bf00      	nop
   177a2:	bd80      	pop	{r7, pc}

000177a4 <k_thread_suspend>:
{
   177a4:	b580      	push	{r7, lr}
   177a6:	b082      	sub	sp, #8
   177a8:	af00      	add	r7, sp, #0
   177aa:	6078      	str	r0, [r7, #4]
	z_impl_k_thread_suspend(thread);
   177ac:	6878      	ldr	r0, [r7, #4]
   177ae:	f7f5 faaf 	bl	cd10 <z_impl_k_thread_suspend>
}
   177b2:	bf00      	nop
   177b4:	3708      	adds	r7, #8
   177b6:	46bd      	mov	sp, r7
   177b8:	bd80      	pop	{r7, pc}

000177ba <z_is_inactive_timeout>:
{
   177ba:	b580      	push	{r7, lr}
   177bc:	b082      	sub	sp, #8
   177be:	af00      	add	r7, sp, #0
   177c0:	6078      	str	r0, [r7, #4]
	return !sys_dnode_is_linked(&t->node);
   177c2:	687b      	ldr	r3, [r7, #4]
   177c4:	4618      	mov	r0, r3
   177c6:	f7ff fcf7 	bl	171b8 <sys_dnode_is_linked>
   177ca:	4603      	mov	r3, r0
   177cc:	2b00      	cmp	r3, #0
   177ce:	bf14      	ite	ne
   177d0:	2301      	movne	r3, #1
   177d2:	2300      	moveq	r3, #0
   177d4:	b2db      	uxtb	r3, r3
   177d6:	f083 0301 	eor.w	r3, r3, #1
   177da:	b2db      	uxtb	r3, r3
   177dc:	f003 0301 	and.w	r3, r3, #1
   177e0:	b2db      	uxtb	r3, r3
}
   177e2:	4618      	mov	r0, r3
   177e4:	3708      	adds	r7, #8
   177e6:	46bd      	mov	sp, r7
   177e8:	bd80      	pop	{r7, pc}

000177ea <z_abort_thread_timeout>:

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
   177ea:	b580      	push	{r7, lr}
   177ec:	b082      	sub	sp, #8
   177ee:	af00      	add	r7, sp, #0
   177f0:	6078      	str	r0, [r7, #4]
	return z_abort_timeout(&thread->base.timeout);
   177f2:	687b      	ldr	r3, [r7, #4]
   177f4:	3318      	adds	r3, #24
   177f6:	4618      	mov	r0, r3
   177f8:	f7f7 fbde 	bl	efb8 <z_abort_timeout>
   177fc:	4603      	mov	r3, r0
}
   177fe:	4618      	mov	r0, r3
   17800:	3708      	adds	r7, #8
   17802:	46bd      	mov	sp, r7
   17804:	bd80      	pop	{r7, pc}

00017806 <z_reschedule_unlocked>:
{
   17806:	b580      	push	{r7, lr}
   17808:	b082      	sub	sp, #8
   1780a:	af00      	add	r7, sp, #0
	__asm__ volatile(
   1780c:	f04f 0320 	mov.w	r3, #32
   17810:	f3ef 8211 	mrs	r2, BASEPRI
   17814:	f383 8811 	msr	BASEPRI, r3
   17818:	f3bf 8f6f 	isb	sy
   1781c:	607a      	str	r2, [r7, #4]
   1781e:	603b      	str	r3, [r7, #0]
	return key;
   17820:	687b      	ldr	r3, [r7, #4]
	(void) z_reschedule_irqlock(arch_irq_lock());
   17822:	4618      	mov	r0, r3
   17824:	f000 fa10 	bl	17c48 <z_reschedule_irqlock>
}
   17828:	bf00      	nop
   1782a:	3708      	adds	r7, #8
   1782c:	46bd      	mov	sp, r7
   1782e:	bd80      	pop	{r7, pc}

00017830 <z_is_thread_pending>:
{
   17830:	b480      	push	{r7}
   17832:	b083      	sub	sp, #12
   17834:	af00      	add	r7, sp, #0
   17836:	6078      	str	r0, [r7, #4]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
   17838:	687b      	ldr	r3, [r7, #4]
   1783a:	7b5b      	ldrb	r3, [r3, #13]
   1783c:	f003 0302 	and.w	r3, r3, #2
   17840:	2b00      	cmp	r3, #0
   17842:	bf14      	ite	ne
   17844:	2301      	movne	r3, #1
   17846:	2300      	moveq	r3, #0
   17848:	b2db      	uxtb	r3, r3
}
   1784a:	4618      	mov	r0, r3
   1784c:	370c      	adds	r7, #12
   1784e:	46bd      	mov	sp, r7
   17850:	bc80      	pop	{r7}
   17852:	4770      	bx	lr

00017854 <z_is_thread_prevented_from_running>:
{
   17854:	b480      	push	{r7}
   17856:	b085      	sub	sp, #20
   17858:	af00      	add	r7, sp, #0
   1785a:	6078      	str	r0, [r7, #4]
	uint8_t state = thread->base.thread_state;
   1785c:	687b      	ldr	r3, [r7, #4]
   1785e:	7b5b      	ldrb	r3, [r3, #13]
   17860:	73fb      	strb	r3, [r7, #15]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   17862:	7bfb      	ldrb	r3, [r7, #15]
   17864:	f003 031f 	and.w	r3, r3, #31
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
   17868:	2b00      	cmp	r3, #0
   1786a:	bf14      	ite	ne
   1786c:	2301      	movne	r3, #1
   1786e:	2300      	moveq	r3, #0
   17870:	b2db      	uxtb	r3, r3
}
   17872:	4618      	mov	r0, r3
   17874:	3714      	adds	r7, #20
   17876:	46bd      	mov	sp, r7
   17878:	bc80      	pop	{r7}
   1787a:	4770      	bx	lr

0001787c <z_is_thread_timeout_active>:
{
   1787c:	b580      	push	{r7, lr}
   1787e:	b082      	sub	sp, #8
   17880:	af00      	add	r7, sp, #0
   17882:	6078      	str	r0, [r7, #4]
	return !z_is_inactive_timeout(&thread->base.timeout);
   17884:	687b      	ldr	r3, [r7, #4]
   17886:	3318      	adds	r3, #24
   17888:	4618      	mov	r0, r3
   1788a:	f7ff ff96 	bl	177ba <z_is_inactive_timeout>
   1788e:	4603      	mov	r3, r0
   17890:	2b00      	cmp	r3, #0
   17892:	bf14      	ite	ne
   17894:	2301      	movne	r3, #1
   17896:	2300      	moveq	r3, #0
   17898:	b2db      	uxtb	r3, r3
   1789a:	f083 0301 	eor.w	r3, r3, #1
   1789e:	b2db      	uxtb	r3, r3
   178a0:	f003 0301 	and.w	r3, r3, #1
   178a4:	b2db      	uxtb	r3, r3
}
   178a6:	4618      	mov	r0, r3
   178a8:	3708      	adds	r7, #8
   178aa:	46bd      	mov	sp, r7
   178ac:	bd80      	pop	{r7, pc}

000178ae <z_is_thread_ready>:
{
   178ae:	b580      	push	{r7, lr}
   178b0:	b082      	sub	sp, #8
   178b2:	af00      	add	r7, sp, #0
   178b4:	6078      	str	r0, [r7, #4]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   178b6:	6878      	ldr	r0, [r7, #4]
   178b8:	f7ff ffcc 	bl	17854 <z_is_thread_prevented_from_running>
   178bc:	4603      	mov	r3, r0
   178be:	f083 0301 	eor.w	r3, r3, #1
   178c2:	b2db      	uxtb	r3, r3
   178c4:	2b00      	cmp	r3, #0
   178c6:	d00a      	beq.n	178de <z_is_thread_ready+0x30>
		 z_is_thread_timeout_active(thread));
   178c8:	6878      	ldr	r0, [r7, #4]
   178ca:	f7ff ffd7 	bl	1787c <z_is_thread_timeout_active>
   178ce:	4603      	mov	r3, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   178d0:	f083 0301 	eor.w	r3, r3, #1
   178d4:	b2db      	uxtb	r3, r3
   178d6:	2b00      	cmp	r3, #0
   178d8:	d001      	beq.n	178de <z_is_thread_ready+0x30>
   178da:	2301      	movs	r3, #1
   178dc:	e000      	b.n	178e0 <z_is_thread_ready+0x32>
   178de:	2300      	movs	r3, #0
   178e0:	f003 0301 	and.w	r3, r3, #1
   178e4:	b2db      	uxtb	r3, r3
}
   178e6:	4618      	mov	r0, r3
   178e8:	3708      	adds	r7, #8
   178ea:	46bd      	mov	sp, r7
   178ec:	bd80      	pop	{r7, pc}

000178ee <z_has_thread_started>:
{
   178ee:	b480      	push	{r7}
   178f0:	b083      	sub	sp, #12
   178f2:	af00      	add	r7, sp, #0
   178f4:	6078      	str	r0, [r7, #4]
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   178f6:	687b      	ldr	r3, [r7, #4]
   178f8:	7b5b      	ldrb	r3, [r3, #13]
   178fa:	f003 0304 	and.w	r3, r3, #4
   178fe:	2b00      	cmp	r3, #0
   17900:	bf0c      	ite	eq
   17902:	2301      	moveq	r3, #1
   17904:	2300      	movne	r3, #0
   17906:	b2db      	uxtb	r3, r3
}
   17908:	4618      	mov	r0, r3
   1790a:	370c      	adds	r7, #12
   1790c:	46bd      	mov	sp, r7
   1790e:	bc80      	pop	{r7}
   17910:	4770      	bx	lr

00017912 <z_is_thread_state_set>:
{
   17912:	b480      	push	{r7}
   17914:	b083      	sub	sp, #12
   17916:	af00      	add	r7, sp, #0
   17918:	6078      	str	r0, [r7, #4]
   1791a:	6039      	str	r1, [r7, #0]
	return (thread->base.thread_state & state) != 0U;
   1791c:	687b      	ldr	r3, [r7, #4]
   1791e:	7b5b      	ldrb	r3, [r3, #13]
   17920:	461a      	mov	r2, r3
   17922:	683b      	ldr	r3, [r7, #0]
   17924:	4013      	ands	r3, r2
   17926:	2b00      	cmp	r3, #0
   17928:	bf14      	ite	ne
   1792a:	2301      	movne	r3, #1
   1792c:	2300      	moveq	r3, #0
   1792e:	b2db      	uxtb	r3, r3
}
   17930:	4618      	mov	r0, r3
   17932:	370c      	adds	r7, #12
   17934:	46bd      	mov	sp, r7
   17936:	bc80      	pop	{r7}
   17938:	4770      	bx	lr

0001793a <z_is_thread_queued>:
{
   1793a:	b580      	push	{r7, lr}
   1793c:	b082      	sub	sp, #8
   1793e:	af00      	add	r7, sp, #0
   17940:	6078      	str	r0, [r7, #4]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   17942:	2180      	movs	r1, #128	; 0x80
   17944:	6878      	ldr	r0, [r7, #4]
   17946:	f7ff ffe4 	bl	17912 <z_is_thread_state_set>
   1794a:	4603      	mov	r3, r0
}
   1794c:	4618      	mov	r0, r3
   1794e:	3708      	adds	r7, #8
   17950:	46bd      	mov	sp, r7
   17952:	bd80      	pop	{r7, pc}

00017954 <z_mark_thread_as_suspended>:
{
   17954:	b480      	push	{r7}
   17956:	b083      	sub	sp, #12
   17958:	af00      	add	r7, sp, #0
   1795a:	6078      	str	r0, [r7, #4]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1795c:	687b      	ldr	r3, [r7, #4]
   1795e:	7b5b      	ldrb	r3, [r3, #13]
   17960:	f043 0310 	orr.w	r3, r3, #16
   17964:	b2da      	uxtb	r2, r3
   17966:	687b      	ldr	r3, [r7, #4]
   17968:	735a      	strb	r2, [r3, #13]
}
   1796a:	bf00      	nop
   1796c:	370c      	adds	r7, #12
   1796e:	46bd      	mov	sp, r7
   17970:	bc80      	pop	{r7}
   17972:	4770      	bx	lr

00017974 <z_mark_thread_as_not_suspended>:
{
   17974:	b480      	push	{r7}
   17976:	b083      	sub	sp, #12
   17978:	af00      	add	r7, sp, #0
   1797a:	6078      	str	r0, [r7, #4]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1797c:	687b      	ldr	r3, [r7, #4]
   1797e:	7b5b      	ldrb	r3, [r3, #13]
   17980:	f023 0310 	bic.w	r3, r3, #16
   17984:	b2da      	uxtb	r2, r3
   17986:	687b      	ldr	r3, [r7, #4]
   17988:	735a      	strb	r2, [r3, #13]
}
   1798a:	bf00      	nop
   1798c:	370c      	adds	r7, #12
   1798e:	46bd      	mov	sp, r7
   17990:	bc80      	pop	{r7}
   17992:	4770      	bx	lr

00017994 <z_mark_thread_as_started>:
{
   17994:	b480      	push	{r7}
   17996:	b083      	sub	sp, #12
   17998:	af00      	add	r7, sp, #0
   1799a:	6078      	str	r0, [r7, #4]
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1799c:	687b      	ldr	r3, [r7, #4]
   1799e:	7b5b      	ldrb	r3, [r3, #13]
   179a0:	f023 0304 	bic.w	r3, r3, #4
   179a4:	b2da      	uxtb	r2, r3
   179a6:	687b      	ldr	r3, [r7, #4]
   179a8:	735a      	strb	r2, [r3, #13]
}
   179aa:	bf00      	nop
   179ac:	370c      	adds	r7, #12
   179ae:	46bd      	mov	sp, r7
   179b0:	bc80      	pop	{r7}
   179b2:	4770      	bx	lr

000179b4 <z_mark_thread_as_pending>:
{
   179b4:	b480      	push	{r7}
   179b6:	b083      	sub	sp, #12
   179b8:	af00      	add	r7, sp, #0
   179ba:	6078      	str	r0, [r7, #4]
	thread->base.thread_state |= _THREAD_PENDING;
   179bc:	687b      	ldr	r3, [r7, #4]
   179be:	7b5b      	ldrb	r3, [r3, #13]
   179c0:	f043 0302 	orr.w	r3, r3, #2
   179c4:	b2da      	uxtb	r2, r3
   179c6:	687b      	ldr	r3, [r7, #4]
   179c8:	735a      	strb	r2, [r3, #13]
}
   179ca:	bf00      	nop
   179cc:	370c      	adds	r7, #12
   179ce:	46bd      	mov	sp, r7
   179d0:	bc80      	pop	{r7}
   179d2:	4770      	bx	lr

000179d4 <z_mark_thread_as_not_pending>:
{
   179d4:	b480      	push	{r7}
   179d6:	b083      	sub	sp, #12
   179d8:	af00      	add	r7, sp, #0
   179da:	6078      	str	r0, [r7, #4]
	thread->base.thread_state &= ~_THREAD_PENDING;
   179dc:	687b      	ldr	r3, [r7, #4]
   179de:	7b5b      	ldrb	r3, [r3, #13]
   179e0:	f023 0302 	bic.w	r3, r3, #2
   179e4:	b2da      	uxtb	r2, r3
   179e6:	687b      	ldr	r3, [r7, #4]
   179e8:	735a      	strb	r2, [r3, #13]
}
   179ea:	bf00      	nop
   179ec:	370c      	adds	r7, #12
   179ee:	46bd      	mov	sp, r7
   179f0:	bc80      	pop	{r7}
   179f2:	4770      	bx	lr

000179f4 <z_set_thread_states>:
{
   179f4:	b480      	push	{r7}
   179f6:	b083      	sub	sp, #12
   179f8:	af00      	add	r7, sp, #0
   179fa:	6078      	str	r0, [r7, #4]
   179fc:	6039      	str	r1, [r7, #0]
	thread->base.thread_state |= states;
   179fe:	687b      	ldr	r3, [r7, #4]
   17a00:	7b5a      	ldrb	r2, [r3, #13]
   17a02:	683b      	ldr	r3, [r7, #0]
   17a04:	b2db      	uxtb	r3, r3
   17a06:	4313      	orrs	r3, r2
   17a08:	b2da      	uxtb	r2, r3
   17a0a:	687b      	ldr	r3, [r7, #4]
   17a0c:	735a      	strb	r2, [r3, #13]
}
   17a0e:	bf00      	nop
   17a10:	370c      	adds	r7, #12
   17a12:	46bd      	mov	sp, r7
   17a14:	bc80      	pop	{r7}
   17a16:	4770      	bx	lr

00017a18 <z_reset_thread_states>:
{
   17a18:	b480      	push	{r7}
   17a1a:	b083      	sub	sp, #12
   17a1c:	af00      	add	r7, sp, #0
   17a1e:	6078      	str	r0, [r7, #4]
   17a20:	6039      	str	r1, [r7, #0]
	thread->base.thread_state &= ~states;
   17a22:	687b      	ldr	r3, [r7, #4]
   17a24:	7b5a      	ldrb	r2, [r3, #13]
   17a26:	683b      	ldr	r3, [r7, #0]
   17a28:	b2db      	uxtb	r3, r3
   17a2a:	43db      	mvns	r3, r3
   17a2c:	b2db      	uxtb	r3, r3
   17a2e:	4013      	ands	r3, r2
   17a30:	b2da      	uxtb	r2, r3
   17a32:	687b      	ldr	r3, [r7, #4]
   17a34:	735a      	strb	r2, [r3, #13]
}
   17a36:	bf00      	nop
   17a38:	370c      	adds	r7, #12
   17a3a:	46bd      	mov	sp, r7
   17a3c:	bc80      	pop	{r7}
   17a3e:	4770      	bx	lr

00017a40 <z_mark_thread_as_queued>:
{
   17a40:	b580      	push	{r7, lr}
   17a42:	b082      	sub	sp, #8
   17a44:	af00      	add	r7, sp, #0
   17a46:	6078      	str	r0, [r7, #4]
	z_set_thread_states(thread, _THREAD_QUEUED);
   17a48:	2180      	movs	r1, #128	; 0x80
   17a4a:	6878      	ldr	r0, [r7, #4]
   17a4c:	f7ff ffd2 	bl	179f4 <z_set_thread_states>
}
   17a50:	bf00      	nop
   17a52:	3708      	adds	r7, #8
   17a54:	46bd      	mov	sp, r7
   17a56:	bd80      	pop	{r7, pc}

00017a58 <z_mark_thread_as_not_queued>:
{
   17a58:	b580      	push	{r7, lr}
   17a5a:	b082      	sub	sp, #8
   17a5c:	af00      	add	r7, sp, #0
   17a5e:	6078      	str	r0, [r7, #4]
	z_reset_thread_states(thread, _THREAD_QUEUED);
   17a60:	2180      	movs	r1, #128	; 0x80
   17a62:	6878      	ldr	r0, [r7, #4]
   17a64:	f7ff ffd8 	bl	17a18 <z_reset_thread_states>
}
   17a68:	bf00      	nop
   17a6a:	3708      	adds	r7, #8
   17a6c:	46bd      	mov	sp, r7
   17a6e:	bd80      	pop	{r7, pc}

00017a70 <z_is_prio1_higher_than_prio2>:
{
   17a70:	b480      	push	{r7}
   17a72:	b083      	sub	sp, #12
   17a74:	af00      	add	r7, sp, #0
   17a76:	6078      	str	r0, [r7, #4]
   17a78:	6039      	str	r1, [r7, #0]
	return prio1 < prio2;
   17a7a:	687a      	ldr	r2, [r7, #4]
   17a7c:	683b      	ldr	r3, [r7, #0]
   17a7e:	429a      	cmp	r2, r3
   17a80:	bfb4      	ite	lt
   17a82:	2301      	movlt	r3, #1
   17a84:	2300      	movge	r3, #0
   17a86:	b2db      	uxtb	r3, r3
}
   17a88:	4618      	mov	r0, r3
   17a8a:	370c      	adds	r7, #12
   17a8c:	46bd      	mov	sp, r7
   17a8e:	bc80      	pop	{r7}
   17a90:	4770      	bx	lr

00017a92 <z_is_prio_higher>:
{
   17a92:	b580      	push	{r7, lr}
   17a94:	b082      	sub	sp, #8
   17a96:	af00      	add	r7, sp, #0
   17a98:	6078      	str	r0, [r7, #4]
   17a9a:	6039      	str	r1, [r7, #0]
	return z_is_prio1_higher_than_prio2(prio, test_prio);
   17a9c:	6839      	ldr	r1, [r7, #0]
   17a9e:	6878      	ldr	r0, [r7, #4]
   17aa0:	f7ff ffe6 	bl	17a70 <z_is_prio1_higher_than_prio2>
   17aa4:	4603      	mov	r3, r0
}
   17aa6:	4618      	mov	r0, r3
   17aa8:	3708      	adds	r7, #8
   17aaa:	46bd      	mov	sp, r7
   17aac:	bd80      	pop	{r7, pc}

00017aae <z_waitq_head>:
{
   17aae:	b580      	push	{r7, lr}
   17ab0:	b082      	sub	sp, #8
   17ab2:	af00      	add	r7, sp, #0
   17ab4:	6078      	str	r0, [r7, #4]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   17ab6:	687b      	ldr	r3, [r7, #4]
   17ab8:	4618      	mov	r0, r3
   17aba:	f7ff fb9e 	bl	171fa <sys_dlist_peek_head>
   17abe:	4603      	mov	r3, r0
}
   17ac0:	4618      	mov	r0, r3
   17ac2:	3708      	adds	r7, #8
   17ac4:	46bd      	mov	sp, r7
   17ac6:	bd80      	pop	{r7, pc}

00017ac8 <z_swap_irqlock>:
{
   17ac8:	b580      	push	{r7, lr}
   17aca:	b084      	sub	sp, #16
   17acc:	af00      	add	r7, sp, #0
   17ace:	6078      	str	r0, [r7, #4]
	ret = arch_swap(key);
   17ad0:	6878      	ldr	r0, [r7, #4]
   17ad2:	f7ec ff2b 	bl	492c <arch_swap>
   17ad6:	60f8      	str	r0, [r7, #12]
	return ret;
   17ad8:	68fb      	ldr	r3, [r7, #12]
}
   17ada:	4618      	mov	r0, r3
   17adc:	3710      	adds	r7, #16
   17ade:	46bd      	mov	sp, r7
   17ae0:	bd80      	pop	{r7, pc}

00017ae2 <z_swap_unlocked>:
{
   17ae2:	b580      	push	{r7, lr}
   17ae4:	b082      	sub	sp, #8
   17ae6:	af00      	add	r7, sp, #0
	__asm__ volatile(
   17ae8:	f04f 0320 	mov.w	r3, #32
   17aec:	f3ef 8211 	mrs	r2, BASEPRI
   17af0:	f383 8811 	msr	BASEPRI, r3
   17af4:	f3bf 8f6f 	isb	sy
   17af8:	607a      	str	r2, [r7, #4]
   17afa:	603b      	str	r3, [r7, #0]
	return key;
   17afc:	687b      	ldr	r3, [r7, #4]
	(void) z_swap_irqlock(arch_irq_lock());
   17afe:	4618      	mov	r0, r3
   17b00:	f7ff ffe2 	bl	17ac8 <z_swap_irqlock>
}
   17b04:	bf00      	nop
   17b06:	3708      	adds	r7, #8
   17b08:	46bd      	mov	sp, r7
   17b0a:	bd80      	pop	{r7, pc}

00017b0c <is_preempt>:
{
   17b0c:	b480      	push	{r7}
   17b0e:	b083      	sub	sp, #12
   17b10:	af00      	add	r7, sp, #0
   17b12:	6078      	str	r0, [r7, #4]
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   17b14:	687b      	ldr	r3, [r7, #4]
   17b16:	89db      	ldrh	r3, [r3, #14]
   17b18:	2b7f      	cmp	r3, #127	; 0x7f
   17b1a:	bf94      	ite	ls
   17b1c:	2301      	movls	r3, #1
   17b1e:	2300      	movhi	r3, #0
   17b20:	b2db      	uxtb	r3, r3
}
   17b22:	4618      	mov	r0, r3
   17b24:	370c      	adds	r7, #12
   17b26:	46bd      	mov	sp, r7
   17b28:	bc80      	pop	{r7}
   17b2a:	4770      	bx	lr

00017b2c <is_metairq>:
{
   17b2c:	b480      	push	{r7}
   17b2e:	b083      	sub	sp, #12
   17b30:	af00      	add	r7, sp, #0
   17b32:	6078      	str	r0, [r7, #4]
	return 0;
   17b34:	2300      	movs	r3, #0
}
   17b36:	4618      	mov	r0, r3
   17b38:	370c      	adds	r7, #12
   17b3a:	46bd      	mov	sp, r7
   17b3c:	bc80      	pop	{r7}
   17b3e:	4770      	bx	lr

00017b40 <z_is_t1_higher_prio_than_t2>:
{
   17b40:	b480      	push	{r7}
   17b42:	b083      	sub	sp, #12
   17b44:	af00      	add	r7, sp, #0
   17b46:	6078      	str	r0, [r7, #4]
   17b48:	6039      	str	r1, [r7, #0]
	if (thread_1->base.prio < thread_2->base.prio) {
   17b4a:	687b      	ldr	r3, [r7, #4]
   17b4c:	f993 200e 	ldrsb.w	r2, [r3, #14]
   17b50:	683b      	ldr	r3, [r7, #0]
   17b52:	f993 300e 	ldrsb.w	r3, [r3, #14]
   17b56:	429a      	cmp	r2, r3
   17b58:	da01      	bge.n	17b5e <z_is_t1_higher_prio_than_t2+0x1e>
		return true;
   17b5a:	2301      	movs	r3, #1
   17b5c:	e000      	b.n	17b60 <z_is_t1_higher_prio_than_t2+0x20>
	return false;
   17b5e:	2300      	movs	r3, #0
}
   17b60:	4618      	mov	r0, r3
   17b62:	370c      	adds	r7, #12
   17b64:	46bd      	mov	sp, r7
   17b66:	bc80      	pop	{r7}
   17b68:	4770      	bx	lr

00017b6a <update_metairq_preempt>:
{
   17b6a:	b480      	push	{r7}
   17b6c:	b083      	sub	sp, #12
   17b6e:	af00      	add	r7, sp, #0
   17b70:	6078      	str	r0, [r7, #4]
}
   17b72:	bf00      	nop
   17b74:	370c      	adds	r7, #12
   17b76:	46bd      	mov	sp, r7
   17b78:	bc80      	pop	{r7}
   17b7a:	4770      	bx	lr

00017b7c <add_thread_timeout>:
{
   17b7c:	b580      	push	{r7, lr}
   17b7e:	b084      	sub	sp, #16
   17b80:	af00      	add	r7, sp, #0
   17b82:	60f8      	str	r0, [r7, #12]
   17b84:	e9c7 2300 	strd	r2, r3, [r7]
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   17b88:	e9d7 2300 	ldrd	r2, r3, [r7]
   17b8c:	f04f 30ff 	mov.w	r0, #4294967295
   17b90:	f04f 31ff 	mov.w	r1, #4294967295
   17b94:	428b      	cmp	r3, r1
   17b96:	bf08      	it	eq
   17b98:	4282      	cmpeq	r2, r0
   17b9a:	d004      	beq.n	17ba6 <add_thread_timeout+0x2a>
		z_add_thread_timeout(thread, timeout);
   17b9c:	e9d7 2300 	ldrd	r2, r3, [r7]
   17ba0:	68f8      	ldr	r0, [r7, #12]
   17ba2:	f7f4 fb6f 	bl	c284 <z_add_thread_timeout>
}
   17ba6:	bf00      	nop
   17ba8:	3710      	adds	r7, #16
   17baa:	46bd      	mov	sp, r7
   17bac:	bd80      	pop	{r7, pc}

00017bae <unpend_thread_no_timeout>:
{
   17bae:	b580      	push	{r7, lr}
   17bb0:	b082      	sub	sp, #8
   17bb2:	af00      	add	r7, sp, #0
   17bb4:	6078      	str	r0, [r7, #4]
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
   17bb6:	6878      	ldr	r0, [r7, #4]
   17bb8:	f7f5 f940 	bl	ce3c <pended_on>
   17bbc:	4603      	mov	r3, r0
   17bbe:	6879      	ldr	r1, [r7, #4]
   17bc0:	4618      	mov	r0, r3
   17bc2:	f7f6 f905 	bl	ddd0 <z_priq_dumb_remove>
	z_mark_thread_as_not_pending(thread);
   17bc6:	6878      	ldr	r0, [r7, #4]
   17bc8:	f7ff ff04 	bl	179d4 <z_mark_thread_as_not_pending>
	thread->base.pended_on = NULL;
   17bcc:	687b      	ldr	r3, [r7, #4]
   17bce:	2200      	movs	r2, #0
   17bd0:	609a      	str	r2, [r3, #8]
}
   17bd2:	bf00      	nop
   17bd4:	3708      	adds	r7, #8
   17bd6:	46bd      	mov	sp, r7
   17bd8:	bd80      	pop	{r7, pc}

00017bda <z_unpend_first_thread>:
{
   17bda:	b580      	push	{r7, lr}
   17bdc:	b084      	sub	sp, #16
   17bde:	af00      	add	r7, sp, #0
   17be0:	6078      	str	r0, [r7, #4]
	struct k_thread *thread = z_unpend1_no_timeout(wait_q);
   17be2:	6878      	ldr	r0, [r7, #4]
   17be4:	f7f4 fbbc 	bl	c360 <z_unpend1_no_timeout>
   17be8:	60f8      	str	r0, [r7, #12]
	if (thread != NULL) {
   17bea:	68fb      	ldr	r3, [r7, #12]
   17bec:	2b00      	cmp	r3, #0
   17bee:	d002      	beq.n	17bf6 <z_unpend_first_thread+0x1c>
		(void)z_abort_thread_timeout(thread);
   17bf0:	68f8      	ldr	r0, [r7, #12]
   17bf2:	f7ff fdfa 	bl	177ea <z_abort_thread_timeout>
	return thread;
   17bf6:	68fb      	ldr	r3, [r7, #12]
}
   17bf8:	4618      	mov	r0, r3
   17bfa:	3710      	adds	r7, #16
   17bfc:	46bd      	mov	sp, r7
   17bfe:	bd80      	pop	{r7, pc}

00017c00 <resched>:
{
   17c00:	b480      	push	{r7}
   17c02:	b085      	sub	sp, #20
   17c04:	af00      	add	r7, sp, #0
   17c06:	6078      	str	r0, [r7, #4]
   17c08:	687b      	ldr	r3, [r7, #4]
   17c0a:	60fb      	str	r3, [r7, #12]

static ALWAYS_INLINE bool arch_irq_unlocked(unsigned int key)
{
	/* This convention works for both PRIMASK and BASEPRI */
	return key == 0U;
   17c0c:	68fb      	ldr	r3, [r7, #12]
   17c0e:	2b00      	cmp	r3, #0
   17c10:	bf0c      	ite	eq
   17c12:	2301      	moveq	r3, #1
   17c14:	2300      	movne	r3, #0
   17c16:	b2db      	uxtb	r3, r3
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   17c18:	2b00      	cmp	r3, #0
   17c1a:	d00f      	beq.n	17c3c <resched+0x3c>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   17c1c:	f3ef 8305 	mrs	r3, IPSR
   17c20:	60bb      	str	r3, [r7, #8]
  return(result);
   17c22:	68bb      	ldr	r3, [r7, #8]
   17c24:	2b00      	cmp	r3, #0
   17c26:	bf14      	ite	ne
   17c28:	2301      	movne	r3, #1
   17c2a:	2300      	moveq	r3, #0
   17c2c:	b2db      	uxtb	r3, r3
   17c2e:	f083 0301 	eor.w	r3, r3, #1
   17c32:	b2db      	uxtb	r3, r3
   17c34:	2b00      	cmp	r3, #0
   17c36:	d001      	beq.n	17c3c <resched+0x3c>
   17c38:	2301      	movs	r3, #1
   17c3a:	e000      	b.n	17c3e <resched+0x3e>
   17c3c:	2300      	movs	r3, #0
}
   17c3e:	4618      	mov	r0, r3
   17c40:	3714      	adds	r7, #20
   17c42:	46bd      	mov	sp, r7
   17c44:	bc80      	pop	{r7}
   17c46:	4770      	bx	lr

00017c48 <z_reschedule_irqlock>:
{
   17c48:	b580      	push	{r7, lr}
   17c4a:	b084      	sub	sp, #16
   17c4c:	af00      	add	r7, sp, #0
   17c4e:	6078      	str	r0, [r7, #4]
	if (resched(key)) {
   17c50:	6878      	ldr	r0, [r7, #4]
   17c52:	f7ff ffd5 	bl	17c00 <resched>
   17c56:	4603      	mov	r3, r0
   17c58:	2b00      	cmp	r3, #0
   17c5a:	d003      	beq.n	17c64 <z_reschedule_irqlock+0x1c>
		z_swap_irqlock(key);
   17c5c:	6878      	ldr	r0, [r7, #4]
   17c5e:	f7ff ff33 	bl	17ac8 <z_swap_irqlock>
}
   17c62:	e007      	b.n	17c74 <z_reschedule_irqlock+0x2c>
   17c64:	687b      	ldr	r3, [r7, #4]
   17c66:	60fb      	str	r3, [r7, #12]
	__asm__ volatile(
   17c68:	68fb      	ldr	r3, [r7, #12]
   17c6a:	f383 8811 	msr	BASEPRI, r3
   17c6e:	f3bf 8f6f 	isb	sy
}
   17c72:	bf00      	nop
   17c74:	bf00      	nop
   17c76:	3710      	adds	r7, #16
   17c78:	46bd      	mov	sp, r7
   17c7a:	bd80      	pop	{r7, pc}

00017c7c <z_priq_dumb_best>:
{
   17c7c:	b580      	push	{r7, lr}
   17c7e:	b084      	sub	sp, #16
   17c80:	af00      	add	r7, sp, #0
   17c82:	6078      	str	r0, [r7, #4]
	struct k_thread *thread = NULL;
   17c84:	2300      	movs	r3, #0
   17c86:	60fb      	str	r3, [r7, #12]
	sys_dnode_t *n = sys_dlist_peek_head(pq);
   17c88:	6878      	ldr	r0, [r7, #4]
   17c8a:	f7ff fab6 	bl	171fa <sys_dlist_peek_head>
   17c8e:	60b8      	str	r0, [r7, #8]
	if (n != NULL) {
   17c90:	68bb      	ldr	r3, [r7, #8]
   17c92:	2b00      	cmp	r3, #0
   17c94:	d001      	beq.n	17c9a <z_priq_dumb_best+0x1e>
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
   17c96:	68bb      	ldr	r3, [r7, #8]
   17c98:	60fb      	str	r3, [r7, #12]
	return thread;
   17c9a:	68fb      	ldr	r3, [r7, #12]
}
   17c9c:	4618      	mov	r0, r3
   17c9e:	3710      	adds	r7, #16
   17ca0:	46bd      	mov	sp, r7
   17ca2:	bd80      	pop	{r7, pc}

00017ca4 <handle_poll_events>:
{
   17ca4:	b480      	push	{r7}
   17ca6:	b083      	sub	sp, #12
   17ca8:	af00      	add	r7, sp, #0
   17caa:	6078      	str	r0, [r7, #4]
}
   17cac:	bf00      	nop
   17cae:	370c      	adds	r7, #12
   17cb0:	46bd      	mov	sp, r7
   17cb2:	bc80      	pop	{r7}
   17cb4:	4770      	bx	lr

00017cb6 <atomic_set>:
{
   17cb6:	b480      	push	{r7}
   17cb8:	b083      	sub	sp, #12
   17cba:	af00      	add	r7, sp, #0
   17cbc:	6078      	str	r0, [r7, #4]
   17cbe:	6039      	str	r1, [r7, #0]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   17cc0:	683a      	ldr	r2, [r7, #0]
   17cc2:	687b      	ldr	r3, [r7, #4]
   17cc4:	e8d3 1fef 	ldaex	r1, [r3]
   17cc8:	e8c3 2fe0 	stlex	r0, r2, [r3]
   17ccc:	2800      	cmp	r0, #0
   17cce:	d1f9      	bne.n	17cc4 <atomic_set+0xe>
   17cd0:	460b      	mov	r3, r1
}
   17cd2:	4618      	mov	r0, r3
   17cd4:	370c      	adds	r7, #12
   17cd6:	46bd      	mov	sp, r7
   17cd8:	bc80      	pop	{r7}
   17cda:	4770      	bx	lr

00017cdc <sys_dlist_init>:
{
   17cdc:	b480      	push	{r7}
   17cde:	b083      	sub	sp, #12
   17ce0:	af00      	add	r7, sp, #0
   17ce2:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   17ce4:	687b      	ldr	r3, [r7, #4]
   17ce6:	687a      	ldr	r2, [r7, #4]
   17ce8:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   17cea:	687b      	ldr	r3, [r7, #4]
   17cec:	687a      	ldr	r2, [r7, #4]
   17cee:	605a      	str	r2, [r3, #4]
}
   17cf0:	bf00      	nop
   17cf2:	370c      	adds	r7, #12
   17cf4:	46bd      	mov	sp, r7
   17cf6:	bc80      	pop	{r7}
   17cf8:	4770      	bx	lr

00017cfa <sys_dnode_init>:
{
   17cfa:	b480      	push	{r7}
   17cfc:	b083      	sub	sp, #12
   17cfe:	af00      	add	r7, sp, #0
   17d00:	6078      	str	r0, [r7, #4]
	node->next = NULL;
   17d02:	687b      	ldr	r3, [r7, #4]
   17d04:	2200      	movs	r2, #0
   17d06:	601a      	str	r2, [r3, #0]
	node->prev = NULL;
   17d08:	687b      	ldr	r3, [r7, #4]
   17d0a:	2200      	movs	r2, #0
   17d0c:	605a      	str	r2, [r3, #4]
}
   17d0e:	bf00      	nop
   17d10:	370c      	adds	r7, #12
   17d12:	46bd      	mov	sp, r7
   17d14:	bc80      	pop	{r7}
   17d16:	4770      	bx	lr

00017d18 <_is_user_context>:
{
   17d18:	b480      	push	{r7}
   17d1a:	af00      	add	r7, sp, #0
	return false;
   17d1c:	2300      	movs	r3, #0
}
   17d1e:	4618      	mov	r0, r3
   17d20:	46bd      	mov	sp, r7
   17d22:	bc80      	pop	{r7}
   17d24:	4770      	bx	lr

00017d26 <k_ms_to_ticks_ceil64>:
{
   17d26:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
   17d2a:	b08c      	sub	sp, #48	; 0x30
   17d2c:	af00      	add	r7, sp, #0
   17d2e:	e9c7 0100 	strd	r0, r1, [r7]
   17d32:	e9d7 2300 	ldrd	r2, r3, [r7]
   17d36:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   17d3a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   17d3e:	627b      	str	r3, [r7, #36]	; 0x24
   17d40:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   17d44:	623b      	str	r3, [r7, #32]
   17d46:	2301      	movs	r3, #1
   17d48:	77fb      	strb	r3, [r7, #31]
   17d4a:	2300      	movs	r3, #0
   17d4c:	77bb      	strb	r3, [r7, #30]
   17d4e:	2301      	movs	r3, #1
   17d50:	777b      	strb	r3, [r7, #29]
   17d52:	2300      	movs	r3, #0
   17d54:	773b      	strb	r3, [r7, #28]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   17d56:	7ffb      	ldrb	r3, [r7, #31]
   17d58:	2b00      	cmp	r3, #0
   17d5a:	d00f      	beq.n	17d7c <k_ms_to_ticks_ceil64+0x56>
	bool mul_ratio = const_hz &&
   17d5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17d5e:	6a3b      	ldr	r3, [r7, #32]
   17d60:	429a      	cmp	r2, r3
   17d62:	d20b      	bcs.n	17d7c <k_ms_to_ticks_ceil64+0x56>
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
   17d64:	6a3b      	ldr	r3, [r7, #32]
   17d66:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17d68:	fbb3 f2f2 	udiv	r2, r3, r2
   17d6c:	6a79      	ldr	r1, [r7, #36]	; 0x24
   17d6e:	fb01 f202 	mul.w	r2, r1, r2
   17d72:	1a9b      	subs	r3, r3, r2
   17d74:	2b00      	cmp	r3, #0
   17d76:	d101      	bne.n	17d7c <k_ms_to_ticks_ceil64+0x56>
   17d78:	2301      	movs	r3, #1
   17d7a:	e000      	b.n	17d7e <k_ms_to_ticks_ceil64+0x58>
   17d7c:	2300      	movs	r3, #0
	bool mul_ratio = const_hz &&
   17d7e:	76fb      	strb	r3, [r7, #27]
   17d80:	7efb      	ldrb	r3, [r7, #27]
   17d82:	f003 0301 	and.w	r3, r3, #1
   17d86:	76fb      	strb	r3, [r7, #27]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   17d88:	7ffb      	ldrb	r3, [r7, #31]
   17d8a:	2b00      	cmp	r3, #0
   17d8c:	d00f      	beq.n	17dae <k_ms_to_ticks_ceil64+0x88>
	bool div_ratio = const_hz &&
   17d8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17d90:	6a3b      	ldr	r3, [r7, #32]
   17d92:	429a      	cmp	r2, r3
   17d94:	d90b      	bls.n	17dae <k_ms_to_ticks_ceil64+0x88>
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
   17d96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17d98:	6a3a      	ldr	r2, [r7, #32]
   17d9a:	fbb3 f2f2 	udiv	r2, r3, r2
   17d9e:	6a39      	ldr	r1, [r7, #32]
   17da0:	fb01 f202 	mul.w	r2, r1, r2
   17da4:	1a9b      	subs	r3, r3, r2
   17da6:	2b00      	cmp	r3, #0
   17da8:	d101      	bne.n	17dae <k_ms_to_ticks_ceil64+0x88>
   17daa:	2301      	movs	r3, #1
   17dac:	e000      	b.n	17db0 <k_ms_to_ticks_ceil64+0x8a>
   17dae:	2300      	movs	r3, #0
	bool div_ratio = const_hz &&
   17db0:	76bb      	strb	r3, [r7, #26]
   17db2:	7ebb      	ldrb	r3, [r7, #26]
   17db4:	f003 0301 	and.w	r3, r3, #1
   17db8:	76bb      	strb	r3, [r7, #26]
	if (from_hz == to_hz) {
   17dba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17dbc:	6a3b      	ldr	r3, [r7, #32]
   17dbe:	429a      	cmp	r2, r3
   17dc0:	d10a      	bne.n	17dd8 <k_ms_to_ticks_ceil64+0xb2>
		return result32 ? ((uint32_t)t) : t;
   17dc2:	7fbb      	ldrb	r3, [r7, #30]
   17dc4:	2b00      	cmp	r3, #0
   17dc6:	d004      	beq.n	17dd2 <k_ms_to_ticks_ceil64+0xac>
   17dc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   17dca:	461a      	mov	r2, r3
   17dcc:	f04f 0300 	mov.w	r3, #0
   17dd0:	e0c8      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
   17dd2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   17dd6:	e0c5      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
	uint64_t off = 0;
   17dd8:	f04f 0200 	mov.w	r2, #0
   17ddc:	f04f 0300 	mov.w	r3, #0
   17de0:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (!mul_ratio) {
   17de4:	7efb      	ldrb	r3, [r7, #27]
   17de6:	f083 0301 	eor.w	r3, r3, #1
   17dea:	b2db      	uxtb	r3, r3
   17dec:	2b00      	cmp	r3, #0
   17dee:	d01e      	beq.n	17e2e <k_ms_to_ticks_ceil64+0x108>
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
   17df0:	7ebb      	ldrb	r3, [r7, #26]
   17df2:	2b00      	cmp	r3, #0
   17df4:	d004      	beq.n	17e00 <k_ms_to_ticks_ceil64+0xda>
   17df6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17df8:	6a3b      	ldr	r3, [r7, #32]
   17dfa:	fbb2 f3f3 	udiv	r3, r2, r3
   17dfe:	e000      	b.n	17e02 <k_ms_to_ticks_ceil64+0xdc>
   17e00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17e02:	60fb      	str	r3, [r7, #12]
		if (round_up) {
   17e04:	7f7b      	ldrb	r3, [r7, #29]
   17e06:	2b00      	cmp	r3, #0
   17e08:	d007      	beq.n	17e1a <k_ms_to_ticks_ceil64+0xf4>
			off = rdivisor - 1U;
   17e0a:	68fb      	ldr	r3, [r7, #12]
   17e0c:	3b01      	subs	r3, #1
   17e0e:	461a      	mov	r2, r3
   17e10:	f04f 0300 	mov.w	r3, #0
   17e14:	e9c7 2304 	strd	r2, r3, [r7, #16]
   17e18:	e009      	b.n	17e2e <k_ms_to_ticks_ceil64+0x108>
		} else if (round_off) {
   17e1a:	7f3b      	ldrb	r3, [r7, #28]
   17e1c:	2b00      	cmp	r3, #0
   17e1e:	d006      	beq.n	17e2e <k_ms_to_ticks_ceil64+0x108>
			off = rdivisor / 2U;
   17e20:	68fb      	ldr	r3, [r7, #12]
   17e22:	085b      	lsrs	r3, r3, #1
   17e24:	461a      	mov	r2, r3
   17e26:	f04f 0300 	mov.w	r3, #0
   17e2a:	e9c7 2304 	strd	r2, r3, [r7, #16]
	if (div_ratio) {
   17e2e:	7ebb      	ldrb	r3, [r7, #26]
   17e30:	2b00      	cmp	r3, #0
   17e32:	d02a      	beq.n	17e8a <k_ms_to_ticks_ceil64+0x164>
		t += off;
   17e34:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   17e38:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
   17e3c:	1884      	adds	r4, r0, r2
   17e3e:	eb41 0503 	adc.w	r5, r1, r3
   17e42:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
		if (result32 && (t < BIT64(32))) {
   17e46:	7fbb      	ldrb	r3, [r7, #30]
   17e48:	2b00      	cmp	r3, #0
   17e4a:	d010      	beq.n	17e6e <k_ms_to_ticks_ceil64+0x148>
   17e4c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
   17e50:	2b01      	cmp	r3, #1
   17e52:	bf08      	it	eq
   17e54:	2a00      	cmpeq	r2, #0
   17e56:	d20a      	bcs.n	17e6e <k_ms_to_ticks_ceil64+0x148>
			return ((uint32_t)t) / (from_hz / to_hz);
   17e58:	6aba      	ldr	r2, [r7, #40]	; 0x28
   17e5a:	6a79      	ldr	r1, [r7, #36]	; 0x24
   17e5c:	6a3b      	ldr	r3, [r7, #32]
   17e5e:	fbb1 f3f3 	udiv	r3, r1, r3
   17e62:	fbb2 f3f3 	udiv	r3, r2, r3
   17e66:	461a      	mov	r2, r3
   17e68:	f04f 0300 	mov.w	r3, #0
   17e6c:	e07a      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
			return t / (from_hz / to_hz);
   17e6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17e70:	6a3b      	ldr	r3, [r7, #32]
   17e72:	fbb2 f3f3 	udiv	r3, r2, r3
   17e76:	461a      	mov	r2, r3
   17e78:	f04f 0300 	mov.w	r3, #0
   17e7c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
   17e80:	f7e8 f960 	bl	144 <__aeabi_uldivmod>
   17e84:	4602      	mov	r2, r0
   17e86:	460b      	mov	r3, r1
   17e88:	e06c      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
	} else if (mul_ratio) {
   17e8a:	7efb      	ldrb	r3, [r7, #27]
   17e8c:	2b00      	cmp	r3, #0
   17e8e:	d021      	beq.n	17ed4 <k_ms_to_ticks_ceil64+0x1ae>
		if (result32) {
   17e90:	7fbb      	ldrb	r3, [r7, #30]
   17e92:	2b00      	cmp	r3, #0
   17e94:	d00a      	beq.n	17eac <k_ms_to_ticks_ceil64+0x186>
			return ((uint32_t)t) * (to_hz / from_hz);
   17e96:	6abb      	ldr	r3, [r7, #40]	; 0x28
   17e98:	6a39      	ldr	r1, [r7, #32]
   17e9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   17e9c:	fbb1 f2f2 	udiv	r2, r1, r2
   17ea0:	fb02 f303 	mul.w	r3, r2, r3
   17ea4:	461a      	mov	r2, r3
   17ea6:	f04f 0300 	mov.w	r3, #0
   17eaa:	e05b      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
			return t * (to_hz / from_hz);
   17eac:	6a3a      	ldr	r2, [r7, #32]
   17eae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17eb0:	fbb2 f3f3 	udiv	r3, r2, r3
   17eb4:	461a      	mov	r2, r3
   17eb6:	f04f 0300 	mov.w	r3, #0
   17eba:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   17ebc:	fb03 f001 	mul.w	r0, r3, r1
   17ec0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   17ec2:	fb02 f101 	mul.w	r1, r2, r1
   17ec6:	4401      	add	r1, r0
   17ec8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   17eca:	fba0 2302 	umull	r2, r3, r0, r2
   17ece:	4419      	add	r1, r3
   17ed0:	460b      	mov	r3, r1
   17ed2:	e047      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
		if (result32) {
   17ed4:	7fbb      	ldrb	r3, [r7, #30]
   17ed6:	2b00      	cmp	r3, #0
   17ed8:	d024      	beq.n	17f24 <k_ms_to_ticks_ceil64+0x1fe>
			return (uint32_t)((t * to_hz + off) / from_hz);
   17eda:	6a3b      	ldr	r3, [r7, #32]
   17edc:	461a      	mov	r2, r3
   17ede:	f04f 0300 	mov.w	r3, #0
   17ee2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   17ee4:	fb03 f001 	mul.w	r0, r3, r1
   17ee8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   17eea:	fb02 f101 	mul.w	r1, r2, r1
   17eee:	4401      	add	r1, r0
   17ef0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   17ef2:	fba0 2302 	umull	r2, r3, r0, r2
   17ef6:	4419      	add	r1, r3
   17ef8:	460b      	mov	r3, r1
   17efa:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   17efe:	eb12 0a00 	adds.w	sl, r2, r0
   17f02:	eb43 0b01 	adc.w	fp, r3, r1
   17f06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17f08:	461a      	mov	r2, r3
   17f0a:	f04f 0300 	mov.w	r3, #0
   17f0e:	4650      	mov	r0, sl
   17f10:	4659      	mov	r1, fp
   17f12:	f7e8 f917 	bl	144 <__aeabi_uldivmod>
   17f16:	4602      	mov	r2, r0
   17f18:	460b      	mov	r3, r1
   17f1a:	4613      	mov	r3, r2
   17f1c:	461a      	mov	r2, r3
   17f1e:	f04f 0300 	mov.w	r3, #0
   17f22:	e01f      	b.n	17f64 <k_ms_to_ticks_ceil64+0x23e>
			return (t * to_hz + off) / from_hz;
   17f24:	6a3b      	ldr	r3, [r7, #32]
   17f26:	461a      	mov	r2, r3
   17f28:	f04f 0300 	mov.w	r3, #0
   17f2c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   17f2e:	fb03 f001 	mul.w	r0, r3, r1
   17f32:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   17f34:	fb02 f101 	mul.w	r1, r2, r1
   17f38:	4401      	add	r1, r0
   17f3a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   17f3c:	fba0 2302 	umull	r2, r3, r0, r2
   17f40:	4419      	add	r1, r3
   17f42:	460b      	mov	r3, r1
   17f44:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
   17f48:	eb12 0800 	adds.w	r8, r2, r0
   17f4c:	eb43 0901 	adc.w	r9, r3, r1
   17f50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   17f52:	461a      	mov	r2, r3
   17f54:	f04f 0300 	mov.w	r3, #0
   17f58:	4640      	mov	r0, r8
   17f5a:	4649      	mov	r1, r9
   17f5c:	f7e8 f8f2 	bl	144 <__aeabi_uldivmod>
   17f60:	4602      	mov	r2, r0
   17f62:	460b      	mov	r3, r1
}
   17f64:	4610      	mov	r0, r2
   17f66:	4619      	mov	r1, r3
   17f68:	3730      	adds	r7, #48	; 0x30
   17f6a:	46bd      	mov	sp, r7
   17f6c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

00017f70 <Z_KERNEL_STACK_BUFFER>:
{
   17f70:	b480      	push	{r7}
   17f72:	b083      	sub	sp, #12
   17f74:	af00      	add	r7, sp, #0
   17f76:	6078      	str	r0, [r7, #4]
	return (char *)sym + K_KERNEL_STACK_RESERVED;
   17f78:	687b      	ldr	r3, [r7, #4]
}
   17f7a:	4618      	mov	r0, r3
   17f7c:	370c      	adds	r7, #12
   17f7e:	46bd      	mov	sp, r7
   17f80:	bc80      	pop	{r7}
   17f82:	4770      	bx	lr

00017f84 <k_thread_start>:
{
   17f84:	b580      	push	{r7, lr}
   17f86:	b082      	sub	sp, #8
   17f88:	af00      	add	r7, sp, #0
   17f8a:	6078      	str	r0, [r7, #4]
	z_impl_k_thread_start(thread);
   17f8c:	6878      	ldr	r0, [r7, #4]
   17f8e:	f000 f85f 	bl	18050 <z_impl_k_thread_start>
}
   17f92:	bf00      	nop
   17f94:	3708      	adds	r7, #8
   17f96:	46bd      	mov	sp, r7
   17f98:	bd80      	pop	{r7, pc}

00017f9a <z_init_timeout>:
{
   17f9a:	b580      	push	{r7, lr}
   17f9c:	b082      	sub	sp, #8
   17f9e:	af00      	add	r7, sp, #0
   17fa0:	6078      	str	r0, [r7, #4]
	sys_dnode_init(&t->node);
   17fa2:	687b      	ldr	r3, [r7, #4]
   17fa4:	4618      	mov	r0, r3
   17fa6:	f7ff fea8 	bl	17cfa <sys_dnode_init>
}
   17faa:	bf00      	nop
   17fac:	3708      	adds	r7, #8
   17fae:	46bd      	mov	sp, r7
   17fb0:	bd80      	pop	{r7, pc}

00017fb2 <z_init_thread_timeout>:
{
   17fb2:	b580      	push	{r7, lr}
   17fb4:	b082      	sub	sp, #8
   17fb6:	af00      	add	r7, sp, #0
   17fb8:	6078      	str	r0, [r7, #4]
	z_init_timeout(&thread_base->timeout);
   17fba:	687b      	ldr	r3, [r7, #4]
   17fbc:	3318      	adds	r3, #24
   17fbe:	4618      	mov	r0, r3
   17fc0:	f7ff ffeb 	bl	17f9a <z_init_timeout>
}
   17fc4:	bf00      	nop
   17fc6:	3708      	adds	r7, #8
   17fc8:	46bd      	mov	sp, r7
   17fca:	bd80      	pop	{r7, pc}

00017fcc <z_waitq_init>:
{
   17fcc:	b580      	push	{r7, lr}
   17fce:	b082      	sub	sp, #8
   17fd0:	af00      	add	r7, sp, #0
   17fd2:	6078      	str	r0, [r7, #4]
	sys_dlist_init(&w->waitq);
   17fd4:	687b      	ldr	r3, [r7, #4]
   17fd6:	4618      	mov	r0, r3
   17fd8:	f7ff fe80 	bl	17cdc <sys_dlist_init>
}
   17fdc:	bf00      	nop
   17fde:	3708      	adds	r7, #8
   17fe0:	46bd      	mov	sp, r7
   17fe2:	bd80      	pop	{r7, pc}

00017fe4 <k_is_in_isr>:
{
   17fe4:	b480      	push	{r7}
   17fe6:	b083      	sub	sp, #12
   17fe8:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   17fea:	f3ef 8305 	mrs	r3, IPSR
   17fee:	607b      	str	r3, [r7, #4]
  return(result);
   17ff0:	687b      	ldr	r3, [r7, #4]
   17ff2:	2b00      	cmp	r3, #0
   17ff4:	bf14      	ite	ne
   17ff6:	2301      	movne	r3, #1
   17ff8:	2300      	moveq	r3, #0
   17ffa:	b2db      	uxtb	r3, r3
}
   17ffc:	4618      	mov	r0, r3
   17ffe:	370c      	adds	r7, #12
   18000:	46bd      	mov	sp, r7
   18002:	bc80      	pop	{r7}
   18004:	4770      	bx	lr

00018006 <z_impl_k_busy_wait>:
{
   18006:	b580      	push	{r7, lr}
   18008:	b082      	sub	sp, #8
   1800a:	af00      	add	r7, sp, #0
   1800c:	6078      	str	r0, [r7, #4]
	if (usec_to_wait == 0) {
   1800e:	687b      	ldr	r3, [r7, #4]
   18010:	2b00      	cmp	r3, #0
   18012:	d003      	beq.n	1801c <z_impl_k_busy_wait+0x16>
	arch_busy_wait(usec_to_wait);
   18014:	6878      	ldr	r0, [r7, #4]
   18016:	f7f8 fe85 	bl	10d24 <arch_busy_wait>
   1801a:	e000      	b.n	1801e <z_impl_k_busy_wait+0x18>
		return;
   1801c:	bf00      	nop
}
   1801e:	3708      	adds	r7, #8
   18020:	46bd      	mov	sp, r7
   18022:	bd80      	pop	{r7, pc}

00018024 <z_impl_k_thread_name_set>:
{
   18024:	b480      	push	{r7}
   18026:	b083      	sub	sp, #12
   18028:	af00      	add	r7, sp, #0
   1802a:	6078      	str	r0, [r7, #4]
   1802c:	6039      	str	r1, [r7, #0]
	return -ENOSYS;
   1802e:	f06f 0346 	mvn.w	r3, #70	; 0x46
}
   18032:	4618      	mov	r0, r3
   18034:	370c      	adds	r7, #12
   18036:	46bd      	mov	sp, r7
   18038:	bc80      	pop	{r7}
   1803a:	4770      	bx	lr

0001803c <k_thread_name_get>:
{
   1803c:	b480      	push	{r7}
   1803e:	b083      	sub	sp, #12
   18040:	af00      	add	r7, sp, #0
   18042:	6078      	str	r0, [r7, #4]
	return NULL;
   18044:	2300      	movs	r3, #0
}
   18046:	4618      	mov	r0, r3
   18048:	370c      	adds	r7, #12
   1804a:	46bd      	mov	sp, r7
   1804c:	bc80      	pop	{r7}
   1804e:	4770      	bx	lr

00018050 <z_impl_k_thread_start>:
{
   18050:	b580      	push	{r7, lr}
   18052:	b082      	sub	sp, #8
   18054:	af00      	add	r7, sp, #0
   18056:	6078      	str	r0, [r7, #4]
	z_sched_start(thread);
   18058:	6878      	ldr	r0, [r7, #4]
   1805a:	f7f4 fde5 	bl	cc28 <z_sched_start>
}
   1805e:	bf00      	nop
   18060:	3708      	adds	r7, #8
   18062:	46bd      	mov	sp, r7
   18064:	bd80      	pop	{r7, pc}

00018066 <schedule_new_thread>:
{
   18066:	b580      	push	{r7, lr}
   18068:	b084      	sub	sp, #16
   1806a:	af00      	add	r7, sp, #0
   1806c:	60f8      	str	r0, [r7, #12]
   1806e:	e9c7 2300 	strd	r2, r3, [r7]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   18072:	e9d7 2300 	ldrd	r2, r3, [r7]
   18076:	f04f 0000 	mov.w	r0, #0
   1807a:	f04f 0100 	mov.w	r1, #0
   1807e:	428b      	cmp	r3, r1
   18080:	bf08      	it	eq
   18082:	4282      	cmpeq	r2, r0
   18084:	d103      	bne.n	1808e <schedule_new_thread+0x28>
		k_thread_start(thread);
   18086:	68f8      	ldr	r0, [r7, #12]
   18088:	f7ff ff7c 	bl	17f84 <k_thread_start>
   1808c:	e004      	b.n	18098 <schedule_new_thread+0x32>
		z_add_thread_timeout(thread, delay);
   1808e:	e9d7 2300 	ldrd	r2, r3, [r7]
   18092:	68f8      	ldr	r0, [r7, #12]
   18094:	f7f6 faa8 	bl	e5e8 <z_add_thread_timeout>
}
   18098:	bf00      	nop
   1809a:	3710      	adds	r7, #16
   1809c:	46bd      	mov	sp, r7
   1809e:	bd80      	pop	{r7, pc}

000180a0 <z_init_thread_base>:
{
   180a0:	b580      	push	{r7, lr}
   180a2:	b084      	sub	sp, #16
   180a4:	af00      	add	r7, sp, #0
   180a6:	60f8      	str	r0, [r7, #12]
   180a8:	60b9      	str	r1, [r7, #8]
   180aa:	607a      	str	r2, [r7, #4]
   180ac:	603b      	str	r3, [r7, #0]
	thread_base->user_options = (uint8_t)options;
   180ae:	683b      	ldr	r3, [r7, #0]
   180b0:	b2da      	uxtb	r2, r3
   180b2:	68fb      	ldr	r3, [r7, #12]
   180b4:	731a      	strb	r2, [r3, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   180b6:	687b      	ldr	r3, [r7, #4]
   180b8:	b2da      	uxtb	r2, r3
   180ba:	68fb      	ldr	r3, [r7, #12]
   180bc:	735a      	strb	r2, [r3, #13]
	thread_base->prio = priority;
   180be:	68bb      	ldr	r3, [r7, #8]
   180c0:	b25a      	sxtb	r2, r3
   180c2:	68fb      	ldr	r3, [r7, #12]
   180c4:	739a      	strb	r2, [r3, #14]
	thread_base->sched_locked = 0U;
   180c6:	68fb      	ldr	r3, [r7, #12]
   180c8:	2200      	movs	r2, #0
   180ca:	73da      	strb	r2, [r3, #15]
	z_init_thread_timeout(thread_base);
   180cc:	68f8      	ldr	r0, [r7, #12]
   180ce:	f7ff ff70 	bl	17fb2 <z_init_thread_timeout>
}
   180d2:	bf00      	nop
   180d4:	3710      	adds	r7, #16
   180d6:	46bd      	mov	sp, r7
   180d8:	bd80      	pop	{r7, pc}

000180da <_is_user_context>:
{
   180da:	b480      	push	{r7}
   180dc:	af00      	add	r7, sp, #0
	return false;
   180de:	2300      	movs	r3, #0
}
   180e0:	4618      	mov	r0, r3
   180e2:	46bd      	mov	sp, r7
   180e4:	bc80      	pop	{r7}
   180e6:	4770      	bx	lr

000180e8 <k_thread_suspend>:
{
   180e8:	b580      	push	{r7, lr}
   180ea:	b082      	sub	sp, #8
   180ec:	af00      	add	r7, sp, #0
   180ee:	6078      	str	r0, [r7, #4]
	z_impl_k_thread_suspend(thread);
   180f0:	6878      	ldr	r0, [r7, #4]
   180f2:	f7f4 fe0d 	bl	cd10 <z_impl_k_thread_suspend>
}
   180f6:	bf00      	nop
   180f8:	3708      	adds	r7, #8
   180fa:	46bd      	mov	sp, r7
   180fc:	bd80      	pop	{r7, pc}

000180fe <z_swap_irqlock>:
{
   180fe:	b580      	push	{r7, lr}
   18100:	b084      	sub	sp, #16
   18102:	af00      	add	r7, sp, #0
   18104:	6078      	str	r0, [r7, #4]
	ret = arch_swap(key);
   18106:	6878      	ldr	r0, [r7, #4]
   18108:	f7ec fc10 	bl	492c <arch_swap>
   1810c:	60f8      	str	r0, [r7, #12]
	return ret;
   1810e:	68fb      	ldr	r3, [r7, #12]
}
   18110:	4618      	mov	r0, r3
   18112:	3710      	adds	r7, #16
   18114:	46bd      	mov	sp, r7
   18116:	bd80      	pop	{r7, pc}

00018118 <sys_dnode_init>:
{
   18118:	b480      	push	{r7}
   1811a:	b083      	sub	sp, #12
   1811c:	af00      	add	r7, sp, #0
   1811e:	6078      	str	r0, [r7, #4]
	node->next = NULL;
   18120:	687b      	ldr	r3, [r7, #4]
   18122:	2200      	movs	r2, #0
   18124:	601a      	str	r2, [r3, #0]
	node->prev = NULL;
   18126:	687b      	ldr	r3, [r7, #4]
   18128:	2200      	movs	r2, #0
   1812a:	605a      	str	r2, [r3, #4]
}
   1812c:	bf00      	nop
   1812e:	370c      	adds	r7, #12
   18130:	46bd      	mov	sp, r7
   18132:	bc80      	pop	{r7}
   18134:	4770      	bx	lr

00018136 <sys_dnode_is_linked>:
{
   18136:	b480      	push	{r7}
   18138:	b083      	sub	sp, #12
   1813a:	af00      	add	r7, sp, #0
   1813c:	6078      	str	r0, [r7, #4]
	return node->next != NULL;
   1813e:	687b      	ldr	r3, [r7, #4]
   18140:	681b      	ldr	r3, [r3, #0]
   18142:	2b00      	cmp	r3, #0
   18144:	bf14      	ite	ne
   18146:	2301      	movne	r3, #1
   18148:	2300      	moveq	r3, #0
   1814a:	b2db      	uxtb	r3, r3
}
   1814c:	4618      	mov	r0, r3
   1814e:	370c      	adds	r7, #12
   18150:	46bd      	mov	sp, r7
   18152:	bc80      	pop	{r7}
   18154:	4770      	bx	lr

00018156 <sys_dlist_is_empty>:
{
   18156:	b480      	push	{r7}
   18158:	b083      	sub	sp, #12
   1815a:	af00      	add	r7, sp, #0
   1815c:	6078      	str	r0, [r7, #4]
	return list->head == list;
   1815e:	687b      	ldr	r3, [r7, #4]
   18160:	681b      	ldr	r3, [r3, #0]
   18162:	687a      	ldr	r2, [r7, #4]
   18164:	429a      	cmp	r2, r3
   18166:	bf0c      	ite	eq
   18168:	2301      	moveq	r3, #1
   1816a:	2300      	movne	r3, #0
   1816c:	b2db      	uxtb	r3, r3
}
   1816e:	4618      	mov	r0, r3
   18170:	370c      	adds	r7, #12
   18172:	46bd      	mov	sp, r7
   18174:	bc80      	pop	{r7}
   18176:	4770      	bx	lr

00018178 <sys_dlist_peek_head>:
{
   18178:	b580      	push	{r7, lr}
   1817a:	b082      	sub	sp, #8
   1817c:	af00      	add	r7, sp, #0
   1817e:	6078      	str	r0, [r7, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   18180:	6878      	ldr	r0, [r7, #4]
   18182:	f7ff ffe8 	bl	18156 <sys_dlist_is_empty>
   18186:	4603      	mov	r3, r0
   18188:	2b00      	cmp	r3, #0
   1818a:	d102      	bne.n	18192 <sys_dlist_peek_head+0x1a>
   1818c:	687b      	ldr	r3, [r7, #4]
   1818e:	681b      	ldr	r3, [r3, #0]
   18190:	e000      	b.n	18194 <sys_dlist_peek_head+0x1c>
   18192:	2300      	movs	r3, #0
}
   18194:	4618      	mov	r0, r3
   18196:	3708      	adds	r7, #8
   18198:	46bd      	mov	sp, r7
   1819a:	bd80      	pop	{r7, pc}

0001819c <sys_dlist_peek_next_no_check>:
{
   1819c:	b480      	push	{r7}
   1819e:	b083      	sub	sp, #12
   181a0:	af00      	add	r7, sp, #0
   181a2:	6078      	str	r0, [r7, #4]
   181a4:	6039      	str	r1, [r7, #0]
	return (node == list->tail) ? NULL : node->next;
   181a6:	687b      	ldr	r3, [r7, #4]
   181a8:	685b      	ldr	r3, [r3, #4]
   181aa:	683a      	ldr	r2, [r7, #0]
   181ac:	429a      	cmp	r2, r3
   181ae:	d002      	beq.n	181b6 <sys_dlist_peek_next_no_check+0x1a>
   181b0:	683b      	ldr	r3, [r7, #0]
   181b2:	681b      	ldr	r3, [r3, #0]
   181b4:	e000      	b.n	181b8 <sys_dlist_peek_next_no_check+0x1c>
   181b6:	2300      	movs	r3, #0
}
   181b8:	4618      	mov	r0, r3
   181ba:	370c      	adds	r7, #12
   181bc:	46bd      	mov	sp, r7
   181be:	bc80      	pop	{r7}
   181c0:	4770      	bx	lr

000181c2 <sys_dlist_peek_next>:
{
   181c2:	b580      	push	{r7, lr}
   181c4:	b082      	sub	sp, #8
   181c6:	af00      	add	r7, sp, #0
   181c8:	6078      	str	r0, [r7, #4]
   181ca:	6039      	str	r1, [r7, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   181cc:	683b      	ldr	r3, [r7, #0]
   181ce:	2b00      	cmp	r3, #0
   181d0:	d005      	beq.n	181de <sys_dlist_peek_next+0x1c>
   181d2:	6839      	ldr	r1, [r7, #0]
   181d4:	6878      	ldr	r0, [r7, #4]
   181d6:	f7ff ffe1 	bl	1819c <sys_dlist_peek_next_no_check>
   181da:	4603      	mov	r3, r0
   181dc:	e000      	b.n	181e0 <sys_dlist_peek_next+0x1e>
   181de:	2300      	movs	r3, #0
}
   181e0:	4618      	mov	r0, r3
   181e2:	3708      	adds	r7, #8
   181e4:	46bd      	mov	sp, r7
   181e6:	bd80      	pop	{r7, pc}

000181e8 <sys_dlist_append>:
{
   181e8:	b480      	push	{r7}
   181ea:	b083      	sub	sp, #12
   181ec:	af00      	add	r7, sp, #0
   181ee:	6078      	str	r0, [r7, #4]
   181f0:	6039      	str	r1, [r7, #0]
	node->next = list;
   181f2:	683b      	ldr	r3, [r7, #0]
   181f4:	687a      	ldr	r2, [r7, #4]
   181f6:	601a      	str	r2, [r3, #0]
	node->prev = list->tail;
   181f8:	687b      	ldr	r3, [r7, #4]
   181fa:	685a      	ldr	r2, [r3, #4]
   181fc:	683b      	ldr	r3, [r7, #0]
   181fe:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   18200:	687b      	ldr	r3, [r7, #4]
   18202:	685b      	ldr	r3, [r3, #4]
   18204:	683a      	ldr	r2, [r7, #0]
   18206:	601a      	str	r2, [r3, #0]
	list->tail = node;
   18208:	687b      	ldr	r3, [r7, #4]
   1820a:	683a      	ldr	r2, [r7, #0]
   1820c:	605a      	str	r2, [r3, #4]
}
   1820e:	bf00      	nop
   18210:	370c      	adds	r7, #12
   18212:	46bd      	mov	sp, r7
   18214:	bc80      	pop	{r7}
   18216:	4770      	bx	lr

00018218 <sys_dlist_insert>:
{
   18218:	b480      	push	{r7}
   1821a:	b083      	sub	sp, #12
   1821c:	af00      	add	r7, sp, #0
   1821e:	6078      	str	r0, [r7, #4]
   18220:	6039      	str	r1, [r7, #0]
	node->prev = successor->prev;
   18222:	687b      	ldr	r3, [r7, #4]
   18224:	685a      	ldr	r2, [r3, #4]
   18226:	683b      	ldr	r3, [r7, #0]
   18228:	605a      	str	r2, [r3, #4]
	node->next = successor;
   1822a:	683b      	ldr	r3, [r7, #0]
   1822c:	687a      	ldr	r2, [r7, #4]
   1822e:	601a      	str	r2, [r3, #0]
	successor->prev->next = node;
   18230:	687b      	ldr	r3, [r7, #4]
   18232:	685b      	ldr	r3, [r3, #4]
   18234:	683a      	ldr	r2, [r7, #0]
   18236:	601a      	str	r2, [r3, #0]
	successor->prev = node;
   18238:	687b      	ldr	r3, [r7, #4]
   1823a:	683a      	ldr	r2, [r7, #0]
   1823c:	605a      	str	r2, [r3, #4]
}
   1823e:	bf00      	nop
   18240:	370c      	adds	r7, #12
   18242:	46bd      	mov	sp, r7
   18244:	bc80      	pop	{r7}
   18246:	4770      	bx	lr

00018248 <sys_dlist_remove>:
{
   18248:	b580      	push	{r7, lr}
   1824a:	b082      	sub	sp, #8
   1824c:	af00      	add	r7, sp, #0
   1824e:	6078      	str	r0, [r7, #4]
	node->prev->next = node->next;
   18250:	687b      	ldr	r3, [r7, #4]
   18252:	685b      	ldr	r3, [r3, #4]
   18254:	687a      	ldr	r2, [r7, #4]
   18256:	6812      	ldr	r2, [r2, #0]
   18258:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   1825a:	687b      	ldr	r3, [r7, #4]
   1825c:	681b      	ldr	r3, [r3, #0]
   1825e:	687a      	ldr	r2, [r7, #4]
   18260:	6852      	ldr	r2, [r2, #4]
   18262:	605a      	str	r2, [r3, #4]
	sys_dnode_init(node);
   18264:	6878      	ldr	r0, [r7, #4]
   18266:	f7ff ff57 	bl	18118 <sys_dnode_init>
}
   1826a:	bf00      	nop
   1826c:	3708      	adds	r7, #8
   1826e:	46bd      	mov	sp, r7
   18270:	bd80      	pop	{r7, pc}

00018272 <remove_timeout>:
{
   18272:	b5f0      	push	{r4, r5, r6, r7, lr}
   18274:	b083      	sub	sp, #12
   18276:	af00      	add	r7, sp, #0
   18278:	6078      	str	r0, [r7, #4]
	if (next(t) != NULL) {
   1827a:	6878      	ldr	r0, [r7, #4]
   1827c:	f7f6 fce6 	bl	ec4c <next>
   18280:	4603      	mov	r3, r0
   18282:	2b00      	cmp	r3, #0
   18284:	d00d      	beq.n	182a2 <remove_timeout+0x30>
		next(t)->dticks += t->dticks;
   18286:	6878      	ldr	r0, [r7, #4]
   18288:	f7f6 fce0 	bl	ec4c <next>
   1828c:	4606      	mov	r6, r0
   1828e:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
   18292:	687b      	ldr	r3, [r7, #4]
   18294:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
   18298:	1884      	adds	r4, r0, r2
   1829a:	eb41 0503 	adc.w	r5, r1, r3
   1829e:	e9c6 4504 	strd	r4, r5, [r6, #16]
	sys_dlist_remove(&t->node);
   182a2:	687b      	ldr	r3, [r7, #4]
   182a4:	4618      	mov	r0, r3
   182a6:	f7ff ffcf 	bl	18248 <sys_dlist_remove>
}
   182aa:	bf00      	nop
   182ac:	370c      	adds	r7, #12
   182ae:	46bd      	mov	sp, r7
   182b0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000182b2 <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
   182b2:	b580      	push	{r7, lr}
   182b4:	af00      	add	r7, sp, #0
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
   182b6:	f7f7 f933 	bl	f520 <z_tick_get>
   182ba:	4602      	mov	r2, r0
   182bc:	460b      	mov	r3, r1
   182be:	4613      	mov	r3, r2
#else
	return (uint32_t)curr_tick;
#endif
}
   182c0:	4618      	mov	r0, r3
   182c2:	bd80      	pop	{r7, pc}

000182c4 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
   182c4:	b580      	push	{r7, lr}
   182c6:	af00      	add	r7, sp, #0
	return z_tick_get();
   182c8:	f7f7 f92a 	bl	f520 <z_tick_get>
   182cc:	4602      	mov	r2, r0
   182ce:	460b      	mov	r3, r1
}
   182d0:	4610      	mov	r0, r2
   182d2:	4619      	mov	r1, r3
   182d4:	bd80      	pop	{r7, pc}

000182d6 <sys_dlist_init>:
{
   182d6:	b480      	push	{r7}
   182d8:	b083      	sub	sp, #12
   182da:	af00      	add	r7, sp, #0
   182dc:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   182de:	687b      	ldr	r3, [r7, #4]
   182e0:	687a      	ldr	r2, [r7, #4]
   182e2:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   182e4:	687b      	ldr	r3, [r7, #4]
   182e6:	687a      	ldr	r2, [r7, #4]
   182e8:	605a      	str	r2, [r3, #4]
}
   182ea:	bf00      	nop
   182ec:	370c      	adds	r7, #12
   182ee:	46bd      	mov	sp, r7
   182f0:	bc80      	pop	{r7}
   182f2:	4770      	bx	lr

000182f4 <sys_dnode_init>:
{
   182f4:	b480      	push	{r7}
   182f6:	b083      	sub	sp, #12
   182f8:	af00      	add	r7, sp, #0
   182fa:	6078      	str	r0, [r7, #4]
	node->next = NULL;
   182fc:	687b      	ldr	r3, [r7, #4]
   182fe:	2200      	movs	r2, #0
   18300:	601a      	str	r2, [r3, #0]
	node->prev = NULL;
   18302:	687b      	ldr	r3, [r7, #4]
   18304:	2200      	movs	r2, #0
   18306:	605a      	str	r2, [r3, #4]
}
   18308:	bf00      	nop
   1830a:	370c      	adds	r7, #12
   1830c:	46bd      	mov	sp, r7
   1830e:	bc80      	pop	{r7}
   18310:	4770      	bx	lr

00018312 <sys_dlist_is_empty>:
{
   18312:	b480      	push	{r7}
   18314:	b083      	sub	sp, #12
   18316:	af00      	add	r7, sp, #0
   18318:	6078      	str	r0, [r7, #4]
	return list->head == list;
   1831a:	687b      	ldr	r3, [r7, #4]
   1831c:	681b      	ldr	r3, [r3, #0]
   1831e:	687a      	ldr	r2, [r7, #4]
   18320:	429a      	cmp	r2, r3
   18322:	bf0c      	ite	eq
   18324:	2301      	moveq	r3, #1
   18326:	2300      	movne	r3, #0
   18328:	b2db      	uxtb	r3, r3
}
   1832a:	4618      	mov	r0, r3
   1832c:	370c      	adds	r7, #12
   1832e:	46bd      	mov	sp, r7
   18330:	bc80      	pop	{r7}
   18332:	4770      	bx	lr

00018334 <sys_dlist_peek_head>:
{
   18334:	b580      	push	{r7, lr}
   18336:	b082      	sub	sp, #8
   18338:	af00      	add	r7, sp, #0
   1833a:	6078      	str	r0, [r7, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1833c:	6878      	ldr	r0, [r7, #4]
   1833e:	f7ff ffe8 	bl	18312 <sys_dlist_is_empty>
   18342:	4603      	mov	r3, r0
   18344:	2b00      	cmp	r3, #0
   18346:	d102      	bne.n	1834e <sys_dlist_peek_head+0x1a>
   18348:	687b      	ldr	r3, [r7, #4]
   1834a:	681b      	ldr	r3, [r3, #0]
   1834c:	e000      	b.n	18350 <sys_dlist_peek_head+0x1c>
   1834e:	2300      	movs	r3, #0
}
   18350:	4618      	mov	r0, r3
   18352:	3708      	adds	r7, #8
   18354:	46bd      	mov	sp, r7
   18356:	bd80      	pop	{r7, pc}

00018358 <z_object_init>:
{
   18358:	b480      	push	{r7}
   1835a:	b083      	sub	sp, #12
   1835c:	af00      	add	r7, sp, #0
   1835e:	6078      	str	r0, [r7, #4]
}
   18360:	bf00      	nop
   18362:	370c      	adds	r7, #12
   18364:	46bd      	mov	sp, r7
   18366:	bc80      	pop	{r7}
   18368:	4770      	bx	lr

0001836a <z_init_timeout>:
{
   1836a:	b580      	push	{r7, lr}
   1836c:	b082      	sub	sp, #8
   1836e:	af00      	add	r7, sp, #0
   18370:	6078      	str	r0, [r7, #4]
	sys_dnode_init(&t->node);
   18372:	687b      	ldr	r3, [r7, #4]
   18374:	4618      	mov	r0, r3
   18376:	f7ff ffbd 	bl	182f4 <sys_dnode_init>
}
   1837a:	bf00      	nop
   1837c:	3708      	adds	r7, #8
   1837e:	46bd      	mov	sp, r7
   18380:	bd80      	pop	{r7, pc}

00018382 <z_reschedule_unlocked>:
{
   18382:	b580      	push	{r7, lr}
   18384:	b082      	sub	sp, #8
   18386:	af00      	add	r7, sp, #0
	__asm__ volatile(
   18388:	f04f 0320 	mov.w	r3, #32
   1838c:	f3ef 8211 	mrs	r2, BASEPRI
   18390:	f383 8811 	msr	BASEPRI, r3
   18394:	f3bf 8f6f 	isb	sy
   18398:	607a      	str	r2, [r7, #4]
   1839a:	603b      	str	r3, [r7, #0]
	return key;
   1839c:	687b      	ldr	r3, [r7, #4]
	(void) z_reschedule_irqlock(arch_irq_lock());
   1839e:	4618      	mov	r0, r3
   183a0:	f7ff fc52 	bl	17c48 <z_reschedule_irqlock>
}
   183a4:	bf00      	nop
   183a6:	3708      	adds	r7, #8
   183a8:	46bd      	mov	sp, r7
   183aa:	bd80      	pop	{r7, pc}

000183ac <z_unpend1_no_timeout>:
{
   183ac:	b580      	push	{r7, lr}
   183ae:	b084      	sub	sp, #16
   183b0:	af00      	add	r7, sp, #0
   183b2:	6078      	str	r0, [r7, #4]
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   183b4:	2100      	movs	r1, #0
   183b6:	6878      	ldr	r0, [r7, #4]
   183b8:	f7f5 f89c 	bl	d4f4 <z_find_first_thread_to_unpend>
   183bc:	60f8      	str	r0, [r7, #12]
	if (thread != NULL) {
   183be:	68fb      	ldr	r3, [r7, #12]
   183c0:	2b00      	cmp	r3, #0
   183c2:	d002      	beq.n	183ca <z_unpend1_no_timeout+0x1e>
		z_unpend_thread_no_timeout(thread);
   183c4:	68f8      	ldr	r0, [r7, #12]
   183c6:	f7f5 f90b 	bl	d5e0 <z_unpend_thread_no_timeout>
	return thread;
   183ca:	68fb      	ldr	r3, [r7, #12]
}
   183cc:	4618      	mov	r0, r3
   183ce:	3710      	adds	r7, #16
   183d0:	46bd      	mov	sp, r7
   183d2:	bd80      	pop	{r7, pc}

000183d4 <z_waitq_init>:
{
   183d4:	b580      	push	{r7, lr}
   183d6:	b082      	sub	sp, #8
   183d8:	af00      	add	r7, sp, #0
   183da:	6078      	str	r0, [r7, #4]
	sys_dlist_init(&w->waitq);
   183dc:	687b      	ldr	r3, [r7, #4]
   183de:	4618      	mov	r0, r3
   183e0:	f7ff ff79 	bl	182d6 <sys_dlist_init>
}
   183e4:	bf00      	nop
   183e6:	3708      	adds	r7, #8
   183e8:	46bd      	mov	sp, r7
   183ea:	bd80      	pop	{r7, pc}

000183ec <z_waitq_head>:
{
   183ec:	b580      	push	{r7, lr}
   183ee:	b082      	sub	sp, #8
   183f0:	af00      	add	r7, sp, #0
   183f2:	6078      	str	r0, [r7, #4]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   183f4:	687b      	ldr	r3, [r7, #4]
   183f6:	4618      	mov	r0, r3
   183f8:	f7ff ff9c 	bl	18334 <sys_dlist_peek_head>
   183fc:	4603      	mov	r3, r0
}
   183fe:	4618      	mov	r0, r3
   18400:	3708      	adds	r7, #8
   18402:	46bd      	mov	sp, r7
   18404:	bd80      	pop	{r7, pc}

00018406 <k_timer_init>:
{
   18406:	b580      	push	{r7, lr}
   18408:	b084      	sub	sp, #16
   1840a:	af00      	add	r7, sp, #0
   1840c:	60f8      	str	r0, [r7, #12]
   1840e:	60b9      	str	r1, [r7, #8]
   18410:	607a      	str	r2, [r7, #4]
	timer->expiry_fn = expiry_fn;
   18412:	68fb      	ldr	r3, [r7, #12]
   18414:	68ba      	ldr	r2, [r7, #8]
   18416:	621a      	str	r2, [r3, #32]
	timer->stop_fn = stop_fn;
   18418:	68fb      	ldr	r3, [r7, #12]
   1841a:	687a      	ldr	r2, [r7, #4]
   1841c:	625a      	str	r2, [r3, #36]	; 0x24
	timer->status = 0U;
   1841e:	68fb      	ldr	r3, [r7, #12]
   18420:	2200      	movs	r2, #0
   18422:	631a      	str	r2, [r3, #48]	; 0x30
	z_waitq_init(&timer->wait_q);
   18424:	68fb      	ldr	r3, [r7, #12]
   18426:	3318      	adds	r3, #24
   18428:	4618      	mov	r0, r3
   1842a:	f7ff ffd3 	bl	183d4 <z_waitq_init>
	z_init_timeout(&timer->timeout);
   1842e:	68fb      	ldr	r3, [r7, #12]
   18430:	4618      	mov	r0, r3
   18432:	f7ff ff9a 	bl	1836a <z_init_timeout>
	timer->user_data = NULL;
   18436:	68fb      	ldr	r3, [r7, #12]
   18438:	2200      	movs	r2, #0
   1843a:	635a      	str	r2, [r3, #52]	; 0x34
	z_object_init(timer);
   1843c:	68f8      	ldr	r0, [r7, #12]
   1843e:	f7ff ff8b 	bl	18358 <z_object_init>
}
   18442:	bf00      	nop
   18444:	3710      	adds	r7, #16
   18446:	46bd      	mov	sp, r7
   18448:	bd80      	pop	{r7, pc}

0001844a <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   1844a:	b580      	push	{r7, lr}
   1844c:	b084      	sub	sp, #16
   1844e:	af00      	add	r7, sp, #0
   18450:	6078      	str	r0, [r7, #4]
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   18452:	687b      	ldr	r3, [r7, #4]
   18454:	4618      	mov	r0, r3
   18456:	f7f6 fdaf 	bl	efb8 <z_abort_timeout>
   1845a:	4603      	mov	r3, r0
   1845c:	2b00      	cmp	r3, #0
   1845e:	bf14      	ite	ne
   18460:	2301      	movne	r3, #1
   18462:	2300      	moveq	r3, #0
   18464:	b2db      	uxtb	r3, r3
   18466:	60fb      	str	r3, [r7, #12]

	if (inactive) {
   18468:	68fb      	ldr	r3, [r7, #12]
   1846a:	2b00      	cmp	r3, #0
   1846c:	d116      	bne.n	1849c <z_impl_k_timer_stop+0x52>
		return;
	}

	if (timer->stop_fn != NULL) {
   1846e:	687b      	ldr	r3, [r7, #4]
   18470:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   18472:	2b00      	cmp	r3, #0
   18474:	d003      	beq.n	1847e <z_impl_k_timer_stop+0x34>
		timer->stop_fn(timer);
   18476:	687b      	ldr	r3, [r7, #4]
   18478:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1847a:	6878      	ldr	r0, [r7, #4]
   1847c:	4798      	blx	r3
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   1847e:	687b      	ldr	r3, [r7, #4]
   18480:	3318      	adds	r3, #24
   18482:	4618      	mov	r0, r3
   18484:	f7ff ff92 	bl	183ac <z_unpend1_no_timeout>
   18488:	60b8      	str	r0, [r7, #8]

	if (pending_thread != NULL) {
   1848a:	68bb      	ldr	r3, [r7, #8]
   1848c:	2b00      	cmp	r3, #0
   1848e:	d006      	beq.n	1849e <z_impl_k_timer_stop+0x54>
		z_ready_thread(pending_thread);
   18490:	68b8      	ldr	r0, [r7, #8]
   18492:	f7f4 fb59 	bl	cb48 <z_ready_thread>
		z_reschedule_unlocked();
   18496:	f7ff ff74 	bl	18382 <z_reschedule_unlocked>
   1849a:	e000      	b.n	1849e <z_impl_k_timer_stop+0x54>
		return;
   1849c:	bf00      	nop
	}
}
   1849e:	3710      	adds	r7, #16
   184a0:	46bd      	mov	sp, r7
   184a2:	bd80      	pop	{r7, pc}

000184a4 <sys_dlist_init>:
{
   184a4:	b480      	push	{r7}
   184a6:	b083      	sub	sp, #12
   184a8:	af00      	add	r7, sp, #0
   184aa:	6078      	str	r0, [r7, #4]
	list->head = (sys_dnode_t *)list;
   184ac:	687b      	ldr	r3, [r7, #4]
   184ae:	687a      	ldr	r2, [r7, #4]
   184b0:	601a      	str	r2, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   184b2:	687b      	ldr	r3, [r7, #4]
   184b4:	687a      	ldr	r2, [r7, #4]
   184b6:	605a      	str	r2, [r3, #4]
}
   184b8:	bf00      	nop
   184ba:	370c      	adds	r7, #12
   184bc:	46bd      	mov	sp, r7
   184be:	bc80      	pop	{r7}
   184c0:	4770      	bx	lr

000184c2 <z_waitq_init>:
{
   184c2:	b580      	push	{r7, lr}
   184c4:	b082      	sub	sp, #8
   184c6:	af00      	add	r7, sp, #0
   184c8:	6078      	str	r0, [r7, #4]
	sys_dlist_init(&w->waitq);
   184ca:	687b      	ldr	r3, [r7, #4]
   184cc:	4618      	mov	r0, r3
   184ce:	f7ff ffe9 	bl	184a4 <sys_dlist_init>
}
   184d2:	bf00      	nop
   184d4:	3708      	adds	r7, #8
   184d6:	46bd      	mov	sp, r7
   184d8:	bd80      	pop	{r7, pc}

000184da <k_heap_init>:
{
   184da:	b580      	push	{r7, lr}
   184dc:	b084      	sub	sp, #16
   184de:	af00      	add	r7, sp, #0
   184e0:	60f8      	str	r0, [r7, #12]
   184e2:	60b9      	str	r1, [r7, #8]
   184e4:	607a      	str	r2, [r7, #4]
	z_waitq_init(&h->wait_q);
   184e6:	68fb      	ldr	r3, [r7, #12]
   184e8:	330c      	adds	r3, #12
   184ea:	4618      	mov	r0, r3
   184ec:	f7ff ffe9 	bl	184c2 <z_waitq_init>
	sys_heap_init(&h->heap, mem, bytes);
   184f0:	68fb      	ldr	r3, [r7, #12]
   184f2:	687a      	ldr	r2, [r7, #4]
   184f4:	68b9      	ldr	r1, [r7, #8]
   184f6:	4618      	mov	r0, r3
   184f8:	f7e8 fd1a 	bl	f30 <sys_heap_init>
}
   184fc:	bf00      	nop
   184fe:	3710      	adds	r7, #16
   18500:	46bd      	mov	sp, r7
   18502:	bd80      	pop	{r7, pc}

00018504 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
   18504:	b480      	push	{r7}
   18506:	af00      	add	r7, sp, #0
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   18508:	bf00      	nop
   1850a:	46bd      	mov	sp, r7
   1850c:	bc80      	pop	{r7}
   1850e:	4770      	bx	lr
